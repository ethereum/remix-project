(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["main"],{

/***/ "../../../dist/libs/remix-analyzer/index.js":
/*!**********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var solidity_analyzer_1 = __webpack_require__(/*! ./solidity-analyzer */ "../../../dist/libs/remix-analyzer/solidity-analyzer/index.js");

exports.CodeAnalysis = solidity_analyzer_1.default;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/index.js":
/*!****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const remix_astwalker_1 = __webpack_require__(/*! @remix-project/remix-astwalker */ "../../../dist/libs/remix-astwalker/index.js");

const list_1 = tslib_1.__importDefault(__webpack_require__(/*! ./modules/list */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/list.js"));

class staticAnalysisRunner {
  /**
   * Run analysis (Used by IDE)
   * @param compilationResult contract compilation result
   * @param toRun module indexes (compiled from remix IDE)
   * @param callback callback
   */
  run(compilationResult, toRun, callback) {
    const modules = toRun.map(i => {
      const module = this.modules()[i];
      const m = new module();
      return {
        'name': m.name,
        'mod': m
      };
    });
    this.runWithModuleList(compilationResult, modules, callback);
  }
  /**
   * Run analysis passing list of modules to run
   * @param compilationResult contract compilation result
   * @param modules analysis module
   * @param callback callback
   */


  runWithModuleList(compilationResult, modules, callback) {
    let reports = []; // Also provide convenience analysis via the AST walker.

    const walker = new remix_astwalker_1.AstWalker();

    for (const k in compilationResult.sources) {
      walker.walkFull(compilationResult.sources[k].ast, node => {
        modules.map(item => {
          if (item.mod.visit !== undefined) {
            try {
              item.mod.visit(node);
            } catch (e) {
              reports.push({
                name: item.name,
                report: [{
                  warning: 'INTERNAL ERROR in module ' + item.name + ' ' + e.message,
                  error: e.stack
                }]
              });
            }
          }
        });
        return true;
      });
    } // Here, modules can just collect the results from the AST walk,
    // but also perform new analysis.


    reports = reports.concat(modules.map(item => {
      let report = null;

      try {
        report = item.mod.report(compilationResult);
      } catch (e) {
        report = [{
          warning: 'INTERNAL ERROR in module ' + item.name + ' ' + e.message,
          error: e.stack
        }];
      }

      return {
        name: item.name,
        report: report
      };
    }));
    callback(reports);
  }
  /**
   * Get list of all analysis modules
   */


  modules() {
    return list_1.default;
  }

}

exports.default = staticAnalysisRunner;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js":
/*!**********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const remix_astwalker_1 = __webpack_require__(/*! @remix-project/remix-astwalker */ "../../../dist/libs/remix-astwalker/index.js");

class abstractAstView {
  constructor() {
    this.contracts = [];
    this.currentContractIndex = -1;
    this.currentFunctionIndex = -1;
    this.currentModifierIndex = -1;
    this.isFunctionNotModifier = false;
    /*
      file1: contract c{}
      file2: import "file1" as x; contract c{}
      therefore we have two contracts with the same name c. At the moment this is not handled because alias name "x" is not
      available in the current AST implementation thus can not be resolved.
      Additionally the fullQuallified function names e.g. [contractName].[functionName](param1Type, param2Type, ... ) must be prefixed to
      fully support this and when inheritance is resolved it must include alias resolving e.g x.c = file1.c
    */

    this.multipleContractsWithSameName = false;
  }
  /**
   * Builds a higher level AST view. I creates a list with each contract as an object in it.
   * Example contractsOut:
   *
   * {
   *  "node": {},                     // actual AST Node of the contract
   *  "functions": [
   *    {
   *      "node": {},                // actual AST Node of the function
   *      "relevantNodes": [],       // AST nodes in the function that are relevant for the anlysis of this function
   *      "modifierInvocations": [], // Modifier invocation AST nodes that are applied on this function
   *      "localVariables": [],      // Local variable declaration nodes
   *      "parameters": []           // Parameter types of the function in order of definition
   *      "returns": []              // list of return vars as { type: ... , name: ... }
   *    }
   *  ],
   *  "modifiers": [],              // Modifiers definded by the contract, format similar to functions
   *  "inheritsFrom": [],           // Names of contract this one inherits from in order of definition
   *  "stateVariables": []          // AST nodes of all State variables
   * }
   *
   * @relevantNodeFilter {ASTNode -> bool} function that selects relevant ast nodes for analysis on function level.
   * @contractsOut {list} return list for high level AST view
   * @return {ASTNode -> void} returns a function that can be used as visit function for static analysis modules, to build up a higher level AST view for further analysis.
   */


  build_visit(relevantNodeFilter) {
    return node => {
      if (node.nodeType === "ContractDefinition") {
        this.setCurrentContract({
          node: node,
          functions: [],
          relevantNodes: [],
          modifiers: [],
          inheritsFrom: [],
          stateVariables: staticAnalysisCommon_1.getStateVariableDeclarationsFromContractNode(node)
        });
      } else if (node.nodeType === "InheritanceSpecifier") {
        const currentContract = this.getCurrentContract();
        const inheritsFromName = staticAnalysisCommon_1.getInheritsFromName(node);
        currentContract.inheritsFrom.push(inheritsFromName);
      } else if (node.nodeType === "FunctionDefinition") {
        this.setCurrentFunction({
          node: node,
          relevantNodes: [],
          modifierInvocations: [],
          localVariables: this.getLocalVariables(node),
          parameters: this.getLocalParameters(node),
          returns: this.getReturnParameters(node)
        }); // push back relevant nodes to their the current fn if any

        this.getCurrentContract().relevantNodes.map(item => {
          if (item.referencedDeclaration === node.id) {
            this.getCurrentFunction().relevantNodes.push(item.node);
          }
        });
      } else if (node.nodeType === "ModifierDefinition") {
        this.setCurrentModifier({
          node: node,
          relevantNodes: [],
          localVariables: this.getLocalVariables(node),
          parameters: this.getLocalParameters(node)
        });
      } else if (node.nodeType === "ModifierInvocation") {
        if (!this.isFunctionNotModifier) throw new Error('abstractAstView.js: Found modifier invocation outside of function scope.');
        this.getCurrentFunction().modifierInvocations.push(node);
      } else if (relevantNodeFilter(node)) {
        let scope = this.isFunctionNotModifier ? this.getCurrentFunction() : this.getCurrentModifier();

        if (scope) {
          scope.relevantNodes.push(node);
        } else {
          scope = this.getCurrentContract(); // if we are not in a function scope, add the node to the contract scope

          if (scope && node.referencedDeclaration) {
            scope.relevantNodes.push({
              referencedDeclaration: node.referencedDeclaration,
              node: node
            });
          }
        }
      }
    };
  }

  build_report(wrap) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    return compilationResult => {
      const solVersion = staticAnalysisCommon_1.getCompilerVersion(compilationResult.contracts);
      this.resolveStateVariablesInHierarchy(this.contracts);
      return wrap(this.contracts, this.multipleContractsWithSameName, solVersion);
    };
  }

  resolveStateVariablesInHierarchy(contracts) {
    contracts.map(c => {
      this.resolveStateVariablesInHierarchyForContract(c, contracts);
    });
  }

  resolveStateVariablesInHierarchyForContract(currentContract, contracts) {
    currentContract.inheritsFrom.map(inheritsFromName => {
      // add variables from inherited contracts
      const inheritsFrom = contracts.find(contract => staticAnalysisCommon_1.getContractName(contract.node) === inheritsFromName);

      if (inheritsFrom) {
        currentContract.stateVariables = currentContract.stateVariables.concat(inheritsFrom.stateVariables);
      } else {
        console.log('abstractAstView.js: could not find contract defintion inherited from ' + inheritsFromName);
      }
    });
  }

  setCurrentContract(contract) {
    const name = staticAnalysisCommon_1.getContractName(contract.node);

    if (this.contracts.map(c => staticAnalysisCommon_1.getContractName(c.node)).filter(n => n === name).length > 0) {
      console.log('abstractAstView.js: two or more contracts with the same name dectected, import aliases not supported at the moment');
      this.multipleContractsWithSameName = true;
    }

    this.currentContractIndex = this.contracts.push(contract) - 1;
  }

  setCurrentFunction(func) {
    this.isFunctionNotModifier = true;
    this.currentFunctionIndex = this.getCurrentContract().functions.push(func) - 1;
  }

  setCurrentModifier(modi) {
    this.isFunctionNotModifier = false;
    this.currentModifierIndex = this.getCurrentContract().modifiers.push(modi) - 1;
  }

  getCurrentContract() {
    return this.contracts[this.currentContractIndex];
  }

  getCurrentFunction() {
    return this.getCurrentContract().functions[this.currentFunctionIndex];
  }

  getCurrentModifier() {
    return this.getCurrentContract().modifiers[this.currentModifierIndex];
  }

  getLocalParameters(funcNode) {
    return staticAnalysisCommon_1.getFunctionOrModifierDefinitionParameterPart(funcNode).parameters.map(staticAnalysisCommon_1.getType);
  }

  getReturnParameters(funcNode) {
    return this.getLocalVariables(staticAnalysisCommon_1.getFunctionDefinitionReturnParameterPart(funcNode)).map(n => {
      return {
        type: staticAnalysisCommon_1.getType(n),
        name: staticAnalysisCommon_1.getDeclaredVariableName(n)
      };
    });
  }

  getLocalVariables(funcNode) {
    const locals = [];
    new remix_astwalker_1.AstWalker().walkFull(funcNode, node => {
      if (node.nodeType === "VariableDeclaration") locals.push(node);
      return true;
    });
    return locals;
  }

}

exports.default = abstractAstView;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js":
/*!**************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
  * Should be used to categorize different modules, main reason is to give users feedback if the modules
  * Produce exact results or have false positives and negatives in them
  * A further category could be approximate if some form of approximation is used
*/

exports.default = {
  EXACT: {
    hasFalsePositives: false,
    hasFalseNegatives: false,
    id: 'EXACT'
  },
  HEURISTIC: {
    hasFalsePositives: true,
    hasFalseNegatives: true,
    id: 'HEURI'
  }
};

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/assignAndCompare.js":
/*!***********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/assignAndCompare.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class assignAndCompare {
  constructor() {
    this.warningNodes = [];
    this.name = `Result not used: `;
    this.description = `The result of an operation not used`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if ((node === null || node === void 0 ? void 0 : node.nodeType) && staticAnalysisCommon_1.isSubScopeWithTopLevelUnAssignedBinOp(node)) staticAnalysisCommon_1.getUnAssignedTopLevelBinOps(node).forEach(n => this.warningNodes.push(n));
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    return this.warningNodes.map(item => {
      return {
        warning: 'A binary operation yields a value that is not used further. This is often caused by confusing assignment (=) and comparison (==).',
        location: item.src
      };
    });
  }

}

exports.default = assignAndCompare;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/blockBlockhash.js":
/*!*********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/blockBlockhash.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class blockBlockhash {
  constructor() {
    this.warningNodes = [];
    this.name = `Block hash: `;
    this.description = `Can be influenced by miners`;
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (node.nodeType === 'FunctionCall' && staticAnalysisCommon_1.isBlockBlockHashAccess(node)) this.warningNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    return this.warningNodes.map(item => {
      return {
        warning: `Use of "blockhash": "blockhash(uint blockNumber)" is used to access the last 256 block hashes. 
                  A miner computes the block hash by "summing up" the information in the current block mined. 
                  By "summing up" the information cleverly, a miner can try to influence the outcome of a transaction in the current block. 
                  This is especially easy if there are only a small number of equally likely outcomes.`,
        location: item.src
      };
    });
  }

}

exports.default = blockBlockhash;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/blockTimestamp.js":
/*!*********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/blockTimestamp.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class blockTimestamp {
  constructor() {
    this.warningNowNodes = [];
    this.warningblockTimestampNodes = [];
    this.name = `Block timestamp: `;
    this.description = `Can be influenced by miners`;
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (node.nodeType === "Identifier" && staticAnalysisCommon_1.isNowAccess(node)) this.warningNowNodes.push(node);else if (node.nodeType === "MemberAccess" && staticAnalysisCommon_1.isBlockTimestampAccess(node)) this.warningblockTimestampNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.warningNowNodes.map((item, i) => {
      return {
        warning: `Use of "now": "now" does not mean current time. "now" is an alias for "block.timestamp". 
                  "block.timestamp" can be influenced by miners to a certain degree, be careful.`,
        location: item.src,
        more: `https://solidity.readthedocs.io/en/${version}/units-and-global-variables.html?highlight=block.timestamp#block-and-transaction-properties`
      };
    }).concat(this.warningblockTimestampNodes.map(item => {
      return {
        warning: `Use of "block.timestamp": "block.timestamp" can be influenced by miners to a certain degree. 
                  That means that a miner can "choose" the block.timestamp, to a certain degree, to change the outcome of a transaction in the mined block.`,
        location: item.src,
        more: `https://solidity.readthedocs.io/en/${version}/units-and-global-variables.html?highlight=block.timestamp#block-and-transaction-properties`
      };
    }));
  }

}

exports.default = blockTimestamp;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js":
/*!*****************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  SECURITY: {
    displayName: 'Security',
    id: 'SEC'
  },
  GAS: {
    displayName: 'Gas & Economy',
    id: 'GAS'
  },
  MISC: {
    displayName: 'Miscellaneous',
    id: 'MISC'
  },
  ERC: {
    displayName: 'ERC',
    id: 'ERC'
  }
};

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/checksEffectsInteraction.js":
/*!*******************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/checksEffectsInteraction.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const functionCallGraph_1 = __webpack_require__(/*! ./functionCallGraph */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/functionCallGraph.js");

const abstractAstView_1 = tslib_1.__importDefault(__webpack_require__(/*! ./abstractAstView */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js"));

class checksEffectsInteraction {
  constructor() {
    this.name = `Check-effects-interaction: `;
    this.description = `Potential reentrancy bugs`;
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.HEURISTIC;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default();
    this.visit = this.abstractAst.build_visit(node => node.nodeType === 'FunctionCall' && (staticAnalysisCommon_1.isInteraction(node) || staticAnalysisCommon_1.isLocalCallGraphRelevantNode(node)) || (node.nodeType === 'Assignment' || node.nodeType === 'UnaryOperation' || node.nodeType === 'InlineAssembly') && staticAnalysisCommon_1.isEffect(node));
    this.report = this.abstractAst.build_report(this._report.bind(this));
  }

  _report(contracts, multipleContractsWithSameName, version) {
    const warnings = [];
    const hasModifiers = contracts.some(item => item.modifiers.length > 0);
    const callGraph = functionCallGraph_1.buildGlobalFuncCallGraph(contracts);
    contracts.forEach(contract => {
      contract.functions.forEach(func => {
        func['changesState'] = this.checkIfChangesState(staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent(contract.node, func.node, func.parameters), this.getContext(callGraph, contract, func));
      });
      contract.functions.forEach(func => {
        if (this.isPotentialVulnerableFunction(func, this.getContext(callGraph, contract, func))) {
          const funcName = staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent(contract.node, func.node, func.parameters);
          let comments = hasModifiers ? 'Note: Modifiers are currently not considered by this static analysis.' : '';
          comments += multipleContractsWithSameName ? 'Note: Import aliases are currently not supported by this static analysis.' : '';
          warnings.push({
            warning: `Potential violation of Checks-Effects-Interaction pattern in ${funcName}: Could potentially lead to re-entrancy vulnerability. ${comments}`,
            location: func.node['src'],
            more: `https://solidity.readthedocs.io/en/${version}/security-considerations.html#re-entrancy`
          });
        }
      });
    });
    return warnings;
  }

  getContext(callGraph, currentContract, func) {
    return {
      callGraph: callGraph,
      currentContract: currentContract,
      stateVariables: this.getStateVariables(currentContract, func)
    };
  }

  getStateVariables(contract, func) {
    return contract.stateVariables.concat(func.localVariables.filter(staticAnalysisCommon_1.isStorageVariableDeclaration));
  }

  isPotentialVulnerableFunction(func, context) {
    let isPotentialVulnerable = false;
    let interaction = false;
    func.relevantNodes.forEach(node => {
      if (staticAnalysisCommon_1.isInteraction(node)) {
        interaction = true;
      } else if (interaction && (staticAnalysisCommon_1.isWriteOnStateVariable(node, context.stateVariables) || this.isLocalCallWithStateChange(node, context))) {
        isPotentialVulnerable = true;
      }
    });
    return isPotentialVulnerable;
  }

  isLocalCallWithStateChange(node, context) {
    if (staticAnalysisCommon_1.isLocalCallGraphRelevantNode(node)) {
      const func = functionCallGraph_1.resolveCallGraphSymbol(context.callGraph, staticAnalysisCommon_1.getFullQualifiedFunctionCallIdent(context.currentContract.node, node));
      return !func || func && func.node['changesState'];
    }

    return false;
  }

  checkIfChangesState(startFuncName, context) {
    return functionCallGraph_1.analyseCallGraph(context.callGraph, startFuncName, context, (node, context) => staticAnalysisCommon_1.isWriteOnStateVariable(node, context.stateVariables));
  }

}

exports.default = checksEffectsInteraction;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/constantFunctions.js":
/*!************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/constantFunctions.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const functionCallGraph_1 = __webpack_require__(/*! ./functionCallGraph */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/functionCallGraph.js");

const abstractAstView_1 = tslib_1.__importDefault(__webpack_require__(/*! ./abstractAstView */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js"));

class constantFunctions {
  constructor() {
    this.name = `Constant/View/Pure functions: `;
    this.description = `Potentially constant/view/pure functions`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.HEURISTIC;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default();
    this.visit = this.abstractAst.build_visit(node => staticAnalysisCommon_1.isLowLevelCall(node) || staticAnalysisCommon_1.isTransfer(node) || staticAnalysisCommon_1.isExternalDirectCall(node) || staticAnalysisCommon_1.isEffect(node) || staticAnalysisCommon_1.isLocalCallGraphRelevantNode(node) || node.nodeType === "InlineAssembly" || node.nodeType === "NewExpression" || staticAnalysisCommon_1.isSelfdestructCall(node) || staticAnalysisCommon_1.isDeleteUnaryOperation(node));
    this.report = this.abstractAst.build_report(this._report.bind(this));
  }

  _report(contracts, multipleContractsWithSameName, version) {
    const warnings = [];
    const hasModifiers = contracts.some(item => item.modifiers.length > 0);
    const callGraph = functionCallGraph_1.buildGlobalFuncCallGraph(contracts);
    contracts.forEach(contract => {
      contract.functions.forEach(func => {
        if (staticAnalysisCommon_1.isPayableFunction(func.node) || staticAnalysisCommon_1.isConstructor(func.node)) {
          func['potentiallyshouldBeConst'] = false;
        } else {
          func['potentiallyshouldBeConst'] = this.checkIfShouldBeConstant(staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent(contract.node, func.node, func.parameters), this.getContext(callGraph, contract, func));
        }
      });
      contract.functions.filter(func => staticAnalysisCommon_1.hasFunctionBody(func.node)).forEach(func => {
        if (staticAnalysisCommon_1.isConstantFunction(func.node) !== func['potentiallyshouldBeConst']) {
          const funcName = staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent(contract.node, func.node, func.parameters);
          let comments = hasModifiers ? 'Note: Modifiers are currently not considered by this static analysis.' : '';
          comments += multipleContractsWithSameName ? 'Note: Import aliases are currently not supported by this static analysis.' : '';

          if (func['potentiallyshouldBeConst']) {
            warnings.push({
              warning: `${funcName} : Potentially should be constant/view/pure but is not. ${comments}`,
              location: func.node['src'],
              more: `https://solidity.readthedocs.io/en/${version}/contracts.html#view-functions`
            });
          } else {
            warnings.push({
              warning: `${funcName} : Is constant but potentially should not be. ${comments}`,
              location: func.node['src'],
              more: `https://solidity.readthedocs.io/en/${version}/contracts.html#view-functions`
            });
          }
        }
      });
    });
    return warnings;
  }

  getContext(callGraph, currentContract, func) {
    return {
      callGraph: callGraph,
      currentContract: currentContract,
      stateVariables: this.getStateVariables(currentContract, func)
    };
  }

  getStateVariables(contract, func) {
    return contract.stateVariables.concat(func.localVariables.filter(staticAnalysisCommon_1.isStorageVariableDeclaration));
  }

  checkIfShouldBeConstant(startFuncName, context) {
    return !functionCallGraph_1.analyseCallGraph(context.callGraph, startFuncName, context, this.isConstBreaker.bind(this));
  }

  isConstBreaker(node, context) {
    return staticAnalysisCommon_1.isWriteOnStateVariable(node, context.stateVariables) || staticAnalysisCommon_1.isLowLevelCall(node) || staticAnalysisCommon_1.isTransfer(node) || this.isCallOnNonConstExternalInterfaceFunction(node, context) || staticAnalysisCommon_1.isCallToNonConstLocalFunction(node) || node.nodeType === "InlineAssembly" || node.nodeType === "NewExpression" || staticAnalysisCommon_1.isSelfdestructCall(node) || staticAnalysisCommon_1.isDeleteUnaryOperation(node);
  }

  isCallOnNonConstExternalInterfaceFunction(node, context) {
    if (staticAnalysisCommon_1.isExternalDirectCall(node)) {
      const func = functionCallGraph_1.resolveCallGraphSymbol(context.callGraph, staticAnalysisCommon_1.getFullQualifiedFunctionCallIdent(context.currentContract.node, node));
      return !func || func && !staticAnalysisCommon_1.isConstantFunction(func.node.node);
    }

    return false;
  }

}

exports.default = constantFunctions;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/deleteDynamicArrays.js":
/*!**************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/deleteDynamicArrays.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class deleteDynamicArrays {
  constructor() {
    this.rel = [];
    this.name = `Delete dynamic array: `;
    this.description = `Use require/assert to ensure complete deletion`;
    this.category = categories_1.default.GAS;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (staticAnalysisCommon_1.isDeleteOfDynamicArray(node)) this.rel.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.rel.map(node => {
      return {
        warning: `The "delete" operation when applied to a dynamically sized array in Solidity generates code to delete each of the elements contained. If the array is large, this operation can surpass the block gas limit and raise an OOG exception. Also nested dynamically sized objects can produce the same results.`,
        location: node.src,
        more: `https://solidity.readthedocs.io/en/${version}/types.html#delete`
      };
    });
  }

}

exports.default = deleteDynamicArrays;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/deleteFromDynamicArray.js":
/*!*****************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/deleteFromDynamicArray.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

class deleteFromDynamicArray {
  constructor() {
    this.relevantNodes = [];
    this.name = `Delete from dynamic array: `;
    this.description = `'delete' leaves a gap in array`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (staticAnalysisCommon_1.isDeleteFromDynamicArray(node) && !staticAnalysisCommon_1.isMappingIndexAccess(node.subExpression)) this.relevantNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    return this.relevantNodes.map(node => {
      return {
        warning: `Using "delete" on an array leaves a gap. The length of the array remains the same. If you want to remove the empty position you need to shift items manually and update the "length" property.`,
        location: node.src,
        more: 'https://github.com/miguelmota/solidity-idiosyncrasies#examples'
      };
    });
  }

}

exports.default = deleteFromDynamicArray;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/erc20Decimals.js":
/*!********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/erc20Decimals.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const abstractAstView_1 = tslib_1.__importDefault(__webpack_require__(/*! ./abstractAstView */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js"));

class erc20Decimals {
  constructor() {
    this.name = `ERC20: `;
    this.description = `'decimals' should be 'uint8'`;
    this.category = categories_1.default.ERC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default(); // eslint-disable-next-line @typescript-eslint/no-unused-vars

    this.visit = this.abstractAst.build_visit(node => false);
    this.report = this.abstractAst.build_report(this._report.bind(this));
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _report(contracts, multipleContractsWithSameName) {
    const warnings = [];
    contracts.forEach(contract => {
      const contractAbiSignatures = contract.functions.map(f => staticAnalysisCommon_1.helpers.buildAbiSignature(staticAnalysisCommon_1.getFunctionDefinitionName(f.node), f.parameters));

      if (this.isERC20(contractAbiSignatures)) {
        const decimalsVar = contract.stateVariables.filter(stateVar => staticAnalysisCommon_1.getDeclaredVariableName(stateVar) === 'decimals' && (staticAnalysisCommon_1.getDeclaredVariableType(stateVar) !== 'uint8' || stateVar.visibility !== 'public'));
        const decimalsFun = contract.functions.filter(f => staticAnalysisCommon_1.getFunctionDefinitionName(f.node) === 'decimals' && (f.returns.length === 0 || f.returns.length > 1 || f.returns.length === 1 && (f.returns[0].type !== 'uint8' || f.node.visibility !== 'public')));

        if (decimalsVar.length > 0) {
          for (const node of decimalsVar) {
            warnings.push({
              warning: `ERC20 contract's "decimals" variable should be "uint8" type`,
              location: node.src,
              more: 'https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#decimals'
            });
          }
        } else if (decimalsFun.length > 0) {
          for (const fn of decimalsFun) {
            warnings.push({
              warning: `ERC20 contract's "decimals" function should have "uint8" as return type`,
              location: fn.node.src,
              more: 'https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#decimals'
            });
          }
        }
      }
    });
    return warnings;
  }

  isERC20(funSignatures) {
    return funSignatures.includes('totalSupply()') && funSignatures.includes('balanceOf(address)') && funSignatures.includes('transfer(address,uint256)') && funSignatures.includes('transferFrom(address,address,uint256)') && funSignatures.includes('approve(address,uint256)') && funSignatures.includes('allowance(address,address)');
  }

}

exports.default = erc20Decimals;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/etherTransferInLoop.js":
/*!**************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/etherTransferInLoop.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

class etherTransferInLoop {
  constructor() {
    this.relevantNodes = [];
    this.name = `Ether transfer in loop: `;
    this.description = `Transferring Ether in a for/while/do-while loop`;
    this.category = categories_1.default.GAS;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    let transferNodes = [];

    if (staticAnalysisCommon_1.isLoop(node)) {
      if (node.body && node.body.nodeType === 'Block') transferNodes = node.body.statements.filter(child => child.nodeType === 'ExpressionStatement' && child.expression.nodeType === 'FunctionCall' && staticAnalysisCommon_1.isTransfer(child.expression.expression)); // When loop body is described without braces
      else if (node.body && node.body.nodeType === 'ExpressionStatement' && node.body.expression.nodeType === 'FunctionCall' && staticAnalysisCommon_1.isTransfer(node.body.expression.expression)) transferNodes.push(node.body);

      if (transferNodes.length > 0) {
        this.relevantNodes.push(...transferNodes);
      }
    }
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.relevantNodes.map(node => {
      return {
        warning: `Ether payout should not be done in a loop: Due to the block gas limit, transactions can only consume a certain amount of gas. The number of iterations in a loop can grow beyond the block gas limit which can cause the complete contract to be stalled at a certain point. If required then make sure that number of iterations are low and you trust each address involved.`,
        location: node.src,
        more: `https://solidity.readthedocs.io/en/${version}/security-considerations.html#gas-limit-and-loops`
      };
    });
  }

}

exports.default = etherTransferInLoop;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/forLoopIteratesOverDynamicArray.js":
/*!**************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/forLoopIteratesOverDynamicArray.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

class forLoopIteratesOverDynamicArray {
  constructor() {
    this.relevantNodes = [];
    this.name = `For loop over dynamic array: `;
    this.description = `Iterations depend on dynamic array's size`;
    this.category = categories_1.default.GAS;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    const {
      condition
    } = node; // Check if condition is `i < array.length - 1`

    if (condition && condition.nodeType === "BinaryOperation" && condition.rightExpression.nodeType === "BinaryOperation" && staticAnalysisCommon_1.isDynamicArrayLengthAccess(condition.rightExpression.leftExpression) || // or condition is `i < array.length`
    condition && condition.nodeType === "BinaryOperation" && staticAnalysisCommon_1.isDynamicArrayLengthAccess(condition.rightExpression)) {
      this.relevantNodes.push(node);
    }
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.relevantNodes.map(node => {
      return {
        warning: `Loops that do not have a fixed number of iterations, for example, loops that depend on storage values, have to be used carefully. Due to the block gas limit, transactions can only consume a certain amount of gas. The number of iterations in a loop can grow beyond the block gas limit which can cause the complete contract to be stalled at a certain point. \n Additionally, using unbounded loops incurs in a lot of avoidable gas costs. Carefully test how many items at maximum you can pass to such functions to make it successful.`,
        location: node.src,
        more: `https://solidity.readthedocs.io/en/${version}/security-considerations.html#gas-limit-and-loops`
      };
    });
  }

}

exports.default = forLoopIteratesOverDynamicArray;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/functionCallGraph.js":
/*!************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/functionCallGraph.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

function buildLocalFuncCallGraphInternal(functions, nodeFilter, extractNodeIdent, extractFuncDefIdent) {
  const callGraph = {};
  functions.forEach(func => {
    const calls = func.relevantNodes.filter(nodeFilter).map(extractNodeIdent).filter(name => name !== extractFuncDefIdent(func)); // filter self recursive call

    callGraph[extractFuncDefIdent(func)] = {
      node: func,
      calls: calls
    };
  });
  return callGraph;
}
/**
 * Builds a function call graph for the current contracts.
 * Example Contract call graph:
 *
 * {
 *  "KingOfTheEtherThrone": {
 *    "contracts": {...},                                        // Contract node as defined in abstractAstView.js
 *    "functions": {
 *      "KingOfTheEtherThrone.claimThrone(string memory)": {    // function in KingOfEtherThrone
 *        "node": {...},                                        // function node as defined in abstractAstView.js
 *        "calls": {                                            // list of full qualified function names which are called form this function
 *        }
 *      }
 *    }
 *  },
 *  "foo": {
 *    "contract": {...},           // Contract node as definded in abstractAstView.js
 *    "functions": {}             // map from full qualified function name to func node
 *  }
 * }
 *
 * @contracts {list contracts} Expects as input the contract structure defined in abstractAstView.js
 * @return {map (string -> Contract Call Graph)} returns map from contract name to contract call graph
 */


function buildGlobalFuncCallGraph(contracts) {
  const callGraph = {};
  contracts.forEach(contract => {
    const filterNodes = node => {
      return staticAnalysisCommon_1.isLocalCallGraphRelevantNode(node) || staticAnalysisCommon_1.isExternalDirectCall(node);
    };

    const getNodeIdent = node => {
      return staticAnalysisCommon_1.getFullQualifiedFunctionCallIdent(contract.node, node);
    };

    const getFunDefIdent = funcDef => {
      return staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent(contract.node, funcDef.node, funcDef.parameters);
    };

    callGraph[staticAnalysisCommon_1.getContractName(contract.node)] = {
      contract: contract,
      functions: buildLocalFuncCallGraphInternal(contract.functions, filterNodes, getNodeIdent, getFunDefIdent)
    };
  });
  return callGraph;
}

exports.buildGlobalFuncCallGraph = buildGlobalFuncCallGraph;
/**
 * Walks through the call graph from a defined starting function, true if nodeCheck holds for every relevant node in the callgraph
 * @callGraph {callGraph} As returned by buildGlobalFuncCallGraph
 * @funcName {string} full qualified name of the starting function
 * @context {Object} provides additional context information that can be used by the nodeCheck function
 * @nodeCheck {(ASTNode, context) -> bool} applied on every relevant node in the call graph
 * @return {bool} returns map from contract name to contract call graph
 */

function analyseCallGraph(callGraph, funcName, context, nodeCheck) {
  return analyseCallGraphInternal(callGraph, funcName, context, (a, b) => a || b, nodeCheck, {});
}

exports.analyseCallGraph = analyseCallGraph;

function analyseCallGraphInternal(callGraph, funcName, context, combinator, nodeCheck, visited) {
  const current = resolveCallGraphSymbol(callGraph, funcName);
  if (current === undefined || visited[funcName] === true) return true;
  visited[funcName] = true;
  return combinator(current.node.relevantNodes.reduce((acc, val) => combinator(acc, nodeCheck(val, context)), false), current.calls.reduce((acc, val) => combinator(acc, analyseCallGraphInternal(callGraph, val, context, combinator, nodeCheck, visited)), false));
}

function resolveCallGraphSymbol(callGraph, funcName) {
  return resolveCallGraphSymbolInternal(callGraph, funcName, false);
}

exports.resolveCallGraphSymbol = resolveCallGraphSymbol;

function resolveCallGraphSymbolInternal(callGraph, funcName, silent) {
  let current = null;

  if (funcName.includes('.')) {
    const parts = funcName.split('.');
    const contractPart = parts[0];
    const functionPart = parts[1];
    const currentContract = callGraph[contractPart];

    if (!(currentContract === undefined)) {
      current = currentContract.functions[funcName]; // resolve inheritance hierarchy

      if (current === undefined) {
        // resolve inheritance lookup in linearized fashion
        const inheritsFromNames = currentContract.contract.inheritsFrom.reverse();

        for (let i = 0; i < inheritsFromNames.length; i++) {
          const res = resolveCallGraphSymbolInternal(callGraph, inheritsFromNames[i] + '.' + functionPart, true);
          if (!(res === undefined)) return res;
        }
      }
    } else {
      if (!silent) console.log(`static analysis functionCallGraph.js: Contract ${contractPart} not found in function call graph.`);
    }
  } else {
    throw new Error('functionCallGraph.js: function does not have full qualified name.');
  }

  if (current === undefined && !silent) console.log(`static analysis functionCallGraph.js: ${funcName} not found in function call graph.`);
  if (current !== null) return current;
}

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/gasCosts.js":
/*!***************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/gasCosts.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

class gasCosts {
  constructor() {
    this.name = `Gas costs: `;
    this.description = `Too high gas requirement of functions`;
    this.category = categories_1.default.GAS;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
    this.warningNodes = [];
  }

  visit(node) {
    if (node.nodeType === 'FunctionDefinition' && node.kind !== 'constructor' && node.implemented || node.nodeType === 'VariableDeclaration' && staticAnalysisCommon_1.isVariableTurnedIntoGetter(node)) this.warningNodes.push(node);
  }

  report(compilationResults) {
    const report = [];
    const methodsWithSignature = this.warningNodes.map(node => {
      let signature;

      if (node.nodeType === 'FunctionDefinition') {
        const functionName = staticAnalysisCommon_1.getFunctionDefinitionName(node);
        signature = staticAnalysisCommon_1.helpers.buildAbiSignature(functionName, staticAnalysisCommon_1.getMethodParamsSplittedTypeDesc(node, compilationResults.contracts));
      } else signature = node.name + '()';

      return {
        name: node.name,
        src: node.src,
        signature: signature
      };
    });

    for (const method of methodsWithSignature) {
      for (const filename in compilationResults.contracts) {
        for (const contractName in compilationResults.contracts[filename]) {
          const contract = compilationResults.contracts[filename][contractName];
          const methodGas = this.checkMethodGas(contract, method.signature);

          if (methodGas && methodGas.isInfinite) {
            if (methodGas.isFallback) {
              report.push({
                warning: `Fallback function of contract ${contractName} requires too much gas (${methodGas.msg}). 
                If the fallback function requires more than 2300 gas, the contract cannot receive Ether.`,
                location: method.src
              });
            } else {
              report.push({
                warning: `Gas requirement of function ${contractName}.${method.name} ${methodGas.msg}: 
                If the gas requirement of a function is higher than the block gas limit, it cannot be executed.
                Please avoid loops in your functions or actions that modify large areas of storage
                (this includes clearing or copying arrays in storage)`,
                location: method.src
              });
            }
          } else continue;
        }
      }
    }

    return report;
  }

  checkMethodGas(contract, methodSignature) {
    if (contract.evm && contract.evm.gasEstimates && contract.evm.gasEstimates.external) {
      if (methodSignature === '()') {
        const fallback = contract.evm.gasEstimates.external[''];

        if (fallback !== undefined && (fallback === null || parseInt(fallback) >= 2100 || fallback === 'infinite')) {
          return {
            isInfinite: true,
            isFallback: true,
            msg: fallback
          };
        }
      } else {
        const gas = contract.evm.gasEstimates.external[methodSignature];
        const gasString = gas === null ? 'unknown or not constant' : 'is ' + gas;

        if (gas === null || parseInt(gas) >= 3000000 || gas === 'infinite') {
          return {
            isInfinite: true,
            isFallback: false,
            msg: gasString
          };
        }
      }
    }
  }

}

exports.default = gasCosts;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/guardConditions.js":
/*!**********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/guardConditions.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class guardConditions {
  constructor() {
    this.guards = [];
    this.name = `Guard conditions: `;
    this.description = `Ensure appropriate use of require/assert`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (staticAnalysisCommon_1.isRequireCall(node) || staticAnalysisCommon_1.isAssertCall(node)) this.guards.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.guards.map(node => {
      return {
        warning: `Use "assert(x)" if you never ever want x to be false, not in any circumstance (apart from a bug in your code). Use "require(x)" if x can be false, due to e.g. invalid input or a failing external component.`,
        location: node.src,
        more: `https://solidity.readthedocs.io/en/${version}/control-structures.html#error-handling-assert-require-revert-and-exceptions`
      };
    });
  }

}

exports.default = guardConditions;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/inlineAssembly.js":
/*!*********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/inlineAssembly.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

class inlineAssembly {
  constructor() {
    this.inlineAssNodes = [];
    this.name = `Inline assembly: `;
    this.description = `Inline assembly used`;
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (node.nodeType === 'InlineAssembly') this.inlineAssNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.inlineAssNodes.map(node => {
      return {
        warning: `The Contract uses inline assembly, this is only advised in rare cases. 
                  Additionally static analysis modules do not parse inline Assembly, this can lead to wrong analysis results.`,
        location: node.src,
        more: `https://solidity.readthedocs.io/en/${version}/assembly.html`
      };
    });
  }

}

exports.default = inlineAssembly;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/intDivisionTruncate.js":
/*!**************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/intDivisionTruncate.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class intDivisionTruncate {
  constructor() {
    this.warningNodes = [];
    this.name = `Data truncated: `;
    this.description = `Division on int/uint values truncates the result`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (staticAnalysisCommon_1.isIntDivision(node)) this.warningNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    return this.warningNodes.map(item => {
      return {
        warning: 'Division of integer values yields an integer value again. That means e.g. 10 / 100 = 0 instead of 0.1 since the result is an integer again. This does not hold for division of (only) literal values since those yield rational constants.',
        location: item.src
      };
    });
  }

}

exports.default = intDivisionTruncate;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/list.js":
/*!***********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/list.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const txOrigin_1 = tslib_1.__importDefault(__webpack_require__(/*! ./txOrigin */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/txOrigin.js"));

const gasCosts_1 = tslib_1.__importDefault(__webpack_require__(/*! ./gasCosts */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/gasCosts.js"));

const thisLocal_1 = tslib_1.__importDefault(__webpack_require__(/*! ./thisLocal */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/thisLocal.js"));

const checksEffectsInteraction_1 = tslib_1.__importDefault(__webpack_require__(/*! ./checksEffectsInteraction */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/checksEffectsInteraction.js"));

const constantFunctions_1 = tslib_1.__importDefault(__webpack_require__(/*! ./constantFunctions */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/constantFunctions.js"));

const similarVariableNames_1 = tslib_1.__importDefault(__webpack_require__(/*! ./similarVariableNames */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/similarVariableNames.js"));

const inlineAssembly_1 = tslib_1.__importDefault(__webpack_require__(/*! ./inlineAssembly */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/inlineAssembly.js"));

const blockTimestamp_1 = tslib_1.__importDefault(__webpack_require__(/*! ./blockTimestamp */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/blockTimestamp.js"));

const lowLevelCalls_1 = tslib_1.__importDefault(__webpack_require__(/*! ./lowLevelCalls */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/lowLevelCalls.js"));

const blockBlockhash_1 = tslib_1.__importDefault(__webpack_require__(/*! ./blockBlockhash */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/blockBlockhash.js"));

const noReturn_1 = tslib_1.__importDefault(__webpack_require__(/*! ./noReturn */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/noReturn.js"));

const selfdestruct_1 = tslib_1.__importDefault(__webpack_require__(/*! ./selfdestruct */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/selfdestruct.js"));

const guardConditions_1 = tslib_1.__importDefault(__webpack_require__(/*! ./guardConditions */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/guardConditions.js"));

const deleteDynamicArrays_1 = tslib_1.__importDefault(__webpack_require__(/*! ./deleteDynamicArrays */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/deleteDynamicArrays.js"));

const assignAndCompare_1 = tslib_1.__importDefault(__webpack_require__(/*! ./assignAndCompare */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/assignAndCompare.js"));

const erc20Decimals_1 = tslib_1.__importDefault(__webpack_require__(/*! ./erc20Decimals */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/erc20Decimals.js"));

const stringBytesLength_1 = tslib_1.__importDefault(__webpack_require__(/*! ./stringBytesLength */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/stringBytesLength.js"));

const deleteFromDynamicArray_1 = tslib_1.__importDefault(__webpack_require__(/*! ./deleteFromDynamicArray */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/deleteFromDynamicArray.js"));

const forLoopIteratesOverDynamicArray_1 = tslib_1.__importDefault(__webpack_require__(/*! ./forLoopIteratesOverDynamicArray */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/forLoopIteratesOverDynamicArray.js"));

const etherTransferInLoop_1 = tslib_1.__importDefault(__webpack_require__(/*! ./etherTransferInLoop */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/etherTransferInLoop.js"));

const intDivisionTruncate_1 = tslib_1.__importDefault(__webpack_require__(/*! ./intDivisionTruncate */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/intDivisionTruncate.js"));

exports.default = [txOrigin_1.default, gasCosts_1.default, thisLocal_1.default, checksEffectsInteraction_1.default, erc20Decimals_1.default, constantFunctions_1.default, similarVariableNames_1.default, inlineAssembly_1.default, blockTimestamp_1.default, lowLevelCalls_1.default, blockBlockhash_1.default, noReturn_1.default, selfdestruct_1.default, guardConditions_1.default, deleteDynamicArrays_1.default, assignAndCompare_1.default, stringBytesLength_1.default, deleteFromDynamicArray_1.default, forLoopIteratesOverDynamicArray_1.default, etherTransferInLoop_1.default, intDivisionTruncate_1.default];

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/lowLevelCalls.js":
/*!********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/lowLevelCalls.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class lowLevelCalls {
  constructor() {
    this.llcNodes = [];
    this.name = `Low level calls: `;
    this.description = `Should only be used by experienced devs`;
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (staticAnalysisCommon_1.isLLCall(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.CALL
      });
    } else if (staticAnalysisCommon_1.isLLDelegatecall(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.DELEGATECALL
      });
    } else if (staticAnalysisCommon_1.isLLSend(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.SEND
      });
    } else if (staticAnalysisCommon_1.isLLDelegatecall04(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.DELEGATECALL
      });
    } else if (staticAnalysisCommon_1.isLLSend04(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.SEND
      });
    } else if (staticAnalysisCommon_1.isLLCall04(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.CALL
      });
    } else if (staticAnalysisCommon_1.isLLCallcode(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.CALLCODE
      });
    }
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.llcNodes.map((item, i) => {
      let text = '';
      let morehref = '';

      switch (item.type) {
        case staticAnalysisCommon_1.lowLevelCallTypes.CALL:
          text = `Use of "call": should be avoided whenever possible. 
                  It can lead to unexpected behavior if return value is not handled properly. 
                  Please use Direct Calls via specifying the called contract's interface.`;
          morehref = `https://solidity.readthedocs.io/en/${version}/control-structures.html?#external-function-calls`;
          break;

        case staticAnalysisCommon_1.lowLevelCallTypes.CALLCODE:
          text = `Use of "callcode": should be avoided whenever possible. 
                  External code, that is called can change the state of the calling contract and send ether from the caller's balance. 
                  If this is wanted behaviour, use the Solidity library feature if possible.`;
          morehref = `https://solidity.readthedocs.io/en/${version}/contracts.html#libraries`;
          break;

        case staticAnalysisCommon_1.lowLevelCallTypes.DELEGATECALL:
          text = `Use of "delegatecall": should be avoided whenever possible. 
                  External code, that is called can change the state of the calling contract and send ether from the caller's balance. 
                  If this is wanted behaviour, use the Solidity library feature if possible.`;
          morehref = `https://solidity.readthedocs.io/en/${version}/contracts.html#libraries`;
          break;

        case staticAnalysisCommon_1.lowLevelCallTypes.SEND:
          text = `Use of "send": "send" does not throw an exception when not successful, make sure you deal with the failure case accordingly. 
                  Use "transfer" whenever failure of the ether transfer should rollback the whole transaction. 
                  Note: if you "send/transfer" ether to a contract the fallback function is called, the callees fallback function is very limited due to the limited amount of gas provided by "send/transfer". 
                  No state changes are possible but the callee can log the event or revert the transfer. "send/transfer" is syntactic sugar for a "call" to the fallback function with 2300 gas and a specified ether value.`;
          morehref = `https://solidity.readthedocs.io/en/${version}/security-considerations.html#sending-and-receiving-ether`;
          break;
      }

      return {
        warning: text,
        more: morehref,
        location: item.node.src
      };
    });
  }

}

exports.default = lowLevelCalls;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/noReturn.js":
/*!***************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/noReturn.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const abstractAstView_1 = tslib_1.__importDefault(__webpack_require__(/*! ./abstractAstView */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js"));

class noReturn {
  constructor() {
    this.name = `No return: `;
    this.description = `Function with 'returns' not returning`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default();
    this.visit = this.abstractAst.build_visit(node => node.nodeType === "Return" || node.nodeType === "Assignment");
    this.report = this.abstractAst.build_report(this._report.bind(this));
  }

  _report(contracts, multipleContractsWithSameName, version) {
    const warnings = [];
    contracts.forEach(contract => {
      contract.functions.filter(func => staticAnalysisCommon_1.hasFunctionBody(func.node)).forEach(func => {
        const funcName = staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent(contract.node, func.node, func.parameters);

        if (this.hasNamedAndUnnamedReturns(func)) {
          warnings.push({
            warning: `${funcName}: Mixing of named and unnamed return parameters is not advised.`,
            location: func.node['src']
          });
        } else if (this.shouldReturn(func) && !(this.hasReturnStatement(func) || this.hasNamedReturns(func) && this.hasAssignToAllNamedReturns(func))) {
          warnings.push({
            warning: `${funcName}: Defines a return type but never explicitly returns a value.`,
            location: func.node['src']
          });
        }
      });
    });
    return warnings;
  }

  shouldReturn(func) {
    return func.returns.length > 0;
  }

  hasReturnStatement(func) {
    return func.relevantNodes.filter(n => n.nodeType === "Return").length > 0;
  }

  hasAssignToAllNamedReturns(func) {
    const namedReturns = func.returns.filter(n => n.name.length > 0).map(n => n.name);
    const assignedVars = func.relevantNodes.filter(n => n.nodeType === "Assignment").map(staticAnalysisCommon_1.getEffectedVariableName);
    const diff = namedReturns.filter(e => !assignedVars.includes(e));
    return diff.length === 0;
  }

  hasNamedReturns(func) {
    return func.returns.filter(n => n.name.length > 0).length > 0;
  }

  hasNamedAndUnnamedReturns(func) {
    return func.returns.filter(n => n.name.length === 0).length > 0 && this.hasNamedReturns(func);
  }

}

exports.default = noReturn;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/selfdestruct.js":
/*!*******************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/selfdestruct.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const abstractAstView_1 = tslib_1.__importDefault(__webpack_require__(/*! ./abstractAstView */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js"));

class selfdestruct {
  constructor() {
    this.name = `Selfdestruct: `;
    this.description = `Contracts using destructed contract can be broken`;
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.HEURISTIC;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default();
    this.visit = this.abstractAst.build_visit(node => staticAnalysisCommon_1.isStatement(node) || node.nodeType === 'FunctionCall' && staticAnalysisCommon_1.isSelfdestructCall(node));
    this.report = this.abstractAst.build_report(this._report.bind(this));
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _report(contracts, multipleContractsWithSameName, version) {
    const warnings = [];
    contracts.forEach(contract => {
      contract.functions.forEach(func => {
        let hasSelf = false;
        func.relevantNodes.forEach(node => {
          if (staticAnalysisCommon_1.isSelfdestructCall(node)) {
            warnings.push({
              warning: `Use of selfdestruct: Can block calling contracts unexpectedly. Be especially careful if this contract is planned to be used by other contracts (i.e. library contracts, interactions). Selfdestruction of the callee contract can leave callers in an inoperable state.`,
              location: node.src,
              more: 'https://paritytech.io/blog/security-alert.html'
            });
            hasSelf = true;
          }

          if (staticAnalysisCommon_1.isStatement(node) && hasSelf) {
            warnings.push({
              warning: `Use of selfdestruct: No code after selfdestruct is executed. Selfdestruct is a terminal.`,
              location: node.src,
              more: `https://solidity.readthedocs.io/en/${version}/introduction-to-smart-contracts.html#deactivate-and-self-destruct`
            });
            hasSelf = false;
          }
        });
      });
    });
    return warnings;
  }

}

exports.default = selfdestruct;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/similarVariableNames.js":
/*!***************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/similarVariableNames.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const abstractAstView_1 = tslib_1.__importDefault(__webpack_require__(/*! ./abstractAstView */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js"));

const fast_levenshtein_1 = __webpack_require__(/*! fast-levenshtein */ "../../../node_modules/fast-levenshtein/levenshtein.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

const remix_astwalker_1 = __webpack_require__(/*! @remix-project/remix-astwalker */ "../../../dist/libs/remix-astwalker/index.js");

class similarVariableNames {
  constructor() {
    this.name = `Similar variable names: `;
    this.description = `Variable names are too similar`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default(); // eslint-disable-next-line @typescript-eslint/no-unused-vars

    this.visit = this.abstractAst.build_visit(node => false);
    this.report = this.abstractAst.build_report(this._report.bind(this));
  }

  _report(contracts, multipleContractsWithSameName, version) {
    const warnings = [];
    const hasModifiers = contracts.some(item => item.modifiers.length > 0);
    contracts.forEach(contract => {
      contract.functions.forEach(func => {
        const funcName = staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent(contract.node, func.node, func.parameters);
        let hasModifiersComments = '';

        if (hasModifiers) {
          hasModifiersComments = 'Note: Modifiers are currently not considered by this static analysis.';
        }

        let multipleContractsWithSameNameComments = '';

        if (multipleContractsWithSameName) {
          multipleContractsWithSameNameComments = 'Note: Import aliases are currently not supported by this static analysis.';
        }

        const vars = this.getFunctionVariables(contract, func).map(staticAnalysisCommon_1.getDeclaredVariableName);
        this.findSimilarVarNames(vars).map(sim => {
          // check if function is implemented
          if (func.node.implemented) {
            const astWalker = new remix_astwalker_1.AstWalker();
            const functionBody = func.node.body; // Walk through all statements of function

            astWalker.walk(functionBody, node => {
              // check if these is an identifier node which is one of the tracked similar variables
              if ((node.nodeType === 'Identifier' || node.nodeType === 'VariableDeclaration') && (node.name === sim.var1 || node.name === sim.var2)) {
                warnings.push({
                  warning: `${funcName} : Variables have very similar names "${sim.var1}" and "${sim.var2}". ${hasModifiersComments} ${multipleContractsWithSameNameComments}`,
                  location: node['src']
                });
              }

              return true;
            });
          }
        });
      });
    });
    return warnings;
  }

  findSimilarVarNames(vars) {
    const similar = [];
    const comb = {};
    vars.map(varName1 => vars.map(varName2 => {
      if (varName1.length > 1 && varName2.length > 1 && varName2 !== varName1 && !this.isCommonPrefixedVersion(varName1, varName2) && !this.isCommonNrSuffixVersion(varName1, varName2) && !(comb[varName1 + ';' + varName2] || comb[varName2 + ';' + varName1])) {
        comb[varName1 + ';' + varName2] = true;
        const distance = fast_levenshtein_1.get(varName1, varName2);
        if (distance <= 2) similar.push({
          var1: varName1,
          var2: varName2,
          distance: distance
        });
      }
    }));
    return similar;
  }

  isCommonPrefixedVersion(varName1, varName2) {
    return varName1.startsWith('_') && varName1.slice(1) === varName2 || varName2.startsWith('_') && varName2.slice(1) === varName1;
  }

  isCommonNrSuffixVersion(varName1, varName2) {
    const ref = '^' + remix_lib_1.util.escapeRegExp(varName1.slice(0, -1)) + '[0-9]*$';
    return varName2.match(ref) != null;
  }

  getFunctionVariables(contract, func) {
    return contract.stateVariables.concat(func.localVariables);
  }

}

exports.default = similarVariableNames;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js":
/*!***************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

const nodeTypes = {
  SOURCEUNIT: 'SourceUnit',
  PRAGMADIRECTIVE: 'PragmaDirective',
  IMPORTDIRECTIVE: 'ImportDirective',
  CONTRACTDEFINITION: 'ContractDefinition',
  INHERITANCESPECIFIER: 'InheritanceSpecifier',
  USINGFORDIRECTIVE: 'UsingForDirective',
  STRUCTDEFINITION: 'StructDefinition',
  ENUMDEFINITION: 'EnumDefinition',
  ENUMVALUE: 'EnumValue',
  PARAMETERLIST: 'ParameterList',
  OVERRIDESPECIFIER: 'OverrideSpecifier',
  FUNCTIONDEFINITION: 'FunctionDefinition',
  VARIABLEDECLARATION: 'VariableDeclaration',
  MODIFIERDEFINITION: 'ModifierDefinition',
  MODIFIERINVOCATION: 'ModifierInvocation',
  EVENTDEFINITION: 'EventDefinition',
  ELEMENTARYTYPENAME: 'ElementaryTypeName',
  USERDEFINEDTYPENAME: 'UserDefinedTypeName',
  FUNCTIONTYPENAME: 'FunctionTypeName',
  MAPPING: 'Mapping',
  ARRAYTYPENAME: 'ArrayTypeName',
  INLINEASSEMBLY: 'InlineAssembly',
  BLOCK: 'Block',
  PLACEHOLDERSTATEMENT: 'PlaceholderStatement',
  IFSTATEMENT: 'IfStatement',
  TRYCATCHCLAUSE: 'TryCatchClause',
  TRYSTATEMENT: 'TryStatement',
  WHILESTATEMENT: 'WhileStatement',
  DOWHILESTATEMENT: 'DoWhileStatement',
  FORSTATEMENT: 'ForStatement',
  CONTINUE: 'Continue',
  BREAK: 'Break',
  RETURN: 'Return',
  THROW: 'Throw',
  EMITSTATEMENT: 'EmitStatement',
  VARIABLEDECLARATIONSTATEMENT: 'VariableDeclarationStatement',
  EXPRESSIONSTATEMENT: 'ExpressionStatement',
  CONDITIONAL: 'Conditional',
  ASSIGNMENT: 'Assignment',
  TUPLEEXPRESSION: 'TupleExpression',
  UNARYOPERATION: 'UnaryOperation',
  BINARYOPERATION: 'BinaryOperation',
  FUNCTIONCALL: 'FunctionCall',
  FUNCTIONCALLOPTIONS: 'FunctionCallOptions',
  NEWEXPRESSION: 'NewExpression',
  MEMBERACCESS: 'MemberAccess',
  INDEXACCESS: 'IndexAccess',
  INDEXRANGEACCESS: 'IndexRangeAccess',
  ELEMENTARYTYPENAMEEXPRESSION: 'ElementaryTypeNameExpression',
  LITERAL: 'Literal',
  IDENTIFIER: 'Identifier',
  STRUCTUREDDOCUMENTATION: 'StructuredDocumentation'
};
exports.nodeTypes = nodeTypes;
const basicTypes = {
  UINT: 'uint256',
  BOOL: 'bool',
  ADDRESS: 'address',
  PAYABLE_ADDRESS: 'address payable',
  BYTES32: 'bytes32',
  STRING_MEM: 'string memory',
  BYTES_MEM: 'bytes memory',
  BYTES4: 'bytes4'
};
exports.basicTypes = basicTypes;
const basicRegex = {
  CONTRACTTYPE: '^contract ',
  FUNCTIONTYPE: '^function \\(',
  EXTERNALFUNCTIONTYPE: '^function \\(.*\\).* external',
  CONSTANTFUNCTIONTYPE: '^function \\(.*\\).* (view|pure)',
  REFTYPE: '(storage)|(mapping\\()|(\\[\\])',
  FUNCTIONSIGNATURE: '^function \\(([^\\(]*)\\)',
  LIBRARYTYPE: '^type\\(library (.*)\\)'
};
const basicFunctionTypes = {
  SEND: buildFunctionSignature([basicTypes.UINT], [basicTypes.BOOL], false),
  'CALL-0.4': buildFunctionSignature([], [basicTypes.BOOL], true),
  CALL: buildFunctionSignature([basicTypes.BYTES_MEM], [basicTypes.BOOL, basicTypes.BYTES_MEM], true),
  'DELEGATECALL-0.4': buildFunctionSignature([], [basicTypes.BOOL], false),
  DELEGATECALL: buildFunctionSignature([basicTypes.BYTES_MEM], [basicTypes.BOOL, basicTypes.BYTES_MEM], false),
  TRANSFER: buildFunctionSignature([basicTypes.UINT], [], false)
};
exports.basicFunctionTypes = basicFunctionTypes;
const builtinFunctions = {
  'keccak256()': true,
  'sha3()': true,
  'sha256()': true,
  'ripemd160()': true,
  'ecrecover(bytes32,uint8,bytes32,bytes32)': true,
  'addmod(uint256,uint256,uint256)': true,
  'mulmod(uint256,uint256,uint256)': true,
  'selfdestruct(address)': true,
  'selfdestruct(address payable)': true,
  'revert()': true,
  'revert(string memory)': true,
  'assert(bool)': true,
  'require(bool)': true,
  'require(bool,string memory)': true,
  'gasleft()': true,
  'blockhash(uint256)': true,
  'address(address)': true
};
const lowLevelCallTypes = {
  'CALL-0.4': {
    ident: 'call',
    type: basicFunctionTypes['CALL-0.4']
  },
  CALL: {
    ident: 'call',
    type: basicFunctionTypes.CALL
  },
  CALLCODE: {
    ident: 'callcode',
    type: basicFunctionTypes['CALL-0.4']
  },
  'DELEGATECALL-0.4': {
    ident: 'delegatecall',
    type: basicFunctionTypes['DELEGATECALL-0.4']
  },
  DELEGATECALL: {
    ident: 'delegatecall',
    type: basicFunctionTypes.DELEGATECALL
  },
  SEND: {
    ident: 'send',
    type: basicFunctionTypes.SEND
  },
  TRANSFER: {
    ident: 'transfer',
    type: basicFunctionTypes.TRANSFER
  }
};
exports.lowLevelCallTypes = lowLevelCallTypes;
const specialVariables = {
  BLOCKTIMESTAMP: {
    obj: 'block',
    member: 'timestamp',
    type: basicTypes.UINT
  },
  BLOCKHASH: {
    obj: 'block',
    member: 'blockhash',
    type: buildFunctionSignature([basicTypes.UINT], [basicTypes.BYTES32], false, 'view')
  }
};
exports.specialVariables = specialVariables;
const abiNamespace = {
  ENCODE: {
    obj: 'abi',
    member: 'encode',
    type: buildFunctionSignature([], [basicTypes.BYTES_MEM], false, 'pure')
  },
  ENCODEPACKED: {
    obj: 'abi',
    member: 'encodePacked',
    type: buildFunctionSignature([], [basicTypes.BYTES_MEM], false, 'pure')
  },
  ENCODE_SELECT: {
    obj: 'abi',
    member: 'encodeWithSelector',
    type: buildFunctionSignature([basicTypes.BYTES4], [basicTypes.BYTES_MEM], false, 'pure')
  },
  ENCODE_SIG: {
    obj: 'abi',
    member: 'encodeWithSignature',
    type: buildFunctionSignature([basicTypes.STRING_MEM], [basicTypes.BYTES_MEM], false, 'pure')
  }
}; // #################### Trivial Getters
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

function getType(node) {
  return node.typeDescriptions.typeString;
}

exports.getType = getType; // #################### Complex Getters

/**
 * Returns the type parameter of function call AST nodes. Throws if not a function call node
 * @func {ASTNode} Function call node
 * @return {string} type of function call
 */

function getFunctionCallType(func) {
  return getType(func.expression);
}

exports.getFunctionCallType = getFunctionCallType;
/**
 * Get the variable name written to by a effect node, except for inline assembly because there is no information to find out where we write to. Trows if not a effect node or is inlineassmbly.
 * Example: x = 10; => x
 * @effectNode {ASTNode} Assignmnet node
 * @return {string} variable name written to
 */

function getEffectedVariableName(effectNode) {
  if (!isEffect(effectNode)) throw new Error('staticAnalysisCommon.js: not an effect Node');

  if (effectNode.nodeType === 'Assignment' || effectNode.nodeType === 'UnaryOperation') {
    const IdentNode = findFirstSubNodeLTR(effectNode, exactMatch(nodeTypes.IDENTIFIER));
    return IdentNode.name;
  } else throw new Error('staticAnalysisCommon.js: wrong node type');
}

exports.getEffectedVariableName = getEffectedVariableName;
/**
 * Returns the identifier of a local call, Throws on wrong node.
 * Example: f(103) => f
 * @localCallNode {ASTNode} Function call node
 * @return {string} name of the function called
 */

function getLocalCallName(localCallNode) {
  if (!isLocalCall(localCallNode) && !isAbiNamespaceCall(localCallNode)) throw new Error('staticAnalysisCommon.js: not a local call Node');
  return localCallNode.expression.name;
}

exports.getLocalCallName = getLocalCallName;
/**
 * Returns the identifier of a this local call, Throws on wrong node.
 * Example: this.f(103) => f
 * @localCallNode {ASTNode} Function call node
 * @return {string} name of the function called
 */

function getThisLocalCallName(thisLocalCallNode) {
  if (!isThisLocalCall(thisLocalCallNode.expression)) throw new Error('staticAnalysisCommon.js: not a this local call Node');
  return thisLocalCallNode.expression.memberName;
}

exports.getThisLocalCallName = getThisLocalCallName;
/**
 * Returns the identifier of a super local call, Throws on wrong node.
 * Example: super.f(103) => f
 * @localCallNode {ASTNode} Function call node
 * @return {string} name of the function called
 */

function getSuperLocalCallName(superLocalCallNode) {
  if (!isSuperLocalCall(superLocalCallNode.expression)) throw new Error('staticAnalysisCommon.js: not a super local call Node');
  return superLocalCallNode.expression.memberName;
}

exports.getSuperLocalCallName = getSuperLocalCallName;
/**
 * Returns the contract type of a external direct call, Throws on wrong node.
 * Example:
 *  foo x = foo(0xdeadbeef...);
 *  x.f(103) => foo
 * @extDirectCall {ASTNode} Function call node
 * @return {string} name of the contract the function is defined in
 */

function getExternalDirectCallContractName(extDirectCall) {
  if (!isExternalDirectCall(extDirectCall)) throw new Error('staticAnalysisCommon.js: not an external direct call Node');
  return extDirectCall.expression.expression.typeDescriptions.typeString.replace(new RegExp(basicRegex.CONTRACTTYPE), '');
}

exports.getExternalDirectCallContractName = getExternalDirectCallContractName;
/**
 * Returns the name of the contract of a this local call (current contract), Throws on wrong node.
 * Example:
 * Contract foo {
 *    ...
 *    this.f(103) => foo
 *    ...
 * @thisLocalCall {ASTNode} Function call node
 * @return {string} name of the contract the function is defined in
 */

function getThisLocalCallContractName(thisLocalCall) {
  if (!isThisLocalCall(thisLocalCall.expression)) throw new Error('staticAnalysisCommon.js: not a this local call Node');
  return thisLocalCall.expression.expression.typeDescriptions.typeString.replace(new RegExp(basicRegex.CONTRACTTYPE), '');
}

exports.getThisLocalCallContractName = getThisLocalCallContractName;
/**
 * Returns the function identifier of a external direct call, Throws on wrong node.
 * Example:
 *  foo x = foo(0xdeadbeef...);
 *  x.f(103) => f
 * @extDirectCall {ASTNode} Function call node
 * @return {string} name of the function called
 */

function getExternalDirectCallMemberName(extDirectCall) {
  if (!isExternalDirectCall(extDirectCall)) throw new Error('staticAnalysisCommon.js: not an external direct call Node');
  return extDirectCall.expression.memberName;
}

exports.getExternalDirectCallMemberName = getExternalDirectCallMemberName;
/**
 * Returns the name of a contract, Throws on wrong node.
 * Example:
 *   Contract foo { => foo
 * @contract {ASTNode} Contract Definition node
 * @return {string} name of a contract defined
 */

function getContractName(contract) {
  if (!nodeType(contract, exactMatch(nodeTypes.CONTRACTDEFINITION))) throw new Error('staticAnalysisCommon.js: not a ContractDefinition Node');
  return contract.name;
}

exports.getContractName = getContractName;
/**
 * Returns the name of a function definition, Throws on wrong node.
 * Example:
 *   func foo(uint bla) { => foo
 * @funcDef {ASTNode} Function Definition node
 * @return {string} name of a function defined
 */

function getFunctionDefinitionName(funcDef) {
  if (!nodeType(funcDef, exactMatch(nodeTypes.FUNCTIONDEFINITION))) throw new Error('staticAnalysisCommon.js: not a FunctionDefinition Node');
  return funcDef.name;
}

exports.getFunctionDefinitionName = getFunctionDefinitionName;
/**
 * Returns the identifier of an inheritance specifier, Throws on wrong node.
 * Example:
 *   contract KingOfTheEtherThrone is b { => b
 * @func {ASTNode} Inheritance specifier
 * @return {string} name of contract inherited from
 */

function getInheritsFromName(inheritsNode) {
  if (!nodeType(inheritsNode, exactMatch(nodeTypes.INHERITANCESPECIFIER))) throw new Error('staticAnalysisCommon.js: not an InheritanceSpecifier Node');
  return inheritsNode.baseName.name;
}

exports.getInheritsFromName = getInheritsFromName;
/**
 * Returns the identifier of a variable definition, Throws on wrong node.
 * Example:
 *   var x = 10; => x
 * @varDeclNode {ASTNode} Variable declaration node
 * @return {string} variable name
 */

function getDeclaredVariableName(varDeclNode) {
  if (!nodeType(varDeclNode, exactMatch(nodeTypes.VARIABLEDECLARATION))) throw new Error('staticAnalysisCommon.js: not a VariableDeclaration Node');
  return varDeclNode.name;
}

exports.getDeclaredVariableName = getDeclaredVariableName;
/**
 * Returns the type of a variable definition, Throws on wrong node.
 * Example:
 *   var x = 10; => x
 * @varDeclNode {ASTNode} Variable declaration node
 * @return {string} variable type
 */

function getDeclaredVariableType(varDeclNode) {
  return varDeclNode.typeName.name;
}

exports.getDeclaredVariableType = getDeclaredVariableType;
/**
 * Returns state variable declaration nodes for a contract, Throws on wrong node.
 * Example:
 * contract foo {
 *     ...
 *   var y = true;
 *   var x = 10; => [y,x]
 * @contractNode {ASTNode} Contract Definition node
 * @return {list variable declaration} state variable node list
 */

function getStateVariableDeclarationsFromContractNode(contractNode) {
  return contractNode.nodes.filter(el => el.nodeType === "VariableDeclaration");
}

exports.getStateVariableDeclarationsFromContractNode = getStateVariableDeclarationsFromContractNode;
/**
 * Returns parameter node for a function or modifier definition, Throws on wrong node.
 * Example:
 * function bar(uint a, uint b) => uint a, uint b
 * @funcNode {ASTNode} Contract Definition node
 * @return {parameterlist node} parameterlist node
 */

function getFunctionOrModifierDefinitionParameterPart(funcNode) {
  if (!nodeTypeIn(funcNode, [exactMatch(nodeTypes.FUNCTIONDEFINITION), exactMatch(nodeTypes.MODIFIERDEFINITION)])) throw new Error('staticAnalysisCommon.js: not a FunctionDefinition or ModifierDefinition Node');
  return funcNode.parameters;
}

exports.getFunctionOrModifierDefinitionParameterPart = getFunctionOrModifierDefinitionParameterPart;
/**
 * Returns return parameter node for a function or modifier definition, Throws on wrong node.
 * Example:
 * function bar(uint a, uint b) returns (bool a, bool b) => bool a, bool b
 * @funcNode {ASTNode} Contract Definition node
 * @return {parameterlist node} parameterlist node
 */

function getFunctionDefinitionReturnParameterPart(funcNode) {
  return funcNode.returnParameters;
}

exports.getFunctionDefinitionReturnParameterPart = getFunctionDefinitionReturnParameterPart;
/**
 * Extracts the parameter types for a function type signature
 * Example:
 * function(uint a, uint b) returns (bool) => uint a, uint b
 * @func {ASTNode} function call node
 * @return {string} parameter signature
 */

function getFunctionCallTypeParameterType(func) {
  const type = getFunctionCallType(func);

  if (type.startsWith('function (')) {
    let paramTypes = '';
    let openPar = 1;

    for (let x = 10; x < type.length; x++) {
      const c = type.charAt(x);
      if (c === '(') openPar++;else if (c === ')') openPar--;
      if (openPar === 0) return paramTypes;
      paramTypes += c;
    }
  } else {
    throw new Error('staticAnalysisCommon.js: cannot extract parameter types from function call');
  }
}

exports.getFunctionCallTypeParameterType = getFunctionCallTypeParameterType;
/**
 * Returns the name of the library called, Throws on wrong node.
 * Example:
 *  library set{...}
 *  contract foo {
 *    ...
 *    function () { set.union() => set}
 * @funcCall {ASTNode} function call node
 * @return {string} name of the lib defined
 */

function getLibraryCallContractName(node) {
  if (!isLibraryCall(node.expression)) throw new Error('staticAnalysisCommon.js: not a library call Node');
  const types = new RegExp(basicRegex.LIBRARYTYPE).exec(node.expression.expression.typeDescriptions.typeString);
  if (types) return types[1];
}

exports.getLibraryCallContractName = getLibraryCallContractName;
/**
 * Returns the name of the function of a library call, Throws on wrong node.
 * Example:
 *  library set{...}
 *  contract foo {
 *    ...
 *    function () { set.union() => uinion}
 * @func {ASTNode} function call node
 * @return {string} name of function called on the library
 */

function getLibraryCallMemberName(funcCall) {
  if (!isLibraryCall(funcCall.expression)) throw new Error('staticAnalysisCommon.js: not a library call Node');
  return funcCall.expression.memberName;
}

exports.getLibraryCallMemberName = getLibraryCallMemberName;
/**
 * Returns full qualified name for a function call, Throws on wrong node.
 * Example:
 *  contract foo {
 *    ...
 *    function bar(uint b) { }
 *    function baz() {
 *      bar(10) => foo.bar(uint)
 * @func {ASTNode} function call node
 * @func {ASTNode} contract defintion
 * @return {string} full qualified identifier for the function call
 */

function getFullQualifiedFunctionCallIdent(contract, func) {
  if (isLocalCall(func)) return getContractName(contract) + '.' + getLocalCallName(func) + '(' + getFunctionCallTypeParameterType(func) + ')';else if (isThisLocalCall(func.expression)) return getThisLocalCallContractName(func) + '.' + getThisLocalCallName(func) + '(' + getFunctionCallTypeParameterType(func) + ')';else if (isSuperLocalCall(func.expression)) return getContractName(contract) + '.' + getSuperLocalCallName(func) + '(' + getFunctionCallTypeParameterType(func) + ')';else if (isExternalDirectCall(func)) return getExternalDirectCallContractName(func) + '.' + getExternalDirectCallMemberName(func) + '(' + getFunctionCallTypeParameterType(func) + ')';else if (isLibraryCall(func.expression)) return getLibraryCallContractName(func) + '.' + getLibraryCallMemberName(func) + '(' + getFunctionCallTypeParameterType(func) + ')';else throw new Error('staticAnalysisCommon.js: Can not get function name from non function call node');
}

exports.getFullQualifiedFunctionCallIdent = getFullQualifiedFunctionCallIdent;

function getFullQuallyfiedFuncDefinitionIdent(contract, func, paramTypes) {
  return getContractName(contract) + '.' + getFunctionDefinitionName(func) + '(' + remix_lib_1.util.concatWithSeperator(paramTypes, ',') + ')';
}

exports.getFullQuallyfiedFuncDefinitionIdent = getFullQuallyfiedFuncDefinitionIdent;

function getUnAssignedTopLevelBinOps(subScope) {
  let result = [];
  if (subScope && subScope.nodeType === 'Block') result = subScope.statements.filter(isBinaryOpInExpression); // for 'without braces' loops
  else if (subScope && subScope.nodeType && subScope.nodeType !== 'Block' && isSubScopeStatement(subScope)) {
      if (subScope.nodeType === 'IfStatement') {
        if (subScope.trueBody && subScope.trueBody.nodeType === "ExpressionStatement" && isBinaryOpInExpression(subScope.trueBody)) result.push(subScope.trueBody);
        if (subScope.falseBody && subScope.falseBody.nodeType === "ExpressionStatement" && isBinaryOpInExpression(subScope.falseBody)) result.push(subScope.falseBody);
      } else {
        if (subScope.body && subScope.body.nodeType === "ExpressionStatement" && isBinaryOpInExpression(subScope.body)) result.push(subScope.body);
      }
    }
  return result;
}

exports.getUnAssignedTopLevelBinOps = getUnAssignedTopLevelBinOps; // #################### Trivial Node Identification
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

function isStatement(node) {
  return nodeType(node, 'Statement$') || node.nodeType === "Block" || node.nodeType === "Return";
}

exports.isStatement = isStatement; // #################### Complex Node Identification

/**
 * True if function defintion has function body
 * @funcNode {ASTNode} function defintion node
 * @return {bool}
 */

function hasFunctionBody(funcNode) {
  return funcNode.body !== null;
}

exports.hasFunctionBody = hasFunctionBody;
/**
 * True if node is a delete instruction of a dynamic array
 * @node {ASTNode} node to check for
 * @return {bool}
 */

function isDeleteOfDynamicArray(node) {
  return isDeleteUnaryOperation(node) && isDynamicArrayAccess(node.subExpression);
}

exports.isDeleteOfDynamicArray = isDeleteOfDynamicArray;
/**
 * True if node is node is a ref to a dynamic array
 * @node {ASTNode} node to check for
 * @return {bool}
 */

function isDynamicArrayAccess(node) {
  return getType(node).endsWith('[] storage ref') || typeDescription(node, 'bytes storage ref') || typeDescription(node, 'string storage ref');
}

exports.isDynamicArrayAccess = isDynamicArrayAccess;
/**
 * True if node accesses 'length' member of dynamic array
 * @node {ASTNode} node to check for
 * @return {bool}
 */

function isDynamicArrayLengthAccess(node) {
  return node.memberName === 'length' && // accessing 'length' member
  node.expression['typeDescriptions']['typeString'].indexOf('[]') !== -1; // member is accessed from dynamic array, notice [] without any number
}

exports.isDynamicArrayLengthAccess = isDynamicArrayLengthAccess;
/**
 * True if node is a delete instruction for an element from a dynamic array
 * @node {ASTNode} node to check for
 * @return {bool}
 */

function isDeleteFromDynamicArray(node) {
  return isDeleteUnaryOperation(node) && node.subExpression.nodeType === 'IndexAccess';
}

exports.isDeleteFromDynamicArray = isDeleteFromDynamicArray;
/**
 * True if node is the access of a mapping index
 * @node {ASTNode} node to check for
 * @return {bool}
 */

function isMappingIndexAccess(node) {
  return node.typeDescriptions.typeString.startsWith('mapping');
}

exports.isMappingIndexAccess = isMappingIndexAccess;
/**
 * True if call to code within the current contracts context including (delegate) library call
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLocalCallGraphRelevantNode(node) {
  return (isLocalCall(node) || isSuperLocalCall(node.expression) || isLibraryCall(node.expression)) && !isBuiltinFunctionCall(node);
}

exports.isLocalCallGraphRelevantNode = isLocalCallGraphRelevantNode;
/**
 * True if is builtin function like assert, sha3, erecover, ...
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isBuiltinFunctionCall(node) {
  return node.nodeType === 'FunctionCall' && isLocalCall(node) && builtinFunctions[getLocalCallName(node) + '(' + getFunctionCallTypeParameterType(node) + ')'] === true || isAbiNamespaceCall(node);
}

exports.isBuiltinFunctionCall = isBuiltinFunctionCall;
/**
 * True if is builtin function like assert, sha3, erecover, ...
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isAbiNamespaceCall(node) {
  return Object.keys(abiNamespace).some(key => Object.prototype.hasOwnProperty.call(abiNamespace, key) && node.expression && isSpecialVariableAccess(node.expression, abiNamespace[key]));
}

exports.isAbiNamespaceCall = isAbiNamespaceCall;
/**
 * True if node is a call to selfdestruct
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isSelfdestructCall(node) {
  return isBuiltinFunctionCall(node) && getLocalCallName(node) === 'selfdestruct';
}

exports.isSelfdestructCall = isSelfdestructCall;
/**
 * True if node is a call to builtin assert(bool)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isAssertCall(node) {
  return isBuiltinFunctionCall(node) && getLocalCallName(node) === 'assert';
}

exports.isAssertCall = isAssertCall;
/**
 * True if node is a call to builtin require(bool)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isRequireCall(node) {
  return isBuiltinFunctionCall(node) && getLocalCallName(node) === 'require';
}

exports.isRequireCall = isRequireCall;
/**
 * True if is storage variable declaration
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isStorageVariableDeclaration(node) {
  return node.storageLocation === 'storage' && new RegExp(basicRegex.REFTYPE).test(node.typeDescriptions.typeIdentifier);
}

exports.isStorageVariableDeclaration = isStorageVariableDeclaration;
/**
 * True if is interaction with external contract (change in context, no delegate calls) (send, call of other contracts)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isInteraction(node) {
  return isLLCall(node.expression) || isLLSend(node.expression) || isExternalDirectCall(node) || isTransfer(node.expression) || isLLCall04(node.expression) || isLLSend04(node.expression) || // to cover case of address.call.value.gas , See: inheritance.sol  
  node.expression && node.expression.expression && isLLCall(node.expression.expression) || node.expression && node.expression.expression && isLLCall04(node.expression.expression);
}

exports.isInteraction = isInteraction;
/**
 * True if node changes state of a variable or is inline assembly (does not include check if it is a global state change, on a state variable)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isEffect(node) {
  return node.nodeType === "Assignment" || node.nodeType === "UnaryOperation" && (isPlusPlusUnaryOperation(node) || isMinusMinusUnaryOperation(node)) || node.nodeType === "InlineAssembly";
}

exports.isEffect = isEffect;
/**
 * True if node changes state of a variable or is inline assembly (Checks if variable is a state variable via provided list)
 * @node {ASTNode} some AstNode
 * @node {list Variable declaration} state variable declaration currently in scope
 * @return {bool}
 */

function isWriteOnStateVariable(effectNode, stateVariables) {
  return effectNode.nodeType === "InlineAssembly" || isEffect(effectNode) && isStateVariable(getEffectedVariableName(effectNode), stateVariables);
}

exports.isWriteOnStateVariable = isWriteOnStateVariable;
/**
 * True if there is a variable with name, name in stateVariables
 * @node {ASTNode} some AstNode
 * @node {list Variable declaration} state variable declaration currently in scope
 * @return {bool}
 */

function isStateVariable(name, stateVariables) {
  return stateVariables.some(item => item.stateVariable && name === getDeclaredVariableName(item));
}

exports.isStateVariable = isStateVariable;
/**
 * True if is function defintion that is flaged as constant
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isConstantFunction(node) {
  return node.stateMutability === 'view' || node.stateMutability === 'pure';
}

exports.isConstantFunction = isConstantFunction;
/**
* True if variable decalaration is converted into a getter method
 * @node {ASTNode} variable declaration AstNode
 * @return {bool}
 */

function isVariableTurnedIntoGetter(varDeclNode) {
  return varDeclNode.stateVariable && varDeclNode.visibility === 'public';
}

exports.isVariableTurnedIntoGetter = isVariableTurnedIntoGetter;
/**
 * True if is function defintion has payable modifier
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isPayableFunction(node) {
  return node.stateMutability === 'payable';
}

exports.isPayableFunction = isPayableFunction;
/**
 * True if is constructor
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isConstructor(node) {
  return node.kind === "constructor";
}

exports.isConstructor = isConstructor;
/**
 * True if node is integer division that truncates (not only int literals since those yield a rational value)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isIntDivision(node) {
  return operator(node, exactMatch(remix_lib_1.util.escapeRegExp('/'))) && typeDescription(node.rightExpression, remix_lib_1.util.escapeRegExp('int'));
}

exports.isIntDivision = isIntDivision;
/**
 * True if is block / SubScope has top level binops (e.g. that are not assigned to anything, most of the time confused compare instead of assign)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isSubScopeWithTopLevelUnAssignedBinOp(node) {
  if (node.nodeType === 'Block') return node.statements.some(isBinaryOpInExpression); // for 'without braces' loops
  else if (node && node.nodeType && isSubScopeStatement(node)) {
      if (node.nodeType === 'IfStatement') return node.trueBody && node.trueBody.nodeType === "ExpressionStatement" && isBinaryOpInExpression(node.trueBody) || node.falseBody && node.falseBody.nodeType === "ExpressionStatement" && isBinaryOpInExpression(node.falseBody);else return node.body && node.body.nodeType === "ExpressionStatement" && isBinaryOpInExpression(node.body);
    }
}

exports.isSubScopeWithTopLevelUnAssignedBinOp = isSubScopeWithTopLevelUnAssignedBinOp;

function isSubScopeStatement(node) {
  if (node.nodeType === 'IfStatement') return node.trueBody && node.trueBody.nodeType && !nodeType(node.trueBody, exactMatch(nodeTypes.BLOCK)) || node.falseBody && node.falseBody.nodeType && !nodeType(node.falseBody, exactMatch(nodeTypes.BLOCK));else return node.body && node.body.nodeType && !nodeType(node.body, exactMatch(nodeTypes.BLOCK));
}
/**
 * True if binary operation inside of expression statement
 * @node {ASTNode} some AstNode
 * @return {bool}
 */


function isBinaryOpInExpression(node) {
  return node.nodeType === "ExpressionStatement" && node.expression.nodeType === "BinaryOperation";
}
/**
 * True if unary increment operation
 * @node {ASTNode} some AstNode
 * @return {bool}
 */


function isPlusPlusUnaryOperation(node) {
  return node.operator === '++';
}

exports.isPlusPlusUnaryOperation = isPlusPlusUnaryOperation;
/**
 * True if unary delete operation
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isDeleteUnaryOperation(node) {
  return node.operator === 'delete';
}

exports.isDeleteUnaryOperation = isDeleteUnaryOperation;
/**
 * True if unary decrement operation
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isMinusMinusUnaryOperation(node) {
  return node.operator === '--';
}

exports.isMinusMinusUnaryOperation = isMinusMinusUnaryOperation;
/**
 * True if all functions on a contract are implemented
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isFullyImplementedContract(node) {
  return node.fullyImplemented === true;
}

exports.isFullyImplementedContract = isFullyImplementedContract;
/**
 * True if it is a library contract defintion
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLibrary(node) {
  return node.contractKind === 'library';
}

exports.isLibrary = isLibrary;
/**
 * True if it is a local call to non const function
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isCallToNonConstLocalFunction(node) {
  return isLocalCall(node) && !expressionTypeDescription(node, basicRegex.CONSTANTFUNCTIONTYPE);
}

exports.isCallToNonConstLocalFunction = isCallToNonConstLocalFunction;
/**
 * True if it is a call to a library
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLibraryCall(node) {
  return isMemberAccess(node, basicRegex.FUNCTIONTYPE, undefined, basicRegex.LIBRARYTYPE, undefined);
}

exports.isLibraryCall = isLibraryCall;
/**
 * True if it is an external call via defined interface (not low level call)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isExternalDirectCall(node) {
  return isMemberAccess(node.expression, basicRegex.EXTERNALFUNCTIONTYPE, undefined, basicRegex.CONTRACTTYPE, undefined) && !isThisLocalCall(node.expression) && !isSuperLocalCall(node.expression);
}

exports.isExternalDirectCall = isExternalDirectCall;
/**
 * True if access to block.timestamp via now alias
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isNowAccess(node) {
  return node.name === "now" && typeDescription(node, exactMatch(basicTypes.UINT));
}

exports.isNowAccess = isNowAccess;
/**
 * True if access to block.timestamp via now alias
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isTxOriginAccess(node) {
  return isMemberAccess(node, 'address', 'tx', 'tx', 'origin');
}

exports.isTxOriginAccess = isTxOriginAccess;
/**
 * True if access to block.timestamp
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isBlockTimestampAccess(node) {
  return isSpecialVariableAccess(node, specialVariables.BLOCKTIMESTAMP);
}

exports.isBlockTimestampAccess = isBlockTimestampAccess;
/**
 * True if access to block.blockhash
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isBlockBlockHashAccess(node) {
  return isBuiltinFunctionCall(node) && getLocalCallName(node) === 'blockhash' || isSpecialVariableAccess(node.expression, specialVariables.BLOCKHASH);
}

exports.isBlockBlockHashAccess = isBlockBlockHashAccess;
/**
 * True if call to local function via this keyword
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isThisLocalCall(node) {
  return isMemberAccess(node, basicRegex.FUNCTIONTYPE, exactMatch('this'), basicRegex.CONTRACTTYPE, undefined);
}

exports.isThisLocalCall = isThisLocalCall;
/**
 * True if access to local function via super keyword
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isSuperLocalCall(node) {
  return isMemberAccess(node, basicRegex.FUNCTIONTYPE, exactMatch('super'), basicRegex.CONTRACTTYPE, undefined);
}

exports.isSuperLocalCall = isSuperLocalCall;
/**
 * True if call to local function
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLocalCall(node) {
  return node.nodeType === 'FunctionCall' && node.kind === 'functionCall' && node.expression.nodeType === 'Identifier' && expressionTypeDescription(node, basicRegex.FUNCTIONTYPE) && !expressionTypeDescription(node, basicRegex.EXTERNALFUNCTIONTYPE);
}

exports.isLocalCall = isLocalCall;
/**
 * True if low level call (send, call, delegatecall, callcode)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLowLevelCall(node) {
  return isLLCall(node) || isLLDelegatecall(node) || isLLSend(node) || isLLSend04(node) || isLLCallcode(node) || isLLCall04(node) || isLLDelegatecall04(node);
}

exports.isLowLevelCall = isLowLevelCall;
/**
 * True if low level send (solidity < 0.5)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLSend04(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.SEND.type)), undefined, exactMatch(basicTypes.ADDRESS), exactMatch(lowLevelCallTypes.SEND.ident));
}

exports.isLLSend04 = isLLSend04;
/**
 * True if low level send (solidity >= 0.5)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLSend(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.SEND.type)), undefined, exactMatch(basicTypes.PAYABLE_ADDRESS), exactMatch(lowLevelCallTypes.SEND.ident));
}

exports.isLLSend = isLLSend;
/**
 * True if low level call
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLCall(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.CALL.type)), undefined, exactMatch(basicTypes.ADDRESS), exactMatch(lowLevelCallTypes.CALL.ident)) || isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.CALL.type)), undefined, exactMatch(basicTypes.PAYABLE_ADDRESS), exactMatch(lowLevelCallTypes.CALL.ident));
}

exports.isLLCall = isLLCall;
/**
 * True if low level payable call (solidity < 0.5)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLCall04(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes['CALL-0.4'].type)), undefined, exactMatch(basicTypes.ADDRESS), exactMatch(lowLevelCallTypes['CALL-0.4'].ident));
}

exports.isLLCall04 = isLLCall04;
/**
 * True if low level callcode
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLCallcode(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.CALLCODE.type)), undefined, exactMatch(basicTypes.ADDRESS), exactMatch(lowLevelCallTypes.CALLCODE.ident));
}

exports.isLLCallcode = isLLCallcode;
/**
 * True if low level delegatecall
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLDelegatecall(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.DELEGATECALL.type)), undefined, matches(basicTypes.PAYABLE_ADDRESS, basicTypes.ADDRESS), exactMatch(lowLevelCallTypes.DELEGATECALL.ident));
}

exports.isLLDelegatecall = isLLDelegatecall;
/**
 * True if low level delegatecall (solidity < 0.5)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLDelegatecall04(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes['DELEGATECALL-0.4'].type)), undefined, matches(basicTypes.PAYABLE_ADDRESS, basicTypes.ADDRESS), exactMatch(lowLevelCallTypes['DELEGATECALL-0.4'].ident));
}

exports.isLLDelegatecall04 = isLLDelegatecall04;
/**
 * True if transfer call
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isTransfer(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.TRANSFER.type)), undefined, matches(basicTypes.ADDRESS, basicTypes.PAYABLE_ADDRESS), exactMatch(lowLevelCallTypes.TRANSFER.ident));
}

exports.isTransfer = isTransfer;

function isStringToBytesConversion(node) {
  return isExplicitCast(node, remix_lib_1.util.escapeRegExp('string *'), remix_lib_1.util.escapeRegExp('bytes'));
}

exports.isStringToBytesConversion = isStringToBytesConversion;

function isExplicitCast(node, castFromType, castToType) {
  return node.kind === "typeConversion" && nodeType(node.expression, exactMatch(nodeTypes.ELEMENTARYTYPENAMEEXPRESSION)) && node.expression.typeName === castToType && nodeType(node.arguments[0], exactMatch(nodeTypes.IDENTIFIER)) && typeDescription(node.arguments[0], castFromType);
}

function isBytesLengthCheck(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(basicTypes.UINT)), undefined, remix_lib_1.util.escapeRegExp('bytes *'), 'length');
}

exports.isBytesLengthCheck = isBytesLengthCheck;
/**
 * True if it is a loop
 * @node {ASTNode} some AstNode
 * @return {bool}
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

function isLoop(node) {
  return nodeType(node, exactMatch(nodeTypes.FORSTATEMENT)) || nodeType(node, exactMatch(nodeTypes.WHILESTATEMENT)) || nodeType(node, exactMatch(nodeTypes.DOWHILESTATEMENT));
}

exports.isLoop = isLoop; // #################### Complex Node Identification - Private

function isMemberAccess(node, retType, accessor, accessorType, memberName) {
  if (node && nodeType(node, exactMatch('MemberAccess'))) {
    const nodeTypeDef = typeDescription(node, retType);
    const nodeMemName = memName(node, memberName);
    const nodeExpMemName = memName(node.expression, accessor);
    const nodeExpTypeDef = expressionTypeDescription(node, accessorType);
    return nodeTypeDef && nodeMemName && nodeExpTypeDef && nodeExpMemName;
  } else return false;
}

function isSpecialVariableAccess(node, varType) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(varType.type)), varType.obj, varType.obj, varType.member);
}

exports.isSpecialVariableAccess = isSpecialVariableAccess; // #################### Node Identification Primitives
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

function expressionTypeDescription(node, typeRegex) {
  return new RegExp(typeRegex).test(node.expression.typeDescriptions.typeString);
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function typeDescription(node, typeRegex) {
  return new RegExp(typeRegex).test(node.typeDescriptions.typeString);
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function nodeType(node, typeRegex) {
  return new RegExp(typeRegex).test(node.nodeType);
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function nodeTypeIn(node, typeRegex) {
  return typeRegex.some(typeRegex => nodeType(node, typeRegex));
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function memName(node, memNameRegex) {
  return node && !memNameRegex || new RegExp(memNameRegex).test(node.name) || new RegExp(memNameRegex).test(node.memberName);
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function operator(node, opRegex) {
  return new RegExp(opRegex).test(node.operator);
} // #################### Helpers


function exactMatch(regexStr) {
  return '^' + regexStr + '$';
}

function matches(...fnArgs) {
  const args = [];

  for (let k = 0; k < fnArgs.length; k++) {
    args.push(fnArgs[k]);
  }

  return '(' + args.join('|') + ')';
}
/**
 * Finds first node of a certain type under a specific node.
 * @node {AstNode} node to start form
 * @type {String} Type the ast node should have
 * @return {AstNode} null or node found
 * Note: developed keeping identifier node search in mind to get first identifier node from left in subscope
 */


function findFirstSubNodeLTR(node, type) {
  if (node.nodeType && nodeType(node, type)) return node;else if (node.nodeType && nodeType(node, exactMatch('Assignment'))) return findFirstSubNodeLTR(node.leftHandSide, type);else if (node.nodeType && nodeType(node, exactMatch('MemberAccess'))) return findFirstSubNodeLTR(node.expression, type);else if (node.nodeType && nodeType(node, exactMatch('IndexAccess'))) return findFirstSubNodeLTR(node.baseExpression, type);else if (node.nodeType && nodeType(node, exactMatch('UnaryOperation'))) return findFirstSubNodeLTR(node.subExpression, type);
}
/**
 * Builds a function signature as used in the AST of the solc-json AST
 * @param {Array} paramTypes
 *  list of parameter type names
 * @param {Array} returnTypes
 *  list of return type names
 * @return {Boolean} isPayable
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function buildFunctionSignature(paramTypes, returnTypes, isPayable, additionalMods) {
  return 'function (' + remix_lib_1.util.concatWithSeperator(paramTypes, ',') + ')' + (isPayable ? ' payable' : '') + (additionalMods ? ' ' + additionalMods : '') + (returnTypes.length ? ' returns (' + remix_lib_1.util.concatWithSeperator(returnTypes, ',') + ')' : '');
}

function buildAbiSignature(funName, paramTypes) {
  return funName + '(' + remix_lib_1.util.concatWithSeperator(paramTypes, ',') + ')';
} // To create the method signature similar to contract.evm.gasEstimates.external object
// For address payable, return address 


function getMethodParamsSplittedTypeDesc(node, contracts) {
  return node.parameters.parameters.map((varNode, varIndex) => {
    let finalTypeString;
    const typeString = varNode.typeDescriptions.typeString;

    if (typeString.includes('struct')) {
      const fnName = node.name;

      for (const filename in contracts) {
        for (const contractName in contracts[filename]) {
          const methodABI = contracts[filename][contractName].abi.find(e => {
            var _a;

            return e.name === fnName && ((_a = e.inputs) === null || _a === void 0 ? void 0 : _a.length) && e.inputs[varIndex]['type'].includes('tuple') && e.inputs[varIndex]['internalType'] === typeString;
          });

          if (methodABI && methodABI.inputs) {
            const inputs = methodABI.inputs[varIndex];
            const typeStr = getTypeStringFromComponents(inputs['components']);
            finalTypeString = typeStr + inputs['type'].replace('tuple', '');
          }
        }
      }
    } else finalTypeString = typeString.split(' ')[0];

    return finalTypeString;
  });
}

exports.getMethodParamsSplittedTypeDesc = getMethodParamsSplittedTypeDesc;

function getTypeStringFromComponents(components) {
  let typeString = '(';

  for (let i = 0; i < components.length; i++) {
    const param = components[i];

    if (param.type.includes('tuple') && param.components && param.components.length > 0) {
      typeString = typeString + getTypeStringFromComponents(param.components);
      typeString = typeString + param.type.replace('tuple', '');
    } else typeString = typeString + param.type;

    if (i !== components.length - 1) typeString = typeString + ',';
  }

  typeString = typeString + ')';
  return typeString;
}
/**
 * Get compiler version from compiler contract object
 * This is used to redirect the user to specific version of Solidity documentation
 * @param contractFiles compiled contract object
 */


function getCompilerVersion(contractFiles) {
  let version = 'latest';
  const fileNames = Object.keys(contractFiles);
  const contracts = contractFiles[fileNames[0]];
  const contractNames = Object.keys(contracts);
  const contract = contracts[contractNames[0]]; // For some compiler/contract,  metadata is ""

  if (contract && contract.metadata) {
    const metadata = JSON.parse(contract.metadata);
    const compilerVersion = metadata.compiler.version;
    if (!compilerVersion.includes('nightly')) version = 'v' + compilerVersion.split('+commit')[0];
  }

  return version;
}

exports.getCompilerVersion = getCompilerVersion;
const helpers = {
  expressionTypeDescription,
  nodeType,
  memName,
  operator,
  buildFunctionSignature,
  buildAbiSignature
};
exports.helpers = helpers;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/stringBytesLength.js":
/*!************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/stringBytesLength.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

class stringBytesLength {
  constructor() {
    this.name = `String length: `;
    this.description = `Bytes length != String length`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
    this.stringToBytesConversions = [];
    this.bytesLengthChecks = [];
  }

  visit(node) {
    if (node.nodeType === "FunctionCall" && staticAnalysisCommon_1.isStringToBytesConversion(node)) this.stringToBytesConversions.push(node);else if (node.nodeType === "MemberAccess" && staticAnalysisCommon_1.isBytesLengthCheck(node)) this.bytesLengthChecks.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);

    if (this.stringToBytesConversions.length > 0 && this.bytesLengthChecks.length > 0) {
      return [{
        warning: `"bytes" and "string" lengths are not the same since strings are assumed to be UTF-8 encoded (according to the ABI defintion) therefore one character is not nessesarily encoded in one byte of data.`,
        location: this.bytesLengthChecks[0].src,
        more: `https://solidity.readthedocs.io/en/${version}/abi-spec.html#argument-encoding`
      }];
    } else {
      return [];
    }
  }

}

exports.default = stringBytesLength;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/thisLocal.js":
/*!****************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/thisLocal.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class thisLocal {
  constructor() {
    this.warningNodes = [];
    this.name = `This on local calls: `;
    this.description = `Invocation of local functions via 'this'`;
    this.category = categories_1.default.GAS;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (node.nodeType === 'MemberAccess' && staticAnalysisCommon_1.isThisLocalCall(node)) this.warningNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.warningNodes.map(function (item, i) {
      return {
        warning: `Use of "this" for local functions: Never use "this" to call functions in the same contract, it only consumes more gas than normal local calls.`,
        location: item.src,
        more: `https://solidity.readthedocs.io/en/${version}/control-structures.html#external-function-calls`
      };
    });
  }

}

exports.default = thisLocal;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/txOrigin.js":
/*!***************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/txOrigin.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

class txOrigin {
  constructor() {
    this.txOriginNodes = [];
    this.name = `Transaction origin: `;
    this.description = `'tx.origin' used`;
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (staticAnalysisCommon_1.isTxOriginAccess(node)) this.txOriginNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.txOriginNodes.map((item, i) => {
      return {
        warning: `Use of tx.origin: "tx.origin" is useful only in very exceptional cases. 
                  If you use it for authentication, you usually want to replace it by "msg.sender", because otherwise any contract you call can act on your behalf.`,
        location: item.src,
        more: `https://solidity.readthedocs.io/en/${version}/security-considerations.html#tx-origin`
      };
    });
  }

}

exports.default = txOrigin;

/***/ }),

/***/ "../../../dist/libs/remix-astwalker/astWalker.js":
/*!***************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-astwalker/astWalker.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const events_1 = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

const isObject = function (obj) {
  return obj != null && obj.constructor.name === "Object";
};

function isAstNode(node) {
  return isObject(node) && 'id' in node && 'nodeType' in node && 'src' in node;
}

exports.isAstNode = isAstNode;

function isYulAstNode(node) {
  return isObject(node) && 'nodeType' in node && 'src' in node;
}

exports.isYulAstNode = isYulAstNode;
/**
 * Crawl the given AST through the function walk(ast, callback)
 */

/**
 * visit all the AST nodes
 *
 * @param {Object} ast  - AST node
 * @return EventEmitter
 * event('node', <Node Type | false>) will be fired for every node of type <Node Type>.
 * event('node', "*") will be fired for all other nodes.
 * in each case, if the event emits false it does not descend into children.
 * If no event for the current type, children are visited.
 */

class AstWalker extends events_1.EventEmitter {
  manageCallback(node, callback // eslint-disable-line @typescript-eslint/ban-types
  ) {
    // FIXME: we shouldn't be doing this callback determination type on each AST node,
    // since the callback function is set once per walk.
    // Better would be to store the right one as a variable and
    // return that.
    if (node) {
      if (node.name in callback) {
        return callback[node.name](node);
      } else {
        return callback["*"](node);
      }
    }

    if (node) {
      if (node.nodeType in callback) {
        /* istanbul ignore next */
        return callback[node.nodeType](node);
      } else {
        /* istanbul ignore next */
        return callback["*"](node);
      }
    }
  }

  normalizeNodes(nodes) {
    // Remove null, undefined and empty elements if any
    nodes = nodes.filter(e => e); // If any element in nodes is array, extract its members

    const objNodes = [];
    nodes.forEach(x => {
      if (Array.isArray(x)) objNodes.push(...x);else objNodes.push(x);
    }); // Filter duplicate nodes using id field

    const normalizedNodes = [];
    objNodes.forEach(element => {
      const firstIndex = normalizedNodes.findIndex(e => e.id === element.id);
      if (firstIndex == -1) normalizedNodes.push(element);
    });
    return normalizedNodes;
  }

  getASTNodeChildren(ast) {
    var _a;

    let nodes = ast.nodes // for ContractDefinition
    || ast.body // for FunctionDefinition, ModifierDefinition, WhileStatement, DoWhileStatement, ForStatement
    || ast.statements // for Block, YulBlock
    || ast.members // for StructDefinition, EnumDefinition
    || ast.overrides // for OverrideSpecifier
    || ast.parameters // for ParameterList, EventDefinition
    || ast.declarations // for VariableDeclarationStatement
    || ast.expression // for Return, ExpressionStatement, FunctionCall, FunctionCallOptions, MemberAccess
    || ast.components // for TupleExpression
    || ast.subExpression // for UnaryOperation
    || ast.eventCall // for EmitStatement
    || []; // If 'nodes' is not an array, convert it into one, for example: ast.body 

    if (nodes && !Array.isArray(nodes)) {
      const tempArr = [];
      tempArr.push(nodes);
      nodes = tempArr;
    } // To break object referencing


    nodes = [...nodes];

    if (ast.nodes && ((_a = ast.baseContracts) === null || _a === void 0 ? void 0 : _a.length)) {
      // for ContractDefinition
      nodes.push(...ast.baseContracts);
    } else if (ast.body && ast.overrides && ast.parameters && ast.returnParameters && ast.modifiers) {
      // for FunctionDefinition
      nodes.push(ast.overrides);
      nodes.push(ast.parameters);
      nodes.push(ast.returnParameters);
      nodes.push(ast.modifiers);
    } else if (ast.typeName) {
      // for VariableDeclaration, NewExpression, ElementaryTypeNameExpression
      nodes.push(ast.typeName);
    } else if (ast.body && ast.overrides && ast.parameters) {
      // for ModifierDefinition
      nodes.push(ast.overrides);
      nodes.push(ast.parameters);
    } else if (ast.modifierName && ast.arguments) {
      // for ModifierInvocation
      nodes.push(ast.modifierName);
      nodes.push(ast.arguments);
    } else if (ast.parameterTypes && ast.returnParameterTypes) {
      // for ModifierInvocation
      nodes.push(ast.parameterTypes);
      nodes.push(ast.returnParameterTypes);
    } else if (ast.keyType && ast.valueType) {
      // for Mapping
      nodes.push(ast.keyType);
      nodes.push(ast.valueType);
    } else if (ast.baseType && ast.length) {
      // for ArrayTypeName
      nodes.push(ast.baseType);
      nodes.push(ast.length);
    } else if (ast.AST) {
      // for InlineAssembly
      nodes.push(ast.AST);
    } else if (ast.condition && (ast.trueBody || ast.falseBody || ast.body)) {
      // for IfStatement, WhileStatement, DoWhileStatement
      nodes.push(ast.condition);
      nodes.push(ast.trueBody);
      nodes.push(ast.falseBody);
    } else if (ast.parameters && ast.block) {
      // for TryCatchClause
      nodes.push(ast.block);
    } else if (ast.externalCall && ast.clauses) {
      // for TryStatement
      nodes.push(ast.externalCall);
      nodes.push(ast.clauses);
    } else if (ast.body && ast.condition && ast.initializationExpression && ast.loopExpression) {
      // for ForStatement
      nodes.push(ast.condition);
      nodes.push(ast.initializationExpression);
      nodes.push(ast.loopExpression);
    } else if (ast.declarations && ast.initialValue) {
      // for VariableDeclarationStatement
      nodes.push(ast.initialValue);
    } else if (ast.condition && (ast.trueExpression || ast.falseExpression)) {
      // for Conditional
      nodes.push(ast.condition);
      nodes.push(ast.trueExpression);
      nodes.push(ast.falseExpression);
    } else if (ast.leftHandSide && ast.rightHandSide) {
      // for Assignment
      nodes.push(ast.leftHandSide);
      nodes.push(ast.rightHandSide);
    } else if (ast.leftExpression && ast.rightExpression) {
      // for BinaryOperation
      nodes.push(ast.leftExpression);
      nodes.push(ast.rightExpression);
    } else if (ast.expression && (ast.arguments || ast.options)) {
      // for FunctionCall, FunctionCallOptions
      nodes.push(ast.arguments ? ast.arguments : ast.options);
    } else if (ast.baseExpression && (ast.indexExpression || ast.startExpression && ast.endExpression)) {
      // for IndexAccess, IndexRangeAccess
      nodes.push(ast.baseExpression);
      if (ast.indexExpression) nodes.push(ast.indexExpression);else {
        nodes.push(ast.startExpression);
        nodes.push(ast.endExpression);
      }
    }

    return this.normalizeNodes(nodes);
  } // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types


  walk(ast, callback) {
    if (ast) {
      const children = this.getASTNodeChildren(ast);

      if (callback) {
        if (callback instanceof Function) {
          callback = Object({
            "*": callback
          });
        }

        if (!("*" in callback)) {
          callback["*"] = function () {
            return true;
          };
        }

        if (this.manageCallback(ast, callback) && (children === null || children === void 0 ? void 0 : children.length)) {
          for (const k in children) {
            const child = children[k];
            this.walk(child, callback);
          }
        }
      } else {
        if (children === null || children === void 0 ? void 0 : children.length) {
          for (const k in children) {
            const child = children[k];
            this.emit("node", child);
            this.walk(child);
          }
        }
      }
    }
  } // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types


  walkFullInternal(ast, callback) {
    if (isAstNode(ast) || isYulAstNode(ast)) {
      // console.log(`XXX id ${ast.id}, nodeType: ${ast.nodeType}, src: ${ast.src}`);
      callback(ast);

      for (const k of Object.keys(ast)) {
        // Possible optimization:
        // if (k in ['id', 'src', 'nodeType']) continue;
        const astItem = ast[k];

        if (Array.isArray(astItem)) {
          for (const child of astItem) {
            if (child) {
              this.walkFullInternal(child, callback);
            }
          }
        } else {
          this.walkFullInternal(astItem, callback);
        }
      }
    }
  } // Normalizes parameter callback and calls walkFullInternal
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


  walkFull(ast, callback) {
    if (isAstNode(ast) || isYulAstNode(ast)) return this.walkFullInternal(ast, callback);
  } // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types


  walkAstList(sourcesList, cb) {
    if (cb) {
      if (sourcesList.ast) {
        this.walk(sourcesList.ast, cb);
      }
    } else {
      if (sourcesList.ast) {
        this.walk(sourcesList.ast);
      }
    }
  }

}

exports.AstWalker = AstWalker;

/***/ }),

/***/ "../../../dist/libs/remix-astwalker/index.js":
/*!***********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-astwalker/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

tslib_1.__exportStar(__webpack_require__(/*! ./astWalker */ "../../../dist/libs/remix-astwalker/astWalker.js"), exports);

tslib_1.__exportStar(__webpack_require__(/*! ./sourceMappings */ "../../../dist/libs/remix-astwalker/sourceMappings.js"), exports);

/***/ }),

/***/ "../../../dist/libs/remix-astwalker/sourceMappings.js":
/*!********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-astwalker/sourceMappings.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const astWalker_1 = __webpack_require__(/*! ./astWalker */ "../../../dist/libs/remix-astwalker/astWalker.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");
/**
 * Turn an character offset into a "LineColPosition".
 *
 * @param offset  The character offset to convert.
 */


function lineColPositionFromOffset(offset, lineBreaks) {
  let line = remix_lib_1.util.findLowerBound(offset, lineBreaks);

  if (lineBreaks[line] !== offset) {
    line += 1;
  }

  const beginColumn = line === 0 ? 0 : lineBreaks[line - 1] + 1;
  return {
    line: line + 1,
    character: offset - beginColumn + 1
  };
}

exports.lineColPositionFromOffset = lineColPositionFromOffset;
/**
 * Turn a solc AST's "src" attribute string (s:l:f)
 * into a Location
 *
 * @param astNode  The object to convert.
 */

function sourceLocationFromAstNode(astNode) {
  if (astWalker_1.isAstNode(astNode) && astWalker_1.isYulAstNode(astNode) && astNode.src) {
    return sourceLocationFromSrc(astNode.src);
  }

  return null;
}

exports.sourceLocationFromAstNode = sourceLocationFromAstNode;
/**
 * Break out fields of solc AST's "src" attribute string (s:l:f)
 * into its "start", "length", and "file index" components
 * and return that as a Location
 *
 * @param src  A solc "src" field.
 * @returns {Location}
 */

function sourceLocationFromSrc(src) {
  const split = src.split(':');
  return {
    start: parseInt(split[0], 10),
    length: parseInt(split[1], 10),
    file: parseInt(split[2], 10)
  };
}

exports.sourceLocationFromSrc = sourceLocationFromSrc;
/**
 * Routines for retrieving solc AST object(s) using some criteria, usually
 * includng "src' information.
 */

class SourceMappings {
  constructor(source) {
    this.source = source; // Create a list of line offsets which will be used to map between
    // character offset and line/column positions.

    const lineBreaks = [];

    for (let pos = source.indexOf('\n'); pos >= 0; pos = source.indexOf('\n', pos + 1)) {
      lineBreaks.push(pos);
    }

    this.lineBreaks = lineBreaks;
  }

  /**
   * Get a list of nodes that are at the given "position".
   *
   * @param astNodeType  Type of node to return or null.
   * @param position     Character offset where AST node should be located.
   */
  nodesAtPosition(astNodeType, position, ast) {
    const astWalker = new astWalker_1.AstWalker();
    const found = [];

    const callback = function (node) {
      const nodeLocation = sourceLocationFromAstNode(node);

      if (nodeLocation && nodeLocation.start == position.start && nodeLocation.length == position.length) {
        if (!astNodeType || astNodeType === node.nodeType) {
          found.push(node);
        }
      }

      return true;
    };

    astWalker.walkFull(ast, callback);
    return found;
  }
  /**
   * Retrieve the first "astNodeType" that includes the source map at arg instIndex, or "null" if none found.
   *
   * @param astNodeType   nodeType that a found ASTNode must be. Use "null" if any ASTNode can match.
   * @param sourceLocation "src" location that the AST node must match.
   */


  findNodeAtSourceLocation(astNodeType, sourceLocation, ast) {
    const astWalker = new astWalker_1.AstWalker();
    let found = null;
    /* FIXME: Looking at AST walker code,
       I don't understand a need to return a boolean. */

    const callback = function (node) {
      const nodeLocation = sourceLocationFromAstNode(node);

      if (nodeLocation && nodeLocation.start == sourceLocation.start && nodeLocation.length == sourceLocation.length) {
        if (astNodeType == undefined || astNodeType === node.nodeType) {
          found = node;
        }
      }

      return true;
    };

    astWalker.walkFull(ast, callback);
    return found;
  }
  /**
   * Retrieve the line/column range position for the given source-mapping string.
   *
   * @param src  Solc "src" object containing attributes {source} and {length}.
   */


  srcToLineColumnRange(src) {
    const sourceLocation = sourceLocationFromSrc(src);

    if (sourceLocation.start >= 0 && sourceLocation.length >= 0) {
      return {
        start: lineColPositionFromOffset(sourceLocation.start, this.lineBreaks),
        end: lineColPositionFromOffset(sourceLocation.start + sourceLocation.length, this.lineBreaks)
      };
    } else {
      return {
        start: null,
        end: null
      };
    }
  }

}

exports.SourceMappings = SourceMappings;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/Ethdebugger.js":
/*!*****************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/Ethdebugger.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const storageViewer_1 = __webpack_require__(/*! ./storage/storageViewer */ "../../../dist/libs/remix-debug/src/storage/storageViewer.js");

const storageResolver_1 = __webpack_require__(/*! ./storage/storageResolver */ "../../../dist/libs/remix-debug/src/storage/storageResolver.js");

const traceManager_1 = __webpack_require__(/*! ./trace/traceManager */ "../../../dist/libs/remix-debug/src/trace/traceManager.js");

const codeManager_1 = __webpack_require__(/*! ./code/codeManager */ "../../../dist/libs/remix-debug/src/code/codeManager.js");

const traceHelper_1 = __webpack_require__(/*! ./trace/traceHelper */ "../../../dist/libs/remix-debug/src/trace/traceHelper.js");

const eventManager_1 = __webpack_require__(/*! ./eventManager */ "../../../dist/libs/remix-debug/src/eventManager.js");

const solidity_decoder_1 = __webpack_require__(/*! ./solidity-decoder */ "../../../dist/libs/remix-debug/src/solidity-decoder/index.js");
/**
  * Ethdebugger is a wrapper around a few classes that helps debugging a transaction
  *
  * - Web3Providers - define which environment (web3) the transaction will be retrieved from
  * - TraceManager - Load / Analyze the trace and retrieve details of specific test
  * - CodeManager - Retrieve loaded byte code and help to resolve AST item from vmtrace index
  * - SolidityProxy - Basically used to extract state variable from AST
  * - Breakpoint Manager - Used to add / remove / jumpto breakpoint
  * - InternalCallTree - Used to retrieved local variables
  * - StorageResolver - Help resolving the storage accross different steps
  *
  * @param {Map} opts  -  { function compilationResult } //
  */


class Ethdebugger {
  constructor(opts) {
    this.compilationResult = opts.compilationResult || function (contractAddress) {
      return null;
    };

    this.web3 = opts.web3;
    this.opts = opts;
    this.event = new eventManager_1.EventManager();
    this.traceManager = new traceManager_1.TraceManager({
      web3: this.web3
    });
    this.codeManager = new codeManager_1.CodeManager(this.traceManager);
    this.solidityProxy = new solidity_decoder_1.SolidityProxy({
      getCurrentCalledAddressAt: this.traceManager.getCurrentCalledAddressAt.bind(this.traceManager),
      getCode: this.codeManager.getCode.bind(this.codeManager)
    });
    this.storageResolver = null;
    const includeLocalVariables = true;
    this.callTree = new solidity_decoder_1.InternalCallTree(this.event, this.traceManager, this.solidityProxy, this.codeManager, Object.assign(Object.assign({}, opts), {
      includeLocalVariables
    }));
  }

  setManagers() {
    this.traceManager = new traceManager_1.TraceManager({
      web3: this.web3
    });
    this.codeManager = new codeManager_1.CodeManager(this.traceManager);
    this.solidityProxy = new solidity_decoder_1.SolidityProxy({
      getCurrentCalledAddressAt: this.traceManager.getCurrentCalledAddressAt.bind(this.traceManager),
      getCode: this.codeManager.getCode.bind(this.codeManager)
    });
    this.storageResolver = null;
    const includeLocalVariables = true;
    this.callTree = new solidity_decoder_1.InternalCallTree(this.event, this.traceManager, this.solidityProxy, this.codeManager, Object.assign(Object.assign({}, this.opts), {
      includeLocalVariables
    }));
    this.event.trigger('managersChanged');
  }

  resolveStep(index) {
    this.codeManager.resolveStep(index, this.tx);
  }

  setCompilationResult(compilationResult) {
    this.solidityProxy.reset(compilationResult && compilationResult.data || {});
  }

  sourceLocationFromVMTraceIndex(address, stepIndex) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      return this.callTree.sourceLocationTracker.getSourceLocationFromVMTraceIndex(address, stepIndex, this.solidityProxy.contracts);
    });
  }

  getValidSourceLocationFromVMTraceIndex(address, stepIndex) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      return this.callTree.sourceLocationTracker.getValidSourceLocationFromVMTraceIndex(address, stepIndex, this.solidityProxy.contracts);
    });
  }

  sourceLocationFromInstructionIndex(address, instIndex, callback) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      return this.callTree.sourceLocationTracker.getSourceLocationFromInstructionIndex(address, instIndex, this.solidityProxy.contracts);
    });
  }
  /* breakpoint */


  setBreakpointManager(breakpointManager) {
    this.breakpointManager = breakpointManager;
  }
  /* decode locals */


  extractLocalsAt(step) {
    return this.callTree.findScope(step);
  }

  decodeLocalsAt(step, sourceLocation, callback) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      try {
        const stack = this.traceManager.getStackAt(step);
        const memory = this.traceManager.getMemoryAt(step);
        const address = this.traceManager.getCurrentCalledAddressAt(step);

        try {
          const storageViewer = new storageViewer_1.StorageViewer({
            stepIndex: step,
            tx: this.tx,
            address: address
          }, this.storageResolver, this.traceManager);
          const locals = yield solidity_decoder_1.localDecoder.solidityLocals(step, this.callTree, stack, memory, storageViewer, sourceLocation, null);

          if (locals['error']) {
            return callback(locals['error']);
          }

          return callback(null, locals);
        } catch (e) {
          callback(e.message);
        }
      } catch (error) {
        callback(error);
      }
    });
  }
  /* decode state */


  extractStateAt(step) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      return this.solidityProxy.extractStateVariablesAt(step);
    });
  }

  decodeStateAt(step, stateVars, callback) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      try {
        const address = this.traceManager.getCurrentCalledAddressAt(step);
        const storageViewer = new storageViewer_1.StorageViewer({
          stepIndex: step,
          tx: this.tx,
          address: address
        }, this.storageResolver, this.traceManager);
        const result = yield solidity_decoder_1.stateDecoder.decodeState(stateVars, storageViewer);
        return result;
      } catch (error) {
        callback(error);
      }
    });
  }

  storageViewAt(step, address) {
    return new storageViewer_1.StorageViewer({
      stepIndex: step,
      tx: this.tx,
      address: address
    }, this.storageResolver, this.traceManager);
  }

  updateWeb3(web3) {
    this.web3 = web3;
    this.setManagers();
  }

  unLoad() {
    this.traceManager.init();
    this.codeManager.clear();
    this.event.trigger('traceUnloaded');
  }

  debug(tx) {
    if (this.traceManager.isLoading) {
      return;
    }

    tx.to = tx.to || traceHelper_1.contractCreationToken('0');
    this.tx = tx;
    this.traceManager.resolveTrace(tx).then(result => tslib_1.__awaiter(this, void 0, void 0, function* () {
      this.setCompilationResult(yield this.compilationResult(tx.to));
      this.event.trigger('newTraceLoaded', [this.traceManager.trace]);

      if (this.breakpointManager && this.breakpointManager.hasBreakpoint()) {
        this.breakpointManager.jumpNextBreakpoint(false);
      }

      this.storageResolver = new storageResolver_1.StorageResolver({
        web3: this.traceManager.web3
      });
    })).catch(error => {
      this.statusMessage = error ? error.message : 'Trace not loaded';
    });
  }

}

exports.Ethdebugger = Ethdebugger;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/cmdline/index.js":
/*!*******************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/cmdline/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const web3_1 = tslib_1.__importDefault(__webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js"));

const debugger_js_1 = __webpack_require__(/*! ../debugger/debugger.js */ "../../../dist/libs/remix-debug/src/debugger/debugger.js");

const events_1 = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

class CmdLine {
  constructor() {
    this.events = new events_1.EventEmitter();
    this.lineColumnPos = null;
    this.rawLocation = null;
  }

  connect(providerType, url) {
    if (providerType !== 'http') throw new Error('unsupported provider type');
    this.web3 = new web3_1.default(new web3_1.default.providers.HttpProvider(url));
  }

  loadCompilationData(inputJson, outputJson) {
    const data = {};
    data['data'] = outputJson;
    data['source'] = {
      sources: inputJson.sources
    };
    this.loadCompilationResult(data);
  }

  loadCompilationResult(compilationResult) {
    this.compilation = {};
    this.compilation.compilationResult = compilationResult;
  }

  initDebugger(cb) {
    this.debugger = new debugger_js_1.Debugger({
      web3: this.web3,
      compilationResult: () => {
        return this.compilation.compilationResult;
      }
    });
  }

  getSource() {
    const lineColumnPos = this.lineColumnPos;
    if (!lineColumnPos || !lineColumnPos.start) return [];
    const content = this.compilation.compilationResult.source.sources[this.filename].content.split('\n');
    const source = [];
    let line;
    line = content[lineColumnPos.start.line - 2];

    if (line !== undefined) {
      source.push('    ' + (lineColumnPos.start.line - 1) + ':  ' + line);
    }

    line = content[lineColumnPos.start.line - 1];

    if (line !== undefined) {
      source.push('    ' + lineColumnPos.start.line + ':  ' + line);
    }

    const currentLineNumber = lineColumnPos.start.line;
    const currentLine = content[currentLineNumber];
    source.push('=>  ' + (currentLineNumber + 1) + ':  ' + currentLine);
    const startLine = lineColumnPos.start.line;

    for (var i = 1; i < 4; i++) {
      const line = content[startLine + i];
      source.push('    ' + (startLine + i + 1) + ':  ' + line);
    }

    return source;
  }

  getCurrentLine() {
    const lineColumnPos = this.lineColumnPos;
    if (!lineColumnPos) return '';
    const currentLineNumber = lineColumnPos.start.line;
    const content = this.compilation.compilationResult.source.sources[this.filename].content.split('\n');
    return content[currentLineNumber];
  }

  startDebug(txNumber, filename, cb) {
    this.filename = filename;
    this.txHash = txNumber;
    this.debugger.debug(null, txNumber, null, () => {
      this.debugger.event.register('newSourceLocation', (lineColumnPos, rawLocation) => {
        if (!lineColumnPos) return;
        this.lineColumnPos = lineColumnPos;
        this.rawLocation = rawLocation;
        this.events.emit('source', [lineColumnPos, rawLocation]);
      });
      this.debugger.vmDebuggerLogic.event.register('solidityState', data => {
        this.solidityState = data;
        this.events.emit('globals', data);
      }); // TODO: this doesnt work too well, it should request the data instead...

      this.debugger.vmDebuggerLogic.event.register('solidityLocals', data => {
        if (JSON.stringify(data) === '{}') return;
        this.solidityLocals = data;
        this.events.emit('locals', data);
      });

      if (cb) {
        // TODO: this should be an onReady event
        setTimeout(cb, 1000);
      }
    });
  }

  getVars() {
    return {
      locals: this.solidityLocals,
      contract: this.solidityState
    };
  }

  triggerSourceUpdate() {
    this.events.emit('source', [this.lineColumnPos, this.rawLocation]);
  }

  stepJumpNextBreakpoint() {
    this.debugger.step_manager.jumpNextBreakpoint();
  }

  stepJumpPreviousBreakpoint() {
    this.debugger.step_manager.jumpPreviousBreakpoint();
  }

  stepOverForward(solidityMode) {
    this.debugger.step_manager.stepOverForward(solidityMode);
  }

  stepOverBack(solidityMode) {
    this.debugger.step_manager.stepOverBack(solidityMode);
  }

  stepIntoForward(solidityMode) {
    this.debugger.step_manager.stepIntoForward(solidityMode);
  }

  stepIntoBack(solidityMode) {
    this.debugger.step_manager.stepIntoBack(solidityMode);
  }

  jumpTo(step) {
    this.debugger.step_manager.jumpTo(step);
  }

  getTraceLength() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.traceLength;
  }

  getCodeFirstStep() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.calculateFirstStep();
  }

  getCodeTraceLength() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.calculateCodeLength();
  }

  nextStep() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.nextStep();
  }

  previousStep() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.previousStep();
  }

  currentStep() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.currentStepIndex;
  }

  canGoNext() {
    return this.currentStep() < this.getCodeTraceLength();
  }

  canGoPrevious() {
    return this.currentStep() > this.getCodeFirstStep();
  }

  unload() {
    return this.debugger.unload();
  }

  displayLocals() {
    console.dir('= displayLocals');
    console.dir(this.solidityLocals);
  }

  displayGlobals() {
    console.dir('= displayGlobals');
    console.dir(this.solidityState);
  }

}

exports.CmdLine = CmdLine;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/code/breakpointManager.js":
/*!****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/code/breakpointManager.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const eventManager_1 = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-debug/src/eventManager.js");

const traceHelper_1 = __webpack_require__(/*! ../trace/traceHelper */ "../../../dist/libs/remix-debug/src/trace/traceHelper.js");
/**
  * allow to manage breakpoint
  *
  * Trigger events: breakpointHit, breakpointAdded, breakpointRemoved
  */


class BreakpointManager {
  /**
    * constructor
    *
    * @param {Object} _debugger - type of EthDebugger
    * @return {Function} _locationToRowConverter - function implemented by editor which return a column/line position for a char source location
    */
  constructor({
    traceManager,
    callTree,
    solidityProxy,
    locationToRowConverter
  }) {
    this.event = new eventManager_1.EventManager();
    this.traceManager = traceManager;
    this.callTree = callTree;
    this.solidityProxy = solidityProxy;
    this.breakpoints = {};
    this.locationToRowConverter = locationToRowConverter;
  }

  setManagers({
    traceManager,
    callTree,
    solidityProxy
  }) {
    this.traceManager = traceManager;
    this.callTree = callTree;
    this.solidityProxy = solidityProxy;
  }
  /**
    * start looking for the next breakpoint
    * @param {Bool} defaultToLimit - if true jump to the end of the trace if no more breakpoint found
    *
    */


  jumpNextBreakpoint(fromStep, defaultToLimit) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.locationToRowConverter) {
        return console.log('row converter not provided');
      }

      this.jump(fromStep || 0, 1, defaultToLimit, this.traceManager.trace);
    });
  }
  /**
    * start looking for the previous breakpoint
    * @param {Bool} defaultToLimit - if true jump to the start of the trace if no more breakpoint found
    *
    */


  jumpPreviousBreakpoint(fromStep, defaultToLimit) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.locationToRowConverter) {
        return console.log('row converter not provided');
      }

      this.jump(fromStep || 0, -1, defaultToLimit, this.traceManager.trace);
    });
  }

  depthChange(step, trace) {
    return trace[step].depth !== trace[step - 1].depth;
  }

  hitLine(currentStep, sourceLocation, previousSourceLocation, trace) {
    // isJumpDestInstruction -> returning from a internal function call
    // depthChange -> returning from an external call
    // sourceLocation.start <= previousSourceLocation.start && ... -> previous src is contained in the current one
    if (traceHelper_1.isJumpDestInstruction(trace[currentStep]) && previousSourceLocation.jump === 'o' || this.depthChange(currentStep, trace) || sourceLocation.start <= previousSourceLocation.start && sourceLocation.start + sourceLocation.length >= previousSourceLocation.start + previousSourceLocation.length) {
      return false;
    }

    this.event.trigger('breakpointStep', [currentStep]);
    this.event.trigger('breakpointHit', [sourceLocation, currentStep]);
    return true;
  }
  /**
    * start looking for the previous or next breakpoint
    * @param {Int} direction - 1 or -1 direction of the search
    * @param {Bool} defaultToLimit - if true jump to the limit (end if direction is 1, beginning if direction is -1) of the trace if no more breakpoint found
    *
    */


  jump(fromStep, direction, defaultToLimit, trace) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      let sourceLocation;
      let previousSourceLocation;
      let currentStep = fromStep + direction;
      let lineHadBreakpoint = false;
      let initialLine;

      while (currentStep > 0 && currentStep < trace.length) {
        try {
          previousSourceLocation = sourceLocation;
          sourceLocation = yield this.callTree.extractValidSourceLocation(currentStep);
        } catch (e) {
          console.log('cannot jump to breakpoint ' + e);
          currentStep += direction;
          continue;
        }

        const lineColumn = yield this.locationToRowConverter(sourceLocation);
        if (!initialLine) initialLine = lineColumn;

        if (initialLine.start.line !== lineColumn.start.line) {
          if (direction === -1 && lineHadBreakpoint) {
            // TODO : improve this when we will build the correct structure before hand
            lineHadBreakpoint = false;

            if (this.hitLine(currentStep + 1, previousSourceLocation, sourceLocation, trace)) {
              return;
            }
          }

          if (this.hasBreakpointAtLine(sourceLocation.file, lineColumn.start.line)) {
            lineHadBreakpoint = true;

            if (direction === 1 && this.hitLine(currentStep, sourceLocation, previousSourceLocation, trace)) {
              return;
            }
          }
        }

        currentStep += direction;
      }

      this.event.trigger('NoBreakpointHit', []);

      if (!defaultToLimit) {
        return;
      }

      if (direction === -1) {
        this.event.trigger('breakpointStep', [0]);
      } else if (direction === 1) {
        this.event.trigger('breakpointStep', [trace.length - 1]);
      }
    });
  }
  /**
    * check the given pair fileIndex/line against registered breakpoints
    *
    * @param {Int} fileIndex - index of the file content (from the compilation result)
    * @param {Int} line - line number where looking for breakpoint
    * @return {Bool} return true if the given @arg fileIndex @arg line refers to a breakpoint
    */


  hasBreakpointAtLine(fileIndex, line) {
    const filename = this.solidityProxy.fileNameFromIndex(fileIndex);

    if (!(filename && this.breakpoints[filename])) {
      return false;
    }

    const sources = this.breakpoints[filename];

    for (const k in sources) {
      const source = sources[k];

      if (line === source.row) {
        return true;
      }
    }
  }
  /**
    * return true if current manager has breakpoint
    *
    * @return {Bool} true if breapoint registered
    */


  hasBreakpoint() {
    for (const k in this.breakpoints) {
      if (this.breakpoints[k].length) {
        return true;
      }
    }

    return false;
  }
  /**
    * add a new breakpoint to the manager
    *
    * @param {Object} sourceLocation - position of the breakpoint { file: '<file index>', row: '<line number' }
    */


  add(sourceLocation) {
    if (!this.breakpoints[sourceLocation.fileName]) {
      this.breakpoints[sourceLocation.fileName] = [];
    }

    this.breakpoints[sourceLocation.fileName].push(sourceLocation);
    this.event.trigger('breakpointAdded', [sourceLocation]);
  }
  /**
    * remove a breakpoint from the manager
    *
    * @param {Object} sourceLocation - position of the breakpoint { file: '<file index>', row: '<line number' }
    */


  remove(sourceLocation) {
    var sources = this.breakpoints[sourceLocation.fileName];

    if (!sources) {
      return;
    }

    for (const k in sources) {
      const source = sources[k];

      if (sourceLocation.row === source.row) {
        sources.splice(k, 1);
        this.event.trigger('breakpointRemoved', [sourceLocation]);
        break;
      }
    }
  }

}

exports.BreakpointManager = BreakpointManager;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/code/codeManager.js":
/*!**********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/code/codeManager.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const eventManager_1 = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-debug/src/eventManager.js");

const traceHelper_1 = __webpack_require__(/*! ../trace/traceHelper */ "../../../dist/libs/remix-debug/src/trace/traceHelper.js");

const sourceMappingDecoder_1 = __webpack_require__(/*! ../source/sourceMappingDecoder */ "../../../dist/libs/remix-debug/src/source/sourceMappingDecoder.js");

const codeResolver_1 = __webpack_require__(/*! ./codeResolver */ "../../../dist/libs/remix-debug/src/code/codeResolver.js");
/*
  resolve contract code referenced by vmtrace in order to be used by asm listview.
  events:
   - changed: triggered when an item is selected
   - resolvingStep: when CodeManager resolves code/selected instruction of a new step
*/


class CodeManager {
  constructor(_traceManager) {
    this.event = new eventManager_1.EventManager();
    this.isLoading = false;
    this.traceManager = _traceManager;
    this.codeResolver = new codeResolver_1.CodeResolver({
      getCode: address => tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          this.traceManager.web3.eth.getCode(address, (error, code) => {
            if (error) {
              return reject(error);
            }

            return resolve(code);
          });
        });
      })
    });
  }
  /**
   * clear the cache
   *
   */


  clear() {
    this.codeResolver.clear();
  }
  /**
   * resolve the code of the given @arg stepIndex and trigger appropriate event
   *
   * @param {String} stepIndex - vm trace step
   * @param {Object} tx - transaction (given by web3)
   */


  resolveStep(stepIndex, tx) {
    if (stepIndex < 0) return;
    this.event.trigger('resolvingStep');

    if (stepIndex === 0) {
      return this.retrieveCodeAndTrigger(this, tx.to, stepIndex, tx);
    }

    try {
      const address = this.traceManager.getCurrentCalledAddressAt(stepIndex);
      this.retrieveCodeAndTrigger(this, address, stepIndex, tx);
    } catch (error) {
      return console.log(error);
    }
  }
  /**
   * Retrieve the code located at the given @arg address
   *
   * @param {String} address - address of the contract to get the code from
   * @param {Function} cb - callback function, return the bytecode
   */


  getCode(address) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!traceHelper_1.isContractCreation(address)) {
        const code = yield this.codeResolver.resolveCode(address);
        return code;
      }

      var codes = this.codeResolver.getExecutingCodeFromCache(address);

      if (codes) {
        return codes;
      }

      const hexCode = this.traceManager.getContractCreationCode(address);
      codes = this.codeResolver.cacheExecutingCode(address, hexCode);
      return codes;
    });
  }
  /**
   * Retrieve the called function for the current vm step for the given @arg address
   *
   * @param {String} stepIndex - vm trace step
   * @param {String} sourceMap - source map given byt the compilation result
   * @param {Object} ast - ast given by the compilation result
   * @return {Object} return the ast node of the function
   */


  getFunctionFromStep(stepIndex, sourceMap, ast) {
    try {
      const address = this.traceManager.getCurrentCalledAddressAt(stepIndex);
      const pc = this.traceManager.getCurrentPC(stepIndex);
      return this.getFunctionFromPC(address, pc, sourceMap, ast);
    } catch (error) {
      console.log(error);
      return {
        error: 'Cannot retrieve current address or PC for ' + stepIndex
      };
    }
  }
  /**
   * Retrieve the instruction index of the given @arg step
   *
   * @param {String} address - address of the current context
   * @param {String} step - vm trace step
   * @param {Function} callback - instruction index
   */


  getInstructionIndex(address, step) {
    try {
      const pc = this.traceManager.getCurrentPC(step);
      const itemIndex = this.codeResolver.getInstructionIndex(address, pc);
      return itemIndex;
    } catch (error) {
      console.log(error);
      throw new Error('Cannot retrieve current PC for ' + step);
    }
  }
  /**
   * Retrieve the called function for the given @arg pc and @arg address
   *
   * @param {String} address - address of the current context (used to resolve instruction index)
   * @param {String} pc - pc that point to the instruction index
   * @param {String} sourceMap - source map given byt the compilation result
   * @param {Object} ast - ast given by the compilation result
   * @return {Object} return the ast node of the function
   */


  getFunctionFromPC(address, pc, sourceMap, ast) {
    const instIndex = this.codeResolver.getInstructionIndex(address, pc);
    return sourceMappingDecoder_1.findNodeAtInstructionIndex('FunctionDefinition', instIndex, sourceMap, ast);
  }

  retrieveCodeAndTrigger(codeMananger, address, stepIndex, tx) {
    codeMananger.getCode(address).then(result => {
      this.retrieveIndexAndTrigger(codeMananger, address, stepIndex, result.instructions);
    }).catch(error => {
      return console.log(error);
    });
  }

  retrieveIndexAndTrigger(codeMananger, address, step, code) {
    let result;

    try {
      result = codeMananger.getInstructionIndex(address, step);
    } catch (error) {
      return console.log(error);
    }

    try {
      codeMananger.event.trigger('changed', [code, address, result]);
    } catch (e) {
      console.log('dispatching event failed', e);
    }
  }

}

exports.CodeManager = CodeManager;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/code/codeResolver.js":
/*!***********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/code/codeResolver.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const codeUtils_1 = __webpack_require__(/*! ./codeUtils */ "../../../dist/libs/remix-debug/src/code/codeUtils.js");

class CodeResolver {
  constructor({
    getCode
  }) {
    this.getCode = getCode;
    this.bytecodeByAddress = {}; // bytes code by contract addesses

    this.instructionsByAddress = {}; // assembly items instructions list by contract addesses

    this.instructionsIndexByBytesOffset = {}; // mapping between bytes offset and instructions index.
  }

  clear() {
    this.bytecodeByAddress = {};
    this.instructionsByAddress = {};
    this.instructionsIndexByBytesOffset = {};
  }

  resolveCode(address) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const cache = this.getExecutingCodeFromCache(address);

      if (cache) {
        return cache;
      }

      const code = yield this.getCode(address);
      return this.cacheExecutingCode(address, code);
    });
  }

  cacheExecutingCode(address, hexCode) {
    const codes = this.formatCode(hexCode);
    this.bytecodeByAddress[address] = hexCode;
    this.instructionsByAddress[address] = codes.code;
    this.instructionsIndexByBytesOffset[address] = codes.instructionsIndexByBytesOffset;
    return this.getExecutingCodeFromCache(address);
  }

  formatCode(hexCode) {
    const [code, instructionsIndexByBytesOffset] = codeUtils_1.nameOpCodes(Buffer.from(hexCode.substring(2), 'hex'));
    return {
      code,
      instructionsIndexByBytesOffset
    };
  }

  getExecutingCodeFromCache(address) {
    if (!this.instructionsByAddress[address]) {
      return null;
    }

    return {
      instructions: this.instructionsByAddress[address],
      instructionsIndexByBytesOffset: this.instructionsIndexByBytesOffset[address],
      bytecode: this.bytecodeByAddress[address]
    };
  }

  getInstructionIndex(address, pc) {
    return this.getExecutingCodeFromCache(address).instructionsIndexByBytesOffset[pc];
  }

}

exports.CodeResolver = CodeResolver;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/code/codeUtils.js":
/*!********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/code/codeUtils.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const opcodes_1 = tslib_1.__importDefault(__webpack_require__(/*! ./opcodes */ "../../../dist/libs/remix-debug/src/code/opcodes.js"));

function nameOpCodes(raw) {
  let pushData = '';
  const codeMap = {};
  const code = [];

  for (let i = 0; i < raw.length; i++) {
    const pc = i;
    const curOpCode = opcodes_1.default(raw[pc], false).name;
    codeMap[i] = code.length; // no destinations into the middle of PUSH

    if (curOpCode.slice(0, 4) === 'PUSH') {
      const jumpNum = raw[pc] - 0x5f;
      pushData = raw.slice(pc + 1, pc + jumpNum + 1);
      i += jumpNum;
    }

    const data = pushData.toString('hex') !== '' ? ' ' + pushData.toString('hex') : '';
    code.push(this.pad(pc, this.roundLog(raw.length, 10)) + ' ' + curOpCode + data);
    pushData = '';
  }

  return [code, codeMap];
}

exports.nameOpCodes = nameOpCodes;
/**
 * Parses code as a list of integers into a list of objects containing
 * information about the opcode.
 */

function parseCode(raw) {
  const code = [];

  for (let i = 0; i < raw.length; i++) {
    const opcode = opcodes_1.default(raw[i], true);

    if (opcode.name.slice(0, 4) === 'PUSH') {
      const length = raw[i] - 0x5f;
      opcode['pushData'] = raw.slice(i + 1, i + length + 1); // in case pushdata extends beyond code

      if (i + 1 + length > raw.length) {
        for (let j = opcode['pushData'].length; j < length; j++) {
          opcode['pushData'].push(0);
        }
      }

      i += length;
    }

    code.push(opcode);
  }

  return code;
}

exports.parseCode = parseCode;

function pad(num, size) {
  let s = num + '';

  while (s.length < size) s = '0' + s;

  return s;
}

exports.pad = pad;

function log(num, base) {
  return Math.log(num) / Math.log(base);
}

exports.log = log;

function roundLog(num, base) {
  return Math.ceil(this.log(num, base));
}

exports.roundLog = roundLog;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/code/opcodes.js":
/*!******************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/code/opcodes.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function default_1(op, full) {
  const codes = {
    // 0x0 range - arithmetic ops
    // name, baseCost, off stack, on stack, dynamic, async
    // @todo can be improved on basis of this: https://github.com/ethereumjs/ethereumjs-vm/blob/master/lib/evm/opcodes.ts
    0x00: ['STOP', 0, 0, 0, false],
    0x01: ['ADD', 3, 2, 1, false],
    0x02: ['MUL', 5, 2, 1, false],
    0x03: ['SUB', 3, 2, 1, false],
    0x04: ['DIV', 5, 2, 1, false],
    0x05: ['SDIV', 5, 2, 1, false],
    0x06: ['MOD', 5, 2, 1, false],
    0x07: ['SMOD', 5, 2, 1, false],
    0x08: ['ADDMOD', 8, 3, 1, false],
    0x09: ['MULMOD', 8, 3, 1, false],
    0x0a: ['EXP', 10, 2, 1, false],
    0x0b: ['SIGNEXTEND', 5, 2, 1, false],
    // 0x10 range - bit ops
    0x10: ['LT', 3, 2, 1, false],
    0x11: ['GT', 3, 2, 1, false],
    0x12: ['SLT', 3, 2, 1, false],
    0x13: ['SGT', 3, 2, 1, false],
    0x14: ['EQ', 3, 2, 1, false],
    0x15: ['ISZERO', 3, 1, 1, false],
    0x16: ['AND', 3, 2, 1, false],
    0x17: ['OR', 3, 2, 1, false],
    0x18: ['XOR', 3, 2, 1, false],
    0x19: ['NOT', 3, 1, 1, false],
    0x1a: ['BYTE', 3, 2, 1, false],
    0x1b: ['SHL', 3, 2, 1, false],
    0x1c: ['SHR', 3, 2, 1, false],
    0x1d: ['SAR', 3, 2, 1, false],
    // 0x20 range - crypto
    0x20: ['SHA3', 30, 2, 1, false],
    // 0x30 range - closure state
    0x30: ['ADDRESS', 2, 0, 1, true],
    0x31: ['BALANCE', 700, 1, 1, true, true],
    0x32: ['ORIGIN', 2, 0, 1, true],
    0x33: ['CALLER', 2, 0, 1, true],
    0x34: ['CALLVALUE', 2, 0, 1, true],
    0x35: ['CALLDATALOAD', 3, 1, 1, true],
    0x36: ['CALLDATASIZE', 2, 0, 1, true],
    0x37: ['CALLDATACOPY', 3, 3, 0, true],
    0x38: ['CODESIZE', 2, 0, 1, false],
    0x39: ['CODECOPY', 3, 3, 0, false],
    0x3a: ['GASPRICE', 2, 0, 1, false],
    0x3b: ['EXTCODESIZE', 700, 1, 1, true, true],
    0x3c: ['EXTCODECOPY', 700, 4, 0, true, true],
    0x3d: ['RETURNDATASIZE', 2, 0, 1, true],
    0x3e: ['RETURNDATACOPY', 3, 3, 0, true],
    0x3f: ['EXTCODEHASH', 400, 3, 0, true],
    // '0x40' range - block operations
    0x40: ['BLOCKHASH', 20, 1, 1, true, true],
    0x41: ['COINBASE', 2, 0, 1, true],
    0x42: ['TIMESTAMP', 2, 0, 1, true],
    0x43: ['NUMBER', 2, 0, 1, true],
    0x44: ['DIFFICULTY', 2, 0, 1, true],
    0x45: ['GASLIMIT', 2, 0, 1, true],
    0x46: ['CHAINID', 2, 0, 1, false],
    0x47: ['SELFBALANCE', 5, 0, 1, false],
    // 0x50 range - 'storage' and execution
    0x50: ['POP', 2, 1, 0, false],
    0x51: ['MLOAD', 3, 1, 1, false],
    0x52: ['MSTORE', 3, 2, 0, false],
    0x53: ['MSTORE8', 3, 2, 0, false],
    0x54: ['SLOAD', 800, 1, 1, true, true],
    0x55: ['SSTORE', 0, 2, 0, true, true],
    0x56: ['JUMP', 8, 1, 0, false],
    0x57: ['JUMPI', 10, 2, 0, false],
    0x58: ['PC', 2, 0, 1, false],
    0x59: ['MSIZE', 2, 0, 1, false],
    0x5a: ['GAS', 2, 0, 1, false],
    0x5b: ['JUMPDEST', 1, 0, 0, false],
    // 0x60, range
    0x60: ['PUSH1', 3, 0, 1, false],
    0x61: ['PUSH2', 3, 0, 1, false],
    0x62: ['PUSH3', 3, 0, 1, false],
    0x63: ['PUSH4', 3, 0, 1, false],
    0x64: ['PUSH5', 3, 0, 1, false],
    0x65: ['PUSH6', 3, 0, 1, false],
    0x66: ['PUSH7', 3, 0, 1, false],
    0x67: ['PUSH8', 3, 0, 1, false],
    0x68: ['PUSH9', 3, 0, 1, false],
    0x69: ['PUSH10', 3, 0, 1, false],
    0x6a: ['PUSH11', 3, 0, 1, false],
    0x6b: ['PUSH12', 3, 0, 1, false],
    0x6c: ['PUSH13', 3, 0, 1, false],
    0x6d: ['PUSH14', 3, 0, 1, false],
    0x6e: ['PUSH15', 3, 0, 1, false],
    0x6f: ['PUSH16', 3, 0, 1, false],
    0x70: ['PUSH17', 3, 0, 1, false],
    0x71: ['PUSH18', 3, 0, 1, false],
    0x72: ['PUSH19', 3, 0, 1, false],
    0x73: ['PUSH20', 3, 0, 1, false],
    0x74: ['PUSH21', 3, 0, 1, false],
    0x75: ['PUSH22', 3, 0, 1, false],
    0x76: ['PUSH23', 3, 0, 1, false],
    0x77: ['PUSH24', 3, 0, 1, false],
    0x78: ['PUSH25', 3, 0, 1, false],
    0x79: ['PUSH26', 3, 0, 1, false],
    0x7a: ['PUSH27', 3, 0, 1, false],
    0x7b: ['PUSH28', 3, 0, 1, false],
    0x7c: ['PUSH29', 3, 0, 1, false],
    0x7d: ['PUSH30', 3, 0, 1, false],
    0x7e: ['PUSH31', 3, 0, 1, false],
    0x7f: ['PUSH32', 3, 0, 1, false],
    0x80: ['DUP1', 3, 0, 1, false],
    0x81: ['DUP2', 3, 0, 1, false],
    0x82: ['DUP3', 3, 0, 1, false],
    0x83: ['DUP4', 3, 0, 1, false],
    0x84: ['DUP5', 3, 0, 1, false],
    0x85: ['DUP6', 3, 0, 1, false],
    0x86: ['DUP7', 3, 0, 1, false],
    0x87: ['DUP8', 3, 0, 1, false],
    0x88: ['DUP9', 3, 0, 1, false],
    0x89: ['DUP10', 3, 0, 1, false],
    0x8a: ['DUP11', 3, 0, 1, false],
    0x8b: ['DUP12', 3, 0, 1, false],
    0x8c: ['DUP13', 3, 0, 1, false],
    0x8d: ['DUP14', 3, 0, 1, false],
    0x8e: ['DUP15', 3, 0, 1, false],
    0x8f: ['DUP16', 3, 0, 1, false],
    0x90: ['SWAP1', 3, 0, 0, false],
    0x91: ['SWAP2', 3, 0, 0, false],
    0x92: ['SWAP3', 3, 0, 0, false],
    0x93: ['SWAP4', 3, 0, 0, false],
    0x94: ['SWAP5', 3, 0, 0, false],
    0x95: ['SWAP6', 3, 0, 0, false],
    0x96: ['SWAP7', 3, 0, 0, false],
    0x97: ['SWAP8', 3, 0, 0, false],
    0x98: ['SWAP9', 3, 0, 0, false],
    0x99: ['SWAP10', 3, 0, 0, false],
    0x9a: ['SWAP11', 3, 0, 0, false],
    0x9b: ['SWAP12', 3, 0, 0, false],
    0x9c: ['SWAP13', 3, 0, 0, false],
    0x9d: ['SWAP14', 3, 0, 0, false],
    0x9e: ['SWAP15', 3, 0, 0, false],
    0x9f: ['SWAP16', 3, 0, 0, false],
    0xa0: ['LOG0', 375, 2, 0, false],
    0xa1: ['LOG1', 375, 3, 0, false],
    0xa2: ['LOG2', 375, 4, 0, false],
    0xa3: ['LOG3', 375, 5, 0, false],
    0xa4: ['LOG4', 375, 6, 0, false],
    // '0xf0' range - closures
    0xf0: ['CREATE', 32000, 3, 1, true, true],
    0xf1: ['CALL', 700, 7, 1, true, true],
    0xf2: ['CALLCODE', 700, 7, 1, true, true],
    0xf3: ['RETURN', 0, 2, 0, false],
    0xf4: ['DELEGATECALL', 700, 6, 1, true, true],
    0xf5: ['CREATE2', 32000, 4, 1, true, true],
    0xfa: ['STATICCALL', 700, 6, 1, true, true],
    0xfd: ['REVERT', 0, 2, 0, false],
    // '0x70', range - other
    0xfe: ['INVALID', 0, 0, 0, false],
    0xff: ['SELFDESTRUCT', 5000, 1, 0, false, true]
  };
  const code = codes[op] ? codes[op] : ['INVALID', 0, 0, 0, false, false];
  let opcode = code[0];

  if (full) {
    if (opcode === 'LOG') {
      opcode += op - 0xa0;
    }

    if (opcode === 'PUSH') {
      opcode += op - 0x5f;
    }

    if (opcode === 'DUP') {
      opcode += op - 0x7f;
    }

    if (opcode === 'SWAP') {
      opcode += op - 0x8f;
    }
  }

  return {
    name: opcode,
    fee: code[1],
    in: code[2],
    out: code[3],
    dynamic: code[4],
    async: code[5]
  };
}

exports.default = default_1;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/debugger/VmDebugger.js":
/*!*************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/debugger/VmDebugger.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const eventManager_1 = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-debug/src/eventManager.js");

const storageResolver_1 = __webpack_require__(/*! ../storage/storageResolver */ "../../../dist/libs/remix-debug/src/storage/storageResolver.js");

const storageViewer_1 = __webpack_require__(/*! ../storage/storageViewer */ "../../../dist/libs/remix-debug/src/storage/storageViewer.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

const solidityState_1 = __webpack_require__(/*! ./solidityState */ "../../../dist/libs/remix-debug/src/debugger/solidityState.js");

const solidityLocals_1 = __webpack_require__(/*! ./solidityLocals */ "../../../dist/libs/remix-debug/src/debugger/solidityLocals.js");

const {
  ui
} = remix_lib_1.helpers;

class VmDebuggerLogic {
  constructor(_debugger, tx, _stepManager, _traceManager, _codeManager, _solidityProxy, _callTree) {
    this.event = new eventManager_1.EventManager();
    this.debugger = _debugger;
    this.stepManager = _stepManager;
    this._traceManager = _traceManager;
    this._codeManager = _codeManager;
    this._solidityProxy = _solidityProxy;
    this._callTree = _callTree;
    this.storageResolver = null;
    this.tx = tx;
    this.debuggerSolidityState = new solidityState_1.DebuggerSolidityState(tx, _stepManager, _traceManager, _codeManager, _solidityProxy);
    this.debuggerSolidityLocals = new solidityLocals_1.DebuggerSolidityLocals(tx, _stepManager, _traceManager, _callTree);
  }

  start() {
    this.listenToEvents();
    this.listenToCodeManagerEvents();
    this.listenToTraceManagerEvents();
    this.listenToFullStorageChanges();
    this.listenToNewChanges();
    this.listenToSolidityStateEvents();
    this.listenToSolidityLocalsEvents();
  }

  listenToEvents() {
    this.debugger.event.register('traceUnloaded', () => {
      this.event.trigger('traceUnloaded');
    });
    this.debugger.event.register('newTraceLoaded', () => {
      this.event.trigger('newTraceLoaded');
    });
  }

  listenToCodeManagerEvents() {
    this._codeManager.event.register('changed', (code, address, index) => {
      this.event.trigger('codeManagerChanged', [code, address, index]);
    });
  }

  listenToTraceManagerEvents() {
    this.event.register('indexChanged', this, index => {
      if (index < 0) return;
      if (this.stepManager.currentStepIndex !== index) return;
      this.event.trigger('indexUpdate', [index]);
      this.event.trigger('functionsStackUpdate', [this._callTree.retrieveFunctionsStack(index)]);

      try {
        const calldata = this._traceManager.getCallDataAt(index);

        if (this.stepManager.currentStepIndex === index) {
          this.event.trigger('traceManagerCallDataUpdate', [calldata]);
        }
      } catch (error) {
        this.event.trigger('traceManagerCallDataUpdate', [{}]);
      }

      try {
        const memory = this._traceManager.getMemoryAt(index);

        if (this.stepManager.currentStepIndex === index) {
          this.event.trigger('traceManagerMemoryUpdate', [ui.formatMemory(memory, 16)]);
        }
      } catch (error) {
        this.event.trigger('traceManagerMemoryUpdate', [{}]);
      }

      try {
        const callstack = this._traceManager.getCallStackAt(index);

        if (this.stepManager.currentStepIndex === index) {
          this.event.trigger('traceManagerCallStackUpdate', [callstack]);
        }
      } catch (error) {
        this.event.trigger('traceManagerCallStackUpdate', [{}]);
      }

      try {
        const callstack = this._traceManager.getStackAt(index);

        if (this.stepManager.currentStepIndex === index) {
          this.event.trigger('traceManagerStackUpdate', [callstack]);
        }
      } catch (error) {
        this.event.trigger('traceManagerStackUpdate', [{}]);
      }

      try {
        const address = this._traceManager.getCurrentCalledAddressAt(index);

        if (!this.storageResolver) return;
        var storageViewer = new storageViewer_1.StorageViewer({
          stepIndex: this.stepManager.currentStepIndex,
          tx: this.tx,
          address: address
        }, this.storageResolver, this._traceManager);
        storageViewer.storageRange().then(storage => {
          if (this.stepManager.currentStepIndex === index) {
            var header = storageViewer.isComplete(address) ? '[Completely Loaded]' : '[Partially Loaded]';
            this.event.trigger('traceManagerStorageUpdate', [storage, header]);
          }
        }).catch(_error => {
          this.event.trigger('traceManagerStorageUpdate', [{}]);
        });
      } catch (error) {
        this.event.trigger('traceManagerStorageUpdate', [{}]);
      }

      try {
        const step = this._traceManager.getCurrentStep(index);

        this.event.trigger('traceCurrentStepUpdate', [null, step]);
      } catch (error) {
        this.event.trigger('traceCurrentStepUpdate', [error]);
      }

      try {
        const addmem = this._traceManager.getMemExpand(index);

        this.event.trigger('traceMemExpandUpdate', [null, addmem]);
      } catch (error) {
        this.event.trigger('traceMemExpandUpdate', [error]);
      }

      try {
        const gas = this._traceManager.getStepCost(index);

        this.event.trigger('traceStepCostUpdate', [null, gas]);
      } catch (error) {
        this.event.trigger('traceStepCostUpdate', [error]);
      }

      try {
        const address = this._traceManager.getCurrentCalledAddressAt(index);

        this.event.trigger('traceCurrentCalledAddressAtUpdate', [null, address]);
      } catch (error) {
        this.event.trigger('traceCurrentCalledAddressAtUpdate', [error]);
      }

      try {
        const remaining = this._traceManager.getRemainingGas(index);

        this.event.trigger('traceRemainingGasUpdate', [null, remaining]);
      } catch (error) {
        this.event.trigger('traceRemainingGasUpdate', [error]);
      }

      try {
        const returnValue = this._traceManager.getReturnValue(index);

        if (this.stepManager.currentStepIndex === index) {
          this.event.trigger('traceReturnValueUpdate', [[returnValue]]);
        }
      } catch (error) {
        this.event.trigger('traceReturnValueUpdate', [[error]]);
      }
    });
  }

  listenToFullStorageChanges() {
    this.address = [];
    this.traceLength = 0;
    this.debugger.event.register('newTraceLoaded', length => {
      const addresses = this._traceManager.getAddresses();

      this.event.trigger('traceAddressesUpdate', [addresses]);
      this.addresses = addresses;

      this._traceManager.getLength((error, length) => {
        if (error) return;
        this.event.trigger('traceLengthUpdate', [length]);
        this.traceLength = length;
      });
    });
    this.debugger.event.register('indexChanged', this, index => {
      if (index < 0) return;
      if (this.stepManager.currentStepIndex !== index) return;
      if (!this.storageResolver) return; // Clean up storage update

      if (index === this.traceLength - 1) {
        return this.event.trigger('traceStorageUpdate', [{}]);
      }

      var storageJSON = {};

      for (var k in this.addresses) {
        var address = this.addresses[k];
        var storageViewer = new storageViewer_1.StorageViewer({
          stepIndex: this.stepManager.currentStepIndex,
          tx: this.tx,
          address: address
        }, this.storageResolver, this._traceManager);
        storageViewer.storageRange().then(result => {
          storageJSON[address] = result;
          this.event.trigger('traceStorageUpdate', [storageJSON]);
        });
      }
    });
  }

  listenToNewChanges() {
    this.debugger.event.register('newTraceLoaded', this, () => {
      this.storageResolver = new storageResolver_1.StorageResolver({
        web3: this.debugger.web3
      });
      this.debuggerSolidityState.storageResolver = this.storageResolver;
      this.debuggerSolidityLocals.storageResolver = this.storageResolver;
      this.event.trigger('newTrace', []);
    });
    this.debugger.callTree.event.register('callTreeReady', () => {
      if (this.debugger.callTree.reducedTrace.length) {
        return this.event.trigger('newCallTree', []);
      }
    });
  }

  listenToSolidityStateEvents() {
    this.event.register('indexChanged', this.debuggerSolidityState.init.bind(this.debuggerSolidityState));
    this.debuggerSolidityState.event.register('solidityState', state => {
      this.event.trigger('solidityState', [state]);
    });
    this.debuggerSolidityState.event.register('solidityStateMessage', message => {
      this.event.trigger('solidityStateMessage', [message]);
    });
    this.debuggerSolidityState.event.register('solidityStateUpdating', () => {
      this.event.trigger('solidityStateUpdating', []);
    });
    this.event.register('traceUnloaded', this.debuggerSolidityState.reset.bind(this.debuggerSolidityState));
    this.event.register('newTraceLoaded', this.debuggerSolidityState.reset.bind(this.debuggerSolidityState));
  }

  listenToSolidityLocalsEvents() {
    this.event.register('sourceLocationChanged', this.debuggerSolidityLocals.init.bind(this.debuggerSolidityLocals));
    this.event.register('solidityLocalsLoadMore', this.debuggerSolidityLocals.decodeMore.bind(this.debuggerSolidityLocals));
    this.debuggerSolidityLocals.event.register('solidityLocalsLoadMoreCompleted', locals => {
      this.event.trigger('solidityLocalsLoadMoreCompleted', [locals]);
    });
    this.debuggerSolidityLocals.event.register('solidityLocals', state => {
      this.event.trigger('solidityLocals', [state]);
    });
    this.debuggerSolidityLocals.event.register('solidityLocalsMessage', message => {
      this.event.trigger('solidityLocalsMessage', [message]);
    });
    this.debuggerSolidityLocals.event.register('solidityLocalsUpdating', () => {
      this.event.trigger('solidityLocalsUpdating', []);
    });
    this.debuggerSolidityLocals.event.register('traceReturnValueUpdate', (data, header) => {
      this.event.trigger('traceReturnValueUpdate', [data, header]);
    });
  }

}

exports.VmDebuggerLogic = VmDebuggerLogic;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/debugger/debugger.js":
/*!***********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/debugger/debugger.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const Ethdebugger_1 = __webpack_require__(/*! ../Ethdebugger */ "../../../dist/libs/remix-debug/src/Ethdebugger.js");

const eventManager_1 = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-debug/src/eventManager.js");

const traceHelper_1 = __webpack_require__(/*! ../trace/traceHelper */ "../../../dist/libs/remix-debug/src/trace/traceHelper.js");

const breakpointManager_1 = __webpack_require__(/*! ../code/breakpointManager */ "../../../dist/libs/remix-debug/src/code/breakpointManager.js");

const stepManager_1 = __webpack_require__(/*! ./stepManager */ "../../../dist/libs/remix-debug/src/debugger/stepManager.js");

const VmDebugger_1 = __webpack_require__(/*! ./VmDebugger */ "../../../dist/libs/remix-debug/src/debugger/VmDebugger.js");

class Debugger {
  constructor(options) {
    this.event = new eventManager_1.EventManager();
    this.offsetToLineColumnConverter = options.offsetToLineColumnConverter;
    /*
      Returns a compilation result for a given address or the last one available if none are found
    */

    this.compilationResult = options.compilationResult || function (contractAddress) {
      return null;
    };

    this.debugger = new Ethdebugger_1.Ethdebugger({
      web3: options.web3,
      debugWithGeneratedSources: options.debugWithGeneratedSources,
      compilationResult: this.compilationResult
    });
    const {
      traceManager,
      callTree,
      solidityProxy
    } = this.debugger;
    this.breakPointManager = new breakpointManager_1.BreakpointManager({
      traceManager,
      callTree,
      solidityProxy,
      locationToRowConverter: sourceLocation => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const compilationResult = yield this.compilationResult();
        if (!compilationResult) return {
          start: null,
          end: null
        };
        return yield this.offsetToLineColumnConverter.offsetToLineColumn(sourceLocation, sourceLocation.file, compilationResult.source.sources, compilationResult.data.sources);
      })
    });
    this.breakPointManager.event.register('managersChanged', () => {
      const {
        traceManager,
        callTree,
        solidityProxy
      } = this.debugger;
      this.breakPointManager.setManagers({
        traceManager,
        callTree,
        solidityProxy
      });
    });
    this.breakPointManager.event.register('breakpointStep', step => {
      this.step_manager.jumpTo(step);
    });
    this.debugger.setBreakpointManager(this.breakPointManager);
    this.debugger.event.register('newTraceLoaded', this, () => {
      this.event.trigger('debuggerStatus', [true]);
    });
    this.debugger.event.register('traceUnloaded', this, () => {
      this.event.trigger('debuggerStatus', [false]);
    });
  }

  registerAndHighlightCodeItem(index) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      // register selected code item, highlight the corresponding source location
      // this.debugger.traceManager.getCurrentCalledAddressAt(index, async (error, address) => {
      try {
        const address = this.debugger.traceManager.getCurrentCalledAddressAt(index);
        const compilationResultForAddress = yield this.compilationResult(address);
        if (!compilationResultForAddress) return;
        this.debugger.callTree.sourceLocationTracker.getValidSourceLocationFromVMTraceIndex(address, index, compilationResultForAddress.data.contracts).then(rawLocation => tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (compilationResultForAddress && compilationResultForAddress.data) {
            const generatedSources = this.debugger.callTree.sourceLocationTracker.getGeneratedSourcesFromAddress(address);
            const astSources = Object.assign({}, compilationResultForAddress.data.sources);
            const sources = Object.assign({}, compilationResultForAddress.source.sources);

            if (generatedSources) {
              for (const genSource of generatedSources) {
                astSources[genSource.name] = {
                  id: genSource.id,
                  ast: genSource.ast
                };
                sources[genSource.name] = {
                  content: genSource.contents
                };
              }
            }

            var lineColumnPos = yield this.offsetToLineColumnConverter.offsetToLineColumn(rawLocation, rawLocation.file, sources, astSources);
            this.event.trigger('newSourceLocation', [lineColumnPos, rawLocation, generatedSources, address]);
          } else {
            this.event.trigger('newSourceLocation', [null]);
          }
        })).catch(_error => {
          this.event.trigger('newSourceLocation', [null]);
        }); // })
      } catch (error) {
        return console.log(error);
      }
    });
  }

  updateWeb3(web3) {
    this.debugger.web3 = web3;
  }

  debug(blockNumber, txNumber, tx, loadingCb) {
    const web3 = this.debugger.web3;
    return new Promise((resolve, reject) => {
      if (this.debugger.traceManager.isLoading) {
        return resolve();
      }

      if (tx) {
        if (!tx.to) {
          tx.to = traceHelper_1.contractCreationToken('0');
        }

        this.debugTx(tx, loadingCb);
        return resolve();
      }

      try {
        if (txNumber.indexOf('0x') !== -1) {
          return web3.eth.getTransaction(txNumber, (_error, tx) => {
            if (_error) return reject(_error);
            if (!tx) return reject(new Error('cannot find transaction ' + txNumber));
            this.debugTx(tx, loadingCb);
            return resolve();
          });
        }

        web3.eth.getTransactionFromBlock(blockNumber, txNumber, (_error, tx) => {
          if (_error) return reject(_error);
          if (!tx) return reject(new Error('cannot find transaction ' + blockNumber + ' ' + txNumber));
          this.debugTx(tx, loadingCb);
          return resolve();
        });
      } catch (e) {
        return reject(e.message);
      }
    });
  }

  debugTx(tx, loadingCb) {
    this.step_manager = new stepManager_1.DebuggerStepManager(this.debugger, this.debugger.traceManager);
    this.debugger.codeManager.event.register('changed', this, (code, address, instIndex) => {
      this.debugger.callTree.sourceLocationTracker.getValidSourceLocationFromVMTraceIndex(address, this.step_manager.currentStepIndex, this.debugger.solidityProxy.contracts).then(sourceLocation => {
        this.vmDebuggerLogic.event.trigger('sourceLocationChanged', [sourceLocation]);
      });
    });
    this.vmDebuggerLogic = new VmDebugger_1.VmDebuggerLogic(this.debugger, tx, this.step_manager, this.debugger.traceManager, this.debugger.codeManager, this.debugger.solidityProxy, this.debugger.callTree);
    this.vmDebuggerLogic.start();
    this.step_manager.event.register('stepChanged', this, stepIndex => {
      if (typeof stepIndex !== 'number' || stepIndex >= this.step_manager.traceLength) {
        return this.event.trigger('endDebug');
      }

      this.debugger.codeManager.resolveStep(stepIndex, tx);
      this.step_manager.event.trigger('indexChanged', [stepIndex]);
      this.vmDebuggerLogic.event.trigger('indexChanged', [stepIndex]);
      this.vmDebuggerLogic.debugger.event.trigger('indexChanged', [stepIndex]);
      this.registerAndHighlightCodeItem(stepIndex);
    });
    loadingCb();
    this.debugger.debug(tx);
  }

  unload() {
    this.debugger.unLoad();
    this.event.trigger('debuggerUnloaded');
  }

}

exports.Debugger = Debugger;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/debugger/solidityLocals.js":
/*!*****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/debugger/solidityLocals.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const eventManager_1 = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-debug/src/eventManager.js");

const localDecoder_1 = __webpack_require__(/*! ../solidity-decoder/localDecoder */ "../../../dist/libs/remix-debug/src/solidity-decoder/localDecoder.js");

const storageViewer_1 = __webpack_require__(/*! ../storage/storageViewer */ "../../../dist/libs/remix-debug/src/storage/storageViewer.js");

class DebuggerSolidityLocals {
  constructor(tx, _stepManager, _traceManager, _internalTreeCall) {
    this.event = new eventManager_1.EventManager();
    this.stepManager = _stepManager;
    this.internalTreeCall = _internalTreeCall;
    this.storageResolver = null;
    this.traceManager = _traceManager;
    this.tx = tx;
  }

  init(sourceLocation) {
    this._sourceLocation = sourceLocation;
    var decodeTimeout = null;

    if (!this.storageResolver) {
      return this.event.trigger('solidityLocalsMessage', ['storage not ready']);
    }

    if (decodeTimeout) {
      window.clearTimeout(decodeTimeout);
    }

    this.event.trigger('solidityLocalsUpdating');
    decodeTimeout = setTimeout(() => {
      this.decode(sourceLocation);
    }, 500);
  }

  decode(sourceLocation, cursor) {
    const self = this;
    this.event.trigger('solidityLocalsMessage', ['']);
    this.traceManager.waterfall([function getStackAt(stepIndex, callback) {
      try {
        const result = self.traceManager.getStackAt(stepIndex);
        callback(null, result);
      } catch (error) {
        callback(error);
      }
    }, function getMemoryAt(stepIndex, callback) {
      try {
        const result = self.traceManager.getMemoryAt(stepIndex);
        callback(null, result);
      } catch (error) {
        callback(error);
      }
    }, function getCurrentCalledAddressAt(stepIndex, next) {
      try {
        const address = self.traceManager.getCurrentCalledAddressAt(stepIndex);
        next(null, address);
      } catch (error) {
        next(error);
      }
    }], this.stepManager.currentStepIndex, (error, result) => {
      if (error) {
        return error;
      }

      var stack = result[0].value;
      var memory = result[1].value;

      try {
        var storageViewer = new storageViewer_1.StorageViewer({
          stepIndex: this.stepManager.currentStepIndex,
          tx: this.tx,
          address: result[2].value
        }, this.storageResolver, this.traceManager);
        localDecoder_1.solidityLocals(this.stepManager.currentStepIndex, this.internalTreeCall, stack, memory, storageViewer, sourceLocation, cursor).then(locals => {
          if (!cursor) {
            if (!locals['error']) {
              this.event.trigger('solidityLocals', [locals]);
            }

            if (!Object.keys(locals).length) {
              this.event.trigger('solidityLocalsMessage', ['no locals']);
            }
          } else {
            if (!locals['error']) {
              this.event.trigger('solidityLocalsLoadMoreCompleted', [locals]);
            }
          }
        });
      } catch (e) {
        this.event.trigger('solidityLocalsMessage', [e.message]);
      }
    });
  }

  decodeMore(cursor) {
    let decodeTimeout = null;
    if (!this.storageResolver) return this.event.trigger('solidityLocalsMessage', ['storage not ready']);
    if (decodeTimeout) window.clearTimeout(decodeTimeout);
    decodeTimeout = setTimeout(() => {
      this.decode(this._sourceLocation, cursor);
    }, 500);
  }

}

exports.DebuggerSolidityLocals = DebuggerSolidityLocals;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/debugger/solidityState.js":
/*!****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/debugger/solidityState.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const eventManager_1 = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-debug/src/eventManager.js");

const stateDecoder_1 = __webpack_require__(/*! ../solidity-decoder/stateDecoder */ "../../../dist/libs/remix-debug/src/solidity-decoder/stateDecoder.js");

const storageViewer_1 = __webpack_require__(/*! ../storage/storageViewer */ "../../../dist/libs/remix-debug/src/storage/storageViewer.js");

class DebuggerSolidityState {
  constructor(tx, _stepManager, _traceManager, _codeManager, _solidityProxy) {
    this.event = new eventManager_1.EventManager();
    this.storageResolver = null;
    this.stepManager = _stepManager;
    this.traceManager = _traceManager;
    this.codeManager = _codeManager;
    this.solidityProxy = _solidityProxy;
    this.stateVariablesByAddresses = {};
    this.tx = tx;
  }

  init(index) {
    let decodeTimeout = null;

    if (index < 0) {
      return this.event.trigger('solidityStateMessage', ['invalid step index']);
    }

    if (this.stepManager.currentStepIndex !== index) return;

    if (!this.solidityProxy.loaded()) {
      return this.event.trigger('solidityStateMessage', ['invalid step index']);
    }

    if (!this.storageResolver) {
      return;
    }

    if (decodeTimeout) {
      window.clearTimeout(decodeTimeout);
    }

    this.event.trigger('solidityStateUpdating');
    decodeTimeout = setTimeout(() => {
      // necessary due to some states that can crash the debugger
      try {
        this.decode(index);
      } catch (err) {
        console.dir('====> error');
        console.dir(err);
      }
    }, 500);
  }

  reset() {
    this.stateVariablesByAddresses = {};
  }

  decode(index) {
    try {
      const address = this.traceManager.getCurrentCalledAddressAt(this.stepManager.currentStepIndex);

      if (this.stateVariablesByAddresses[address]) {
        return this.extractStateVariables(this.stateVariablesByAddresses[address], address);
      }

      this.solidityProxy.extractStateVariablesAt(index).then(stateVars => {
        this.stateVariablesByAddresses[address] = stateVars;
        this.extractStateVariables(stateVars, address);
      }).catch(_error => {
        this.event.trigger('solidityState', [{}]);
      });
    } catch (error) {
      return this.event.trigger('solidityState', [{}]);
    }
  }

  extractStateVariables(stateVars, address) {
    const storageViewer = new storageViewer_1.StorageViewer({
      stepIndex: this.stepManager.currentStepIndex,
      tx: this.tx,
      address: address
    }, this.storageResolver, this.traceManager);
    stateDecoder_1.decodeState(stateVars, storageViewer).then(result => {
      this.event.trigger('solidityStateMessage', ['']);

      if (result['error']) {
        return this.event.trigger('solidityStateMessage', [result['error']]);
      }

      this.event.trigger('solidityState', [result]);
    });
  }

}

exports.DebuggerSolidityState = DebuggerSolidityState;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/debugger/stepManager.js":
/*!**************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/debugger/stepManager.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

const eventManager_1 = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-debug/src/eventManager.js");

class DebuggerStepManager {
  constructor(_debugger, traceManager) {
    this.event = new eventManager_1.EventManager();
    this.debugger = _debugger;
    this.traceManager = traceManager;
    this.currentStepIndex = 0;
    this.traceLength = 0;
    this.codeTraceLength = 0;
    this.revertionPoint = null;
    this.listenToEvents();
  }

  listenToEvents() {
    this.debugger.event.register('newTraceLoaded', this, () => {
      this.traceManager.getLength((error, newLength) => {
        if (error) {
          return console.log(error);
        }

        if (this.traceLength !== newLength) {
          this.event.trigger('traceLengthChanged', [newLength]);
          this.traceLength = newLength;
          this.codeTraceLength = this.calculateCodeLength();
        }

        this.jumpTo(0);
      });
    });
    this.debugger.callTree.event.register('callTreeReady', () => {
      if (this.debugger.callTree.functionCallStack.length) {
        this.jumpTo(this.debugger.callTree.functionCallStack[0]);
      }
    });
    this.event.register('indexChanged', this, index => {
      if (index < 0) return;
      if (this.currentStepIndex !== index) return;
      this.traceManager.buildCallPath(index).then(callsPath => {
        this.currentCall = callsPath[callsPath.length - 1];

        if (this.currentCall.reverted) {
          const revertedReason = this.currentCall.outofgas ? 'outofgas' : '';
          this.revertionPoint = this.currentCall.return;
          return this.event.trigger('revertWarning', [revertedReason]);
        }

        for (var k = callsPath.length - 2; k >= 0; k--) {
          var parent = callsPath[k];
          if (!parent.reverted) continue;
          this.revertionPoint = parent.return;
          this.event.trigger('revertWarning', ['parenthasthrown']);
        }

        this.event.trigger('revertWarning', ['']);
      }).catch(error => {
        console.log(error);
        this.event.trigger('revertWarning', ['']);
      });
    });
  }

  triggerStepChanged(step) {
    this.traceManager.getLength((error, length) => {
      let stepState = 'valid';

      if (error) {
        stepState = 'invalid';
      } else if (step <= 0) {
        stepState = 'initial';
      } else if (step >= length - 1) {
        stepState = 'end';
      }

      const jumpOutDisabled = step === this.traceManager.findStepOut(step);
      this.event.trigger('stepChanged', [step, stepState, jumpOutDisabled]);
    });
  }

  stepIntoBack(solidityMode) {
    if (!this.traceManager.isLoaded()) return;
    let step = this.currentStepIndex - 1;
    this.currentStepIndex = step;

    if (solidityMode) {
      step = this.resolveToReducedTrace(step, -1);
    }

    if (!this.traceManager.inRange(step)) {
      return;
    }

    this.event.trigger('stepChanged', [step]);
  }

  stepIntoForward(solidityMode) {
    if (!this.traceManager.isLoaded()) return;
    let step = this.currentStepIndex + 1;
    this.currentStepIndex = step;

    if (solidityMode) {
      step = this.resolveToReducedTrace(step, 1);
    }

    if (!this.traceManager.inRange(step)) {
      return;
    }

    this.event.trigger('stepChanged', [step]);
  }

  stepOverBack(solidityMode) {
    if (!this.traceManager.isLoaded()) return;
    let step = this.traceManager.findStepOverBack(this.currentStepIndex);

    if (solidityMode) {
      step = this.resolveToReducedTrace(step, -1);
    }

    this.currentStepIndex = step;
    this.event.trigger('stepChanged', [step]);
  }

  stepOverForward(solidityMode) {
    if (!this.traceManager.isLoaded()) return;
    if (this.currentStepIndex >= this.traceLength - 1) return;
    let step = this.currentStepIndex + 1;
    const scope = this.debugger.callTree.findScope(step);

    if (scope && scope.firstStep === step) {
      step = scope.lastStep + 1;
    }

    if (solidityMode) {
      step = this.resolveToReducedTrace(step, 1);
    }

    this.currentStepIndex = step;
    this.event.trigger('stepChanged', [step]);
  }

  jumpOut(solidityMode) {
    if (!this.traceManager.isLoaded()) return;
    var step = this.traceManager.findStepOut(this.currentStepIndex);

    if (solidityMode) {
      step = this.resolveToReducedTrace(step, 0);
    }

    this.currentStepIndex = step;
    this.event.trigger('stepChanged', [step]);
  }

  jumpTo(step) {
    if (!this.traceManager.inRange(step)) return;
    this.currentStepIndex = step;
    this.event.trigger('stepChanged', [step]);
  }

  jumpToException() {
    this.jumpTo(this.revertionPoint);
  }

  jumpNextBreakpoint() {
    this.debugger.breakpointManager.jumpNextBreakpoint(this.currentStepIndex, true);
  }

  jumpPreviousBreakpoint() {
    this.debugger.breakpointManager.jumpPreviousBreakpoint(this.currentStepIndex, true);
  }

  calculateFirstStep() {
    const step = this.resolveToReducedTrace(0, 1);
    return this.resolveToReducedTrace(step, 1);
  }

  calculateCodeStepList() {
    let step = 0;
    let steps = [];

    while (step < this.traceLength) {
      const _step = this.resolveToReducedTrace(step, 1);

      if (!_step) break;
      steps.push(_step);
      step += 1;
    }

    steps = steps.filter((item, pos, self) => {
      return steps.indexOf(item) === pos;
    });
    return steps;
  }

  calculateCodeLength() {
    this.calculateCodeStepList().reverse();
    return this.calculateCodeStepList().reverse()[1] || this.traceLength;
  }

  nextStep() {
    return this.resolveToReducedTrace(this.currentStepIndex, 1);
  }

  previousStep() {
    return this.resolveToReducedTrace(this.currentStepIndex, -1);
  }

  resolveToReducedTrace(value, incr) {
    if (!this.debugger.callTree.reducedTrace.length) {
      return value;
    }

    var nextSource = remix_lib_1.util.findClosestIndex(value, this.debugger.callTree.reducedTrace);
    nextSource = nextSource + incr;

    if (nextSource <= 0) {
      nextSource = 0;
    } else if (nextSource > this.debugger.callTree.reducedTrace.length) {
      nextSource = this.debugger.callTree.reducedTrace.length - 1;
    }

    return this.debugger.callTree.reducedTrace[nextSource];
  }

}

exports.DebuggerStepManager = DebuggerStepManager;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/eventManager.js":
/*!******************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/eventManager.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class EventManager {
  constructor() {
    this.registered = {};
    this.anonymous = {};
  }
  /*
    * Unregister a listener.
    * Note that if obj is a function. the unregistration will be applied to the dummy obj {}.
    *
    * @param {String} eventName  - the event name
    * @param {Object or Func} obj - object that will listen on this event
    * @param {Func} func         - function of the listeners that will be executed
  */


  unregister(eventName, obj, func) {
    if (!this.registered[eventName]) {
      return;
    }

    if (obj instanceof Function) {
      func = obj;
      obj = this.anonymous;
    }

    for (const reg in this.registered[eventName]) {
      if (this.registered[eventName][reg].obj === obj && this.registered[eventName][reg].func === func) {
        this.registered[eventName].splice(reg, 1);
      }
    }
  }
  /*
    * Register a new listener.
    * Note that if obj is a function, the function registration will be associated with the dummy object {}
    *
    * @param {String} eventName  - the event name
    * @param {Object or Func} obj - object that will listen on this event
    * @param {Func} func         - function of the listeners that will be executed
  */


  register(eventName, obj, func) {
    if (!this.registered[eventName]) {
      this.registered[eventName] = [];
    }

    if (obj instanceof Function) {
      func = obj;
      obj = this.anonymous;
    }

    this.registered[eventName].push({
      obj: obj,
      func: func
    });
  }
  /*
    * trigger event.
    * Every listener have their associated function executed
    *
    * @param {String} eventName  - the event name
    * @param {Array}j - argument that will be passed to the executed function.
  */


  trigger(eventName, args) {
    if (!this.registered[eventName]) {
      return;
    }

    for (const listener in this.registered[eventName]) {
      const l = this.registered[eventName][listener];
      l.func.apply(l.obj === this.anonymous ? {} : l.obj, args);
    }
  }

}

exports.EventManager = EventManager;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/index.js":
/*!***********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const init = tslib_1.__importStar(__webpack_require__(/*! ./init */ "../../../dist/libs/remix-debug/src/init.js"));

const Ethdebugger_1 = __webpack_require__(/*! ./Ethdebugger */ "../../../dist/libs/remix-debug/src/Ethdebugger.js");

const debugger_1 = __webpack_require__(/*! ./debugger/debugger */ "../../../dist/libs/remix-debug/src/debugger/debugger.js");

const cmdline_1 = __webpack_require__(/*! ./cmdline */ "../../../dist/libs/remix-debug/src/cmdline/index.js");

const storageViewer_1 = __webpack_require__(/*! ./storage/storageViewer */ "../../../dist/libs/remix-debug/src/storage/storageViewer.js");

const storageResolver_1 = __webpack_require__(/*! ./storage/storageResolver */ "../../../dist/libs/remix-debug/src/storage/storageResolver.js");

const SolidityDecoder = tslib_1.__importStar(__webpack_require__(/*! ./solidity-decoder */ "../../../dist/libs/remix-debug/src/solidity-decoder/index.js"));

const breakpointManager_1 = __webpack_require__(/*! ./code/breakpointManager */ "../../../dist/libs/remix-debug/src/code/breakpointManager.js");

const sourceMappingDecoder = tslib_1.__importStar(__webpack_require__(/*! ./source/sourceMappingDecoder */ "../../../dist/libs/remix-debug/src/source/sourceMappingDecoder.js"));

const traceHelper = tslib_1.__importStar(__webpack_require__(/*! ./trace/traceHelper */ "../../../dist/libs/remix-debug/src/trace/traceHelper.js"));

module.exports = {
  init,
  traceHelper,
  sourceMappingDecoder,
  EthDebugger: Ethdebugger_1.Ethdebugger,
  TransactionDebugger: debugger_1.Debugger,

  /**
   * constructor
   *
   * @param {Object} _debugger - type of EthDebugger
   * @return {Function} _locationToRowConverter - function implemented by editor which return a column/line position for a char source location
   */
  BreakpointManager: breakpointManager_1.BreakpointManager,
  SolidityDecoder,
  storage: {
    StorageViewer: storageViewer_1.StorageViewer,
    StorageResolver: storageResolver_1.StorageResolver
  },
  CmdLine: cmdline_1.CmdLine
};

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/init.js":
/*!**********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/init.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const web3_1 = tslib_1.__importDefault(__webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js"));

function loadWeb3(url) {
  if (!url) url = 'http://localhost:8545';
  const web3 = new web3_1.default();
  web3.setProvider(new web3_1.default.providers.HttpProvider(url));
  extend(web3);
  return web3;
}

exports.loadWeb3 = loadWeb3;

function extendWeb3(web3) {
  extend(web3);
}

exports.extendWeb3 = extendWeb3;

function setProvider(web3, url) {
  web3.setProvider(new web3.providers.HttpProvider(url));
}

exports.setProvider = setProvider;

function web3DebugNode(network) {
  const web3DebugNodes = {
    Main: 'https://rpc.archivenode.io/e50zmkroshle2e2e50zm0044i7ao04ym',
    Rinkeby: 'https://remix-rinkeby.ethdevops.io',
    Ropsten: 'https://remix-ropsten.ethdevops.io',
    Goerli: 'https://remix-goerli.ethdevops.io',
    Kovan: 'https://remix-kovan.ethdevops.io'
  };

  if (web3DebugNodes[network]) {
    return loadWeb3(web3DebugNodes[network]);
  }

  return null;
}

exports.web3DebugNode = web3DebugNode;

function extend(web3) {
  if (!web3.extend) {
    return;
  } // DEBUG


  const methods = [];

  if (!(web3.debug && web3.debug.preimage)) {
    methods.push(new web3.extend.Method({
      name: 'preimage',
      call: 'debug_preimage',
      inputFormatter: [null],
      params: 1
    }));
  }

  if (!(web3.debug && web3.debug.traceTransaction)) {
    methods.push(new web3.extend.Method({
      name: 'traceTransaction',
      call: 'debug_traceTransaction',
      inputFormatter: [null, null],
      params: 2
    }));
  }

  if (!(web3.debug && web3.debug.storageRangeAt)) {
    methods.push(new web3.extend.Method({
      name: 'storageRangeAt',
      call: 'debug_storageRangeAt',
      inputFormatter: [null, null, null, null, null],
      params: 5
    }));
  }

  if (methods.length > 0) {
    web3.extend({
      property: 'debug',
      methods: methods,
      properties: []
    });
  }
}

exports.extend = extend;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/astHelper.js":
/*!********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/astHelper.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const remix_astwalker_1 = __webpack_require__(/*! @remix-project/remix-astwalker */ "../../../dist/libs/remix-astwalker/index.js");
/**
  * return all contract definitions of the given @astList
  *
  * @param {Object} sourcesList - sources list (containing root AST node)
  * @return {Object} - returns a mapping from AST node ids to AST nodes for the contracts
  */


function extractContractDefinitions(sourcesList) {
  const ret = {
    contractsById: {},
    contractsByName: {},
    sourcesByContract: {}
  };
  const walker = new remix_astwalker_1.AstWalker();

  for (const k in sourcesList) {
    walker.walkFull(sourcesList[k].ast, node => {
      if (node.nodeType === 'ContractDefinition') {
        ret.contractsById[node.id] = node;
        ret.sourcesByContract[node.id] = k;
        ret.contractsByName[k + ':' + node.name] = node;
      }
    });
  }

  return ret;
}

exports.extractContractDefinitions = extractContractDefinitions;
/**
  * returns the linearized base contracts of the contract @arg id
  *
  * @param {Int} id - contract id to resolve
  * @param {Map} contracts  - all contracts defined in the current context
  * @return {Array} - array of base contracts in derived to base order as AST nodes.
  */

function getLinearizedBaseContracts(id, contractsById) {
  return contractsById[id].linearizedBaseContracts.map(function (id) {
    return contractsById[id];
  });
}

exports.getLinearizedBaseContracts = getLinearizedBaseContracts;
/**
  * return state var and type definition of the given contract
  *
  * @param {String} contractName - contract for which state var should be resolved
  * @param {Object} sourcesList - sources list (containing root AST node)
  * @param {Object} [contracts] - map of contract definitions (contains contractsById, contractsByName)
  * @return {Object} - return an object containing: stateItems - list of all the children node of the @arg contractName
  *                                                 stateVariables - list of all the variable declaration of the @arg contractName
  */

function extractStateDefinitions(contractName, sourcesList, contracts) {
  if (!contracts) {
    contracts = extractContractDefinitions(sourcesList);
  }

  const node = contracts.contractsByName[contractName];

  if (!node) {
    return null;
  }

  const stateItems = [];
  const stateVar = [];
  const baseContracts = getLinearizedBaseContracts(node.id, contracts.contractsById);
  baseContracts.reverse();

  for (const k in baseContracts) {
    const ctr = baseContracts[k];

    for (const i in ctr.nodes) {
      const item = ctr.nodes[i];
      stateItems.push(item);

      if (item.nodeType === 'VariableDeclaration') {
        stateVar.push(item);
      }
    }
  }

  return {
    stateDefinitions: stateItems,
    stateVariables: stateVar
  };
}

exports.extractStateDefinitions = extractStateDefinitions;
/**
  * return state var and type definition of all the contracts from the given @args sourcesList
  *
  * @param {Object} sourcesList - sources list (containing root AST node)
  * @param {Object} [contracts] - map of contract definitions (contains contractsById, contractsByName)
  * @return {Object} - returns a mapping between contract name and contract state
  */

function extractStatesDefinitions(sourcesList, contracts) {
  if (!contracts) {
    contracts = extractContractDefinitions(sourcesList);
  }

  const ret = {};

  for (const contract in contracts.contractsById) {
    const name = contracts.contractsById[contract].name;
    const source = contracts.sourcesByContract[contract];
    const fullName = source + ':' + name;
    const state = extractStateDefinitions(fullName, sourcesList, contracts);
    ret[fullName] = state;
    ret[name] = state; // solc < 0.4.9
  }

  return ret;
}

exports.extractStatesDefinitions = extractStatesDefinitions;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/decodeInfo.js":
/*!*********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/decodeInfo.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const Address_1 = __webpack_require__(/*! ./types/Address */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Address.js");

const ArrayType_1 = __webpack_require__(/*! ./types/ArrayType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ArrayType.js");

const Bool_1 = __webpack_require__(/*! ./types/Bool */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Bool.js");

const DynamicByteArray_1 = __webpack_require__(/*! ./types/DynamicByteArray */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/DynamicByteArray.js");

const FixedByteArray_1 = __webpack_require__(/*! ./types/FixedByteArray */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/FixedByteArray.js");

const Enum_1 = __webpack_require__(/*! ./types/Enum */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Enum.js");

const StringType_1 = __webpack_require__(/*! ./types/StringType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/StringType.js");

const Struct_1 = __webpack_require__(/*! ./types/Struct */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Struct.js");

const Int_1 = __webpack_require__(/*! ./types/Int */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Int.js");

const Uint_1 = __webpack_require__(/*! ./types/Uint */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Uint.js");

const Mapping_1 = __webpack_require__(/*! ./types/Mapping */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Mapping.js");

const util_1 = __webpack_require__(/*! ./types/util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");
/**
  * mapping decode the given @arg type
  *
  * @param {String} type - type given by the AST
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */


function mapping(type, stateDefinitions, contractName) {
  const match = type.match(/mapping\((.*?)=>(.*)\)$/);
  const keyTypeName = match[1].trim();
  const valueTypeName = match[2].trim();
  const keyType = parseType(keyTypeName, stateDefinitions, contractName, 'storage');
  const valueType = parseType(valueTypeName, stateDefinitions, contractName, 'storage');
  var underlyingTypes = {
    keyType: keyType,
    valueType: valueType
  };
  return new Mapping_1.Mapping(underlyingTypes, 'location', util_1.removeLocation(type));
}
/**
  * Uint decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g uint256, uint32)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */


function uint(type) {
  type = type === 'uint' ? 'uint256' : type;
  const storageBytes = parseInt(type.replace('uint', '')) / 8;
  return new Uint_1.Uint(storageBytes);
}

exports.Uint = uint;
/**
  * Int decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g int256, int32)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */

function int(type) {
  type = type === 'int' ? 'int256' : type;
  const storageBytes = parseInt(type.replace('int', '')) / 8;
  return new Int_1.Int(storageBytes);
}

exports.Int = int;
/**
  * Address decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g address)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */

function address(type) {
  return new Address_1.Address();
}

exports.Address = address;
/**
  * Bool decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g bool)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */

function bool(type) {
  return new Bool_1.Bool();
}

exports.Bool = bool;
/**
  * DynamicByteArray decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g bytes storage ref)
  * @param {null} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {null} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */

function dynamicByteArray(type, stateDefinitions, contractName, location) {
  if (!location) {
    location = util_1.extractLocation(type);
  }

  if (location) {
    return new DynamicByteArray_1.DynamicByteArray(location);
  } else {
    return null;
  }
}

exports.DynamicByteArray = dynamicByteArray;
/**
  * FixedByteArray decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g bytes16)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */

function fixedByteArray(type) {
  const storageBytes = parseInt(type.replace('bytes', ''));
  return new FixedByteArray_1.FixedByteArray(storageBytes);
}

exports.FixedByteArray = fixedByteArray;
/**
  * StringType decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g string storage ref)
  * @param {null} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {null} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */

function stringType(type, stateDefinitions, contractName, location) {
  if (!location) {
    location = util_1.extractLocation(type);
  }

  if (location) {
    return new StringType_1.StringType(location);
  } else {
    return null;
  }
}

exports.String = stringType;
/**
  * ArrayType decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g int256[] storage ref, int256[] storage ref[] storage ref)
  * @param {Object} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName, arraySize, subArray}
  */

function array(type, stateDefinitions, contractName, location) {
  const match = type.match(/(.*)\[(.*?)\]( storage ref| storage pointer| memory| calldata)?$/);

  if (!match) {
    console.log('unable to parse type ' + type);
    return null;
  }

  if (!location) {
    location = match[3].trim();
  }

  const arraySize = match[2] === '' ? 'dynamic' : parseInt(match[2]);
  const underlyingType = parseType(match[1], stateDefinitions, contractName, location);

  if (underlyingType === null) {
    console.log('unable to parse type ' + type);
    return null;
  }

  return new ArrayType_1.ArrayType(underlyingType, arraySize, location);
}

exports.Array = array;
/**
  * Enum decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g enum enumDef)
  * @param {Object} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName, enum}
  */

function enumType(type, stateDefinitions, contractName) {
  const match = type.match(/enum (.*)/);
  const enumDef = getEnum(match[1], stateDefinitions, contractName);

  if (enumDef === null) {
    console.log('unable to retrieve decode info of ' + type);
    return null;
  }

  return new Enum_1.Enum(enumDef);
}

exports.Enum = enumType;
/**
  * Struct decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g struct structDef storage ref)
  * @param {Object} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName, members}
  */

function struct(type, stateDefinitions, contractName, location) {
  const match = type.match(/struct (\S*?)( storage ref| storage pointer| memory| calldata)?$/);

  if (match) {
    if (!location) {
      location = match[2].trim();
    }

    const memberDetails = getStructMembers(match[1], stateDefinitions, contractName, location); // type is used to extract the ast struct definition

    if (!memberDetails) return null;
    return new Struct_1.Struct(memberDetails, location, match[1]);
  } else {
    return null;
  }
}

exports.Struct = struct;
/**
  * retrieve enum declaration of the given @arg type
  *
  * @param {String} type - type given by the AST (e.g enum enumDef)
  * @param {Object} stateDefinitions  - all state declarations given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @return {Array} - containing all value declaration of the current enum type
  */

function getEnum(type, stateDefinitions, contractName) {
  const split = type.split('.');

  if (!split.length) {
    type = contractName + '.' + type;
  } else {
    contractName = split[0];
  }

  const state = stateDefinitions[contractName];

  if (state) {
    for (const dec of state.stateDefinitions) {
      if (dec && dec.name && type === contractName + '.' + dec.name) {
        return dec;
      }
    }
  }

  return null;
}
/**
  * retrieve memebers declared in the given @arg tye
  *
  * @param {String} typeName - name of the struct type (e.g struct <name>)
  * @param {Object} stateDefinitions  - all state definition given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Array} containing all members of the current struct type
  */


function getStructMembers(type, stateDefinitions, contractName, location) {
  const split = type.split('.');

  if (!split.length) {
    type = contractName + '.' + type;
  } else {
    contractName = split[0];
  }

  const state = stateDefinitions[contractName];

  if (state) {
    for (const dec of state.stateDefinitions) {
      if (dec.nodeType === 'StructDefinition' && type === contractName + '.' + dec.name) {
        const offsets = computeOffsets(dec.members, stateDefinitions, contractName, location);

        if (!offsets) {
          return null;
        }

        return {
          members: offsets.typesOffsets,
          storageSlots: offsets.endLocation.slot
        };
      }
    }
  }

  return null;
}
/**
  * parse the full type
  *
  * @param {String} fullType - type given by the AST (ex: uint[2] storage ref[2])
  * @return {String} returns the token type (used to instanciate the right decoder) (uint[2] storage ref[2] will return 'array', uint256 will return uintX)
  */


function typeClass(fullType) {
  fullType = util_1.removeLocation(fullType);

  if (fullType.lastIndexOf(']') === fullType.length - 1) {
    return 'array';
  }

  if (fullType.indexOf('mapping') === 0) {
    return 'mapping';
  }

  if (fullType.indexOf(' ') !== -1) {
    fullType = fullType.split(' ')[0];
  }

  const char = fullType.indexOf('bytes') === 0 ? 'X' : '';
  return fullType.replace(/[0-9]+/g, char);
}
/**
  * parse the type and return an object representing the type
  *
  * @param {Object} type - type name given by the ast node
  * @param {Object} stateDefinitions - all state stateDefinitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Object} - return the corresponding decoder or null on error
  */


function parseType(type, stateDefinitions, contractName, location) {
  const decodeInfos = {
    contract: address,
    address: address,
    array: array,
    bool: bool,
    bytes: dynamicByteArray,
    bytesX: fixedByteArray,
    enum: enumType,
    string: stringType,
    struct: struct,
    int: int,
    uint: uint,
    mapping: mapping
  };
  const currentType = typeClass(type);

  if (currentType === null) {
    console.log('unable to retrieve decode info of ' + type);
    return null;
  }

  if (decodeInfos[currentType]) {
    return decodeInfos[currentType](type, stateDefinitions, contractName, location);
  } else {
    return null;
  }
}

exports.parseType = parseType;
/**
  * compute offset (slot offset and byte offset of the @arg list of types)
  *
  * @param {Array} types - list of types
  * @param {Object} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Array} - return an array of types item: {name, type, location}. location defines the byte offset and slot offset
  */

function computeOffsets(types, stateDefinitions, contractName, location) {
  const ret = [];
  const storagelocation = {
    offset: 0,
    slot: 0
  };

  for (var i in types) {
    var variable = types[i];
    var type = parseType(variable.typeDescriptions.typeString, stateDefinitions, contractName, location);

    if (!type) {
      console.log('unable to retrieve decode info of ' + variable.typeDescriptions.typeString);
      return null;
    }

    if (!variable.constant && storagelocation.offset + type.storageBytes > 32) {
      storagelocation.slot++;
      storagelocation.offset = 0;
    }

    ret.push({
      name: variable.name,
      type: type,
      constant: variable.constant,
      storagelocation: {
        offset: variable.constant ? 0 : storagelocation.offset,
        slot: variable.constant ? 0 : storagelocation.slot
      }
    });

    if (!variable.constant) {
      if (type.storageSlots === 1 && storagelocation.offset + type.storageBytes <= 32) {
        storagelocation.offset += type.storageBytes;
      } else {
        storagelocation.slot += type.storageSlots;
        storagelocation.offset = 0;
      }
    }
  }

  if (storagelocation.offset > 0) {
    storagelocation.slot++;
  }

  return {
    typesOffsets: ret,
    endLocation: storagelocation
  };
}

exports.computeOffsets = computeOffsets;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/index.js":
/*!****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const solidityProxy_1 = __webpack_require__(/*! ./solidityProxy */ "../../../dist/libs/remix-debug/src/solidity-decoder/solidityProxy.js");

exports.SolidityProxy = solidityProxy_1.SolidityProxy;

const stateDecoder = tslib_1.__importStar(__webpack_require__(/*! ./stateDecoder */ "../../../dist/libs/remix-debug/src/solidity-decoder/stateDecoder.js"));

exports.stateDecoder = stateDecoder;

const localDecoder = tslib_1.__importStar(__webpack_require__(/*! ./localDecoder */ "../../../dist/libs/remix-debug/src/solidity-decoder/localDecoder.js"));

exports.localDecoder = localDecoder;

const internalCallTree_1 = __webpack_require__(/*! ./internalCallTree */ "../../../dist/libs/remix-debug/src/solidity-decoder/internalCallTree.js");

exports.InternalCallTree = internalCallTree_1.InternalCallTree;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/internalCallTree.js":
/*!***************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/internalCallTree.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const remix_astwalker_1 = __webpack_require__(/*! @remix-project/remix-astwalker */ "../../../dist/libs/remix-astwalker/index.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

const sourceLocationTracker_1 = __webpack_require__(/*! ../source/sourceLocationTracker */ "../../../dist/libs/remix-debug/src/source/sourceLocationTracker.js");

const eventManager_1 = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-debug/src/eventManager.js");

const decodeInfo_1 = __webpack_require__(/*! ./decodeInfo */ "../../../dist/libs/remix-debug/src/solidity-decoder/decodeInfo.js");

const traceHelper_1 = __webpack_require__(/*! ../trace/traceHelper */ "../../../dist/libs/remix-debug/src/trace/traceHelper.js");

const util_1 = __webpack_require__(/*! ./types/util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");
/**
 * Tree representing internal jump into function.
 * Triggers `callTreeReady` event when tree is ready
 * Triggers `callTreeBuildFailed` event when tree fails to build
 */


class InternalCallTree {
  /**
    * constructor
    *
    * @param {Object} debuggerEvent  - event declared by the debugger (EthDebugger)
    * @param {Object} traceManager  - trace manager
    * @param {Object} solidityProxy  - solidity proxy
    * @param {Object} codeManager  - code manager
    * @param {Object} opts  - { includeLocalVariables, debugWithGeneratedSources }
    */
  constructor(debuggerEvent, traceManager, solidityProxy, codeManager, opts) {
    this.includeLocalVariables = opts.includeLocalVariables;
    this.debugWithGeneratedSources = opts.debugWithGeneratedSources;
    this.event = new eventManager_1.EventManager();
    this.solidityProxy = solidityProxy;
    this.traceManager = traceManager;
    this.sourceLocationTracker = new sourceLocationTracker_1.SourceLocationTracker(codeManager, {
      debugWithGeneratedSources: opts.debugWithGeneratedSources
    });
    debuggerEvent.register('newTraceLoaded', trace => {
      this.reset();

      if (!this.solidityProxy.loaded()) {
        this.event.trigger('callTreeBuildFailed', ['compilation result not loaded. Cannot build internal call tree']);
      } else {
        // each recursive call to buildTree represent a new context (either call, delegatecall, internal function)
        const calledAddress = traceManager.getCurrentCalledAddressAt(0);
        const isCreation = traceHelper_1.isContractCreation(calledAddress);
        buildTree(this, 0, '', true, isCreation).then(result => {
          if (result.error) {
            this.event.trigger('callTreeBuildFailed', [result.error]);
          } else {
            createReducedTrace(this, traceManager.trace.length - 1);
            this.event.trigger('callTreeReady', [this.scopes, this.scopeStarts]);
          }
        }, reason => {
          console.log('analyzing trace falls ' + reason);
          this.event.trigger('callTreeNotReady', [reason]);
        });
      }
    });
  }
  /**
    * reset tree
    *
    */


  reset() {
    /*
      scopes: map of scopes defined by range in the vmtrace {firstStep, lastStep, locals}.
      Keys represent the level of deepness (scopeId)
      scopeId : <currentscope_id>.<sub_scope_id>.<sub_sub_scope_id>
    */
    this.scopes = {};
    /*
      scopeStart: represent start of a new scope. Keys are index in the vmtrace, values are scopeId
    */

    this.sourceLocationTracker.clearCache();
    this.functionCallStack = [];
    this.functionDefinitionsByScope = {};
    this.scopeStarts = {};
    this.variableDeclarationByFile = {};
    this.functionDefinitionByFile = {};
    this.astWalker = new remix_astwalker_1.AstWalker();
    this.reducedTrace = [];
  }
  /**
    * find the scope given @arg vmTraceIndex
    *
    * @param {Int} vmtraceIndex  - index on the vm trace
    */


  findScope(vmtraceIndex) {
    let scopeId = this.findScopeId(vmtraceIndex);
    if (scopeId !== '' && !scopeId) return null;
    let scope = this.scopes[scopeId];

    while (scope.lastStep && scope.lastStep < vmtraceIndex && scope.firstStep > 0) {
      scopeId = this.parentScope(scopeId);
      scope = this.scopes[scopeId];
    }

    return scope;
  }

  parentScope(scopeId) {
    return scopeId.replace(/(.\d|\d)$/, '');
  }

  findScopeId(vmtraceIndex) {
    const scopes = Object.keys(this.scopeStarts);
    if (!scopes.length) return null;
    const scopeStart = remix_lib_1.util.findLowerBoundValue(vmtraceIndex, scopes);
    return this.scopeStarts[scopeStart];
  }

  retrieveFunctionsStack(vmtraceIndex) {
    const scope = this.findScope(vmtraceIndex);
    if (!scope) return [];
    let scopeId = this.scopeStarts[scope.firstStep];
    const functions = [];
    if (!scopeId) return functions;
    let i = 0; // eslint-disable-next-line no-constant-condition

    while (true) {
      i += 1;
      if (i > 1000) throw new Error('retrieFunctionStack: recursion too deep');
      const functionDefinition = this.functionDefinitionsByScope[scopeId];

      if (functionDefinition !== undefined) {
        functions.push(functionDefinition);
      }

      const parent = this.parentScope(scopeId);
      if (!parent) break;else scopeId = parent;
    }

    return functions;
  }

  extractSourceLocation(step) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      try {
        const address = this.traceManager.getCurrentCalledAddressAt(step);
        const location = yield this.sourceLocationTracker.getSourceLocationFromVMTraceIndex(address, step, this.solidityProxy.contracts);
        return location;
      } catch (error) {
        throw new Error('InternalCallTree - Cannot retrieve sourcelocation for step ' + step + ' ' + error);
      }
    });
  }

  extractValidSourceLocation(step) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      try {
        const address = this.traceManager.getCurrentCalledAddressAt(step);
        const location = yield this.sourceLocationTracker.getValidSourceLocationFromVMTraceIndex(address, step, this.solidityProxy.contracts);
        return location;
      } catch (error) {
        throw new Error('InternalCallTree - Cannot retrieve valid sourcelocation for step ' + step + ' ' + error);
      }
    });
  }

}

exports.InternalCallTree = InternalCallTree;

function buildTree(tree, step, scopeId, isExternalCall, isCreation) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    let subScope = 1;
    tree.scopeStarts[step] = scopeId;
    tree.scopes[scopeId] = {
      firstStep: step,
      locals: {},
      isCreation
    };

    function callDepthChange(step, trace) {
      if (step + 1 < trace.length) {
        return trace[step].depth !== trace[step + 1].depth;
      }

      return false;
    }

    function includedSource(source, included) {
      return included.start !== -1 && included.length !== -1 && included.file !== -1 && included.start >= source.start && included.start + included.length <= source.start + source.length && included.file === source.file;
    }

    let currentSourceLocation = {
      start: -1,
      length: -1,
      file: -1
    };
    let previousSourceLocation = currentSourceLocation;

    while (step < tree.traceManager.trace.length) {
      let sourceLocation;
      let newLocation = false;

      try {
        sourceLocation = yield tree.extractSourceLocation(step);

        if (!includedSource(sourceLocation, currentSourceLocation)) {
          tree.reducedTrace.push(step);
          currentSourceLocation = sourceLocation;
          newLocation = true;
        }
      } catch (e) {
        return {
          outStep: step,
          error: 'InternalCallTree - Error resolving source location. ' + step + ' ' + e
        };
      }

      if (!sourceLocation) {
        return {
          outStep: step,
          error: 'InternalCallTree - No source Location. ' + step
        };
      }

      const isCallInstrn = traceHelper_1.isCallInstruction(tree.traceManager.trace[step]);
      const isCreateInstrn = traceHelper_1.isCreateInstruction(tree.traceManager.trace[step]); // we are checking if we are jumping in a new CALL or in an internal function

      if (isCallInstrn || sourceLocation.jump === 'i') {
        try {
          const externalCallResult = yield buildTree(tree, step + 1, scopeId === '' ? subScope.toString() : scopeId + '.' + subScope, isCallInstrn, isCreateInstrn);

          if (externalCallResult.error) {
            return {
              outStep: step,
              error: 'InternalCallTree - ' + externalCallResult.error
            };
          } else {
            step = externalCallResult.outStep;
            subScope++;
          }
        } catch (e) {
          return {
            outStep: step,
            error: 'InternalCallTree - ' + e.message
          };
        }
      } else if (isExternalCall && callDepthChange(step, tree.traceManager.trace) || !isExternalCall && sourceLocation.jump === 'o') {
        // if not, we might be returning from a CALL or internal function. This is what is checked here.
        tree.scopes[scopeId].lastStep = step;
        return {
          outStep: step + 1
        };
      } else {
        // if not, we are in the current scope.
        // We check in `includeVariableDeclaration` if there is a new local variable in scope for this specific `step`
        if (tree.includeLocalVariables) {
          yield includeVariableDeclaration(tree, step, sourceLocation, scopeId, newLocation, previousSourceLocation);
        }

        previousSourceLocation = sourceLocation;
        step++;
      }
    }

    return {
      outStep: step
    };
  });
} // the reduced trace contain an entry only if that correspond to a new source location


function createReducedTrace(tree, index) {
  tree.reducedTrace.push(index);
}

function getGeneratedSources(tree, scopeId, contractObj) {
  if (tree.debugWithGeneratedSources && contractObj && tree.scopes[scopeId]) {
    return tree.scopes[scopeId].isCreation ? contractObj.contract.evm.bytecode.generatedSources : contractObj.contract.evm.deployedBytecode.generatedSources;
  }

  return null;
}

function includeVariableDeclaration(tree, step, sourceLocation, scopeId, newLocation, previousSourceLocation) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    const contractObj = yield tree.solidityProxy.contractObjectAt(step);
    let states = null;
    const generatedSources = getGeneratedSources(tree, scopeId, contractObj);
    const variableDeclarations = resolveVariableDeclaration(tree, sourceLocation, generatedSources); // using the vm trace step, the current source location and the ast,
    // we check if the current vm trace step target a new ast node of type VariableDeclaration
    // that way we know that there is a new local variable from here.

    if (variableDeclarations && variableDeclarations.length) {
      for (const variableDeclaration of variableDeclarations) {
        if (variableDeclaration && !tree.scopes[scopeId].locals[variableDeclaration.name]) {
          try {
            const stack = tree.traceManager.getStackAt(step); // the stack length at this point is where the value of the new local variable will be stored.
            // so, either this is the direct value, or the offset in memory. That depends on the type.

            if (variableDeclaration.name !== '') {
              states = tree.solidityProxy.extractStatesDefinitions();
              var location = util_1.extractLocationFromAstVariable(variableDeclaration);
              location = location === 'default' ? 'storage' : location; // we push the new local variable in our tree

              tree.scopes[scopeId].locals[variableDeclaration.name] = {
                name: variableDeclaration.name,
                type: decodeInfo_1.parseType(variableDeclaration.typeDescriptions.typeString, states, contractObj.name, location),
                stackDepth: stack.length,
                sourceLocation: sourceLocation
              };
            }
          } catch (error) {
            console.log(error);
          }
        }
      }
    } // we check here if we are at the beginning inside a new function.
    // if that is the case, we have to add to locals tree the inputs and output params


    const functionDefinition = resolveFunctionDefinition(tree, previousSourceLocation, generatedSources);
    if (!functionDefinition) return;
    const previousIsJumpDest2 = traceHelper_1.isJumpDestInstruction(tree.traceManager.trace[step - 2]);
    const previousIsJumpDest1 = traceHelper_1.isJumpDestInstruction(tree.traceManager.trace[step - 1]);
    const isConstructor = functionDefinition.kind === 'constructor';

    if (newLocation && (previousIsJumpDest1 || previousIsJumpDest2 || isConstructor)) {
      tree.functionCallStack.push(step);
      const functionDefinitionAndInputs = {
        functionDefinition,
        inputs: []
      }; // means: the previous location was a function definition && JUMPDEST
      // => we are at the beginning of the function and input/output are setup

      try {
        const stack = tree.traceManager.getStackAt(step);
        states = tree.solidityProxy.extractStatesDefinitions();

        if (functionDefinition.parameters) {
          const inputs = functionDefinition.parameters;
          const outputs = functionDefinition.returnParameters; // for (const element of functionDefinition.parameters) {
          //   if (element.nodeType === 'ParameterList') {
          //     if (!inputs) inputs = element
          //     else {
          //       outputs = element
          //       break
          //     }
          //   }
          // }
          // input params

          if (inputs && inputs.parameters) {
            functionDefinitionAndInputs.inputs = addParams(inputs, tree, scopeId, states, contractObj.name, previousSourceLocation, stack.length, inputs.parameters.length, -1);
          } // output params


          if (outputs) addParams(outputs, tree, scopeId, states, contractObj.name, previousSourceLocation, stack.length, 0, 1);
        }
      } catch (error) {
        console.log(error);
      }

      tree.functionDefinitionsByScope[scopeId] = functionDefinitionAndInputs;
    }
  });
} // this extract all the variable declaration for a given ast and file
// and keep this in a cache


function resolveVariableDeclaration(tree, sourceLocation, generatedSources) {
  if (!tree.variableDeclarationByFile[sourceLocation.file]) {
    const ast = tree.solidityProxy.ast(sourceLocation, generatedSources);

    if (ast) {
      tree.variableDeclarationByFile[sourceLocation.file] = extractVariableDeclarations(ast, tree.astWalker);
    } else {
      return null;
    }
  }

  return tree.variableDeclarationByFile[sourceLocation.file][sourceLocation.start + ':' + sourceLocation.length + ':' + sourceLocation.file];
} // this extract all the function definition for a given ast and file
// and keep this in a cache


function resolveFunctionDefinition(tree, sourceLocation, generatedSources) {
  if (!tree.functionDefinitionByFile[sourceLocation.file]) {
    const ast = tree.solidityProxy.ast(sourceLocation, generatedSources);

    if (ast) {
      tree.functionDefinitionByFile[sourceLocation.file] = extractFunctionDefinitions(ast, tree.astWalker);
    } else {
      return null;
    }
  }

  return tree.functionDefinitionByFile[sourceLocation.file][sourceLocation.start + ':' + sourceLocation.length + ':' + sourceLocation.file];
}

function extractVariableDeclarations(ast, astWalker) {
  const ret = {};
  astWalker.walkFull(ast, node => {
    if (node.nodeType === 'VariableDeclaration' || node.nodeType === 'YulVariableDeclaration') {
      ret[node.src] = [node];
    }

    const hasChild = node.initialValue && (node.nodeType === 'VariableDeclarationStatement' || node.nodeType === 'YulVariableDeclarationStatement');
    if (hasChild) ret[node.initialValue.src] = node.declarations;
  });
  return ret;
}

function extractFunctionDefinitions(ast, astWalker) {
  const ret = {};
  astWalker.walkFull(ast, node => {
    if (node.nodeType === 'FunctionDefinition' || node.nodeType === 'YulFunctionDefinition') {
      ret[node.src] = node;
    }
  });
  return ret;
}

function addParams(parameterList, tree, scopeId, states, contractName, sourceLocation, stackLength, stackPosition, dir) {
  const params = [];

  for (const inputParam in parameterList.parameters) {
    const param = parameterList.parameters[inputParam];
    const stackDepth = stackLength + dir * stackPosition;

    if (stackDepth >= 0) {
      let location = util_1.extractLocationFromAstVariable(param);
      location = location === 'default' ? 'memory' : location;
      const attributesName = param.name === '' ? `$${inputParam}` : param.name;
      tree.scopes[scopeId].locals[attributesName] = {
        name: attributesName,
        type: decodeInfo_1.parseType(param.typeDescriptions.typeString, states, contractName, location),
        stackDepth: stackDepth,
        sourceLocation: sourceLocation
      };
      params.push(attributesName);
    }

    stackPosition += dir;
  }

  return params;
}

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/localDecoder.js":
/*!***********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/localDecoder.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

function solidityLocals(vmtraceIndex, internalTreeCall, stack, memory, storageResolver, currentSourceLocation, cursor) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    const scope = internalTreeCall.findScope(vmtraceIndex);

    if (!scope) {
      const error = {
        message: 'Can\'t display locals. reason: compilation result might not have been provided'
      };
      throw error;
    }

    const locals = {};
    memory = formatMemory(memory);
    let anonymousIncr = 1;

    for (const local in scope.locals) {
      var variable = scope.locals[local];

      if (variable.stackDepth < stack.length && variable.sourceLocation.start <= currentSourceLocation.start) {
        let name = variable.name;

        if (name.indexOf('$') !== -1) {
          name = '<' + anonymousIncr + '>';
          anonymousIncr++;
        }

        try {
          locals[name] = yield variable.type.decodeFromStack(variable.stackDepth, stack, memory, storageResolver, cursor);
        } catch (e) {
          console.log(e);
          locals[name] = '<decoding failed - ' + e.message + '>';
        }
      }
    }

    return locals;
  });
}

exports.solidityLocals = solidityLocals;

function formatMemory(memory) {
  if (memory instanceof Array) {
    memory = memory.join('').replace(/0x/g, '');
  }

  return memory;
}

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/solidityProxy.js":
/*!************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/solidityProxy.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

const traceHelper_1 = __webpack_require__(/*! ../trace/traceHelper */ "../../../dist/libs/remix-debug/src/trace/traceHelper.js");

const stateDecoder_1 = __webpack_require__(/*! ./stateDecoder */ "../../../dist/libs/remix-debug/src/solidity-decoder/stateDecoder.js");

const astHelper_1 = __webpack_require__(/*! ./astHelper */ "../../../dist/libs/remix-debug/src/solidity-decoder/astHelper.js");

class SolidityProxy {
  constructor({
    getCurrentCalledAddressAt,
    getCode
  }) {
    this.cache = new Cache();
    this.reset({});
    this.getCurrentCalledAddressAt = getCurrentCalledAddressAt;
    this.getCode = getCode;
  }
  /**
    * reset the cache and apply a new @arg compilationResult
    *
    * @param {Object} compilationResult  - result os a compilatiion (diectly returned by the compiler)
    */


  reset(compilationResult) {
    this.sources = compilationResult.sources;
    this.contracts = compilationResult.contracts;
    this.cache.reset();
  }
  /**
    * check if the object has been properly loaded
    *
    * @return {Bool} - returns true if a compilation result has been applied
    */


  loaded() {
    return this.contracts !== undefined;
  }
  /**
    * retrieve the compiled contract name at the @arg vmTraceIndex (cached)
    *
    * @param {Int} vmTraceIndex  - index in the vm trave where to resolve the executed contract name
    * @param {Function} cb  - callback returns (error, contractName)
    */


  contractObjectAt(vmTraceIndex) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const address = this.getCurrentCalledAddressAt(vmTraceIndex);

      if (this.cache.contractObjectByAddress[address]) {
        return this.cache.contractObjectByAddress[address];
      }

      const code = yield this.getCode(address);
      const contract = contractObjectFromCode(this.contracts, code.bytecode, address);
      this.cache.contractObjectByAddress[address] = contract;
      return contract;
    });
  }
  /**
    * extract the state variables of the given compiled @arg contractName (cached)
    *
    * @param {String} contractName  - name of the contract to retrieve state variables from
    * @return {Object} - returns state variables of @args contractName
    */


  extractStatesDefinitions() {
    if (!this.cache.contractDeclarations) {
      this.cache.contractDeclarations = astHelper_1.extractContractDefinitions(this.sources);
    }

    if (!this.cache.statesDefinitions) {
      this.cache.statesDefinitions = astHelper_1.extractStatesDefinitions(this.sources, this.cache.contractDeclarations);
    }

    return this.cache.statesDefinitions;
  }
  /**
    * extract the state variables of the given compiled @arg contractName (cached)
    *
    * @param {String} contractName  - name of the contract to retrieve state variables from
    * @return {Object} - returns state variables of @args contractName
    */


  extractStateVariables(contractName) {
    if (!this.cache.stateVariablesByContractName[contractName]) {
      this.cache.stateVariablesByContractName[contractName] = stateDecoder_1.extractStateVariables(contractName, this.sources);
    }

    return this.cache.stateVariablesByContractName[contractName];
  }
  /**
    * extract the state variables of the given compiled @arg vmtraceIndex (cached)
    *
    * @param {Int} vmTraceIndex  - index in the vm trave where to resolve the state variables
    * @return {Object} - returns state variables of @args vmTraceIndex
    */


  extractStateVariablesAt(vmtraceIndex) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const contract = yield this.contractObjectAt(vmtraceIndex);
      return this.extractStateVariables(contract.name);
    });
  }
  /**
    * get the AST of the file declare in the @arg sourceLocation
    *
    * @param {Object} sourceLocation  - source location containing the 'file' to retrieve the AST from
    * @return {Object} - AST of the current file
    */


  ast(sourceLocation, generatedSources) {
    const file = this.fileNameFromIndex(sourceLocation.file);

    if (!file && generatedSources && generatedSources.length) {
      for (const source of generatedSources) {
        if (source.id === sourceLocation.file) return source.ast;
      }
    } else if (this.sources[file]) {
      return this.sources[file].ast;
    }

    return null;
  }
  /**
   * get the filename refering to the index from the compilation result
   *
   * @param {Int} index  - index of the filename
   * @return {String} - filename
   */


  fileNameFromIndex(index) {
    return Object.keys(this.contracts)[index];
  }

}

exports.SolidityProxy = SolidityProxy;

function contractObjectFromCode(contracts, code, address) {
  const isCreation = traceHelper_1.isContractCreation(address);

  for (const file in contracts) {
    for (const contract in contracts[file]) {
      const bytecode = isCreation ? contracts[file][contract].evm.bytecode.object : contracts[file][contract].evm.deployedBytecode.object;

      if (remix_lib_1.util.compareByteCode(code, '0x' + bytecode)) {
        return {
          name: contract,
          contract: contracts[file][contract]
        };
      }
    }
  }

  return null;
}

class Cache {
  constructor() {
    this.reset();
  }

  reset() {
    this.contractObjectByAddress = {};
    this.stateVariablesByContractName = {};
    this.contractDeclarations = null;
    this.statesDefinitions = null;
  }

}

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/stateDecoder.js":
/*!***********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/stateDecoder.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const astHelper_1 = __webpack_require__(/*! ./astHelper */ "../../../dist/libs/remix-debug/src/solidity-decoder/astHelper.js");

const decodeInfo_1 = __webpack_require__(/*! ./decodeInfo */ "../../../dist/libs/remix-debug/src/solidity-decoder/decodeInfo.js");
/**
  * decode the contract state storage
  *
  * @param {Array} storage location  - location of all state variables
  * @param {Object} storageResolver  - resolve storage queries
  * @return {Map} - decoded state variable
  */


function decodeState(stateVars, storageResolver) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    const ret = {};

    for (var k in stateVars) {
      var stateVar = stateVars[k];

      try {
        const decoded = yield stateVar.type.decodeFromStorage(stateVar.storagelocation, storageResolver);
        decoded.constant = stateVar.constant;

        if (decoded.constant) {
          decoded.value = '<constant>';
        }

        ret[stateVar.name] = decoded;
      } catch (e) {
        console.log(e);
        ret[stateVar.name] = '<decoding failed - ' + e.message + '>';
      }
    }

    return ret;
  });
}

exports.decodeState = decodeState;
/**
  * return all storage location variables of the given @arg contractName
  *
  * @param {String} contractName  - name of the contract
  * @param {Object} sourcesList  - sources list
  * @return {Object} - return the location of all contract variables in the storage
  */

function extractStateVariables(contractName, sourcesList) {
  const states = astHelper_1.extractStatesDefinitions(sourcesList, null);

  if (!states[contractName]) {
    return [];
  }

  const types = states[contractName].stateVariables;
  const offsets = decodeInfo_1.computeOffsets(types, states, contractName, 'storage');

  if (!offsets) {
    return []; // TODO should maybe return an error
  }

  return offsets.typesOffsets;
}

exports.extractStateVariables = extractStateVariables;
/**
  * return the state of the given @a contractName as a json object
  *
  * @param {Object} storageResolver  - resolve storage queries
  * @param {astList} astList  - AST nodes of all the sources
  * @param {String} contractName  - contract for which state var should be resolved
  * @return {Map} - return the state of the contract
  */

function solidityState(storageResolver, astList, contractName) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    const stateVars = extractStateVariables(contractName, astList);

    try {
      return yield decodeState(stateVars, storageResolver);
    } catch (e) {
      return '<decoding failed - ' + e.message + '>';
    }
  });
}

exports.solidityState = solidityState;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Address.js":
/*!************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/Address.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const util_1 = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

const ValueType_1 = __webpack_require__(/*! ./ValueType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js");

class Address extends ValueType_1.ValueType {
  constructor() {
    super(1, 20, 'address');
  }

  decodeValue(value) {
    if (!value) {
      return '0x0000000000000000000000000000000000000000';
    }

    return '0x' + util_1.extractHexByteSlice(value, this.storageBytes, 0).toUpperCase();
  }

}

exports.Address = Address;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ArrayType.js":
/*!**************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/ArrayType.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const util_1 = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const RefType_1 = __webpack_require__(/*! ./RefType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/RefType.js");

const sha3256 = remix_lib_1.util.sha3_256;

class ArrayType extends RefType_1.RefType {
  constructor(underlyingType, arraySize, location) {
    let storageSlots = null;

    if (arraySize === 'dynamic') {
      storageSlots = 1;
    } else {
      if (underlyingType.storageBytes < 32) {
        const itemPerSlot = Math.floor(32 / underlyingType.storageBytes);
        storageSlots = Math.ceil(arraySize / itemPerSlot);
      } else {
        storageSlots = arraySize * underlyingType.storageSlots;
      }
    }

    const size = arraySize !== 'dynamic' ? arraySize : '';
    super(storageSlots, 32, underlyingType.typeName + '[' + size + ']', location);
    this.underlyingType = underlyingType;
    this.arraySize = arraySize;
  }

  decodeFromStorage(location, storageResolver) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const ret = [];
      let size = null;
      let slotValue;

      try {
        slotValue = yield util_1.extractHexValue(location, storageResolver, this.storageBytes);
      } catch (e) {
        console.log(e);
        return {
          value: '<decoding failed - ' + e.message + '>',
          type: this.typeName
        };
      }

      const currentLocation = {
        offset: 0,
        slot: location.slot
      };

      if (this.arraySize === 'dynamic') {
        size = util_1.toBN('0x' + slotValue);
        currentLocation.slot = sha3256(location.slot);
      } else {
        size = new ethereumjs_util_1.BN(this.arraySize);
      }

      var k = util_1.toBN(0);

      for (; k.lt(size) && k.ltn(300); k.iaddn(1)) {
        try {
          ret.push(yield this.underlyingType.decodeFromStorage(currentLocation, storageResolver));
        } catch (e) {
          return {
            value: '<decoding failed - ' + e.message + '>',
            type: this.typeName
          };
        }

        if (this.underlyingType.storageSlots === 1 && location.offset + this.underlyingType.storageBytes <= 32) {
          currentLocation.offset += this.underlyingType.storageBytes;

          if (currentLocation.offset + this.underlyingType.storageBytes > 32) {
            currentLocation.offset = 0;
            currentLocation.slot = '0x' + util_1.add(currentLocation.slot, 1).toString(16);
          }
        } else {
          currentLocation.slot = '0x' + util_1.add(currentLocation.slot, this.underlyingType.storageSlots).toString(16);
          currentLocation.offset = 0;
        }
      }

      return {
        value: ret,
        length: '0x' + size.toString(16),
        type: this.typeName
      };
    });
  }

  decodeFromMemoryInternal(offset, memory, skip) {
    const ret = [];
    let length = this.arraySize;

    if (this.arraySize === 'dynamic') {
      length = memory.substr(2 * offset, 64);
      length = parseInt(length, 16);
      offset = offset + 32;
    }

    if (isNaN(length)) {
      return {
        value: '<decoding failed - length is NaN>',
        type: 'Error'
      };
    }

    if (!skip) skip = 0;
    if (skip) offset = offset + 32 * skip;
    let limit = length - skip;
    if (limit > 10) limit = 10;

    for (var k = 0; k < limit; k++) {
      var contentOffset = offset;
      ret.push(this.underlyingType.decodeFromMemory(contentOffset, memory));
      offset += 32;
    }

    return {
      value: ret,
      length: '0x' + length.toString(16),
      type: this.typeName,
      cursor: skip + limit,
      hasNext: length > skip + limit
    };
  }

}

exports.ArrayType = ArrayType;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Bool.js":
/*!*********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/Bool.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const ValueType_1 = __webpack_require__(/*! ./ValueType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js");

const util_1 = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

class Bool extends ValueType_1.ValueType {
  constructor() {
    super(1, 1, 'bool');
  }

  decodeValue(value) {
    if (!value) {
      return false;
    }

    value = util_1.extractHexByteSlice(value, this.storageBytes, 0);
    return value !== '00';
  }

}

exports.Bool = Bool;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/DynamicByteArray.js":
/*!*********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/DynamicByteArray.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const util_1 = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const RefType_1 = __webpack_require__(/*! ./RefType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/RefType.js");

const sha3256 = remix_lib_1.util.sha3_256;

class DynamicByteArray extends RefType_1.RefType {
  constructor(location) {
    super(1, 32, 'bytes', location);
  }

  decodeFromStorage(location, storageResolver) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      let value = '0x0';

      try {
        value = yield util_1.extractHexValue(location, storageResolver, this.storageBytes);
      } catch (e) {
        console.log(e);
        return {
          value: '<decoding failed - ' + e.message + '>',
          type: this.typeName
        };
      }

      const length = new ethereumjs_util_1.BN(value, 16);

      if (length.testn(0)) {
        let dataPos = new ethereumjs_util_1.BN(sha3256(location.slot).replace('0x', ''), 16);
        let ret = '';
        let currentSlot = '0x';

        try {
          currentSlot = yield util_1.readFromStorage(dataPos, storageResolver);
        } catch (e) {
          console.log(e);
          return {
            value: '<decoding failed - ' + e.message + '>',
            type: this.typeName
          };
        }

        while (length.gt(new ethereumjs_util_1.BN(ret.length)) && ret.length < 32000) {
          currentSlot = currentSlot.replace('0x', '');
          ret += currentSlot;
          dataPos = dataPos.add(new ethereumjs_util_1.BN(1));

          try {
            currentSlot = yield util_1.readFromStorage(dataPos, storageResolver);
          } catch (e) {
            console.log(e);
            return {
              value: '<decoding failed - ' + e.message + '>',
              type: this.typeName
            };
          }
        }

        return {
          value: '0x' + ret.replace(/(00)+$/, ''),
          length: '0x' + length.toString(16),
          type: this.typeName
        };
      } else {
        var size = parseInt(value.substr(value.length - 2, 2), 16) / 2;
        return {
          value: '0x' + value.substr(0, size * 2),
          length: '0x' + size.toString(16),
          type: this.typeName
        };
      }
    });
  }

  decodeFromMemoryInternal(offset, memory) {
    offset = 2 * offset;
    let length = memory.substr(offset, 64);
    length = 2 * parseInt(length, 16);
    return {
      length: '0x' + length.toString(16),
      value: '0x' + memory.substr(offset + 64, length),
      type: this.typeName
    };
  }

}

exports.DynamicByteArray = DynamicByteArray;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Enum.js":
/*!*********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/Enum.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const ValueType_1 = __webpack_require__(/*! ./ValueType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js");

class Enum extends ValueType_1.ValueType {
  constructor(enumDef) {
    let storageBytes = 0;
    let length = enumDef.members.length;

    while (length > 1) {
      length = length / 256;
      storageBytes++;
    }

    super(1, storageBytes, 'enum');
    this.enumDef = enumDef;
  }

  decodeValue(value) {
    if (!value) {
      return this.enumDef.members[0].name;
    }

    value = parseInt(value, 16);

    if (this.enumDef.members.length > value) {
      return this.enumDef.members[value].name;
    }

    return 'INVALID_ENUM<' + value + '>';
  }

}

exports.Enum = Enum;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/FixedByteArray.js":
/*!*******************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/FixedByteArray.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const ValueType_1 = __webpack_require__(/*! ./ValueType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js");

class FixedByteArray extends ValueType_1.ValueType {
  constructor(storageBytes) {
    super(1, storageBytes, 'bytes' + storageBytes);
  }

  decodeValue(value) {
    return '0x' + value.substr(0, 2 * this.storageBytes).toUpperCase();
  }

}

exports.FixedByteArray = FixedByteArray;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Int.js":
/*!********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/Int.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const util_1 = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

const ValueType_1 = __webpack_require__(/*! ./ValueType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js");

class Int extends ValueType_1.ValueType {
  constructor(storageBytes) {
    super(1, storageBytes, 'int' + storageBytes * 8);
  }

  decodeValue(value) {
    value = util_1.extractHexByteSlice(value, this.storageBytes, 0);
    return util_1.decodeIntFromHex(value, this.storageBytes, true);
  }

}

exports.Int = Int;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Mapping.js":
/*!************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/Mapping.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const RefType_1 = __webpack_require__(/*! ./RefType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/RefType.js");

const util_1 = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const ethjs_util_1 = __webpack_require__(/*! ethjs-util */ "../../../node_modules/ethjs-util/lib/index.js");

class Mapping extends RefType_1.RefType {
  constructor(underlyingTypes, location, fullType) {
    super(1, 32, fullType, 'storage');
    this.keyType = underlyingTypes.keyType;
    this.valueType = underlyingTypes.valueType;
    this.initialDecodedState = null;
  }

  decodeFromStorage(location, storageResolver) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const corrections = this.valueType.members ? this.valueType.members.map(value => {
        return value.storagelocation;
      }) : [];

      if (!this.initialDecodedState) {
        // cache the decoded initial storage
        let mappingsInitialPreimages;

        try {
          mappingsInitialPreimages = yield storageResolver.initialMappingsLocation(corrections);
          this.initialDecodedState = yield this.decodeMappingsLocation(mappingsInitialPreimages, location, storageResolver);
        } catch (e) {
          return {
            value: e.message,
            type: this.typeName
          };
        }
      }

      const mappingPreimages = yield storageResolver.mappingsLocation(corrections);
      let ret = yield this.decodeMappingsLocation(mappingPreimages, location, storageResolver); // fetch mapping storage changes

      ret = Object.assign({}, this.initialDecodedState, ret); // merge changes

      return {
        value: ret,
        type: this.typeName
      };
    });
  }

  decodeFromMemoryInternal(offset, memory) {
    // mappings can only exist in storage and not in memory
    // so this should never be called
    return {
      value: '<not implemented>',
      length: '0x',
      type: this.typeName
    };
  }

  decodeMappingsLocation(preimages, location, storageResolver) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const mapSlot = util_1.normalizeHex(ethereumjs_util_1.bufferToHex(location.slot));

      if (!preimages[mapSlot]) {
        return {};
      }

      const ret = {};

      for (const i in preimages[mapSlot]) {
        const mapLocation = getMappingLocation(i, location.slot);
        const globalLocation = {
          offset: location.offset,
          slot: mapLocation
        };
        ret[i] = yield this.valueType.decodeFromStorage(globalLocation, storageResolver);
      }

      return ret;
    });
  }

}

exports.Mapping = Mapping;

function getMappingLocation(key, position) {
  // mapping storage location decribed at http://solidity.readthedocs.io/en/develop/miscellaneous.html#layout-of-state-variables-in-storage
  // > the value corresponding to a mapping key k is located at keccak256(k . p) where . is concatenation.
  // key should be a hex string, and position an int
  const mappingK = ethereumjs_util_1.toBuffer('0x' + key);
  let mappingP = ethjs_util_1.intToBuffer(position);
  mappingP = ethereumjs_util_1.setLengthLeft(mappingP, 32);
  const mappingKeyBuf = concatTypedArrays(mappingK, mappingP);
  const mappingKeyPreimage = '0x' + mappingKeyBuf.toString('hex');
  const mappingStorageLocation = ethereumjs_util_1.keccak(mappingKeyPreimage);
  const mappingStorageLocationinBn = new ethereumjs_util_1.BN(mappingStorageLocation, 16);
  return mappingStorageLocationinBn;
}

function concatTypedArrays(a, b) {
  const c = new a.constructor(a.length + b.length);
  c.set(a, 0);
  c.set(b, a.length);
  return c;
}

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/RefType.js":
/*!************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/RefType.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const util_1 = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

class RefType {
  constructor(storageSlots, storageBytes, typeName, location) {
    this.location = location;
    this.storageSlots = storageSlots;
    this.storageBytes = storageBytes;
    this.typeName = typeName;
    this.basicType = 'RefType';
  }

  decodeFromStorage(input1, input2) {
    throw new Error('This method is abstract');
  }

  decodeFromMemoryInternal(input1, input2, input3) {
    throw new Error('This method is abstract');
  }
  /**
    * decode the type from the stack
    *
    * @param {Int} stackDepth - position of the type in the stack
    * @param {Array} stack - stack
    * @param {String} - memory
    * @param {Object} - storageResolver
    * @return {Object} decoded value
    */


  decodeFromStack(stackDepth, stack, memory, storageResolver, cursor) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (stack.length - 1 < stackDepth) {
        return {
          error: '<decoding failed - stack underflow ' + stackDepth + '>',
          type: this.typeName
        };
      }

      let offset = stack[stack.length - 1 - stackDepth];

      if (this.isInStorage()) {
        offset = util_1.toBN(offset);

        try {
          return yield this.decodeFromStorage({
            offset: 0,
            slot: offset
          }, storageResolver);
        } catch (e) {
          console.log(e);
          return {
            error: '<decoding failed - ' + e.message + '>',
            type: this.typeName
          };
        }
      } else if (this.isInMemory()) {
        offset = parseInt(offset, 16);
        return this.decodeFromMemoryInternal(offset, memory, cursor);
      } else {
        return {
          error: '<decoding failed - no decoder for ' + this.location + '>',
          type: this.typeName
        };
      }
    });
  }
  /**
    * decode the type from the memory
    *
    * @param {Int} offset - position of the ref of the type in memory
    * @param {String} memory - memory
    * @return {Object} decoded value
    */


  decodeFromMemory(offset, memory) {
    offset = memory.substr(2 * offset, 64);
    offset = parseInt(offset, 16);
    return this.decodeFromMemoryInternal(offset, memory);
  }
  /**
    * current type defined in storage
    *
    * @return {Bool} - return true if the type is defined in the storage
    */


  isInStorage() {
    return this.location.indexOf('storage') === 0;
  }
  /**
    * current type defined in memory
    *
    * @return {Bool} - return true if the type is defined in the memory
    */


  isInMemory() {
    return this.location.indexOf('memory') === 0;
  }

}

exports.RefType = RefType;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/StringType.js":
/*!***************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/StringType.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const DynamicByteArray_1 = __webpack_require__(/*! ./DynamicByteArray */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/DynamicByteArray.js");

class StringType extends DynamicByteArray_1.DynamicByteArray {
  constructor(location) {
    super(location);
    this.typeName = 'string';
  }

  decodeFromStorage(location, storageResolver) {
    const _super = Object.create(null, {
      decodeFromStorage: {
        get: () => super.decodeFromStorage
      }
    });

    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      let decoded = '0x';

      try {
        decoded = yield _super.decodeFromStorage.call(this, location, storageResolver);
      } catch (e) {
        console.log(e);
        return '<decoding failed - ' + e.message + '>';
      }

      return format(decoded);
    });
  }

  decodeFromStack(stackDepth, stack, memory) {
    const _super = Object.create(null, {
      decodeFromStack: {
        get: () => super.decodeFromStack
      }
    });

    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      try {
        return yield _super.decodeFromStack.call(this, stackDepth, stack, memory, null, null);
      } catch (e) {
        console.log(e);
        return '<decoding failed - ' + e.message + '>';
      }
    });
  }

  decodeFromMemoryInternal(offset, memory) {
    const decoded = super.decodeFromMemoryInternal(offset, memory);
    return format(decoded);
  }

}

exports.StringType = StringType;

function format(decoded) {
  if (decoded.error) {
    return decoded;
  }

  let value = decoded.value;
  value = value.replace('0x', '').replace(/(..)/g, '%$1');
  const ret = {
    length: decoded.length,
    raw: decoded.value,
    type: 'string'
  };

  try {
    ret['value'] = decodeURIComponent(value);
  } catch (e) {
    ret['error'] = 'Invalid UTF8 encoding';
    ret.raw = decoded.value;
  }

  return ret;
}

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Struct.js":
/*!***********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/Struct.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const util_1 = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

const RefType_1 = __webpack_require__(/*! ./RefType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/RefType.js");

class Struct extends RefType_1.RefType {
  constructor(memberDetails, location, fullType) {
    super(memberDetails.storageSlots, 32, 'struct ' + fullType, location);
    this.members = memberDetails.members;
  }

  decodeFromStorage(location, storageResolver) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const ret = {};

      for (var item of this.members) {
        const globalLocation = {
          offset: location.offset + item.storagelocation.offset,
          slot: util_1.add(location.slot, item.storagelocation.slot)
        };

        try {
          ret[item.name] = yield item.type.decodeFromStorage(globalLocation, storageResolver);
        } catch (e) {
          console.log(e);
          ret[item.name] = '<decoding failed - ' + e.message + '>';
        }
      }

      return {
        value: ret,
        type: this.typeName
      };
    });
  }

  decodeFromMemoryInternal(offset, memory) {
    const ret = {};
    this.members.map((item, i) => {
      var contentOffset = offset;
      var member = item.type.decodeFromMemory(contentOffset, memory);
      ret[item.name] = member;
      offset += 32;
    });
    return {
      value: ret,
      type: this.typeName
    };
  }

}

exports.Struct = Struct;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Uint.js":
/*!*********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/Uint.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const util_1 = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

const ValueType_1 = __webpack_require__(/*! ./ValueType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js");

class Uint extends ValueType_1.ValueType {
  constructor(storageBytes) {
    super(1, storageBytes, 'uint' + storageBytes * 8);
  }

  decodeValue(value) {
    value = util_1.extractHexByteSlice(value, this.storageBytes, 0);
    return util_1.decodeIntFromHex(value, this.storageBytes, false);
  }

}

exports.Uint = Uint;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js":
/*!**************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const util_1 = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

class ValueType {
  constructor(storageSlots, storageBytes, typeName) {
    this.storageSlots = storageSlots;
    this.storageBytes = storageBytes;
    this.typeName = typeName;
    this.basicType = 'ValueType';
  }

  decodeValue(input) {
    throw new Error('This method is abstract');
  }
  /**
    * decode the type with the @arg location from the storage
    *
    * @param {Object} location - containing offset and slot
    * @param {Object} storageResolver  - resolve storage queries
    * @return {Object} - decoded value
    */


  decodeFromStorage(location, storageResolver) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      try {
        var value = yield util_1.extractHexValue(location, storageResolver, this.storageBytes);
        return {
          value: this.decodeValue(value),
          type: this.typeName
        };
      } catch (e) {
        console.log(e);
        return {
          value: '<decoding failed - ' + e.message + '>',
          type: this.typeName
        };
      }
    });
  }
  /**
    * decode the type from the stack
    *
    * @param {Int} stackDepth - position of the type in the stack
    * @param {Array} stack - stack
    * @param {String} - memory
    * @return {Object} - decoded value
    */


  decodeFromStack(stackDepth, stack, memory) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      let value;

      if (stackDepth >= stack.length) {
        value = this.decodeValue('');
      } else {
        value = this.decodeValue(stack[stack.length - 1 - stackDepth].replace('0x', ''));
      }

      return {
        value,
        type: this.typeName
      };
    });
  }
  /**
    * decode the type with the @arg offset location from the memory
    *
    * @param {Int} stackDepth - position of the type in the stack
    * @return {String} - memory
    * @return {Object} - decoded value
    */


  decodeFromMemory(offset, memory) {
    const value = memory.substr(2 * offset, 64);
    return {
      value: this.decodeValue(value),
      type: this.typeName
    };
  }

}

exports.ValueType = ValueType;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js":
/*!*********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/util.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

function decodeIntFromHex(value, byteLength, signed) {
  let bigNumber = new ethereumjs_util_1.BN(value, 16);

  if (signed) {
    bigNumber = bigNumber.fromTwos(8 * byteLength);
  }

  return bigNumber.toString(10);
}

exports.decodeIntFromHex = decodeIntFromHex;

function readFromStorage(slot, storageResolver) {
  const hexSlot = '0x' + normalizeHex(ethereumjs_util_1.bufferToHex(slot));
  return new Promise((resolve, reject) => {
    storageResolver.storageSlot(hexSlot, (error, slot) => {
      if (error) {
        return reject(error);
      }

      if (!slot) {
        slot = {
          key: slot,
          value: ''
        };
      }

      return resolve(normalizeHex(slot.value));
    });
  });
}

exports.readFromStorage = readFromStorage;
/**
 * @returns a hex encoded byte slice of length @arg byteLength from inside @arg slotValue.
 *
 * @param {String} slotValue  - hex encoded value to extract the byte slice from
 * @param {Int} byteLength  - Length of the byte slice to extract
 * @param {Int} offsetFromLSB  - byte distance from the right end slot value to the right end of the byte slice
 */

function extractHexByteSlice(slotValue, byteLength, offsetFromLSB) {
  const offset = slotValue.length - 2 * offsetFromLSB - 2 * byteLength;
  return slotValue.substr(offset, 2 * byteLength);
}

exports.extractHexByteSlice = extractHexByteSlice;
/**
 * @returns a hex encoded storage content at the given @arg location. it does not have Ox prefix but always has the full length.
 *
 * @param {Object} location  - object containing the slot and offset of the data to extract.
 * @param {Object} storageResolver  - storage resolver
 * @param {Int} byteLength  - Length of the byte slice to extract
 */

function extractHexValue(location, storageResolver, byteLength) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    let slotvalue;

    try {
      slotvalue = yield readFromStorage(location.slot, storageResolver);
    } catch (e) {
      return '0x';
    }

    return extractHexByteSlice(slotvalue, byteLength, location.offset);
  });
}

exports.extractHexValue = extractHexValue;

function toBN(value) {
  if (value instanceof ethereumjs_util_1.BN) {
    return value;
  } else if (value.match && value.match(/^(0x)?([a-f0-9]*)$/)) {
    value = ethereumjs_util_1.unpad(value.replace(/^(0x)/, ''));
    value = new ethereumjs_util_1.BN(value === '' ? '0' : value, 16);
  } else if (!isNaN(value)) {
    value = new ethereumjs_util_1.BN(value);
  }

  return value;
}

exports.toBN = toBN;

function add(value1, value2) {
  return toBN(value1).add(toBN(value2));
}

exports.add = add;

function sub(value1, value2) {
  return toBN(value1).sub(toBN(value2));
}

exports.sub = sub;

function removeLocation(type) {
  return type.replace(/( storage ref| storage pointer| memory| calldata)/g, '');
}

exports.removeLocation = removeLocation;

function extractLocation(type) {
  const match = type.match(/( storage ref| storage pointer| memory| calldata)?$/);

  if (match[1] !== '') {
    return match[1].trim();
  }

  return null;
}

exports.extractLocation = extractLocation;

function extractLocationFromAstVariable(node) {
  if (node.storageLocation !== 'default') {
    return node.storageLocation;
  } else if (node.stateVariable) {
    return 'storage';
  }

  return 'default'; // local variables => storage, function parameters & return values => memory, state => storage
}

exports.extractLocationFromAstVariable = extractLocationFromAstVariable;

function normalizeHex(hex) {
  hex = hex.replace('0x', '');

  if (hex.length < 64) {
    return new Array(64 - hex.length + 1).join('0') + hex;
  }

  return hex;
}

exports.normalizeHex = normalizeHex;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/source/sourceLocationTracker.js":
/*!**********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/source/sourceLocationTracker.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const eventManager_1 = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-debug/src/eventManager.js");

const traceHelper_1 = __webpack_require__(/*! ../trace/traceHelper */ "../../../dist/libs/remix-debug/src/trace/traceHelper.js");

const sourceMappingDecoder_1 = __webpack_require__(/*! ./sourceMappingDecoder */ "../../../dist/libs/remix-debug/src/source/sourceMappingDecoder.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");
/**
 * Process the source code location for the current executing bytecode
 */


class SourceLocationTracker {
  constructor(_codeManager, {
    debugWithGeneratedSources
  }) {
    this.opts = {
      debugWithGeneratedSources: debugWithGeneratedSources || false
    };
    this.codeManager = _codeManager;
    this.event = new eventManager_1.EventManager();
    this.sourceMapByAddress = {};
  }
  /**
   * Return the source location associated with the given @arg index (instruction index)
   *
   * @param {String} address - contract address from which the source location is retrieved
   * @param {Int} index - index in the instruction list from where the source location is retrieved
   * @param {Object} contractDetails - AST of compiled contracts
   */


  getSourceLocationFromInstructionIndex(address, index, contracts) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const sourceMap = yield this.extractSourceMap(this, this.codeManager, address, contracts);
      return sourceMappingDecoder_1.atIndex(index, sourceMap['map']);
    });
  }
  /**
   * Return the source location associated with the given @arg vmTraceIndex
   *
   * @param {String} address - contract address from which the source location is retrieved
   * @param {Int} vmtraceStepIndex - index of the current code in the vmtrace
   * @param {Object} contractDetails - AST of compiled contracts
   */


  getSourceLocationFromVMTraceIndex(address, vmtraceStepIndex, contracts) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const sourceMap = yield this.extractSourceMap(this, this.codeManager, address, contracts);
      const index = this.codeManager.getInstructionIndex(address, vmtraceStepIndex);
      return sourceMappingDecoder_1.atIndex(index, sourceMap['map']);
    });
  }
  /**
   * Returns the generated sources from a specific @arg address
   *
   * @param {String} address - contract address from which has generated sources
   * @param {Object} generatedSources - Object containing the sourceid, ast and the source code.
   */


  getGeneratedSourcesFromAddress(address) {
    if (!this.opts.debugWithGeneratedSources) return null;
    if (this.sourceMapByAddress[address]) return this.sourceMapByAddress[address].generatedSources;
    return null;
  }
  /**
   * Returns the total amount of sources from a specific @arg address and @arg contracts
   *
   * @param {String} address - contract address from which has generated sources
   * @param {Object} contracts - AST of compiled contracts
   */


  getTotalAmountOfSources(address, contracts) {
    let sourcesLength = Object.keys(contracts).length;
    const generatedSources = this.getGeneratedSourcesFromAddress(address);
    if (generatedSources) sourcesLength = sourcesLength + Object.keys(generatedSources).length;
    return sourcesLength;
  }
  /**
   * Return a valid source location associated with the given @arg vmTraceIndex
   *
   * @param {String} address - contract address from which the source location is retrieved
   * @param {Int} vmtraceStepIndex - index of the current code in the vmtrace
   * @param {Object} contractDetails - AST of compiled contracts
   */


  getValidSourceLocationFromVMTraceIndex(address, vmtraceStepIndex, contracts) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const amountOfSources = this.getTotalAmountOfSources(address, contracts);
      let map = {
        file: -1
      };
      /*
        (map.file === -1) this indicates that it isn't associated with a known source code
        (map.file > amountOfSources - 1) this indicates the current file index exceed the total number of files.
                                                this happens when generated sources should not be considered.
      */

      while (vmtraceStepIndex >= 0 && (map.file === -1 || map.file > amountOfSources - 1)) {
        map = yield this.getSourceLocationFromVMTraceIndex(address, vmtraceStepIndex, contracts);
        vmtraceStepIndex = vmtraceStepIndex - 1;
      }

      return map;
    });
  }

  clearCache() {
    this.sourceMapByAddress = {};
  }

  getSourceMap(address, code, contracts) {
    const isCreation = traceHelper_1.isContractCreation(address);
    let bytes;

    for (const file in contracts) {
      for (const contract in contracts[file]) {
        const bytecode = contracts[file][contract].evm.bytecode;
        const deployedBytecode = contracts[file][contract].evm.deployedBytecode;
        if (!deployedBytecode) continue;
        bytes = isCreation ? bytecode.object : deployedBytecode.object;

        if (remix_lib_1.util.compareByteCode(code, '0x' + bytes)) {
          const generatedSources = isCreation ? bytecode.generatedSources : deployedBytecode.generatedSources;
          const map = isCreation ? bytecode.sourceMap : deployedBytecode.sourceMap;
          return {
            generatedSources,
            map
          };
        }
      }
    }

    return null;
  }

  extractSourceMap(self, codeManager, address, contracts) {
    return new Promise((resolve, reject) => {
      if (self.sourceMapByAddress[address]) return resolve(self.sourceMapByAddress[address]);
      codeManager.getCode(address).then(result => {
        const sourceMap = this.getSourceMap(address, result.bytecode, contracts);

        if (sourceMap) {
          if (!traceHelper_1.isContractCreation(address)) self.sourceMapByAddress[address] = sourceMap;
          return resolve(sourceMap);
        }

        reject(new Error('no sourcemap associated with the code ' + address));
      }).catch(reject);
    });
  }

}

exports.SourceLocationTracker = SourceLocationTracker;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/source/sourceMappingDecoder.js":
/*!*********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/source/sourceMappingDecoder.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const remix_astwalker_1 = __webpack_require__(/*! @remix-project/remix-astwalker */ "../../../dist/libs/remix-astwalker/index.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");
/**
 * Decompress the source mapping given by solc-bin.js
 * s:l:f:j
 */

/**
 * Decode the given @arg value
 *
 * @param {string} value      - source location to decode ( should be start:length:file )
 * @return {Object} returns the decompressed source mapping {start, length, file}
 */


function decode(value) {
  if (value) {
    value = value.split(':');
    return {
      start: parseInt(value[0]),
      length: parseInt(value[1]),
      file: parseInt(value[2])
    };
  }
}

exports.decode = decode;
/**
 * Decode the source mapping for the given compressed mapping
 *
 * @param {String} mapping     - compressed source mapping given by solc-bin
 * @return {Array} returns the decompressed source mapping. Array of {start, length, file, jump}
 */

function decompressAll(mapping) {
  const map = mapping.split(';');
  const ret = [];

  for (const k in map) {
    const compressed = map[k].split(':');
    const sourceMap = {
      start: compressed[0] ? parseInt(compressed[0]) : ret[ret.length - 1].start,
      length: compressed[1] ? parseInt(compressed[1]) : ret[ret.length - 1].length,
      file: compressed[2] ? parseInt(compressed[2]) : ret[ret.length - 1].file,
      jump: compressed[3] ? compressed[3] : ret[ret.length - 1].jump
    };
    ret.push(sourceMap);
  }

  return ret;
}

exports.decompressAll = decompressAll;
/**
  * Retrieve line/column position of each source char
  *
  * @param {String} source - contract source code
  * @return {Array} returns an array containing offset of line breaks
  */

function getLinebreakPositions(source) {
  const ret = [];

  for (let pos = source.indexOf('\n'); pos >= 0; pos = source.indexOf('\n', pos + 1)) {
    ret.push(pos);
  }

  return ret;
}

exports.getLinebreakPositions = getLinebreakPositions;
/**
 * Retrieve the line/column position for the given source mapping
 *
 * @param {Object} sourceLocation - object containing attributes {source} and {length}
 * @param {Array} lineBreakPositions - array returned by the function 'getLinebreakPositions'
 * @return {Object} returns an object {start: {line, column}, end: {line, column}} (line/column count start at 0)
 */

function convertOffsetToLineColumn(sourceLocation, lineBreakPositions) {
  if (sourceLocation.start >= 0 && sourceLocation.length >= 0) {
    return {
      start: convertFromCharPosition(sourceLocation.start, lineBreakPositions),
      end: convertFromCharPosition(sourceLocation.start + sourceLocation.length, lineBreakPositions)
    };
  }

  return {
    start: null,
    end: null
  };
}

exports.convertOffsetToLineColumn = convertOffsetToLineColumn;

function convertFromCharPosition(pos, lineBreakPositions) {
  let line = remix_lib_1.util.findLowerBound(pos, lineBreakPositions);

  if (lineBreakPositions[line] !== pos) {
    line = line + 1;
  }

  const beginColumn = line === 0 ? 0 : lineBreakPositions[line - 1] + 1;
  const column = pos - beginColumn;
  return {
    line,
    column
  };
}

function sourceLocationFromAstNode(astNode) {
  if (astNode.src) {
    const split = astNode.src.split(':');
    return {
      start: parseInt(split[0]),
      length: parseInt(split[1]),
      file: parseInt(split[2])
    };
  }

  return null;
}
/**
 * Retrieve the first @arg astNodeType that include the source map at arg instIndex
 *
 * @param {String} astNodeType - node type that include the source map instIndex
 * @param {String} instIndex - instruction index used to retrieve the source map
 * @param {String} sourceMap - source map given by the compilation result
 * @param {Object} ast - ast given by the compilation result
 */


function findNodeAtInstructionIndex(astNodeType, instIndex, sourceMap, ast) {
  const sourceLocation = this.atIndex(instIndex, sourceMap);
  return findNodeAtSourceLocation(astNodeType, sourceLocation, ast);
}

exports.findNodeAtInstructionIndex = findNodeAtInstructionIndex;

function findNodeAtSourceLocation(astNodeType, sourceLocation, ast) {
  const astWalker = new remix_astwalker_1.AstWalker();
  let found = null;

  const callback = function (node) {
    const nodeLocation = sourceLocationFromAstNode(node);

    if (!nodeLocation) {
      return;
    }

    if (nodeLocation.start <= sourceLocation.start && nodeLocation.start + nodeLocation.length >= sourceLocation.start + sourceLocation.length) {
      if (astNodeType === node.nodeType) {
        found = node;
      }
    }
  };

  astWalker.walkFull(ast.ast, callback);
  return found;
}
/**
 * get a list of nodes that are at the given @arg position
 *
 * @param {String} astNodeType      - type of node to return
 * @param {Int} position     - cursor position
 * @return {Object} ast object given by the compiler
 */


function nodesAtPosition(astNodeType, position, ast) {
  const astWalker = new remix_astwalker_1.AstWalker();
  const found = [];

  const callback = function (node) {
    var nodeLocation = sourceLocationFromAstNode(node);

    if (!nodeLocation) {
      return;
    }

    if (nodeLocation.start <= position && nodeLocation.start + nodeLocation.length >= position) {
      if (!astNodeType || astNodeType === node.nodeType) {
        found.push(node);
      }
    }
  };

  astWalker.walkFull(ast.ast, callback);
  return found;
}

exports.nodesAtPosition = nodesAtPosition;
/**
 * starts with the given @arg index and move backward until it can find all the values for start, length, file, jump
 * if `file === -1` then the value of the sourcemap should be taken from the previous step,
 * because some steps are internal subroutine for the compiler and doesn't link to any high level code.
 *
 * Solidity source maps format is
 *  - start:length:file:jump
 *  - jump can be 'i', 'o' or '-' (jump 'in' or 'out' of a function)
 *  - if no value is specified ( e.g "5:2" - no mention of 'file' and 'jump' ), actual values are the one of the step before
 *  - if the file (3rd value) has -1, the source maps should be discarded
 *
 *  @param Int index - index in the bytecode to decode source mapping from
 *  @param Array mapping - source maps returned by the compiler. e.g 121:3741:0:-:0;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;121:3741:0;;;;;;;
 *  @return Object { start, length, file, jump }
 */

function atIndex(index, mapping) {
  const ret = {};
  const map = mapping.split(';');

  if (index >= map.length) {
    index = map.length - 1;
  }

  for (let k = index; k >= 0; k--) {
    let current = map[k];

    if (!current.length) {
      continue;
    }

    current = current.split(':');

    if (ret['start'] === undefined && current[0] && current[0] !== '-1' && current[0].length) {
      ret['start'] = parseInt(current[0]);
    }

    if (ret['length'] === undefined && current[1] && current[1] !== '-1' && current[1].length) {
      ret['length'] = parseInt(current[1]);
    }

    if (ret['file'] === undefined && current[2] && current[2].length) {
      ret['file'] = parseInt(current[2]);
    }

    if (ret['jump'] === undefined && current[3] && current[3].length) {
      ret['jump'] = current[3];
    }

    if (ret['start'] !== undefined && ret['length'] !== undefined && ret['file'] !== undefined && ret['jump'] !== undefined) {
      break;
    }
  }

  return ret;
}

exports.atIndex = atIndex;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/storage/mappingPreimages.js":
/*!******************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/storage/mappingPreimages.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const util_1 = __webpack_require__(/*! ../solidity-decoder/types/util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");
/**
  * extract the mappings location from the storage
  * like { "<mapping_slot>" : { "<mapping-key1>": preimageOf1 }, { "<mapping-key2>": preimageOf2 }, ... }
  *
  * @param {Object} storage  - storage given by storage Viewer (basically a mapping hashedkey : {key, value})
  * @param {Array} corrections - used in case the calculated sha3 has been modifyed before SSTORE (notably used for struct in mapping).
  * @param {Function} callback  - calback
  * @return {Map} - solidity mapping location (e.g { "<mapping_slot>" : { "<mapping-key1>": preimageOf1 }, { "<mapping-key2>": preimageOf2 }, ... })
  */


function decodeMappingsKeys(web3, storage, corrections) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    const ret = {};
    if (!corrections.length) corrections.push({
      offset: 0,
      slot: 0
    });

    for (const hashedLoc in storage) {
      var preimage;

      try {
        const key = storage[hashedLoc].key;

        for (const k in corrections) {
          const corrected = util_1.sub(key, corrections[k].slot).toString(16);
          preimage = yield getPreimage(web3, '0x' + corrected);
          if (preimage) break;
        }
      } catch (e) {} // eslint-disable-line no-empty


      if (preimage) {
        // got preimage!
        // get mapping position (i.e. storage slot), its the last 32 bytes
        const slotByteOffset = preimage.length - 64;
        const mappingSlot = preimage.substr(slotByteOffset);
        const mappingKey = preimage.substr(0, slotByteOffset);

        if (!ret[mappingSlot]) {
          ret[mappingSlot] = {};
        }

        ret[mappingSlot][mappingKey] = preimage;
      }
    }

    return ret;
  });
}

exports.decodeMappingsKeys = decodeMappingsKeys;
/**
  * Uses web3 to return preimage of a key
  *
  * @param {String} key  - key to retrieve the preimage of
  * @return {String} - preimage of the given key
  */

function getPreimage(web3, key) {
  return new Promise((resolve, reject) => {
    web3.debug.preimage(key.indexOf('0x') === 0 ? key : '0x' + key, (error, preimage) => {
      if (error) {
        return resolve(null);
      }

      resolve(preimage);
    });
  });
}

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/storage/storageResolver.js":
/*!*****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/storage/storageResolver.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const traceHelper_1 = __webpack_require__(/*! ../trace/traceHelper */ "../../../dist/libs/remix-debug/src/trace/traceHelper.js");

const mappingPreimages_1 = __webpack_require__(/*! ./mappingPreimages */ "../../../dist/libs/remix-debug/src/storage/mappingPreimages.js");
/**
  * Basically one instance is created for one debugging session.
  * (TODO: one instance need to be shared over all the components)
  */


class StorageResolver {
  constructor(options) {
    this.storageByAddress = {};
    this.preimagesMappingByAddress = {};
    this.maxSize = 100;
    this.web3 = options.web3;
    this.zeroSlot = '0x0000000000000000000000000000000000000000000000000000000000000000';
  }
  /**
   * returns the storage for the given context (address and vm trace index)
   * returns the range 0x0 => this.maxSize
   *
   * @param {Object} - tx - transaction
   * @param {Int} - stepIndex - Index of the stop in the vm trace
   * @param {String} - address - lookup address
   * @param {Function} - callback - contains a map: [hashedKey] = {key, hashedKey, value}
   */


  storageRange(tx, stepIndex, address) {
    return this.storageRangeInternal(this, this.zeroSlot, tx, stepIndex, address);
  }
  /**
   * compute the mappgings type locations for the current address (cached for a debugging session)
   * note: that only retrieve the first 100 items.
   *
   * @param {Object} tx
   * @param {Int} stepIndex
   * @param {Object} address  - storage
   * @param {Array} corrections - used in case the calculated sha3 has been modifyed before SSTORE (notably used for struct in mapping).
   * @return {Function} - callback
   */


  initialPreimagesMappings(tx, stepIndex, address, corrections) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (this.preimagesMappingByAddress[address]) {
        return this.preimagesMappingByAddress[address];
      }

      const storage = yield this.storageRange(tx, stepIndex, address);
      const mappings = mappingPreimages_1.decodeMappingsKeys(this.web3, storage, corrections);
      this.preimagesMappingByAddress[address] = mappings;
      return mappings;
    });
  }
  /**
   * return a slot value for the given context (address and vm trace index)
   *
   * @param {String} - slot - slot key
   * @param {Object} - tx - transaction
   * @param {Int} - stepIndex - Index of the stop in the vm trace
   * @param {String} - address - lookup address
   * @param {Function} - callback - {key, hashedKey, value} -
   */


  storageSlot(slot, tx, stepIndex, address) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const storage = yield this.storageRangeInternal(this, slot, tx, stepIndex, address);
      return storage[slot] !== undefined ? storage[slot] : null;
    });
  }
  /**
   * return True if the storage at @arg address is complete
   *
   * @param {String} address  - contract address
   * @return {Bool} - return True if the storage at @arg address is complete
   */


  isComplete(address) {
    return this.storageByAddress[address] && this.storageByAddress[address].complete;
  }
  /**
   * retrieve the storage and ensure at least @arg slot is cached.
   * - If @arg slot is already cached, the storage will be returned from the cache
   *   even if the next 1000 items are not in the cache.
   * - If @arg slot is not cached, the corresponding value will be resolved and the next 1000 slots.
   */


  storageRangeInternal(self, slotKey, tx, stepIndex, address) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      var cached = this.fromCache(self, address);

      if (cached && cached.storage[slotKey]) {
        // we have the current slot in the cache and maybe the next 1000...
        return cached.storage;
      }

      const result = yield this.storageRangeWeb3Call(tx, address, slotKey, self.maxSize);
      const [storage, nextKey] = result;

      if (!storage[slotKey] && slotKey !== self.zeroSlot) {
        // we don't cache the zero slot (could lead to inconsistency)
        storage[slotKey] = {
          key: slotKey,
          value: self.zeroSlot
        };
      }

      self.toCache(self, address, storage);

      if (slotKey === self.zeroSlot && !nextKey) {
        // only working if keys are sorted !!
        self.storageByAddress[address].complete = true;
      }

      return storage;
    });
  }
  /**
   * retrieve the storage from the cache. if @arg slot is defined, return only the desired slot, if not return the entire known storage
   *
   * @param {String} address  - contract address
   * @return {String} - either the entire known storage or a single value
   */


  fromCache(self, address) {
    if (!self.storageByAddress[address]) {
      return null;
    }

    return self.storageByAddress[address];
  }
  /**
   * store the result of `storageRangeAtInternal`
   *
   * @param {String} address  - contract address
   * @param {Object} storage  - result of `storageRangeAtInternal`, contains {key, hashedKey, value}
   */


  toCache(self, address, storage) {
    if (!self.storageByAddress[address]) {
      self.storageByAddress[address] = {};
    }

    self.storageByAddress[address].storage = Object.assign(self.storageByAddress[address].storage || {}, storage);
  }

  storageRangeWeb3Call(tx, address, start, maxSize) {
    return new Promise((resolve, reject) => {
      if (traceHelper_1.isContractCreation(address)) {
        resolve([{}, null]);
      } else {
        this.web3.debug.storageRangeAt(tx.blockHash, tx.transactionIndex === undefined ? tx.hash : tx.transactionIndex, address, start, maxSize, (error, result) => {
          if (error) {
            reject(error);
          } else if (result.storage) {
            resolve([result.storage, result.nextKey]);
          } else {
            reject(new Error('the storage has not been provided'));
          }
        });
      }
    });
  }

}

exports.StorageResolver = StorageResolver;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/storage/storageViewer.js":
/*!***************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/storage/storageViewer.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

const mappingPreimages_1 = __webpack_require__(/*! ./mappingPreimages */ "../../../dist/libs/remix-debug/src/storage/mappingPreimages.js");
/**
   * easier access to the storage resolver
   * Basically one instance is created foreach execution step and foreach component that need it.
   * (TODO: one instance need to be shared over all the components)
   */


class StorageViewer {
  constructor(_context, _storageResolver, _traceManager) {
    this.context = _context;
    this.storageResolver = _storageResolver;
    this.web3 = this.storageResolver.web3;
    this.initialMappingsLocationPromise = null;
    this.currentMappingsLocationPromise = null;
    this.storageChanges = _traceManager.accumulateStorageChanges(this.context.stepIndex, this.context.address, {});
  }
  /**
    * return the storage for the current context (address and vm trace index)
    * by default now returns the range 0 => 1000
    *
    * @param {Function} - callback - contains a map: [hashedKey] = {key, hashedKey, value}
    */


  storageRange() {
    return new Promise((resolve, reject) => {
      this.storageResolver.storageRange(this.context.tx, this.context.stepIndex, this.context.address).then(storage => {
        resolve(Object.assign({}, storage, this.storageChanges));
      }).catch(reject);
    });
  }
  /**
    * return a slot value for the current context (address and vm trace index)
    * @param {String} - slot - slot key (not hashed key!)
    * @param {Function} - callback - {key, hashedKey, value} -
    */


  storageSlot(slot, callback) {
    const hashed = remix_lib_1.util.sha3_256(slot);

    if (this.storageChanges[hashed]) {
      return callback(null, this.storageChanges[hashed]);
    }

    this.storageResolver.storageSlot(hashed, this.context.tx, this.context.stepIndex, this.context.address).then(storage => {
      callback(null, storage);
    }).catch(callback);
  }
  /**
    * return True if the storage at @arg address is complete
    *
    * @param {String} address  - contract address
    * @return {Bool} - return True if the storage at @arg address is complete
    */


  isComplete(address) {
    return this.storageResolver.isComplete(address);
  }
  /**
    * return all the possible mappings locations for the current context (cached) do not return state changes during the current transaction
    *
    * @param {Array} corrections - used in case the calculated sha3 has been modifyed before SSTORE (notably used for struct in mapping).
    */


  initialMappingsLocation(corrections) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.initialMappingsLocationPromise) {
        this.initialMappingsLocationPromise = this.storageResolver.initialPreimagesMappings(this.context.tx, this.context.stepIndex, this.context.address, corrections);
      }

      return this.initialMappingsLocationPromise;
    });
  }
  /**
    * return all the possible mappings locations for the current context (cached) and current mapping slot. returns state changes during the current transaction
    *
    * @param {Array} corrections - used in case the calculated sha3 has been modifyed before SSTORE (notably used for struct in mapping).
    */


  mappingsLocation(corrections) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.currentMappingsLocationPromise) {
        this.currentMappingsLocationPromise = new Promise((resolve, reject) => {
          const mappingsLocationChanges = this.extractMappingsLocationChanges(this.storageChanges, corrections);
          return resolve(mappingsLocationChanges);
        });
      }

      return this.currentMappingsLocationPromise;
    });
  }
  /**
    * retrieve mapping location changes from the storage changes.
    * @param {Map} storageChanges
    * @param {Array} corrections - used in case the calculated sha3 has been modifyed before SSTORE (notably used for struct in mapping).
    */


  extractMappingsLocationChanges(storageChanges, corrections) {
    if (this.mappingsLocationChanges) {
      return this.mappingsLocationChanges;
    }

    const mappings = mappingPreimages_1.decodeMappingsKeys(this.web3, storageChanges, corrections);
    this.mappingsLocationChanges = mappings;
    return this.mappingsLocationChanges;
  }

}

exports.StorageViewer = StorageViewer;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/trace/traceAnalyser.js":
/*!*************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/trace/traceAnalyser.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const traceHelper = tslib_1.__importStar(__webpack_require__(/*! ./traceHelper */ "../../../dist/libs/remix-debug/src/trace/traceHelper.js"));

class TraceAnalyser {
  constructor(_cache) {
    this.traceCache = _cache;
    this.trace = null;
  }

  analyse(trace, tx) {
    this.trace = trace;
    this.traceCache.pushStoreChanges(0, tx.to);
    let context = {
      storageContext: [tx.to],
      currentCallIndex: 0,
      lastCallIndex: 0
    };
    const callStack = [tx.to];
    this.traceCache.pushCall(trace[0], 0, callStack[0], callStack.slice(0));

    if (traceHelper.isContractCreation(tx.to)) {
      this.traceCache.pushContractCreation(tx.to, tx.input);
    }

    this.buildCalldata(0, this.trace[0], tx, true);

    for (let k = 0; k < this.trace.length; k++) {
      const step = this.trace[k];
      this.buildMemory(k, step);
      context = this.buildDepth(k, step, tx, callStack, context);
      context = this.buildStorage(k, step, context);
      this.buildReturnValues(k, step);
    }

    return true;
  }

  buildReturnValues(index, step) {
    if (traceHelper.isReturnInstruction(step)) {
      let offset = 2 * parseInt(step.stack[step.stack.length - 1], 16);
      const size = 2 * parseInt(step.stack[step.stack.length - 2], 16);
      const memory = this.trace[this.traceCache.memoryChanges[this.traceCache.memoryChanges.length - 1]].memory;
      const noOfReturnParams = size / 64;
      const memoryInString = memory.join('');
      const returnParamsObj = [];

      for (let i = 0; i < noOfReturnParams; i++) {
        returnParamsObj.push('0x' + memoryInString.substring(offset, offset + 64));
        offset += 64;
      }

      this.traceCache.pushReturnValue(index, returnParamsObj);
    }
  }

  buildCalldata(index, step, tx, newContext) {
    let calldata = '';

    if (index === 0) {
      calldata = tx.input;
      this.traceCache.pushCallDataChanges(index, calldata);
    } else if (!newContext) {
      const lastCall = this.traceCache.callsData[this.traceCache.callDataChanges[this.traceCache.callDataChanges.length - 2]];
      this.traceCache.pushCallDataChanges(index + 1, lastCall);
    } else {
      const memory = this.trace[this.traceCache.memoryChanges[this.traceCache.memoryChanges.length - 1]].memory;
      const callStep = this.trace[index];
      const stack = callStep.stack;
      let offset = 0;
      let size = 0;

      if (callStep.op === 'DELEGATECALL') {
        offset = 2 * parseInt(stack[stack.length - 3], 16);
        size = 2 * parseInt(stack[stack.length - 4], 16);
      } else {
        offset = 2 * parseInt(stack[stack.length - 4], 16);
        size = 2 * parseInt(stack[stack.length - 5], 16);
      }

      calldata = '0x' + memory.join('').substr(offset, size);
      this.traceCache.pushCallDataChanges(index + 1, calldata);
    }
  }

  buildMemory(index, step) {
    if (step.memory) {
      this.traceCache.pushMemoryChanges(index);
    }
  }

  buildStorage(index, step, context) {
    if (traceHelper.newContextStorage(step) && !traceHelper.isCallToPrecompiledContract(index, this.trace)) {
      const calledAddress = traceHelper.resolveCalledAddress(index, this.trace);

      if (calledAddress) {
        context.storageContext.push(calledAddress);
      } else {
        console.log('unable to build storage changes. ' + index + ' does not match with a CALL. storage changes will be corrupted');
      }

      this.traceCache.pushStoreChanges(index + 1, context.storageContext[context.storageContext.length - 1]);
    } else if (traceHelper.isSSTOREInstruction(step)) {
      this.traceCache.pushStoreChanges(index + 1, context.storageContext[context.storageContext.length - 1], step.stack[step.stack.length - 1], step.stack[step.stack.length - 2]);
    } else if (traceHelper.isReturnInstruction(step) || traceHelper.isStopInstruction(step)) {
      context.storageContext.pop();
      this.traceCache.pushStoreChanges(index + 1, context.storageContext[context.storageContext.length - 1]);
    } else if (traceHelper.isRevertInstruction(step)) {
      context.storageContext.pop();
      this.traceCache.resetStoreChanges();
    }

    return context;
  }

  buildDepth(index, step, tx, callStack, context) {
    if (traceHelper.isCallInstruction(step) && !traceHelper.isCallToPrecompiledContract(index, this.trace)) {
      let newAddress;

      if (traceHelper.isCreateInstruction(step)) {
        newAddress = traceHelper.contractCreationToken(index);
        callStack.push(newAddress);
        const lastMemoryChange = this.traceCache.memoryChanges[this.traceCache.memoryChanges.length - 1];
        this.traceCache.pushContractCreationFromMemory(index, newAddress, this.trace, lastMemoryChange);
      } else {
        newAddress = traceHelper.resolveCalledAddress(index, this.trace);

        if (newAddress) {
          callStack.push(newAddress);
        } else {
          console.log('unable to build depth changes. ' + index + ' does not match with a CALL. depth changes will be corrupted');
        }
      }

      this.traceCache.pushCall(step, index + 1, newAddress, callStack.slice(0));
      this.buildCalldata(index, step, tx, true);
      this.traceCache.pushSteps(index, context.currentCallIndex);
      context.lastCallIndex = context.currentCallIndex;
      context.currentCallIndex = 0;
    } else if (traceHelper.isReturnInstruction(step) || traceHelper.isStopInstruction(step) || step.error || step.invalidDepthChange) {
      if (index < this.trace.length) {
        callStack.pop();
        this.traceCache.pushCall(step, index + 1, null, callStack.slice(0), step.error || step.invalidDepthChange);
        this.buildCalldata(index, step, tx, false);
        this.traceCache.pushSteps(index, context.currentCallIndex);
        context.currentCallIndex = context.lastCallIndex + 1;
      }
    } else {
      this.traceCache.pushSteps(index, context.currentCallIndex);
      context.currentCallIndex++;
    }

    return context;
  }

}

exports.TraceAnalyser = TraceAnalyser;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/trace/traceCache.js":
/*!**********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/trace/traceCache.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

const {
  sha3_256
} = remix_lib_1.util;

class TraceCache {
  constructor() {
    this.init();
  }

  init() {
    // ...Changes contains index in the vmtrace of the corresponding changes
    this.returnValues = {};
    this.currentCall = null;
    this.callsTree = null;
    this.callsData = {};
    this.contractCreation = {};
    this.steps = {};
    this.addresses = [];
    this.callDataChanges = [];
    this.memoryChanges = [];
    this.storageChanges = [];
    this.sstore = {}; // all sstore occurence in the trace
  }

  pushSteps(index, currentCallIndex) {
    this.steps[index] = currentCallIndex;
  }

  pushCallDataChanges(value, calldata) {
    this.callDataChanges.push(value);
    this.callsData[value] = calldata;
  }

  pushMemoryChanges(value) {
    this.memoryChanges.push(value);
  } // outOfGas has been removed because gas left logging is apparently made differently
  // in the vm/geth/eth. TODO add the error property (with about the error in all clients)


  pushCall(step, index, address, callStack, reverted) {
    const validReturnStep = step.op === 'RETURN' || step.op === 'STOP';

    if ((validReturnStep || reverted) && this.currentCall) {
      this.currentCall.call.return = index - 1;

      if (!validReturnStep) {
        this.currentCall.call.reverted = reverted;
      }

      var parent = this.currentCall.parent;
      this.currentCall = parent ? {
        call: parent.call,
        parent: parent.parent
      } : null;
      return;
    }

    const call = {
      op: step.op,
      address: address,
      callStack: callStack,
      calls: {},
      start: index
    };
    this.addresses.push(address);

    if (this.currentCall) {
      this.currentCall.call.calls[index] = call;
    } else {
      this.callsTree = {
        call: call
      };
    }

    this.currentCall = {
      call: call,
      parent: this.currentCall
    };
  }

  pushReturnValue(step, value) {
    this.returnValues[step] = value;
  }

  pushContractCreationFromMemory(index, token, trace, lastMemoryChange) {
    const memory = trace[lastMemoryChange].memory;
    const stack = trace[index].stack;
    const offset = 2 * parseInt(stack[stack.length - 2], 16);
    const size = 2 * parseInt(stack[stack.length - 3], 16);
    this.contractCreation[token] = '0x' + memory.join('').substr(offset, size);
  }

  pushContractCreation(token, code) {
    this.contractCreation[token] = code;
  }

  resetStoreChanges(index, address, key, value) {
    this.sstore = {};
    this.storageChanges = [];
  }

  pushStoreChanges(index, address, key, value) {
    this.sstore[index] = {
      address: address,
      key: key,
      value: value,
      hashedKey: sha3_256(key)
    };
    this.storageChanges.push(index);
  }

  accumulateStorageChanges(index, address, storage) {
    const ret = Object.assign({}, storage);

    for (var k in this.storageChanges) {
      const changesIndex = this.storageChanges[k];

      if (changesIndex > index) {
        return ret;
      }

      var sstore = this.sstore[changesIndex];

      if (sstore.address === address && sstore.key) {
        ret[sstore.hashedKey] = {
          key: sstore.key,
          value: sstore.value
        };
      }
    }

    return ret;
  }

}

exports.TraceCache = TraceCache;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/trace/traceHelper.js":
/*!***********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/trace/traceHelper.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

const {
  ui
} = remix_lib_1.helpers; // vmTraceIndex has to point to a CALL, CODECALL, ...

function resolveCalledAddress(vmTraceIndex, trace) {
  const step = trace[vmTraceIndex];

  if (isCreateInstruction(step)) {
    return contractCreationToken(vmTraceIndex);
  } else if (isCallInstruction(step)) {
    const stack = step.stack; // callcode, delegatecall, ...

    return ui.normalizeHexAddress(stack[stack.length - 2]);
  }

  return undefined;
}

exports.resolveCalledAddress = resolveCalledAddress;

function isCallInstruction(step) {
  return ['CALL', 'STATICCALL', 'CALLCODE', 'CREATE', 'DELEGATECALL'].includes(step.op);
}

exports.isCallInstruction = isCallInstruction;

function isCreateInstruction(step) {
  return step.op === 'CREATE';
}

exports.isCreateInstruction = isCreateInstruction;

function isReturnInstruction(step) {
  return step.op === 'RETURN';
}

exports.isReturnInstruction = isReturnInstruction;

function isJumpDestInstruction(step) {
  return step.op === 'JUMPDEST';
}

exports.isJumpDestInstruction = isJumpDestInstruction;

function isStopInstruction(step) {
  return step.op === 'STOP';
}

exports.isStopInstruction = isStopInstruction;

function isRevertInstruction(step) {
  return step.op === 'REVERT';
}

exports.isRevertInstruction = isRevertInstruction;

function isSSTOREInstruction(step) {
  return step.op === 'SSTORE';
}

exports.isSSTOREInstruction = isSSTOREInstruction;

function isSHA3Instruction(step) {
  return step.op === 'SHA3';
}

exports.isSHA3Instruction = isSHA3Instruction;

function newContextStorage(step) {
  return step.op === 'CREATE' || step.op === 'CALL';
}

exports.newContextStorage = newContextStorage;

function isCallToPrecompiledContract(index, trace) {
  // if stack empty => this is not a precompiled contract
  const step = trace[index];

  if (this.isCallInstruction(step)) {
    return index + 1 < trace.length && trace[index + 1].stack.length !== 0;
  }

  return false;
}

exports.isCallToPrecompiledContract = isCallToPrecompiledContract;

function contractCreationToken(index) {
  return '(Contract Creation - Step ' + index + ')';
}

exports.contractCreationToken = contractCreationToken;

function isContractCreation(address) {
  return address.indexOf('(Contract Creation - Step') !== -1;
}

exports.isContractCreation = isContractCreation;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/trace/traceManager.js":
/*!************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/trace/traceManager.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const traceAnalyser_1 = __webpack_require__(/*! ./traceAnalyser */ "../../../dist/libs/remix-debug/src/trace/traceAnalyser.js");

const traceCache_1 = __webpack_require__(/*! ./traceCache */ "../../../dist/libs/remix-debug/src/trace/traceCache.js");

const traceStepManager_1 = __webpack_require__(/*! ./traceStepManager */ "../../../dist/libs/remix-debug/src/trace/traceStepManager.js");

const traceHelper_1 = __webpack_require__(/*! ./traceHelper */ "../../../dist/libs/remix-debug/src/trace/traceHelper.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

class TraceManager {
  constructor(options) {
    this.web3 = options.web3;
    this.isLoading = false;
    this.trace = null;
    this.traceCache = new traceCache_1.TraceCache();
    this.traceAnalyser = new traceAnalyser_1.TraceAnalyser(this.traceCache);
    this.traceStepManager = new traceStepManager_1.TraceStepManager(this.traceAnalyser);
  } // init section


  resolveTrace(tx) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      this.tx = tx;
      this.init();
      if (!this.web3) throw new Error('web3 not loaded');
      this.isLoading = true;

      try {
        const result = yield this.getTrace(tx.hash);

        if (result['structLogs'].length > 0) {
          this.trace = result['structLogs'];
          this.traceAnalyser.analyse(result['structLogs'], tx);
          this.isLoading = false;
          return true;
        }

        var mes = tx.hash + ' is not a contract invocation or contract creation.';
        console.log(mes);
        this.isLoading = false;
        throw new Error(mes);
      } catch (error) {
        console.log(error);
        this.isLoading = false;
        throw new Error(error);
      }
    });
  }

  getTrace(txHash) {
    return new Promise((resolve, reject) => {
      const options = {
        disableStorage: true,
        disableMemory: false,
        disableStack: false,
        fullStorage: false
      };
      this.web3.debug.traceTransaction(txHash, options, function (error, result) {
        if (error) return reject(error);
        resolve(result);
      });
    });
  }

  init() {
    this.trace = null;
    this.traceCache.init();
  } // API section


  inRange(step) {
    return this.isLoaded() && step >= 0 && step < this.trace.length;
  }

  isLoaded() {
    return !this.isLoading && this.trace !== null;
  }

  getLength(callback) {
    if (!this.trace) {
      callback(new Error('no trace available'), null);
    } else {
      callback(null, this.trace.length);
    }
  }

  accumulateStorageChanges(index, address, storageOrigin) {
    return this.traceCache.accumulateStorageChanges(index, address, storageOrigin);
  }

  getAddresses() {
    return this.traceCache.addresses;
  }

  getCallDataAt(stepIndex) {
    try {
      this.checkRequestedStep(stepIndex);
    } catch (check) {
      throw new Error(check);
    }

    const callDataChange = remix_lib_1.util.findLowerBoundValue(stepIndex, this.traceCache.callDataChanges);

    if (callDataChange === null) {
      throw new Error('no calldata found');
    }

    return [this.traceCache.callsData[callDataChange]];
  }

  buildCallPath(stepIndex) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      try {
        this.checkRequestedStep(stepIndex);
      } catch (check) {
        throw new Error(check);
      }

      const callsPath = remix_lib_1.util.buildCallPath(stepIndex, this.traceCache.callsTree.call);
      if (callsPath === null) throw new Error('no call path built');
      return callsPath;
    });
  }

  getCallStackAt(stepIndex) {
    try {
      this.checkRequestedStep(stepIndex);
    } catch (check) {
      throw new Error(check);
    }

    const call = remix_lib_1.util.findCall(stepIndex, this.traceCache.callsTree.call);

    if (call === null) {
      throw new Error('no callstack found');
    }

    return call.callStack;
  }

  getStackAt(stepIndex) {
    this.checkRequestedStep(stepIndex);

    if (this.trace[stepIndex] && this.trace[stepIndex].stack) {
      // there's always a stack
      const stack = this.trace[stepIndex].stack.slice(0);
      stack.reverse();
      return stack;
    } else {
      throw new Error('no stack found');
    }
  }

  getLastCallChangeSince(stepIndex) {
    try {
      this.checkRequestedStep(stepIndex);
    } catch (check) {
      throw new Error(check);
    }

    const callChange = remix_lib_1.util.findCall(stepIndex, this.traceCache.callsTree.call);

    if (callChange === null) {
      return 0;
    }

    return callChange;
  }

  getCurrentCalledAddressAt(stepIndex) {
    try {
      this.checkRequestedStep(stepIndex);
      const resp = this.getLastCallChangeSince(stepIndex);

      if (!resp) {
        throw new Error('unable to get current called address. ' + stepIndex + ' does not match with a CALL');
      }

      return resp.address;
    } catch (error) {
      throw new Error(error);
    }
  }

  getContractCreationCode(token) {
    if (!this.traceCache.contractCreation[token]) {
      throw new Error('no contract creation named ' + token);
    }

    return this.traceCache.contractCreation[token];
  }

  getMemoryAt(stepIndex) {
    this.checkRequestedStep(stepIndex);
    const lastChanges = remix_lib_1.util.findLowerBoundValue(stepIndex, this.traceCache.memoryChanges);

    if (lastChanges === null) {
      throw new Error('no memory found');
    }

    return this.trace[lastChanges].memory;
  }

  getCurrentPC(stepIndex) {
    try {
      this.checkRequestedStep(stepIndex);
    } catch (check) {
      throw new Error(check);
    }

    return this.trace[stepIndex].pc;
  }

  getReturnValue(stepIndex) {
    try {
      this.checkRequestedStep(stepIndex);
    } catch (check) {
      throw new Error(check);
    }

    if (!this.traceCache.returnValues[stepIndex]) {
      throw new Error('current step is not a return step');
    }

    return this.traceCache.returnValues[stepIndex];
  }

  getCurrentStep(stepIndex) {
    try {
      this.checkRequestedStep(stepIndex);
    } catch (check) {
      throw new Error(check);
    }

    return this.traceCache.steps[stepIndex];
  }

  getMemExpand(stepIndex) {
    return this.getStepProperty(stepIndex, 'memexpand') || '';
  }

  getStepCost(stepIndex) {
    return this.getStepProperty(stepIndex, 'gasCost');
  }

  getRemainingGas(stepIndex) {
    return this.getStepProperty(stepIndex, 'gas');
  }

  getStepProperty(stepIndex, property) {
    try {
      this.checkRequestedStep(stepIndex);
    } catch (check) {
      throw new Error(check);
    }

    return this.trace[stepIndex][property];
  }

  isCreationStep(stepIndex) {
    return traceHelper_1.isCreateInstruction(this.trace[stepIndex]);
  } // step section


  findStepOverBack(currentStep) {
    return this.traceStepManager.findStepOverBack(currentStep);
  }

  findStepOverForward(currentStep) {
    return this.traceStepManager.findStepOverForward(currentStep);
  }

  findNextCall(currentStep) {
    return this.traceStepManager.findNextCall(currentStep);
  }

  findStepOut(currentStep) {
    return this.traceStepManager.findStepOut(currentStep);
  }

  checkRequestedStep(stepIndex) {
    if (!this.trace) {
      throw new Error('trace not loaded');
    } else if (stepIndex >= this.trace.length) {
      throw new Error('trace smaller than requested');
    }
  }

  waterfall(calls, stepindex, cb) {
    const ret = [];
    let retError = null;

    for (var call in calls) {
      calls[call].apply(this, [stepindex, function (error, result) {
        retError = error;
        ret.push({
          error: error,
          value: result
        });
      }]);
    }

    cb(retError, ret);
  }

}

exports.TraceManager = TraceManager;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/trace/traceStepManager.js":
/*!****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/trace/traceStepManager.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const traceHelper_1 = __webpack_require__(/*! ./traceHelper */ "../../../dist/libs/remix-debug/src/trace/traceHelper.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

class TraceStepManager {
  constructor(_traceAnalyser) {
    this.traceAnalyser = _traceAnalyser;
  }

  isCallInstruction(index) {
    const state = this.traceAnalyser.trace[index];
    return traceHelper_1.isCallInstruction(state) && !traceHelper_1.isCallToPrecompiledContract(index, this.traceAnalyser.trace);
  }

  isReturnInstruction(index) {
    const state = this.traceAnalyser.trace[index];
    return traceHelper_1.isReturnInstruction(state);
  }

  findStepOverBack(currentStep) {
    if (this.isReturnInstruction(currentStep)) {
      const call = remix_lib_1.util.findCall(currentStep, this.traceAnalyser.traceCache.callsTree.call);
      return call.start > 0 ? call.start - 1 : 0;
    }

    return currentStep > 0 ? currentStep - 1 : 0;
  }

  findStepOverForward(currentStep) {
    if (this.isCallInstruction(currentStep)) {
      const call = remix_lib_1.util.findCall(currentStep + 1, this.traceAnalyser.traceCache.callsTree.call);
      return call.return + 1 < this.traceAnalyser.trace.length ? call.return + 1 : this.traceAnalyser.trace.length - 1;
    }

    return this.traceAnalyser.trace.length >= currentStep + 1 ? currentStep + 1 : currentStep;
  }

  findNextCall(currentStep) {
    const call = remix_lib_1.util.findCall(currentStep, this.traceAnalyser.traceCache.callsTree.call);
    const subCalls = Object.keys(call.calls);

    if (subCalls.length) {
      var callStart = remix_lib_1.util.findLowerBound(currentStep, subCalls) + 1;

      if (subCalls.length > callStart) {
        return parseInt(subCalls[callStart]) - 1;
      }

      return currentStep;
    }

    return currentStep;
  }

  findStepOut(currentStep) {
    const call = remix_lib_1.util.findCall(currentStep, this.traceAnalyser.traceCache.callsTree.call);
    return call.return;
  }

}

exports.TraceStepManager = TraceStepManager;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/eventManager.js":
/*!****************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/eventManager.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class EventManager {
  constructor() {
    this.registered = {};
    this.anonymous = {};
  }
  /*
    * Unregister a listener.
    * Note that if obj is a function. the unregistration will be applied to the dummy obj {}.
    *
    * @param {String} eventName  - the event name
    * @param {Object or Func} obj - object that will listen on this event
    * @param {Func} func         - function of the listeners that will be executed
  */


  unregister(eventName, obj, func) {
    if (!this.registered[eventName]) {
      return;
    }

    if (obj instanceof Function) {
      func = obj;
      obj = this.anonymous;
    }

    for (const reg in this.registered[eventName]) {
      if (this.registered[eventName][reg].obj === obj && this.registered[eventName][reg].func.toString() === func.toString()) {
        this.registered[eventName].splice(reg, 1);
      }
    }
  }
  /*
    * Register a new listener.
    * Note that if obj is a function, the function registration will be associated with the dummy object {}
    *
    * @param {String} eventName  - the event name
    * @param {Object or Func} obj - object that will listen on this event
    * @param {Func} func         - function of the listeners that will be executed
  */


  register(eventName, obj, func) {
    if (!this.registered[eventName]) {
      this.registered[eventName] = [];
    }

    if (obj instanceof Function) {
      func = obj;
      obj = this.anonymous;
    }

    this.registered[eventName].push({
      obj,
      func
    });
  }
  /*
    * trigger event.
    * Every listener have their associated function executed
    *
    * @param {String} eventName  - the event name
    * @param {Array}j - argument that will be passed to the executed function.
  */


  trigger(eventName, args) {
    if (!this.registered[eventName]) {
      return;
    }

    for (const listener in this.registered[eventName]) {
      const l = this.registered[eventName][listener];
      l.func.apply(l.obj === this.anonymous ? {} : l.obj, args);
    }
  }

}

exports.EventManager = EventManager;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/eventsDecoder.js":
/*!***************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/eventsDecoder.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const ethers_1 = __webpack_require__(/*! ethers */ "../../../node_modules/ethers/dist/ethers.umd.js");

const txHelper_1 = __webpack_require__(/*! ./txHelper */ "../../../dist/libs/remix-lib/src/execution/txHelper.js");
/**
  * Register to txListener and extract events
  *
  */


class EventsDecoder {
  constructor({
    resolveReceipt
  }) {
    this.resolveReceipt = resolveReceipt;
  }
  /**
  * use Transaction Receipt to decode logs. assume that the transaction as already been resolved by txListener.
  * logs are decoded only if the contract if known by remix.
  *
  * @param {Object} tx - transaction object
  * @param {Function} cb - callback
  */


  parseLogs(tx, contractName, compiledContracts, cb) {
    if (tx.isCall) return cb(null, {
      decoded: [],
      raw: []
    });
    this.resolveReceipt(tx, (error, receipt) => {
      if (error) return cb(error);

      this._decodeLogs(tx, receipt, contractName, compiledContracts, cb);
    });
  }

  _decodeLogs(tx, receipt, contract, contracts, cb) {
    if (!contract || !receipt) {
      return cb('cannot decode logs - contract or receipt not resolved ');
    }

    if (!receipt.logs) {
      return cb(null, {
        decoded: [],
        raw: []
      });
    }

    this._decodeEvents(tx, receipt.logs, contract, contracts, cb);
  }

  _eventABI(contract) {
    const eventABI = {};
    const abi = new ethers_1.ethers.utils.Interface(contract.abi);

    for (const e in abi.events) {
      const event = abi.getEvent(e);
      eventABI[abi.getEventTopic(e).replace('0x', '')] = {
        event: event.name,
        inputs: event.inputs,
        object: event,
        abi: abi
      };
    }

    return eventABI;
  }

  _eventsABI(compiledContracts) {
    const eventsABI = {};
    txHelper_1.visitContracts(compiledContracts, contract => {
      eventsABI[contract.name] = this._eventABI(contract.object);
    });
    return eventsABI;
  }

  _event(hash, eventsABI) {
    for (const k in eventsABI) {
      if (eventsABI[k][hash]) {
        const event = eventsABI[k][hash];

        for (const input of event.inputs) {
          if (input.type === 'function') {
            input.type = 'bytes24';
            input.baseType = 'bytes24';
          }
        }

        return event;
      }
    }

    return null;
  }

  _stringifyBigNumber(value) {
    return value._isBigNumber ? value.toString() : value;
  }

  _stringifyEvent(value) {
    if (value === null || value === undefined) return ' - ';
    if (value._ethersType) value.type = value._ethersType;

    if (Array.isArray(value)) {
      // for struct && array
      return value.map(item => {
        return this._stringifyEvent(item);
      });
    } else {
      return this._stringifyBigNumber(value);
    }
  }

  _decodeEvents(tx, logs, contractName, compiledContracts, cb) {
    const eventsABI = this._eventsABI(compiledContracts);

    const events = [];

    for (const i in logs) {
      // [address, topics, mem]
      const log = logs[i];
      const topicId = log.topics[0];

      const eventAbi = this._event(topicId.replace('0x', ''), eventsABI);

      if (eventAbi) {
        const decodedlog = eventAbi.abi.parseLog(log);
        const decoded = {};

        for (const v in decodedlog.args) {
          decoded[v] = this._stringifyEvent(decodedlog.args[v]);
        }

        events.push({
          from: log.address,
          topic: topicId,
          event: eventAbi.event,
          args: decoded
        });
      } else {
        events.push({
          from: log.address,
          data: log.data,
          topics: log.topics
        });
      }
    }

    cb(null, {
      decoded: events,
      raw: logs
    });
  }

}

exports.EventsDecoder = EventsDecoder;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/execution-context.js":
/*!*******************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/execution-context.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global ethereum */


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const web3_1 = tslib_1.__importDefault(__webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js"));

const eventManager_1 = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-lib/src/eventManager.js");

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const web3VmProvider_1 = __webpack_require__(/*! ../web3Provider/web3VmProvider */ "../../../dist/libs/remix-lib/src/web3Provider/web3VmProvider.js");

const logsManager_1 = __webpack_require__(/*! ./logsManager */ "../../../dist/libs/remix-lib/src/execution/logsManager.js");

const EthJSVM = __webpack_require__(/*! ethereumjs-vm */ "../../../node_modules/ethereumjs-vm/dist/index.js").default;

const StateManager = __webpack_require__(/*! ethereumjs-vm/dist/state/stateManager */ "../../../node_modules/ethereumjs-vm/dist/state/stateManager.js").default;

let web3;

if (typeof window !== 'undefined' && typeof window['ethereum'] !== 'undefined') {
  var injectedProvider = window['ethereum'];
  web3 = new web3_1.default(injectedProvider);
} else {
  web3 = new web3_1.default(new web3_1.default.providers.HttpProvider('http://localhost:8545'));
}
/*
  extend vm state manager and instanciate VM
*/


class StateManagerCommonStorageDump extends StateManager {
  constructor(arg) {
    super(arg);
    this.keyHashes = {};
  }

  putContractStorage(address, key, value, cb) {
    this.keyHashes[ethereumjs_util_1.keccak(key).toString('hex')] = ethereumjs_util_1.bufferToHex(key);
    super.putContractStorage(address, key, value, cb);
  }

  dumpStorage(address, cb) {
    this._getStorageTrie(address, (err, trie) => {
      if (err) {
        return cb(err);
      }

      const storage = {};
      const stream = trie.createReadStream();
      stream.on('data', val => {
        const value = ethereumjs_util_1.rlp.decode(val.value);
        storage['0x' + val.key.toString('hex')] = {
          key: this.keyHashes[val.key.toString('hex')],
          value: '0x' + value.toString('hex')
        };
      });
      stream.on('end', function () {
        cb(storage);
      });
    });
  }

  getStateRoot(cb) {
    const checkpoint = this._checkpointCount;
    this._checkpointCount = 0;
    super.getStateRoot((err, stateRoot) => {
      this._checkpointCount = checkpoint;
      cb(err, stateRoot);
    });
  }

  setStateRoot(stateRoot, cb) {
    const checkpoint = this._checkpointCount;
    this._checkpointCount = 0;
    super.setStateRoot(stateRoot, err => {
      this._checkpointCount = checkpoint;
      cb(err);
    });
  }

}
/*
  trigger contextChanged, web3EndpointChanged
*/


class ExecutionContext {
  constructor() {
    this.event = new eventManager_1.EventManager();
    this.logsManager = new logsManager_1.LogsManager();
    this.executionContext = null;
    this.blockGasLimitDefault = 4300000;
    this.blockGasLimit = this.blockGasLimitDefault;
    this.currentFork = 'muirGlacier';
    this.vms = {
      /*
      byzantium: createVm('byzantium'),
      constantinople: createVm('constantinople'),
      petersburg: createVm('petersburg'),
      istanbul: createVm('istanbul'),
      */
      muirGlacier: this.createVm('muirGlacier')
    };
    this.mainNetGenesisHash = '0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3';
    this.customNetWorks = {};
    this.blocks = {};
    this.latestBlockNumber = 0;
    this.txs = {};
  }

  init(config) {
    if (config.get('settings/always-use-vm')) {
      this.executionContext = 'vm';
    } else {
      this.executionContext = injectedProvider ? 'injected' : 'vm';
      if (this.executionContext === 'injected') this.askPermission();
    }
  }

  createVm(hardfork) {
    const stateManager = new StateManagerCommonStorageDump({});
    stateManager.checkpoint(() => {});
    const vm = new EthJSVM({
      activatePrecompiles: true,
      blockchain: stateManager.blockchain,
      stateManager: stateManager,
      hardfork: hardfork
    });
    vm.blockchain.validate = false;
    const web3vm = new web3VmProvider_1.Web3VmProvider();
    web3vm.setVM(vm);
    return {
      vm,
      web3vm,
      stateManager
    };
  }

  askPermission() {
    // metamask
    if (ethereum && typeof ethereum.enable === 'function') ethereum.enable();
  }

  getProvider() {
    return this.executionContext;
  }

  isVM() {
    return this.executionContext === 'vm';
  }

  web3() {
    return this.isVM() ? this.vms[this.currentFork].web3vm : web3;
  }

  detectNetwork(callback) {
    if (this.isVM()) {
      callback(null, {
        id: '-',
        name: 'VM'
      });
    } else {
      web3.eth.net.getId((err, id) => {
        let name = null;
        if (err) name = 'Unknown'; // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md
        else if (id === 1) name = 'Main';else if (id === 2) name = 'Morden (deprecated)';else if (id === 3) name = 'Ropsten';else if (id === 4) name = 'Rinkeby';else if (id === 5) name = 'Goerli';else if (id === 42) name = 'Kovan';else name = 'Custom';

        if (id === '1') {
          web3.eth.getBlock(0, (error, block) => {
            if (error) console.log('cant query first block');
            if (block && block.hash !== this.mainNetGenesisHash) name = 'Custom';
            callback(err, {
              id,
              name
            });
          });
        } else {
          callback(err, {
            id,
            name
          });
        }
      });
    }
  }

  removeProvider(name) {
    if (name && this.customNetWorks[name]) {
      if (this.executionContext === name) this.setContext('vm', null, null, null);
      delete this.customNetWorks[name];
      this.event.trigger('removeProvider', [name]);
    }
  }

  addProvider(network) {
    if (network && network.name && !this.customNetWorks[network.name]) {
      this.customNetWorks[network.name] = network;
      this.event.trigger('addProvider', [network]);
    }
  }

  internalWeb3() {
    return web3;
  }

  blankWeb3() {
    return new web3_1.default();
  }

  vm() {
    return this.vms[this.currentFork].vm;
  }

  setContext(context, endPointUrl, confirmCb, infoCb) {
    this.executionContext = context;
    this.executionContextChange(context, endPointUrl, confirmCb, infoCb, null);
  }

  executionContextChange(context, endPointUrl, confirmCb, infoCb, cb) {
    if (!cb) cb = () => {};
    if (!confirmCb) confirmCb = () => {};
    if (!infoCb) infoCb = () => {};

    if (context === 'vm') {
      this.executionContext = context;
      this.vms[this.currentFork].stateManager.revert(() => {
        this.vms[this.currentFork].stateManager.checkpoint(() => {});
      });
      this.event.trigger('contextChanged', ['vm']);
      return cb();
    }

    if (context === 'injected') {
      if (injectedProvider === undefined) {
        infoCb('No injected Web3 provider found. Make sure your provider (e.g. MetaMask) is active and running (when recently activated you may have to reload the page).');
        return cb();
      } else {
        this.askPermission();
        this.executionContext = context;
        web3.setProvider(injectedProvider);

        this._updateBlockGasLimit();

        this.event.trigger('contextChanged', ['injected']);
        return cb();
      }
    }

    if (context === 'web3') {
      confirmCb(cb);
    }

    if (this.customNetWorks[context]) {
      var network = this.customNetWorks[context];
      this.setProviderFromEndpoint(network.provider, network.name, error => {
        if (error) infoCb(error);
        cb();
      });
    }
  }

  currentblockGasLimit() {
    return this.blockGasLimit;
  }

  stopListenOnLastBlock() {
    if (this.listenOnLastBlockId) clearInterval(this.listenOnLastBlockId);
    this.listenOnLastBlockId = null;
  }

  _updateBlockGasLimit() {
    if (this.getProvider() !== 'vm') {
      web3.eth.getBlock('latest', (err, block) => {
        if (!err) {
          // we can't use the blockGasLimit cause the next blocks could have a lower limit : https://github.com/ethereum/remix/issues/506
          this.blockGasLimit = block && block.gasLimit ? Math.floor(block.gasLimit - 5 * block.gasLimit / 1024) : this.blockGasLimitDefault;
        } else {
          this.blockGasLimit = this.blockGasLimitDefault;
        }
      });
    }
  }

  listenOnLastBlock() {
    this.listenOnLastBlockId = setInterval(() => {
      this._updateBlockGasLimit();
    }, 15000);
  } // TODO: remove this when this function is moved


  setProviderFromEndpoint(endpoint, context, cb) {
    const oldProvider = web3.currentProvider;
    web3.setProvider(endpoint);
    web3.eth.net.isListening((err, isConnected) => {
      if (!err && isConnected) {
        this.executionContext = context;

        this._updateBlockGasLimit();

        this.event.trigger('contextChanged', [context]);
        this.event.trigger('web3EndpointChanged');
        cb();
      } else {
        web3.setProvider(oldProvider);
        cb('Not possible to connect to the Web3 provider. Make sure the provider is running, a connection is open (via IPC or RPC) or that the provider plugin is properly configured.');
      }
    });
  }

  txDetailsLink(network, hash) {
    const transactionDetailsLinks = {
      Main: 'https://www.etherscan.io/tx/',
      Rinkeby: 'https://rinkeby.etherscan.io/tx/',
      Ropsten: 'https://ropsten.etherscan.io/tx/',
      Kovan: 'https://kovan.etherscan.io/tx/',
      Goerli: 'https://goerli.etherscan.io/tx/'
    };

    if (transactionDetailsLinks[network]) {
      return transactionDetailsLinks[network] + hash;
    }
  }

  addBlock(block) {
    let blockNumber = '0x' + block.header.number.toString('hex');

    if (blockNumber === '0x') {
      blockNumber = '0x0';
    }

    blockNumber = web3.utils.toHex(web3.utils.toBN(blockNumber));
    this.blocks['0x' + block.hash().toString('hex')] = block;
    this.blocks[blockNumber] = block;
    this.latestBlockNumber = blockNumber;
    this.logsManager.checkBlock(blockNumber, block, this.web3());
  }

  trackTx(tx, block) {
    this.txs[tx] = block;
  }

}

exports.ExecutionContext = ExecutionContext;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/logsManager.js":
/*!*************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/logsManager.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const async_1 = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

const crypto_1 = __webpack_require__(/*! crypto */ "../../../node_modules/crypto-browserify/index.js");

class LogsManager {
  constructor() {
    this.notificationCallbacks = [];
    this.subscriptions = {};
    this.filters = {};
    this.filterTracking = {};
    this.oldLogs = [];
  }

  checkBlock(blockNumber, block, web3) {
    async_1.eachOf(block.transactions, (tx, i, next) => {
      const txHash = '0x' + tx.hash().toString('hex');
      web3.eth.getTransactionReceipt(txHash, (_error, receipt) => {
        for (const log of receipt.logs) {
          this.oldLogs.push({
            type: 'block',
            blockNumber,
            block,
            tx,
            log,
            txNumber: i
          });
          const subscriptions = this.getSubscriptionsFor({
            type: 'block',
            blockNumber,
            block,
            tx,
            log
          });

          for (const subscriptionId of subscriptions) {
            const result = {
              logIndex: '0x1',
              blockNumber: blockNumber,
              blockHash: '0x' + block.hash().toString('hex'),
              transactionHash: '0x' + tx.hash().toString('hex'),
              transactionIndex: '0x' + i.toString(16),
              // TODO: if it's a contract deploy, it should be that address instead
              address: log.address,
              data: log.data,
              topics: log.topics
            };

            if (result.address === '0x') {
              delete result.address;
            }

            const response = {
              jsonrpc: '2.0',
              method: 'eth_subscription',
              params: {
                result: result,
                subscription: subscriptionId
              }
            };
            this.transmit(response);
          }
        }
      });
    }, _err => {});
  }

  eventMatchesFilter(changeEvent, queryType, queryFilter) {
    if (queryFilter.topics.filter(logTopic => changeEvent.log.topics.indexOf(logTopic) >= 0).length === 0) return false;

    if (queryType === 'logs') {
      if (queryFilter.address === '0x' + changeEvent.tx.to.toString('hex') && queryFilter.address === '0x' + changeEvent.tx.from.toString('hex')) {
        if (!queryFilter.toBlock) {
          return true;
        } else if (parseInt(queryFilter.toBlock) > parseInt(changeEvent.blockNumber)) {
          return true;
        }
      }
    }

    return false;
  }

  getSubscriptionsFor(changeEvent) {
    const matchedSubscriptions = [];

    for (const subscriptionId of Object.keys(this.subscriptions)) {
      const subscriptionParams = this.subscriptions[subscriptionId];
      const [queryType, queryFilter] = subscriptionParams;

      if (this.eventMatchesFilter(changeEvent, queryType, queryFilter || {
        topics: []
      })) {
        matchedSubscriptions.push(subscriptionId);
      }
    }

    return matchedSubscriptions;
  }

  getLogsForSubscription(subscriptionId) {
    const subscriptionParams = this.subscriptions[subscriptionId];
    const [_queryType, queryFilter] = subscriptionParams; // eslint-disable-line

    return this.getLogsFor(queryFilter);
  }

  transmit(result) {
    this.notificationCallbacks.forEach(callback => {
      if (result.params.result.raw) {
        result.params.result.data = result.params.result.raw.data;
        result.params.result.topics = result.params.result.raw.topics;
      }

      callback(result);
    });
  }

  addListener(_type, cb) {
    this.notificationCallbacks.push(cb);
  }

  subscribe(params) {
    const subscriptionId = '0x' + crypto_1.randomBytes(16).toString('hex');
    this.subscriptions[subscriptionId] = params;
    return subscriptionId;
  }

  unsubscribe(subscriptionId) {
    delete this.subscriptions[subscriptionId];
  }

  newFilter(filterType, params) {
    const filterId = '0x' + crypto_1.randomBytes(16).toString('hex');

    if (filterType === 'block' || filterType === 'pendingTransactions') {
      this.filters[filterId] = {
        filterType
      };
    }

    if (filterType === 'filter') {
      this.filters[filterId] = {
        filterType,
        params
      };
    }

    this.filterTracking[filterId] = {};
    return filterId;
  }

  uninstallFilter(filterId) {
    delete this.filters[filterId];
  }

  getLogsForFilter(filterId, logsOnly) {
    const {
      filterType,
      params
    } = this.filters[filterId];
    const tracking = this.filterTracking[filterId];

    if (logsOnly || filterType === 'filter') {
      return this.getLogsFor(params || {
        topics: []
      });
    }

    if (filterType === 'block') {
      const blocks = this.oldLogs.filter(x => x.type === 'block').filter(x => tracking.block === undefined || x.blockNumber >= tracking.block);
      tracking.block = blocks[blocks.length - 1];
      return blocks.map(block => '0x' + block.hash().toString('hex'));
    }

    if (filterType === 'pendingTransactions') {
      return [];
    }
  }

  getLogsFor(params) {
    const results = [];

    for (const log of this.oldLogs) {
      if (this.eventMatchesFilter(log, 'logs', params)) {
        results.push({
          logIndex: '0x1',
          blockNumber: log.blockNumber,
          blockHash: '0x' + log.block.hash().toString('hex'),
          transactionHash: '0x' + log.tx.hash().toString('hex'),
          transactionIndex: '0x' + log.txNumber.toString(16),
          // TODO: if it's a contract deploy, it should be that address instead
          address: log.log.address,
          data: log.log.data,
          topics: log.log.topics
        });
      }
    }

    return results;
  }

}

exports.LogsManager = LogsManager;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/txExecution.js":
/*!*************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/txExecution.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const ethers_1 = __webpack_require__(/*! ethers */ "../../../node_modules/ethers/dist/ethers.umd.js");
/**
  * deploy the given contract
  *
  * @param {String} from    - sender address
  * @param {String} data    - data to send with the transaction ( return of txFormat.buildData(...) ).
  * @param {String} value    - decimal representation of value.
  * @param {String} gasLimit    - decimal representation of gas limit.
  * @param {Object} txRunner    - TxRunner.js instance
  * @param {Object} callbacks    - { confirmationCb, gasEstimationForceSend, promptCb }
  *     [validate transaction] confirmationCb (network, tx, gasEstimation, continueTxExecution, cancelCb)
  *     [transaction failed, force send] gasEstimationForceSend (error, continueTxExecution, cancelCb)
  *     [personal mode enabled, need password to continue] promptCb (okCb, cancelCb)
  * @param {Function} finalCallback    - last callback.
  */


function createContract(from, data, value, gasLimit, txRunner, callbacks, finalCallback) {
  if (!callbacks.confirmationCb || !callbacks.gasEstimationForceSend || !callbacks.promptCb) {
    return finalCallback('all the callbacks must have been defined');
  }

  const tx = {
    from: from,
    to: null,
    data: data,
    useCall: false,
    value: value,
    gasLimit: gasLimit
  };
  txRunner.rawRun(tx, callbacks.confirmationCb, callbacks.gasEstimationForceSend, callbacks.promptCb, (error, txResult) => {
    // see universaldapp.js line 660 => 700 to check possible values of txResult (error case)
    finalCallback(error, txResult);
  });
}

exports.createContract = createContract;
/**
  * call the current given contract ! that will create a transaction !
  *
  * @param {String} from    - sender address
  * @param {String} to    - recipient address
  * @param {String} data    - data to send with the transaction ( return of txFormat.buildData(...) ).
  * @param {String} value    - decimal representation of value.
  * @param {String} gasLimit    - decimal representation of gas limit.
  * @param {Object} txRunner    - TxRunner.js instance
  * @param {Object} callbacks    - { confirmationCb, gasEstimationForceSend, promptCb }
  *     [validate transaction] confirmationCb (network, tx, gasEstimation, continueTxExecution, cancelCb)
  *     [transaction failed, force send] gasEstimationForceSend (error, continueTxExecution, cancelCb)
  *     [personal mode enabled, need password to continue] promptCb (okCb, cancelCb)
  * @param {Function} finalCallback    - last callback.
  */

function callFunction(from, to, data, value, gasLimit, funAbi, txRunner, callbacks, finalCallback) {
  const useCall = funAbi.stateMutability === 'view' || funAbi.stateMutability === 'pure' || funAbi.constant;
  const tx = {
    from,
    to,
    data,
    useCall,
    value,
    gasLimit
  };
  txRunner.rawRun(tx, callbacks.confirmationCb, callbacks.gasEstimationForceSend, callbacks.promptCb, (error, txResult) => {
    // see universaldapp.js line 660 => 700 to check possible values of txResult (error case)
    finalCallback(error, txResult);
  });
}

exports.callFunction = callFunction;
/**
  * check if the vm has errored
  *
  * @param {Object} txResult    - the value returned by the vm
  * @return {Object} -  { error: true/false, message: DOMNode }
  */

function checkVMError(txResult) {
  const errorCode = {
    OUT_OF_GAS: 'out of gas',
    STACK_UNDERFLOW: 'stack underflow',
    STACK_OVERFLOW: 'stack overflow',
    INVALID_JUMP: 'invalid JUMP',
    INVALID_OPCODE: 'invalid opcode',
    REVERT: 'revert',
    STATIC_STATE_CHANGE: 'static state change',
    INTERNAL_ERROR: 'internal error',
    CREATE_COLLISION: 'create collision',
    STOP: 'stop',
    REFUND_EXHAUSTED: 'refund exhausted'
  };
  const ret = {
    error: false,
    message: ''
  };

  if (!txResult.result.execResult.exceptionError) {
    return ret;
  }

  const exceptionError = txResult.result.execResult.exceptionError.error || '';
  const error = `VM error: ${exceptionError}.\n`;
  let msg;

  if (exceptionError === errorCode.INVALID_OPCODE) {
    msg = '\t\n\tThe execution might have thrown.\n';
    ret.error = true;
  } else if (exceptionError === errorCode.OUT_OF_GAS) {
    msg = '\tThe transaction ran out of gas. Please increase the Gas Limit.\n';
    ret.error = true;
  } else if (exceptionError === errorCode.REVERT) {
    const returnData = txResult.result.execResult.returnValue; // It is the hash of Error(string)

    if (returnData && returnData.slice(0, 4).toString('hex') === '08c379a0') {
      const abiCoder = new ethers_1.ethers.utils.AbiCoder();
      const reason = abiCoder.decode(['string'], returnData.slice(4))[0];
      msg = `\tThe transaction has been reverted to the initial state.\nReason provided by the contract: "${reason}".`;
    } else {
      msg = '\tThe transaction has been reverted to the initial state.\nNote: The called function should be payable if you send value and the value you send should be less than your current balance.';
    }

    ret.error = true;
  } else if (exceptionError === errorCode.STATIC_STATE_CHANGE) {
    msg = '\tState changes is not allowed in Static Call context\n';
    ret.error = true;
  }

  ret.message = `${error}${exceptionError}${msg}\tDebug the transaction to get more information.`;
  return ret;
}

exports.checkVMError = checkVMError;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/txFormat.js":
/*!**********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/txFormat.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ethers_1 = __webpack_require__(/*! ethers */ "../../../node_modules/ethers/dist/ethers.umd.js");

const txHelper_1 = __webpack_require__(/*! ./txHelper */ "../../../dist/libs/remix-lib/src/execution/txHelper.js");

const async_1 = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

const linker_1 = __webpack_require__(/*! solc/linker */ "../../../node_modules/solc/linker.js");

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");
/**
  * build the transaction data
  *
  * @param {Object} function abi
  * @param {Object} values to encode
  * @param {String} contractbyteCode
  */


function encodeData(funABI, values, contractbyteCode) {
  let encoded;
  let encodedHex;

  try {
    encoded = txHelper_1.encodeParams(funABI, values);
    encodedHex = encoded.toString('hex');
  } catch (e) {
    return {
      error: 'cannot encode arguments'
    };
  }

  if (contractbyteCode) {
    return {
      data: '0x' + contractbyteCode + encodedHex.replace('0x', '')
    };
  } else {
    return {
      data: txHelper_1.encodeFunctionId(funABI) + encodedHex.replace('0x', '')
    };
  }
}

exports.encodeData = encodeData;
/**
* encode function / constructor parameters
*
* @param {Object} params    - input paramater of the function to call
* @param {Object} funAbi    - abi definition of the function to call. null if building data for the ctor.
* @param {Function} callback    - callback
*/

function encodeParams(params, funAbi, callback) {
  let data = '';
  let dataHex = '';
  let funArgs;

  if (params.indexOf('raw:0x') === 0) {
    // in that case we consider that the input is already encoded and *does not* contain the method signature
    dataHex = params.replace('raw:0x', '');
    data = Buffer.from(dataHex, 'hex');
  } else {
    try {
      params = params.replace(/(^|,\s+|,)(\d+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted number by quoted number

      params = params.replace(/(^|,\s+|,)(0[xX][0-9a-fA-F]+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted hex string by quoted hex string

      funArgs = JSON.parse('[' + params + ']');
    } catch (e) {
      return callback('Error encoding arguments: ' + e);
    }

    if (funArgs.length > 0) {
      try {
        data = txHelper_1.encodeParams(funAbi, funArgs);
        dataHex = data.toString();
      } catch (e) {
        return callback('Error encoding arguments: ' + e);
      }
    }

    if (data.slice(0, 9) === 'undefined') {
      dataHex = data.slice(9);
    }

    if (data.slice(0, 2) === '0x') {
      dataHex = data.slice(2);
    }
  }

  callback(null, {
    data: data,
    dataHex: dataHex,
    funArgs: funArgs
  });
}

exports.encodeParams = encodeParams;
/**
* encode function call (function id + encoded parameters)
*
* @param {Object} params    - input paramater of the function to call
* @param {Object} funAbi    - abi definition of the function to call. null if building data for the ctor.
* @param {Function} callback    - callback
*/

function encodeFunctionCall(params, funAbi, callback) {
  this.encodeParams(params, funAbi, (error, encodedParam) => {
    if (error) return callback(error);
    callback(null, {
      dataHex: txHelper_1.encodeFunctionId(funAbi) + encodedParam.dataHex,
      funAbi,
      funArgs: encodedParam.funArgs
    });
  });
}

exports.encodeFunctionCall = encodeFunctionCall;
/**
* encode constructor creation and link with provided libraries if needed
*
* @param {Object} contract    - input paramater of the function to call
* @param {Object} params    - input paramater of the function to call
* @param {Object} funAbi    - abi definition of the function to call. null if building data for the ctor.
* @param {Object} linkLibraries    - contains {linkReferences} object which list all the addresses to be linked
* @param {Object} linkReferences    - given by the compiler, contains the proper linkReferences
* @param {Function} callback    - callback
*/

function encodeConstructorCallAndLinkLibraries(contract, params, funAbi, linkLibraries, linkReferences, callback) {
  this.encodeParams(params, funAbi, (error, encodedParam) => {
    if (error) return callback(error);
    let bytecodeToDeploy = contract.evm.bytecode.object;

    if (bytecodeToDeploy.indexOf('_') >= 0) {
      if (linkLibraries && linkReferences) {
        for (const libFile in linkLibraries) {
          for (const lib in linkLibraries[libFile]) {
            const address = linkLibraries[libFile][lib];
            if (!ethereumjs_util_1.isValidAddress(address)) return callback(address + ' is not a valid address. Please check the provided address is valid.');
            bytecodeToDeploy = this.linkLibraryStandardFromlinkReferences(lib, address.replace('0x', ''), bytecodeToDeploy, linkReferences);
          }
        }
      }
    }

    if (bytecodeToDeploy.indexOf('_') >= 0) {
      return callback('Failed to link some libraries');
    }

    return callback(null, {
      dataHex: bytecodeToDeploy + encodedParam.dataHex,
      funAbi,
      funArgs: encodedParam.funArgs,
      contractBytecode: contract.evm.bytecode.object
    });
  });
}

exports.encodeConstructorCallAndLinkLibraries = encodeConstructorCallAndLinkLibraries;
/**
* encode constructor creation and deploy librairies if needed
*
* @param {String} contractName    - current contract name
* @param {Object} contract    - input paramater of the function to call
* @param {Object} contracts    - map of all compiled contracts.
* @param {Object} params    - input paramater of the function to call
* @param {Object} funAbi    - abi definition of the function to call. null if building data for the ctor.
* @param {Function} callback    - callback
* @param {Function} callbackStep  - callbackStep
* @param {Function} callbackDeployLibrary  - callbackDeployLibrary
* @param {Function} callback    - callback
*/

function encodeConstructorCallAndDeployLibraries(contractName, contract, contracts, params, funAbi, callback, callbackStep, callbackDeployLibrary) {
  this.encodeParams(params, funAbi, (error, encodedParam) => {
    if (error) return callback(error);
    let dataHex = '';
    const contractBytecode = contract.evm.bytecode.object;
    let bytecodeToDeploy = contract.evm.bytecode.object;

    if (bytecodeToDeploy.indexOf('_') >= 0) {
      this.linkBytecode(contract, contracts, (err, bytecode) => {
        if (err) {
          callback('Error deploying required libraries: ' + err);
        } else {
          bytecodeToDeploy = bytecode + dataHex;
          return callback(null, {
            dataHex: bytecodeToDeploy,
            funAbi,
            funArgs: encodedParam.funArgs,
            contractBytecode,
            contractName: contractName
          });
        }
      }, callbackStep, callbackDeployLibrary);
      return;
    } else {
      dataHex = bytecodeToDeploy + encodedParam.dataHex;
    }

    callback(null, {
      dataHex: bytecodeToDeploy,
      funAbi,
      funArgs: encodedParam.funArgs,
      contractBytecode,
      contractName: contractName
    });
  });
}

exports.encodeConstructorCallAndDeployLibraries = encodeConstructorCallAndDeployLibraries;
/**
* (DEPRECATED) build the transaction data
*
* @param {String} contractName
* @param {Object} contract    - abi definition of the current contract.
* @param {Object} contracts    - map of all compiled contracts.
* @param {Bool} isConstructor    - isConstructor.
* @param {Object} funAbi    - abi definition of the function to call. null if building data for the ctor.
* @param {Object} params    - input paramater of the function to call
* @param {Function} callback    - callback
* @param {Function} callbackStep  - callbackStep
* @param {Function} callbackDeployLibrary  - callbackDeployLibrary
*/

function buildData(contractName, contract, contracts, isConstructor, funAbi, params, callback, callbackStep, callbackDeployLibrary) {
  let funArgs = [];
  let data = '';
  let dataHex = '';

  if (params.indexOf('raw:0x') === 0) {
    // in that case we consider that the input is already encoded and *does not* contain the method signature
    dataHex = params.replace('raw:0x', '');
    data = Buffer.from(dataHex, 'hex');
  } else {
    try {
      if (params.length > 0) {
        funArgs = this.parseFunctionParams(params);
      }
    } catch (e) {
      return callback('Error encoding arguments: ' + e);
    }

    try {
      data = txHelper_1.encodeParams(funAbi, funArgs);
      dataHex = data.toString();
    } catch (e) {
      return callback('Error encoding arguments: ' + e);
    }

    if (data.slice(0, 9) === 'undefined') {
      dataHex = data.slice(9);
    }

    if (data.slice(0, 2) === '0x') {
      dataHex = data.slice(2);
    }
  }

  let contractBytecode;

  if (isConstructor) {
    contractBytecode = contract.evm.bytecode.object;
    let bytecodeToDeploy = contract.evm.bytecode.object;

    if (bytecodeToDeploy.indexOf('_') >= 0) {
      this.linkBytecode(contract, contracts, (err, bytecode) => {
        if (err) {
          callback('Error deploying required libraries: ' + err);
        } else {
          bytecodeToDeploy = bytecode + dataHex;
          return callback(null, {
            dataHex: bytecodeToDeploy,
            funAbi,
            funArgs,
            contractBytecode,
            contractName: contractName
          });
        }
      }, callbackStep, callbackDeployLibrary);
      return;
    } else {
      dataHex = bytecodeToDeploy + dataHex;
    }
  } else {
    dataHex = txHelper_1.encodeFunctionId(funAbi) + dataHex;
  }

  callback(null, {
    dataHex,
    funAbi,
    funArgs,
    contractBytecode,
    contractName: contractName
  });
}

exports.buildData = buildData;

function atAddress() {}

exports.atAddress = atAddress;

function linkBytecodeStandard(contract, contracts, callback, callbackStep, callbackDeployLibrary) {
  let contractBytecode = contract.evm.bytecode.object;
  async_1.eachOfSeries(contract.evm.bytecode.linkReferences, (libs, file, cbFile) => {
    async_1.eachOfSeries(contract.evm.bytecode.linkReferences[file], (libRef, libName, cbLibDeployed) => {
      const library = contracts[file][libName];

      if (library) {
        this.deployLibrary(file + ':' + libName, libName, library, contracts, (error, address) => {
          if (error) {
            return cbLibDeployed(error);
          }

          let hexAddress = address.toString('hex');

          if (hexAddress.slice(0, 2) === '0x') {
            hexAddress = hexAddress.slice(2);
          }

          contractBytecode = this.linkLibraryStandard(libName, hexAddress, contractBytecode, contract);
          cbLibDeployed();
        }, callbackStep, callbackDeployLibrary);
      } else {
        cbLibDeployed('Cannot find compilation data of library ' + libName);
      }
    }, error => {
      cbFile(error);
    });
  }, error => {
    if (error) {
      callbackStep(error);
    }

    callback(error, contractBytecode);
  });
}

exports.linkBytecodeStandard = linkBytecodeStandard;

function linkBytecodeLegacy(contract, contracts, callback, callbackStep, callbackDeployLibrary) {
  const libraryRefMatch = contract.evm.bytecode.object.match(/__([^_]{1,36})__/);

  if (!libraryRefMatch) {
    return callback('Invalid bytecode format.');
  }

  const libraryName = libraryRefMatch[1]; // file_name:library_name

  const libRef = libraryName.match(/(.*):(.*)/);

  if (!libRef) {
    return callback('Cannot extract library reference ' + libraryName);
  }

  if (!contracts[libRef[1]] || !contracts[libRef[1]][libRef[2]]) {
    return callback('Cannot find library reference ' + libraryName);
  }

  const libraryShortName = libRef[2];
  const library = contracts[libRef[1]][libraryShortName];

  if (!library) {
    return callback('Library ' + libraryName + ' not found.');
  }

  this.deployLibrary(libraryName, libraryShortName, library, contracts, (err, address) => {
    if (err) {
      return callback(err);
    }

    let hexAddress = address.toString('hex');

    if (hexAddress.slice(0, 2) === '0x') {
      hexAddress = hexAddress.slice(2);
    }

    contract.evm.bytecode.object = this.linkLibrary(libraryName, hexAddress, contract.evm.bytecode.object);
    this.linkBytecode(contract, contracts, callback, callbackStep, callbackDeployLibrary);
  }, callbackStep, callbackDeployLibrary);
}

exports.linkBytecodeLegacy = linkBytecodeLegacy;

function linkBytecode(contract, contracts, callback, callbackStep, callbackDeployLibrary) {
  if (contract.evm.bytecode.object.indexOf('_') < 0) {
    return callback(null, contract.evm.bytecode.object);
  }

  if (contract.evm.bytecode.linkReferences && Object.keys(contract.evm.bytecode.linkReferences).length) {
    this.linkBytecodeStandard(contract, contracts, callback, callbackStep, callbackDeployLibrary);
  } else {
    this.linkBytecodeLegacy(contract, contracts, callback, callbackStep, callbackDeployLibrary);
  }
}

exports.linkBytecode = linkBytecode;

function deployLibrary(libraryName, libraryShortName, library, contracts, callback, callbackStep, callbackDeployLibrary) {
  const address = library.address;

  if (address) {
    return callback(null, address);
  }

  const bytecode = library.evm.bytecode.object;

  if (bytecode.indexOf('_') >= 0) {
    this.linkBytecode(library, contracts, (err, bytecode) => {
      if (err) callback(err);else {
        library.evm.bytecode.object = bytecode;
        this.deployLibrary(libraryName, libraryShortName, library, contracts, callback, callbackStep, callbackDeployLibrary);
      }
    }, callbackStep, callbackDeployLibrary);
  } else {
    callbackStep(`creation of library ${libraryName} pending...`);
    const data = {
      dataHex: bytecode,
      funAbi: {
        type: 'constructor'
      },
      funArgs: [],
      contractBytecode: bytecode,
      contractName: libraryShortName
    };
    callbackDeployLibrary({
      data: data,
      useCall: false
    }, (err, txResult) => {
      if (err) {
        return callback(err);
      }

      const address = txResult.result.createdAddress || txResult.result.contractAddress;
      library.address = address;
      callback(err, address);
    });
  }
}

exports.deployLibrary = deployLibrary;

function linkLibraryStandardFromlinkReferences(libraryName, address, bytecode, linkReferences) {
  for (const file in linkReferences) {
    for (const libName in linkReferences[file]) {
      if (libraryName === libName) {
        bytecode = this.setLibraryAddress(address, bytecode, linkReferences[file][libName]);
      }
    }
  }

  return bytecode;
}

exports.linkLibraryStandardFromlinkReferences = linkLibraryStandardFromlinkReferences;

function linkLibraryStandard(libraryName, address, bytecode, contract) {
  return this.linkLibraryStandardFromlinkReferences(libraryName, address, bytecode, contract.evm.bytecode.linkReferences);
}

exports.linkLibraryStandard = linkLibraryStandard;

function setLibraryAddress(address, bytecodeToLink, positions) {
  if (positions) {
    for (const pos of positions) {
      const regpos = bytecodeToLink.match(new RegExp(`(.{${2 * pos.start}})(.{${2 * pos.length}})(.*)`));

      if (regpos) {
        bytecodeToLink = regpos[1] + address + regpos[3];
      }
    }
  }

  return bytecodeToLink;
}

exports.setLibraryAddress = setLibraryAddress;

function linkLibrary(libraryName, address, bytecodeToLink) {
  return linker_1.linkBytecode(bytecodeToLink, {
    [libraryName]: ethereumjs_util_1.addHexPrefix(address)
  });
}

exports.linkLibrary = linkLibrary;

function decodeResponse(response, fnabi) {
  // Only decode if there supposed to be fields
  if (fnabi.outputs && fnabi.outputs.length > 0) {
    try {
      let i;
      const outputTypes = [];

      for (i = 0; i < fnabi.outputs.length; i++) {
        const type = fnabi.outputs[i].type;
        outputTypes.push(type.indexOf('tuple') === 0 ? txHelper_1.makeFullTypeDefinition(fnabi.outputs[i]) : type);
      }

      if (!response.length) response = new Uint8Array(32 * fnabi.outputs.length); // ensuring the data is at least filled by 0 cause `AbiCoder` throws if there's not engouh data
      // decode data

      const abiCoder = new ethers_1.ethers.utils.AbiCoder();
      const decodedObj = abiCoder.decode(outputTypes, response);
      const json = {};

      for (i = 0; i < outputTypes.length; i++) {
        const name = fnabi.outputs[i].name;
        json[i] = outputTypes[i] + ': ' + (name ? name + ' ' + decodedObj[i] : decodedObj[i]);
      }

      return json;
    } catch (e) {
      return {
        error: 'Failed to decode output: ' + e
      };
    }
  }

  return {};
}

exports.decodeResponse = decodeResponse;

function parseFunctionParams(params) {
  let args = []; // Check if parameter string starts with array or string

  let startIndex = this.isArrayOrStringStart(params, 0) ? -1 : 0;

  for (let i = 0; i < params.length; i++) {
    // If a quote is received
    if (params.charAt(i) === '"') {
      startIndex = -1;
      let endQuoteIndex = false; // look for closing quote. On success, push the complete string in arguments list

      for (let j = i + 1; !endQuoteIndex; j++) {
        if (params.charAt(j) === '"') {
          args.push(params.substring(i + 1, j));
          endQuoteIndex = true;
          i = j;
        } // Throw error if end of params string is arrived but couldn't get end quote


        if (!endQuoteIndex && j === params.length - 1) {
          throw new Error('invalid params');
        }
      }
    } else if (params.charAt(i) === '[') {
      // If an array/struct opening bracket is received
      startIndex = -1;
      let bracketCount = 1;
      let j;

      for (j = i + 1; bracketCount !== 0; j++) {
        // Increase count if another array opening bracket is received (To handle nested array)
        if (params.charAt(j) === '[') {
          bracketCount++;
        } else if (params.charAt(j) === ']') {
          // // Decrease count if an array closing bracket is received (To handle nested array)
          bracketCount--;
        } // Throw error if end of params string is arrived but couldn't get end of tuple


        if (bracketCount !== 0 && j === params.length - 1) {
          throw new Error('invalid tuple params');
        }
      } // If bracketCount = 0, it means complete array/nested array parsed, push it to the arguments list


      args.push(JSON.parse(params.substring(i, j)));
      i = j - 1;
    } else if (params.charAt(i) === ',') {
      // if startIndex >= 0, it means a parameter was being parsed, it can be first or other parameter
      if (startIndex >= 0) {
        args.push(params.substring(startIndex, i));
      } // Register start index of a parameter to parse


      startIndex = this.isArrayOrStringStart(params, i + 1) ? -1 : i + 1;
    } else if (startIndex >= 0 && i === params.length - 1) {
      // If start index is registered and string is completed (To handle last parameter)
      args.push(params.substring(startIndex, params.length));
    }
  }

  args = args.map(e => {
    if (!Array.isArray(e)) {
      return e.trim();
    } else {
      return e;
    }
  });
  return args;
}

exports.parseFunctionParams = parseFunctionParams;

function isArrayOrStringStart(str, index) {
  return str.charAt(index) === '"' || str.charAt(index) === '[';
}

exports.isArrayOrStringStart = isArrayOrStringStart;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/txHelper.js":
/*!**********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/txHelper.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const ethers_1 = __webpack_require__(/*! ethers */ "../../../node_modules/ethers/dist/ethers.umd.js");

function makeFullTypeDefinition(typeDef) {
  if (typeDef && typeDef.type.indexOf('tuple') === 0 && typeDef.components) {
    const innerTypes = typeDef.components.map(innerType => {
      return this.makeFullTypeDefinition(innerType);
    });
    return `tuple(${innerTypes.join(',')})${this.extractSize(typeDef.type)}`;
  }

  return typeDef.type;
}

exports.makeFullTypeDefinition = makeFullTypeDefinition;

function encodeParams(funABI, args) {
  const types = [];

  if (funABI.inputs && funABI.inputs.length) {
    for (let i = 0; i < funABI.inputs.length; i++) {
      const type = funABI.inputs[i].type; // "false" will be converting to `false` and "true" will be working
      // fine as abiCoder assume anything in quotes as `true`

      if (type === 'bool' && args[i] === 'false') {
        args[i] = false;
      }

      types.push(type.indexOf('tuple') === 0 ? this.makeFullTypeDefinition(funABI.inputs[i]) : type);

      if (args.length < types.length) {
        args.push('');
      }
    }
  } // NOTE: the caller will concatenate the bytecode and this
  //       it could be done here too for consistency


  const abiCoder = new ethers_1.ethers.utils.AbiCoder();
  return abiCoder.encode(types, args);
}

exports.encodeParams = encodeParams;

function encodeFunctionId(funABI) {
  if (funABI.type === 'fallback' || funABI.type === 'receive') return '0x';
  const abi = new ethers_1.ethers.utils.Interface([funABI]);
  return abi.getSighash(funABI.name);
}

exports.encodeFunctionId = encodeFunctionId;

function sortAbiFunction(contractabi) {
  // Check if function is constant (introduced with Solidity 0.6.0)
  const isConstant = ({
    stateMutability
  }) => stateMutability === 'view' || stateMutability === 'pure'; // Sorts the list of ABI entries. Constant functions will appear first,
  // followed by non-constant functions. Within those t wo groupings, functions
  // will be sorted by their names.


  return contractabi.sort(function (a, b) {
    if (isConstant(a) && !isConstant(b)) {
      return 1;
    } else if (isConstant(b) && !isConstant(a)) {
      return -1;
    } // If we reach here, either a and b are both constant or both not; sort by name then
    // special case for fallback, receive and constructor function


    if (a.type === 'function' && typeof a.name !== 'undefined') {
      return a.name.localeCompare(b.name);
    } else if (a.type === 'constructor' || a.type === 'fallback' || a.type === 'receive') {
      return 1;
    }
  });
}

exports.sortAbiFunction = sortAbiFunction;

function getConstructorInterface(abi) {
  const funABI = {
    name: '',
    inputs: [],
    type: 'constructor',
    payable: false,
    outputs: []
  };

  if (typeof abi === 'string') {
    try {
      abi = JSON.parse(abi);
    } catch (e) {
      console.log('exception retrieving ctor abi ' + abi);
      return funABI;
    }
  }

  for (let i = 0; i < abi.length; i++) {
    if (abi[i].type === 'constructor') {
      funABI.inputs = abi[i].inputs || [];
      funABI.payable = abi[i].payable;
      funABI['stateMutability'] = abi[i].stateMutability;
      break;
    }
  }

  return funABI;
}

exports.getConstructorInterface = getConstructorInterface;

function serializeInputs(fnAbi) {
  let serialized = '(';

  if (fnAbi.inputs && fnAbi.inputs.length) {
    serialized += fnAbi.inputs.map(input => {
      return input.type;
    }).join(',');
  }

  serialized += ')';
  return serialized;
}

exports.serializeInputs = serializeInputs;

function extractSize(type) {
  const size = type.match(/([a-zA-Z0-9])(\[.*\])/);
  return size ? size[2] : '';
}

exports.extractSize = extractSize;

function getFunction(abi, fnName) {
  for (let i = 0; i < abi.length; i++) {
    const fn = abi[i];

    if (fn.type === 'function' && fnName === fn.name + '(' + fn.inputs.map(value => {
      if (value.components) {
        const fullType = this.makeFullTypeDefinition(value);
        return fullType.replace(/tuple/g, ''); // return of makeFullTypeDefinition might contain `tuple`, need to remove it cause `methodIdentifier` (fnName) does not include `tuple` keyword
      } else {
        return value.type;
      }
    }).join(',') + ')') {
      return fn;
    }
  }

  return null;
}

exports.getFunction = getFunction;

function getFallbackInterface(abi) {
  for (let i = 0; i < abi.length; i++) {
    if (abi[i].type === 'fallback') {
      return abi[i];
    }
  }
}

exports.getFallbackInterface = getFallbackInterface;

function getReceiveInterface(abi) {
  for (let i = 0; i < abi.length; i++) {
    if (abi[i].type === 'receive') {
      return abi[i];
    }
  }
}

exports.getReceiveInterface = getReceiveInterface;
/**
  * return the contract obj of the given @arg name. Uses last compilation result.
  * return null if not found
  * @param {String} name    - contract name
  * @returns contract obj and associated file: { contract, file } or null
  */

function getContract(contractName, contracts) {
  for (const file in contracts) {
    if (contracts[file][contractName]) {
      return {
        object: contracts[file][contractName],
        file: file
      };
    }
  }

  return null;
}

exports.getContract = getContract;
/**
  * call the given @arg cb (function) for all the contracts. Uses last compilation result
  * stop visiting when cb return true
  * @param {Function} cb    - callback
  */

function visitContracts(contracts, cb) {
  for (const file in contracts) {
    for (const name in contracts[file]) {
      if (cb({
        name: name,
        object: contracts[file][name],
        file: file
      })) return;
    }
  }
}

exports.visitContracts = visitContracts;

function inputParametersDeclarationToString(abiinputs) {
  const inputs = (abiinputs || []).map(inp => inp.type + ' ' + inp.name);
  return inputs.join(', ');
}

exports.inputParametersDeclarationToString = inputParametersDeclarationToString;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/txListener.js":
/*!************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/txListener.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const async_1 = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

const ethers_1 = __webpack_require__(/*! ethers */ "../../../node_modules/ethers/dist/ethers.umd.js");

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const eventManager_1 = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-lib/src/eventManager.js");

const util_1 = __webpack_require__(/*! ../util */ "../../../dist/libs/remix-lib/src/util.js");

const execution_context_1 = __webpack_require__(/*! ./execution-context */ "../../../dist/libs/remix-lib/src/execution/execution-context.js");

const txFormat_1 = __webpack_require__(/*! ./txFormat */ "../../../dist/libs/remix-lib/src/execution/txFormat.js");

const txHelper_1 = __webpack_require__(/*! ./txHelper */ "../../../dist/libs/remix-lib/src/execution/txHelper.js");

function addExecutionCosts(txResult, tx) {
  if (txResult && txResult.result) {
    if (txResult.result.execResult) {
      tx.returnValue = txResult.result.execResult.returnValue;
      if (txResult.result.execResult.gasUsed) tx.executionCost = txResult.result.execResult.gasUsed.toString(10);
    }

    if (txResult.result.gasUsed) tx.transactionCost = txResult.result.gasUsed.toString(10);
  }
}
/**
  * poll web3 each 2s if web3
  * listen on transaction executed event if VM
  * attention: blocks returned by the event `newBlock` have slightly different json properties whether web3 or the VM is used
  * trigger 'newBlock'
  *
  */


class TxListener {
  constructor(opt, executionContext) {
    this.event = new eventManager_1.EventManager(); // has a default for now for backwards compatability

    this.executionContext = executionContext || new execution_context_1.ExecutionContext();
    this._api = opt.api;
    this._resolvedTransactions = {};
    this._resolvedContracts = {};
    this._isListening = false;
    this._listenOnNetwork = false;
    this._loopId = null;
    this.init();
    this.executionContext.event.register('contextChanged', context => {
      if (this._isListening) {
        this.stopListening();
        this.startListening();
      }
    });
    opt.event.udapp.register('callExecuted', (error, from, to, data, lookupOnly, txResult) => {
      if (error) return; // we go for that case if
      // in VM mode
      // in web3 mode && listen remix txs only

      if (!this._isListening) return; // we don't listen

      if (this._loopId && this.executionContext.getProvider() !== 'vm') return; // we seems to already listen on a "web3" network

      const call = {
        from: from,
        to: to,
        input: data,
        hash: txResult.transactionHash ? txResult.transactionHash : 'call' + (from || '') + to + data,
        isCall: true,
        returnValue: this.executionContext.isVM() ? txResult.result.execResult.returnValue : ethereumjs_util_1.toBuffer(txResult.result),
        envMode: this.executionContext.getProvider()
      };
      addExecutionCosts(txResult, call);

      this._resolveTx(call, call, (error, resolvedData) => {
        if (!error) {
          this.event.trigger('newCall', [call]);
        }
      });
    });
    opt.event.udapp.register('transactionExecuted', (error, from, to, data, lookupOnly, txResult) => {
      if (error) return;
      if (lookupOnly) return; // we go for that case if
      // in VM mode
      // in web3 mode && listen remix txs only

      if (!this._isListening) return; // we don't listen

      if (this._loopId && this.executionContext.getProvider() !== 'vm') return; // we seems to already listen on a "web3" network

      this.executionContext.web3().eth.getTransaction(txResult.transactionHash, (error, tx) => {
        if (error) return console.log(error);
        addExecutionCosts(txResult, tx);
        tx.envMode = this.executionContext.getProvider();
        tx.status = txResult.result.status; // 0x0 or 0x1

        this._resolve([tx], () => {});
      });
    });
  }
  /**
    * define if txlistener should listen on the network or if only tx created from remix are managed
    *
    * @param {Bool} type - true if listen on the network
    */


  setListenOnNetwork(listenOnNetwork) {
    this._listenOnNetwork = listenOnNetwork;

    if (this._loopId) {
      clearInterval(this._loopId);
    }

    if (this._listenOnNetwork) {
      this._startListenOnNetwork();
    }
  }
  /**
    * reset recorded transactions
    */


  init() {
    this.blocks = [];
    this.lastBlock = null;
  }
  /**
    * start listening for incoming transactions
    *
    * @param {String} type - type/name of the provider to add
    * @param {Object} obj  - provider
    */


  startListening() {
    this.init();
    this._isListening = true;

    if (this._listenOnNetwork && this.executionContext.getProvider() !== 'vm') {
      this._startListenOnNetwork();
    }
  }
  /**
    * stop listening for incoming transactions. do not reset the recorded pool.
    *
    * @param {String} type - type/name of the provider to add
    * @param {Object} obj  - provider
    */


  stopListening() {
    if (this._loopId) {
      clearInterval(this._loopId);
    }

    this._loopId = null;
    this._isListening = false;
  }

  _startListenOnNetwork() {
    this._loopId = setInterval(() => {
      const currentLoopId = this._loopId;
      this.executionContext.web3().eth.getBlockNumber((error, blockNumber) => {
        if (this._loopId === null) return;
        if (error) return console.log(error);

        if (currentLoopId === this._loopId && (!this.lastBlock || blockNumber > this.lastBlock)) {
          if (!this.lastBlock) this.lastBlock = blockNumber - 1;
          let current = this.lastBlock + 1;
          this.lastBlock = blockNumber;

          while (blockNumber >= current) {
            try {
              this._manageBlock(current);
            } catch (e) {
              console.log(e);
            }

            current++;
          }
        }
      });
    }, 2000);
  }

  _manageBlock(blockNumber) {
    this.executionContext.web3().eth.getBlock(blockNumber, true, (error, result) => {
      if (!error) {
        this._newBlock(Object.assign({
          type: 'web3'
        }, result));
      }
    });
  }
  /**
    * try to resolve the contract name from the given @arg address
    *
    * @param {String} address - contract address to resolve
    * @return {String} - contract name
    */


  resolvedContract(address) {
    if (this._resolvedContracts[address]) return this._resolvedContracts[address].name;
    return null;
  }
  /**
    * try to resolve the transaction from the given @arg txHash
    *
    * @param {String} txHash - contract address to resolve
    * @return {String} - contract name
    */


  resolvedTransaction(txHash) {
    return this._resolvedTransactions[txHash];
  }

  _newBlock(block) {
    this.blocks.push(block);

    this._resolve(block.transactions, () => {
      this.event.trigger('newBlock', [block]);
    });
  }

  _resolve(transactions, callback) {
    async_1.each(transactions, (tx, cb) => {
      this._api.resolveReceipt(tx, (error, receipt) => {
        if (error) return cb(error);

        this._resolveTx(tx, receipt, (error, resolvedData) => {
          if (error) cb(error);

          if (resolvedData) {
            this.event.trigger('txResolved', [tx, receipt, resolvedData]);
          }

          this.event.trigger('newTransaction', [tx, receipt]);
          cb();
        });
      });
    }, () => {
      callback();
    });
  }

  _resolveTx(tx, receipt, cb) {
    const contracts = this._api.contracts();

    if (!contracts) return cb();
    let fun;
    let contract;

    if (!tx.to || tx.to === '0x0') {
      // testrpc returns 0x0 in that case
      // contract creation / resolve using the creation bytes code
      // if web3: we have to call getTransactionReceipt to get the created address
      // if VM: created address already included
      const code = tx.input;
      contract = this._tryResolveContract(code, contracts, true);

      if (contract) {
        const address = receipt.contractAddress;
        this._resolvedContracts[address] = contract;
        fun = this._resolveFunction(contract, tx, true);

        if (this._resolvedTransactions[tx.hash]) {
          this._resolvedTransactions[tx.hash].contractAddress = address;
        }

        return cb(null, {
          to: null,
          contractName: contract.name,
          function: fun,
          creationAddress: address
        });
      }

      return cb();
    } else {
      // first check known contract, resolve against the `runtimeBytecode` if not known
      contract = this._resolvedContracts[tx.to];

      if (!contract) {
        this.executionContext.web3().eth.getCode(tx.to, (error, code) => {
          if (error) return cb(error);

          if (code) {
            const contract = this._tryResolveContract(code, contracts, false);

            if (contract) {
              this._resolvedContracts[tx.to] = contract;

              const fun = this._resolveFunction(contract, tx, false);

              return cb(null, {
                to: tx.to,
                contractName: contract.name,
                function: fun
              });
            }
          }

          return cb();
        });
        return;
      }

      if (contract) {
        fun = this._resolveFunction(contract, tx, false);
        return cb(null, {
          to: tx.to,
          contractName: contract.name,
          function: fun
        });
      }

      return cb();
    }
  }

  _resolveFunction(contract, tx, isCtor) {
    if (!contract) {
      console.log('txListener: cannot resolve contract - contract is null');
      return;
    }

    const abi = contract.object.abi;
    const inputData = tx.input.replace('0x', '');

    if (!isCtor) {
      const methodIdentifiers = contract.object.evm.methodIdentifiers;

      for (const fn in methodIdentifiers) {
        if (methodIdentifiers[fn] === inputData.substring(0, 8)) {
          const fnabi = txHelper_1.getFunction(abi, fn);
          this._resolvedTransactions[tx.hash] = {
            contractName: contract.name,
            to: tx.to,
            fn: fn,
            params: this._decodeInputParams(inputData.substring(8), fnabi)
          };

          if (tx.returnValue) {
            this._resolvedTransactions[tx.hash].decodedReturnValue = txFormat_1.decodeResponse(tx.returnValue, fnabi);
          }

          return this._resolvedTransactions[tx.hash];
        }
      } // receive function


      if (!inputData && txHelper_1.getReceiveInterface(abi)) {
        this._resolvedTransactions[tx.hash] = {
          contractName: contract.name,
          to: tx.to,
          fn: '(receive)',
          params: null
        };
      } else {
        // fallback function
        this._resolvedTransactions[tx.hash] = {
          contractName: contract.name,
          to: tx.to,
          fn: '(fallback)',
          params: null
        };
      }
    } else {
      const bytecode = contract.object.evm.bytecode.object;
      let params = null;

      if (bytecode && bytecode.length) {
        params = this._decodeInputParams(inputData.substring(bytecode.length), txHelper_1.getConstructorInterface(abi));
      }

      this._resolvedTransactions[tx.hash] = {
        contractName: contract.name,
        to: null,
        fn: '(constructor)',
        params: params
      };
    }

    return this._resolvedTransactions[tx.hash];
  }

  _tryResolveContract(codeToResolve, compiledContracts, isCreation) {
    let found = null;
    txHelper_1.visitContracts(compiledContracts, contract => {
      const bytes = isCreation ? contract.object.evm.bytecode.object : contract.object.evm.deployedBytecode.object;

      if (util_1.compareByteCode(codeToResolve, '0x' + bytes)) {
        found = contract;
        return true;
      }
    });
    return found;
  }

  _decodeInputParams(data, abi) {
    data = ethereumjs_util_1.toBuffer('0x' + data);
    if (!data.length) data = new Uint8Array(32 * abi.inputs.length); // ensuring the data is at least filled by 0 cause `AbiCoder` throws if there's not engouh data

    const inputTypes = [];

    for (let i = 0; i < abi.inputs.length; i++) {
      const type = abi.inputs[i].type;
      inputTypes.push(type.indexOf('tuple') === 0 ? txHelper_1.makeFullTypeDefinition(abi.inputs[i]) : type);
    }

    const abiCoder = new ethers_1.ethers.utils.AbiCoder();
    const decoded = abiCoder.decode(inputTypes, data);
    const ret = {};

    for (var k in abi.inputs) {
      ret[abi.inputs[k].type + ' ' + abi.inputs[k].name] = decoded[k];
    }

    return ret;
  }

}

exports.TxListener = TxListener;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/txRunner.js":
/*!**********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/txRunner.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const ethereumjs_tx_1 = __webpack_require__(/*! ethereumjs-tx */ "../../../node_modules/ethereumjs-tx/dist/index.js");

const ethereumjs_block_1 = tslib_1.__importDefault(__webpack_require__(/*! ethereumjs-block */ "../../../node_modules/ethereumjs-block/index.js"));

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const execution_context_1 = __webpack_require__(/*! ./execution-context */ "../../../dist/libs/remix-lib/src/execution/execution-context.js");

const eventManager_1 = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-lib/src/eventManager.js");

class TxRunner {
  constructor(vmaccounts, api, executionContext) {
    this.event = new eventManager_1.EventManager(); // has a default for now for backwards compatability

    this.executionContext = executionContext || new execution_context_1.ExecutionContext();
    this._api = api;
    this.blockNumber = 0;
    this.runAsync = true;

    if (this.executionContext.isVM()) {
      // this.blockNumber = 1150000 // The VM is running in Homestead mode, which started at this block.
      this.blockNumber = 0; // The VM is running in Homestead mode, which started at this block.

      this.runAsync = false; // We have to run like this cause the VM Event Manager does not support running multiple txs at the same time.
    }

    this.pendingTxs = {};
    this.vmaccounts = vmaccounts;
    this.queusTxs = [];
    this.blocks = [];
  }

  rawRun(args, confirmationCb, gasEstimationForceSend, promptCb, cb) {
    let timestamp = Date.now();

    if (args.timestamp) {
      timestamp = args.timestamp;
    }

    run(this, args, timestamp, confirmationCb, gasEstimationForceSend, promptCb, cb);
  }

  _executeTx(tx, gasPrice, api, promptCb, callback) {
    if (gasPrice) tx.gasPrice = this.executionContext.web3().utils.toHex(gasPrice);

    if (api.personalMode()) {
      promptCb(value => {
        this._sendTransaction(this.executionContext.web3().personal.sendTransaction, tx, value, callback);
      }, () => {
        return callback('Canceled by user.');
      });
    } else {
      this._sendTransaction(this.executionContext.web3().eth.sendTransaction, tx, null, callback);
    }
  }

  _sendTransaction(sendTx, tx, pass, callback) {
    const cb = (err, resp) => {
      if (err) {
        return callback(err, resp);
      }

      this.event.trigger('transactionBroadcasted', [resp]);

      var listenOnResponse = () => {
        // eslint-disable-next-line no-async-promise-executor
        return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          const result = yield tryTillReceiptAvailable(resp, this.executionContext);
          tx = yield tryTillTxAvailable(resp, this.executionContext);
          resolve({
            result,
            tx,
            transactionHash: result ? result['transactionHash'] : null
          });
        }));
      };

      listenOnResponse().then(txData => {
        callback(null, txData);
      }).catch(error => {
        callback(error);
      });
    };

    const args = pass !== null ? [tx, pass, cb] : [tx, cb];

    try {
      sendTx.apply({}, args);
    } catch (e) {
      return callback(`Send transaction failed: ${e.message} . if you use an injected provider, please check it is properly unlocked. `);
    }
  }

  execute(args, confirmationCb, gasEstimationForceSend, promptCb, callback) {
    let data = args.data;

    if (data.slice(0, 2) !== '0x') {
      data = '0x' + data;
    }

    if (!this.executionContext.isVM()) {
      return this.runInNode(args.from, args.to, data, args.value, args.gasLimit, args.useCall, confirmationCb, gasEstimationForceSend, promptCb, callback);
    }

    try {
      this.runInVm(args.from, args.to, data, args.value, args.gasLimit, args.useCall, args.timestamp, callback);
    } catch (e) {
      callback(e, null);
    }
  }

  runInVm(from, to, data, value, gasLimit, useCall, timestamp, callback) {
    const self = this;
    const account = self.vmaccounts[from];

    if (!account) {
      return callback('Invalid account selected');
    }

    this.executionContext.vm().stateManager.getAccount(Buffer.from(from.replace('0x', ''), 'hex'), (err, res) => {
      if (err) {
        callback('Account not found');
      } else {
        // See https://github.com/ethereumjs/ethereumjs-tx/blob/master/docs/classes/transaction.md#constructor
        // for initialization fields and their types
        value = value ? parseInt(value) : 0;
        const tx = new ethereumjs_tx_1.Transaction({
          nonce: new ethereumjs_util_1.BN(res.nonce),
          gasPrice: '0x1',
          gasLimit: gasLimit,
          to: to,
          value: value,
          data: Buffer.from(data.slice(2), 'hex')
        });
        tx.sign(account.privateKey);
        const coinbases = ['0x0e9281e9c6a0808672eaba6bd1220e144c9bb07a', '0x8945a1288dc78a6d8952a92c77aee6730b414778', '0x94d76e24f818426ae84aa404140e8d5f60e10e7e'];
        const difficulties = [new ethereumjs_util_1.BN('69762765929000', 10), new ethereumjs_util_1.BN('70762765929000', 10), new ethereumjs_util_1.BN('71762765929000', 10)];
        const block = new ethereumjs_block_1.default({
          header: {
            timestamp: timestamp || new Date().getTime() / 1000 | 0,
            number: self.blockNumber,
            coinbase: coinbases[self.blockNumber % coinbases.length],
            difficulty: difficulties[self.blockNumber % difficulties.length],
            gasLimit: new ethereumjs_util_1.BN(gasLimit, 10).imuln(2)
          },
          transactions: [tx],
          uncleHeaders: []
        });

        if (!useCall) {
          ++self.blockNumber;
          this.runBlockInVm(tx, block, callback);
        } else {
          this.executionContext.vm().stateManager.checkpoint(() => {
            this.runBlockInVm(tx, block, (err, result) => {
              this.executionContext.vm().stateManager.revert(() => {
                callback(err, result);
              });
            });
          });
        }
      }
    });
  }

  runBlockInVm(tx, block, callback) {
    this.executionContext.vm().runBlock({
      block: block,
      generate: true,
      skipBlockValidation: true,
      skipBalance: false
    }).then(results => {
      const result = results.results[0];

      if (result) {
        const status = result.execResult.exceptionError ? 0 : 1;
        result.status = `0x${status}`;
      }

      this.executionContext.addBlock(block);
      this.executionContext.trackTx('0x' + tx.hash().toString('hex'), block);
      callback(null, {
        result: result,
        transactionHash: ethereumjs_util_1.bufferToHex(Buffer.from(tx.hash()))
      });
    }).catch(function (err) {
      callback(err);
    });
  }

  runInNode(from, to, data, value, gasLimit, useCall, confirmCb, gasEstimationForceSend, promptCb, callback) {
    const tx = {
      from: from,
      to: to,
      data: data,
      value: value
    };

    if (useCall) {
      tx['gas'] = gasLimit;
      return this.executionContext.web3().eth.call(tx, function (error, result) {
        callback(error, {
          result: result,
          transactionHash: result ? result.transactionHash : null
        });
      });
    }

    this.executionContext.web3().eth.estimateGas(tx, (err, gasEstimation) => {
      if (err && err.message.indexOf('Invalid JSON RPC response') !== -1) {
        // // @todo(#378) this should be removed when https://github.com/WalletConnect/walletconnect-monorepo/issues/334 is fixed
        err = 'Gas estimation failed because of an unknown internal error. This may indicated that the transaction will fail.';
      }

      gasEstimationForceSend(err, () => {
        // callback is called whenever no error
        tx['gas'] = !gasEstimation ? gasLimit : gasEstimation;

        if (this._api.config.getUnpersistedProperty('doNotShowTransactionConfirmationAgain')) {
          return this._executeTx(tx, null, this._api, promptCb, callback);
        }

        this._api.detectNetwork((err, network) => {
          if (err) {
            console.log(err);
            return;
          }

          confirmCb(network, tx, tx['gas'], gasPrice => {
            return this._executeTx(tx, gasPrice, this._api, promptCb, callback);
          }, error => {
            callback(error);
          });
        });
      }, () => {
        const blockGasLimit = this.executionContext.currentblockGasLimit(); // NOTE: estimateGas very likely will return a large limit if execution of the code failed
        //       we want to be able to run the code in order to debug and find the cause for the failure

        if (err) return callback(err);
        let warnEstimation = ' An important gas estimation might also be the sign of a problem in the contract code. Please check loops and be sure you did not sent value to a non payable function (that\'s also the reason of strong gas estimation). ';
        warnEstimation += ' ' + err;

        if (gasEstimation > gasLimit) {
          return callback('Gas required exceeds limit: ' + gasLimit + '. ' + warnEstimation);
        }

        if (gasEstimation > blockGasLimit) {
          return callback('Gas required exceeds block gas limit: ' + gasLimit + '. ' + warnEstimation);
        }
      });
    });
  }

}

exports.TxRunner = TxRunner;

function tryTillReceiptAvailable(txhash, executionContext) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      executionContext.web3().eth.getTransactionReceipt(txhash, (err, receipt) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (err || !receipt) {
          // Try again with a bit of delay if error or if result still null
          yield pause();
          return resolve(yield tryTillReceiptAvailable(txhash, executionContext));
        }

        return resolve(receipt);
      }));
    });
  });
}

function tryTillTxAvailable(txhash, executionContext) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      executionContext.web3().eth.getTransaction(txhash, (err, tx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (err || !tx) {
          // Try again with a bit of delay if error or if result still null
          yield pause();
          return resolve(yield tryTillTxAvailable(txhash, executionContext));
        }

        return resolve(tx);
      }));
    });
  });
}

function pause() {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      setTimeout(resolve, 500);
    });
  });
}

function run(self, tx, stamp, confirmationCb, gasEstimationForceSend = null, promptCb = null, callback = null) {
  if (!self.runAsync && Object.keys(self.pendingTxs).length) {
    return self.queusTxs.push({
      tx,
      stamp,
      callback
    });
  }

  self.pendingTxs[stamp] = tx;
  self.execute(tx, confirmationCb, gasEstimationForceSend, promptCb, function (error, result) {
    delete self.pendingTxs[stamp];
    if (callback && typeof callback === 'function') callback(error, result);

    if (self.queusTxs.length) {
      const next = self.queusTxs.pop();
      run(self, next.tx, next.stamp, next.callback);
    }
  });
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/typeConversion.js":
/*!****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/typeConversion.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

function toInt(h) {
  if (h.indexOf && h.indexOf('0x') === 0) {
    return new ethereumjs_util_1.BN(h.replace('0x', ''), 16).toString(10);
  } else if (h.constructor && h.constructor.name === 'BigNumber' || ethereumjs_util_1.BN.isBN(h)) {
    return h.toString(10);
  }

  return h;
}

exports.toInt = toInt;
exports.stringify = convertToString;

function convertToString(v) {
  try {
    if (v instanceof Array) {
      const ret = [];

      for (var k in v) {
        ret.push(convertToString(v[k]));
      }

      return ret;
    } else if (ethereumjs_util_1.BN.isBN(v) || v.constructor && v.constructor.name === 'BigNumber') {
      return v.toString(10);
    } else if (v._isBuffer) {
      return ethereumjs_util_1.bufferToHex(v);
    } else if (typeof v === 'object') {
      const retObject = {};

      for (const i in v) {
        retObject[i] = convertToString(v[i]);
      }

      return retObject;
    } else {
      return v;
    }
  } catch (e) {
    console.log(e);
    return v;
  }
}

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/helpers/compilerHelper.js":
/*!**************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/helpers/compilerHelper.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function compilerInput(contracts) {
  return JSON.stringify({
    language: 'Solidity',
    sources: {
      'test.sol': {
        content: contracts
      }
    },
    settings: {
      optimizer: {
        enabled: false,
        runs: 200
      },
      outputSelection: {
        '*': {
          '': ['ast'],
          '*': ['abi', 'metadata', 'evm.legacyAssembly', 'evm.bytecode', 'evm.deployedBytecode', 'evm.methodIdentifiers', 'evm.gasEstimates']
        }
      }
    }
  });
}

exports.compilerInput = compilerInput;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/helpers/txResultHelper.js":
/*!**************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/helpers/txResultHelper.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const ethjs_util_1 = __webpack_require__(/*! ethjs-util */ "../../../node_modules/ethjs-util/lib/index.js");

function convertToPrefixedHex(input) {
  if (input === undefined || input === null || ethjs_util_1.isHexString(input)) {
    return input;
  } else if (Buffer.isBuffer(input)) {
    return ethereumjs_util_1.bufferToHex(input);
  }

  return '0x' + input.toString(16);
}
/*
 txResult.result can be 3 different things:
 - VM call or tx: ethereumjs-vm result object
 - Node transaction: object returned from eth.getTransactionReceipt()
 - Node call: return value from function call (not an object)

 Also, VM results use BN and Buffers, Node results use hex strings/ints,
 So we need to normalize the values to prefixed hex strings
*/


function resultToRemixTx(txResult) {
  const {
    result,
    transactionHash
  } = txResult;
  const {
    status,
    execResult,
    gasUsed,
    createdAddress,
    contractAddress
  } = result;
  let returnValue, errorMessage;

  if (ethjs_util_1.isHexString(result)) {
    returnValue = result;
  } else if (execResult !== undefined) {
    returnValue = execResult.returnValue;
    errorMessage = execResult.exceptionError;
  }

  return {
    transactionHash,
    status,
    gasUsed: convertToPrefixedHex(gasUsed),
    error: errorMessage,
    return: convertToPrefixedHex(returnValue),
    createdAddress: convertToPrefixedHex(createdAddress || contractAddress)
  };
}

exports.resultToRemixTx = resultToRemixTx;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/helpers/uiHelper.js":
/*!********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/helpers/uiHelper.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function formatMemory(mem, width) {
  const ret = {};

  if (!mem) {
    return ret;
  }

  if (!mem.substr) {
    mem = mem.join(''); // geth returns an array, eth return raw string
  }

  for (let k = 0; k < mem.length; k += width * 2) {
    const memory = mem.substr(k, width * 2);
    const content = this.tryConvertAsciiFormat(memory);
    ret['0x' + (k / 2).toString(16)] = content.raw + '\t' + content.ascii;
  }

  return ret;
}

exports.formatMemory = formatMemory;

function tryConvertAsciiFormat(memorySlot) {
  const ret = {
    ascii: '',
    raw: ''
  };

  for (let k = 0; k < memorySlot.length; k += 2) {
    const raw = memorySlot.substr(k, 2);
    let ascii = String.fromCharCode(parseInt(raw, 16));
    ascii = ascii.replace(/[^\w\s]/, '?');

    if (ascii === '') {
      ascii = '?';
    }

    ret.ascii += ascii;
    ret.raw += raw;
  }

  return ret;
}

exports.tryConvertAsciiFormat = tryConvertAsciiFormat;
/**
 * format @args css1, css2, css3 to css inline style
 *
 * @param {Object} css1 - css inline declaration
 * @param {Object} css2 - css inline declaration
 * @param {Object} css3 - css inline declaration
 * @param {Object} ...
 * @return {String} css inline style
 *                  if the key start with * the value is direcly appended to the inline style (which should be already inline style formatted)
 *                  used if multiple occurences of the same key is needed
 */

function formatCss(css1, css2) {
  let ret = '';

  for (const arg in arguments) {
    for (const k in arguments[arg]) {
      if (arguments[arg][k] && ret.indexOf(k) === -1) {
        if (k.indexOf('*') === 0) {
          ret += arguments[arg][k];
        } else {
          ret += k + ':' + arguments[arg][k] + ';';
        }
      }
    }
  }

  return ret;
}

exports.formatCss = formatCss;

function normalizeHex(hex) {
  if (hex.indexOf('0x') === 0) {
    hex = hex.replace('0x', '');
  }

  hex = hex.replace(/^0+/, '');
  return '0x' + hex;
}

exports.normalizeHex = normalizeHex;

function normalizeHexAddress(hex) {
  if (hex.indexOf('0x') === 0) hex = hex.replace('0x', '');

  if (hex.length >= 40) {
    const reg = /(.{40})$/.exec(hex);

    if (reg) {
      return '0x' + reg[0];
    }
  } else {
    return '0x' + new Array(40 - hex.length + 1).join('0') + hex;
  }
}

exports.normalizeHexAddress = normalizeHexAddress;

function runInBrowser() {
  return typeof window !== 'undefined';
}

exports.runInBrowser = runInBrowser;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/index.js":
/*!*********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const eventManager_1 = __webpack_require__(/*! ./eventManager */ "../../../dist/libs/remix-lib/src/eventManager.js");

const uiHelper = tslib_1.__importStar(__webpack_require__(/*! ./helpers/uiHelper */ "../../../dist/libs/remix-lib/src/helpers/uiHelper.js"));

const compilerHelper = tslib_1.__importStar(__webpack_require__(/*! ./helpers/compilerHelper */ "../../../dist/libs/remix-lib/src/helpers/compilerHelper.js"));

const util = tslib_1.__importStar(__webpack_require__(/*! ./util */ "../../../dist/libs/remix-lib/src/util.js"));

const web3Providers_1 = __webpack_require__(/*! ./web3Provider/web3Providers */ "../../../dist/libs/remix-lib/src/web3Provider/web3Providers.js");

const dummyProvider_1 = __webpack_require__(/*! ./web3Provider/dummyProvider */ "../../../dist/libs/remix-lib/src/web3Provider/dummyProvider.js");

const web3VmProvider_1 = __webpack_require__(/*! ./web3Provider/web3VmProvider */ "../../../dist/libs/remix-lib/src/web3Provider/web3VmProvider.js");

const storage_1 = __webpack_require__(/*! ./storage */ "../../../dist/libs/remix-lib/src/storage.js");

const eventsDecoder_1 = __webpack_require__(/*! ./execution/eventsDecoder */ "../../../dist/libs/remix-lib/src/execution/eventsDecoder.js");

const txExecution = tslib_1.__importStar(__webpack_require__(/*! ./execution/txExecution */ "../../../dist/libs/remix-lib/src/execution/txExecution.js"));

const txHelper = tslib_1.__importStar(__webpack_require__(/*! ./execution/txHelper */ "../../../dist/libs/remix-lib/src/execution/txHelper.js"));

const txFormat = tslib_1.__importStar(__webpack_require__(/*! ./execution/txFormat */ "../../../dist/libs/remix-lib/src/execution/txFormat.js"));

const txListener_1 = __webpack_require__(/*! ./execution/txListener */ "../../../dist/libs/remix-lib/src/execution/txListener.js");

const txRunner_1 = __webpack_require__(/*! ./execution/txRunner */ "../../../dist/libs/remix-lib/src/execution/txRunner.js");

const execution_context_1 = __webpack_require__(/*! ./execution/execution-context */ "../../../dist/libs/remix-lib/src/execution/execution-context.js");

const typeConversion = tslib_1.__importStar(__webpack_require__(/*! ./execution/typeConversion */ "../../../dist/libs/remix-lib/src/execution/typeConversion.js"));

const universalDapp_1 = __webpack_require__(/*! ./universalDapp */ "../../../dist/libs/remix-lib/src/universalDapp.js");

function modules() {
  return {
    EventManager: eventManager_1.EventManager,
    helpers: {
      ui: uiHelper,
      compiler: compilerHelper
    },
    vm: {
      Web3Providers: web3Providers_1.Web3Providers,
      DummyProvider: dummyProvider_1.DummyProvider,
      Web3VMProvider: web3VmProvider_1.Web3VmProvider
    },
    Storage: storage_1.Storage,
    util: util,
    execution: {
      EventsDecoder: eventsDecoder_1.EventsDecoder,
      txExecution: txExecution,
      txHelper: txHelper,
      executionContext: new execution_context_1.ExecutionContext(),
      txFormat: txFormat,
      txListener: txListener_1.TxListener,
      txRunner: txRunner_1.TxRunner,
      typeConversion: typeConversion
    },
    UniversalDApp: universalDapp_1.UniversalDApp
  };
}

module.exports = modules();

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/init.js":
/*!********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/init.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const web3_1 = tslib_1.__importDefault(__webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js"));

function loadWeb3(url = 'http://localhost:8545') {
  const web3 = new web3_1.default();
  web3.setProvider(new web3_1.default.providers.HttpProvider(url));
  this.extend(web3);
  return web3;
}

exports.loadWeb3 = loadWeb3;

function extendWeb3(web3) {
  this.extend(web3);
}

exports.extendWeb3 = extendWeb3;

function setProvider(web3, url) {
  web3.setProvider(new web3.providers.HttpProvider(url));
}

exports.setProvider = setProvider;

function web3DebugNode(network) {
  const web3DebugNodes = {
    Main: 'https://gethmainnet.komputing.org',
    Rinkeby: 'https://remix-rinkeby.ethdevops.io',
    Ropsten: 'https://remix-ropsten.ethdevops.io',
    Goerli: 'https://remix-goerli.ethdevops.io',
    Kovan: 'https://remix-kovan.ethdevops.io'
  };

  if (web3DebugNodes[network]) {
    return this.loadWeb3(web3DebugNodes[network]);
  }

  return null;
}

exports.web3DebugNode = web3DebugNode;

function extend(web3) {
  if (!web3.extend) {
    return;
  } // DEBUG


  const methods = [];

  if (!(web3.debug && web3.debug.preimage)) {
    methods.push(new web3.extend.Method({
      name: 'preimage',
      call: 'debug_preimage',
      inputFormatter: [null],
      params: 1
    }));
  }

  if (!(web3.debug && web3.debug.traceTransaction)) {
    methods.push(new web3.extend.Method({
      name: 'traceTransaction',
      call: 'debug_traceTransaction',
      inputFormatter: [null, null],
      params: 2
    }));
  }

  if (!(web3.debug && web3.debug.storageRangeAt)) {
    methods.push(new web3.extend.Method({
      name: 'storageRangeAt',
      call: 'debug_storageRangeAt',
      inputFormatter: [null, null, null, null, null],
      params: 5
    }));
  }

  if (methods.length > 0) {
    web3.extend({
      property: 'debug',
      methods: methods,
      properties: []
    });
  }
}

exports.extend = extend;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/storage.js":
/*!***********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/storage.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class Storage {
  constructor(prefix) {
    this.prefix = prefix; // on startup, upgrade the old storage layout

    if (typeof window !== 'undefined') {
      this.safeKeys().forEach(function (name) {
        if (name.indexOf('sol-cache-file-', 0) === 0) {
          var content = window.localStorage.getItem(name);
          window.localStorage.setItem(name.replace(/^sol-cache-file-/, 'sol:'), content);
          window.localStorage.removeItem(name);
        }
      });
    } // remove obsolete key


    if (typeof window !== 'undefined') {
      window.localStorage.removeItem('editor-size-cache');
    }
  }

  exists(name) {
    if (typeof window !== 'undefined') {
      return this.get(name) !== null;
    }
  }

  get(name) {
    if (typeof window !== 'undefined') {
      return window.localStorage.getItem(this.prefix + name);
    }
  }

  set(name, content) {
    try {
      if (typeof window !== 'undefined') {
        window.localStorage.setItem(this.prefix + name, content);
      }
    } catch (exception) {
      return false;
    }

    return true;
  }

  remove(name) {
    if (typeof window !== 'undefined') {
      window.localStorage.removeItem(this.prefix + name);
    }

    return true;
  }

  rename(originalName, newName) {
    const content = this.get(originalName);

    if (!this.set(newName, content)) {
      return false;
    }

    this.remove(originalName);
    return true;
  }

  safeKeys() {
    // NOTE: this is a workaround for some browsers
    if (typeof window !== 'undefined') {
      return Object.keys(window.localStorage).filter(function (item) {
        return item !== null && item !== undefined;
      });
    }

    return [];
  }

  keys() {
    return this.safeKeys() // filter any names not including the prefix
    .filter(item => item.indexOf(this.prefix, 0) === 0) // remove prefix from filename and add the 'browser' path
    .map(item => item.substr(this.prefix.length));
  }

}

exports.Storage = Storage;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/universalDapp.js":
/*!*****************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/universalDapp.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

const async_1 = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const ethjs_util_1 = __webpack_require__(/*! ethjs-util */ "../../../node_modules/ethjs-util/lib/index.js");

const crypto_1 = __webpack_require__(/*! crypto */ "../../../node_modules/crypto-browserify/index.js");

const events_1 = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

const txRunner_1 = __webpack_require__(/*! ./execution/txRunner */ "../../../dist/libs/remix-lib/src/execution/txRunner.js");

const txHelper_1 = __webpack_require__(/*! ./execution/txHelper */ "../../../dist/libs/remix-lib/src/execution/txHelper.js");

const eventManager_1 = __webpack_require__(/*! ./eventManager */ "../../../dist/libs/remix-lib/src/eventManager.js");

const execution_context_1 = __webpack_require__(/*! ./execution/execution-context */ "../../../dist/libs/remix-lib/src/execution/execution-context.js");

const txResultHelper_1 = __webpack_require__(/*! ./helpers/txResultHelper */ "../../../dist/libs/remix-lib/src/helpers/txResultHelper.js");

class UniversalDApp {
  constructor(config, executionContext) {
    this.events = new events_1.EventEmitter();
    this.event = new eventManager_1.EventManager(); // has a default for now for backwards compatability

    this.executionContext = executionContext || new execution_context_1.ExecutionContext();
    this.config = config;
    this.txRunner = new txRunner_1.TxRunner({}, {
      config: config,
      detectNetwork: cb => {
        this.executionContext.detectNetwork(cb);
      },
      personalMode: () => {
        return this.executionContext.getProvider() === 'web3' ? this.config.get('settings/personal-mode') : false;
      }
    }, this.executionContext);
    this.accounts = {};
    this.executionContext.event.register('contextChanged', this.resetEnvironment.bind(this));
  } // TODO : event should be triggered by Udapp instead of TxListener

  /** Listen on New Transaction. (Cannot be done inside constructor because txlistener doesn't exist yet) */


  startListening(txlistener) {
    txlistener.event.register('newTransaction', tx => {
      this.events.emit('newTransaction', tx);
    });
  }

  resetEnvironment() {
    this.accounts = {};

    if (this.executionContext.isVM()) {
      this._addAccount('3cd7232cd6f3fc66a57a6bedc1a8ed6c228fff0a327e169c2bcc5e869ed49511', '0x56BC75E2D63100000');

      this._addAccount('2ac6c190b09897cd8987869cc7b918cfea07ee82038d492abce033c75c1b1d0c', '0x56BC75E2D63100000');

      this._addAccount('dae9801649ba2d95a21e688b56f77905e5667c44ce868ec83f82e838712a2c7a', '0x56BC75E2D63100000');

      this._addAccount('d74aa6d18aa79a05f3473dd030a97d3305737cbc8337d940344345c1f6b72eea', '0x56BC75E2D63100000');

      this._addAccount('71975fbf7fe448e004ac7ae54cad0a383c3906055a65468714156a07385e96ce', '0x56BC75E2D63100000');
    } // TODO: most params here can be refactored away in txRunner


    this.txRunner = new txRunner_1.TxRunner(this.accounts, {
      // TODO: only used to check value of doNotShowTransactionConfirmationAgain property
      config: this.config,
      // TODO: to refactor, TxRunner already has access to executionContext
      detectNetwork: cb => {
        this.executionContext.detectNetwork(cb);
      },
      personalMode: () => {
        return this.executionContext.getProvider() === 'web3' ? this.config.get('settings/personal-mode') : false;
      }
    }, this.executionContext);
    this.txRunner.event.register('transactionBroadcasted', txhash => {
      this.executionContext.detectNetwork((error, network) => {
        if (error || !network) return;
        this.event.trigger('transactionBroadcasted', [txhash, network.name]);
      });
    });
  }

  resetAPI(transactionContextAPI) {
    this.transactionContextAPI = transactionContextAPI;
  }
  /**
   * Create a VM Account
   * @param {{privateKey: string, balance: string}} newAccount The new account to create
   */


  createVMAccount(newAccount) {
    const {
      privateKey,
      balance
    } = newAccount;

    if (this.executionContext.getProvider() !== 'vm') {
      throw new Error('plugin API does not allow creating a new account through web3 connection. Only vm mode is allowed');
    }

    this._addAccount(privateKey, balance);

    const privKey = Buffer.from(privateKey, 'hex');
    return '0x' + ethereumjs_util_1.privateToAddress(privKey).toString('hex');
  }

  newAccount(password, passwordPromptCb, cb) {
    if (!this.executionContext.isVM()) {
      if (!this.config.get('settings/personal-mode')) {
        return cb('Not running in personal mode');
      }

      return passwordPromptCb(passphrase => {
        this.executionContext.web3().personal.newAccount(passphrase, cb);
      });
    }

    let privateKey;

    do {
      privateKey = crypto_1.randomBytes(32);
    } while (!ethereumjs_util_1.isValidPrivate(privateKey));

    this._addAccount(privateKey, '0x56BC75E2D63100000');

    cb(null, '0x' + ethereumjs_util_1.privateToAddress(privateKey).toString('hex'));
  }
  /** Add an account to the list of account (only for Javascript VM) */


  _addAccount(privateKey, balance) {
    if (!this.executionContext.isVM()) {
      throw new Error('_addAccount() cannot be called in non-VM mode');
    }

    if (!this.accounts) {
      return;
    }

    privateKey = Buffer.from(privateKey, 'hex');
    const address = ethereumjs_util_1.privateToAddress(privateKey); // FIXME: we don't care about the callback, but we should still make this proper

    const stateManager = this.executionContext.vm().stateManager;
    stateManager.getAccount(address, (error, account) => {
      if (error) return console.log(error);
      account.balance = balance || '0xf00000000000000001';
      stateManager.putAccount(address, account, function cb(error) {
        if (error) console.log(error);
      });
    });
    this.accounts[ethereumjs_util_1.toChecksumAddress('0x' + address.toString('hex'))] = {
      privateKey,
      nonce: 0
    };
  }
  /** Return the list of accounts */


  getAccounts(cb) {
    return new Promise((resolve, reject) => {
      const provider = this.executionContext.getProvider();

      switch (provider) {
        case 'vm':
          if (!this.accounts) {
            if (cb) cb('No accounts?');
            reject(new Error('No accounts?'));
            return;
          }

          if (cb) cb(null, Object.keys(this.accounts));
          resolve(Object.keys(this.accounts));
          break;

        case 'web3':
          if (this.config.get('settings/personal-mode')) {
            return this.executionContext.web3().personal.getListAccounts((error, accounts) => {
              if (cb) cb(error, accounts);
              if (error) return reject(error);
              resolve(accounts);
            });
          } else {
            this.executionContext.web3().eth.getAccounts((error, accounts) => {
              if (cb) cb(error, accounts);
              if (error) return reject(error);
              resolve(accounts);
            });
          }

          break;

        case 'injected':
          {
            this.executionContext.web3().eth.getAccounts((error, accounts) => {
              if (cb) cb(error, accounts);
              if (error) return reject(error);
              resolve(accounts);
            });
          }
      }
    });
  }
  /** Get the balance of an address */


  getBalance(address, cb) {
    address = ethjs_util_1.stripHexPrefix(address);

    if (!this.executionContext.isVM()) {
      return this.executionContext.web3().eth.getBalance(address, (err, res) => {
        if (err) {
          return cb(err);
        }

        cb(null, res.toString(10));
      });
    }

    if (!this.accounts) {
      return cb('No accounts?');
    }

    this.executionContext.vm().stateManager.getAccount(Buffer.from(address, 'hex'), (err, res) => {
      if (err) {
        return cb('Account not found');
      }

      cb(null, new ethereumjs_util_1.BN(res.balance).toString(10));
    });
  }
  /** Get the balance of an address, and convert wei to ether */


  getBalanceInEther(address, callback) {
    this.getBalance(address, (error, balance) => {
      if (error) {
        return callback(error);
      }

      callback(null, this.executionContext.web3().utils.fromWei(balance, 'ether'));
    });
  }

  pendingTransactionsCount() {
    return Object.keys(this.txRunner.pendingTxs).length;
  }
  /**
    * deploy the given contract
    *
    * @param {String} data    - data to send with the transaction ( return of txFormat.buildData(...) ).
    * @param {Function} callback    - callback.
    */


  createContract(data, confirmationCb, continueCb, promptCb, callback) {
    this.runTx({
      data: data,
      useCall: false
    }, confirmationCb, continueCb, promptCb, callback);
  }
  /**
    * call the current given contract
    *
    * @param {String} to    - address of the contract to call.
    * @param {String} data    - data to send with the transaction ( return of txFormat.buildData(...) ).
    * @param {Object} funAbi    - abi definition of the function to call.
    * @param {Function} callback    - callback.
    */


  callFunction(to, data, funAbi, confirmationCb, continueCb, promptCb, callback) {
    const useCall = funAbi.stateMutability === 'view' || funAbi.stateMutability === 'pure';
    this.runTx({
      to,
      data,
      useCall
    }, confirmationCb, continueCb, promptCb, callback);
  }
  /**
    * call the current given contract
    *
    * @param {String} to    - address of the contract to call.
    * @param {String} data    - data to send with the transaction ( return of txFormat.buildData(...) ).
    * @param {Function} callback    - callback.
    */


  sendRawTransaction(to, data, confirmationCb, continueCb, promptCb, callback) {
    this.runTx({
      to,
      data,
      useCall: false
    }, confirmationCb, continueCb, promptCb, callback);
  }

  context() {
    return this.executionContext.isVM() ? 'memory' : 'blockchain';
  }

  getABI(contract) {
    return txHelper_1.sortAbiFunction(contract.abi);
  }

  getFallbackInterface(contractABI) {
    return txHelper_1.getFallbackInterface(contractABI);
  }

  getReceiveInterface(contractABI) {
    return txHelper_1.getReceiveInterface(contractABI);
  }

  getInputs(funABI) {
    if (!funABI.inputs) {
      return '';
    }

    return txHelper_1.inputParametersDeclarationToString(funABI.inputs);
  }
  /**
   * This function send a tx only to javascript VM or testnet, will return an error for the mainnet
   * SHOULD BE TAKEN CAREFULLY!
   *
   * @param {Object} tx    - transaction.
   */


  sendTransaction(tx) {
    return new Promise((resolve, reject) => {
      this.executionContext.detectNetwork((error, network) => {
        if (error) return reject(error);

        if (network.name === 'Main' && network.id === '1') {
          return reject(new Error('It is not allowed to make this action against mainnet'));
        }

        this.silentRunTx(tx, (error, result) => {
          if (error) return reject(error);

          try {
            resolve(txResultHelper_1.resultToRemixTx(result));
          } catch (e) {
            reject(e);
          }
        });
      });
    });
  }
  /**
   * This function send a tx without alerting the user (if mainnet or if gas estimation too high).
   * SHOULD BE TAKEN CAREFULLY!
   *
   * @param {Object} tx    - transaction.
   * @param {Function} callback    - callback.
   */


  silentRunTx(tx, cb) {
    this.txRunner.rawRun(tx, (network, tx, gasEstimation, continueTxExecution, cancelCb) => {
      continueTxExecution();
    }, (error, continueTxExecution, cancelCb) => {
      if (error) {
        cb(error);
      } else {
        continueTxExecution();
      }
    }, (okCb, cancelCb) => {
      okCb();
    }, cb);
  }

  runTx(args, confirmationCb, continueCb, promptCb, cb) {
    const self = this;
    async_1.waterfall([function getGasLimit(next) {
      if (self.transactionContextAPI.getGasLimit) {
        return self.transactionContextAPI.getGasLimit(next);
      }

      next(null, 3000000);
    }, function queryValue(gasLimit, next) {
      if (args.value) {
        return next(null, args.value, gasLimit);
      }

      if (args.useCall || !self.transactionContextAPI.getValue) {
        return next(null, 0, gasLimit);
      }

      self.transactionContextAPI.getValue(function (err, value) {
        next(err, value, gasLimit);
      });
    }, function getAccount(value, gasLimit, next) {
      if (args.from) {
        return next(null, args.from, value, gasLimit);
      }

      if (self.transactionContextAPI.getAddress) {
        return self.transactionContextAPI.getAddress(function (err, address) {
          next(err, address, value, gasLimit);
        });
      }

      self.getAccounts(function (err, accounts) {
        const address = accounts[0];
        if (err) return next(err);
        if (!address) return next('No accounts available');

        if (self.executionContext.isVM() && !self.accounts[address]) {
          return next('Invalid account selected');
        }

        next(null, address, value, gasLimit);
      });
    }, function runTransaction(fromAddress, value, gasLimit, next) {
      const tx = {
        to: args.to,
        data: args.data.dataHex,
        useCall: args.useCall,
        from: fromAddress,
        value: value,
        gasLimit: gasLimit,
        timestamp: args.data.timestamp
      };
      const payLoad = {
        funAbi: args.data.funAbi,
        funArgs: args.data.funArgs,
        contractBytecode: args.data.contractBytecode,
        contractName: args.data.contractName,
        contractABI: args.data.contractABI,
        linkReferences: args.data.linkReferences
      };
      let timestamp = Date.now();

      if (tx.timestamp) {
        timestamp = tx.timestamp;
      }

      self.event.trigger('initiatingTransaction', [timestamp, tx, payLoad]);
      self.txRunner.rawRun(tx, confirmationCb, continueCb, promptCb, function (error, result) {
        const eventName = tx.useCall ? 'callExecuted' : 'transactionExecuted';
        self.event.trigger(eventName, [error, tx.from, tx.to, tx.data, tx.useCall, result, timestamp, payLoad]);

        if (error && typeof error !== 'string') {
          if (error.message) error = error.message;else {
            // eslint-disable-next-line no-empty
            try {
              error = 'error: ' + JSON.stringify(error);
            } catch (e) {}
          }
        }

        next(error, result);
      });
    }], cb);
  }

}

exports.UniversalDApp = UniversalDApp;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/util.js":
/*!********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/util.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");
/*
 contains misc util: @TODO should be splitted
  - hex conversion
  - binary search
  - CALL related look up
  - sha3 calculation
  - swarm hash extraction
  - bytecode comparison
*/

/*
    ints: IntArray
  */


function hexConvert(ints) {
  let ret = '0x';

  for (let i = 0; i < ints.length; i++) {
    const h = ints[i];

    if (h) {
      ret += (h <= 0xf ? '0' : '') + h.toString(16);
    } else {
      ret += '00';
    }
  }

  return ret;
}

exports.hexConvert = hexConvert;
/**
   * Converts a hex string to an array of integers.
   */

function hexToIntArray(hexString) {
  if (hexString.slice(0, 2) === '0x') {
    hexString = hexString.slice(2);
  }

  const integers = [];

  for (let i = 0; i < hexString.length; i += 2) {
    integers.push(parseInt(hexString.slice(i, i + 2), 16));
  }

  return integers;
}

exports.hexToIntArray = hexToIntArray;
/*
    ints: list of BNs
  */

function hexListFromBNs(bnList) {
  const ret = [];

  for (const k in bnList) {
    const v = bnList[k];

    if (ethereumjs_util_1.BN.isBN(v)) {
      ret.push('0x' + v.toString('hex', 64));
    } else {
      ret.push('0x' + new ethereumjs_util_1.BN(v).toString('hex', 64)); // TEMP FIX TO REMOVE ONCE https://github.com/ethereumjs/ethereumjs-vm/pull/293 is released
    }
  }

  return ret;
}

exports.hexListFromBNs = hexListFromBNs;
/*
  ints: list of IntArrays
*/

function hexListConvert(intsList) {
  const ret = [];

  for (const k in intsList) {
    ret.push(this.hexConvert(intsList[k]));
  }

  return ret;
}

exports.hexListConvert = hexListConvert;
/*
  ints: ints: IntArray
*/

function formatMemory(mem) {
  const hexMem = this.hexConvert(mem).substr(2);
  const ret = [];

  for (let k = 0; k < hexMem.length; k += 32) {
    const row = hexMem.substr(k, 32);
    ret.push(row);
  }

  return ret;
}

exports.formatMemory = formatMemory;
/*
  Binary Search:
  Assumes that @arg array is sorted increasingly
  return largest i such that array[i] <= target; return -1 if array[0] > target || array is empty
*/

function findLowerBound(target, array) {
  let start = 0;
  let length = array.length;

  while (length > 0) {
    const half = length >> 1;
    const middle = start + half;

    if (array[middle] <= target) {
      length = length - 1 - half;
      start = middle + 1;
    } else {
      length = half;
    }
  }

  return start - 1;
}

exports.findLowerBound = findLowerBound;
/*
  Binary Search:
  Assumes that @arg array is sorted increasingly
  return largest array[i] such that array[i] <= target; return null if array[0] > target || array is empty
*/

function findLowerBoundValue(target, array) {
  const index = this.findLowerBound(target, array);
  return index >= 0 ? array[index] : null;
}

exports.findLowerBoundValue = findLowerBoundValue;
/*
  Binary Search:
  Assumes that @arg array is sorted increasingly
  return Return i such that |array[i] - target| is smallest among all i and -1 for an empty array.
  Returns the smallest i for multiple candidates.
*/

function findClosestIndex(target, array) {
  if (array.length === 0) {
    return -1;
  }

  const index = this.findLowerBound(target, array);

  if (index < 0) {
    return 0;
  } else if (index >= array.length - 1) {
    return array.length - 1;
  } else {
    const middle = (array[index] + array[index + 1]) / 2;
    return target <= middle ? index : index + 1;
  }
}

exports.findClosestIndex = findClosestIndex;
/**
  * Find the call from @args rootCall which contains @args index (recursive)
  *
  * @param {Int} index - index of the vmtrace
  * @param {Object} rootCall  - call tree, built by the trace analyser
  * @return {Object} - return the call which include the @args index
  */

function findCall(index, rootCall) {
  const ret = buildCallPath(index, rootCall);
  return ret[ret.length - 1];
}

exports.findCall = findCall;
/**
  * Find calls path from @args rootCall which leads to @args index (recursive)
  *
  * @param {Int} index - index of the vmtrace
  * @param {Object} rootCall  - call tree, built by the trace analyser
  * @return {Array} - return the calls path to @args index
  */

function buildCallPath(index, rootCall) {
  const ret = [];
  findCallInternal(index, rootCall, ret);
  return ret;
}

exports.buildCallPath = buildCallPath;
/**
  * sha3 the given @arg value (left pad to 32 bytes)
  *
  * @param {String} value - value to sha3
  * @return {Object} - return sha3ied value
  */

function sha3_256(value) {
  if (typeof value === 'string' && value.indexOf('0x') !== 0) {
    value = '0x' + value;
  }

  const ret = ethereumjs_util_1.bufferToHex(ethereumjs_util_1.setLengthLeft(value, 32));
  const retInBuffer = ethereumjs_util_1.keccak(ret);
  return ethereumjs_util_1.bufferToHex(retInBuffer);
}

exports.sha3_256 = sha3_256;
/**
  * return a regex which extract the swarmhash from the bytecode.
  *
  * @return {RegEx}
  */

function swarmHashExtraction() {
  return /a165627a7a72305820([0-9a-f]{64})0029$/;
}

exports.swarmHashExtraction = swarmHashExtraction;
/**
  * return a regex which extract the swarmhash from the bytecode, from POC 0.3
  *
  * @return {RegEx}
  */

function swarmHashExtractionPOC31() {
  return /a265627a7a72315820([0-9a-f]{64})64736f6c6343([0-9a-f]{6})0032$/;
}

exports.swarmHashExtractionPOC31 = swarmHashExtractionPOC31;
/**
  * return a regex which extract the swarmhash from the bytecode, from POC 0.3
  *
  * @return {RegEx}
  */

function swarmHashExtractionPOC32() {
  return /a265627a7a72305820([0-9a-f]{64})64736f6c6343([0-9a-f]{6})0032$/;
}

exports.swarmHashExtractionPOC32 = swarmHashExtractionPOC32;
/**
  * return a regex which extract the cbor encoded metadata : {"ipfs": <IPFS hash>, "solc": <compiler version>} from the bytecode.
  * ref https://solidity.readthedocs.io/en/v0.6.6/metadata.html?highlight=ipfs#encoding-of-the-metadata-hash-in-the-bytecode
  * @return {RegEx}
  */

function cborEncodedValueExtraction() {
  return /64697066735822([0-9a-f]{68})64736f6c6343([0-9a-f]{6})0033$/;
}

exports.cborEncodedValueExtraction = cborEncodedValueExtraction;

function extractcborMetadata(value) {
  return value.replace(this.cborEncodedValueExtraction(), '');
}

exports.extractcborMetadata = extractcborMetadata;

function extractSwarmHash(value) {
  value = value.replace(this.swarmHashExtraction(), '');
  value = value.replace(this.swarmHashExtractionPOC31(), '');
  value = value.replace(this.swarmHashExtractionPOC32(), '');
  return value;
}

exports.extractSwarmHash = extractSwarmHash;
/**
  * Compare bytecode. return true if the code is equal (handle swarm hash and library references)
  * @param {String} code1 - the bytecode that is actually deployed (contains resolved library reference and a potentially different swarmhash)
  * @param {String} code2 - the bytecode generated by the compiler (contains unresolved library reference and a potentially different swarmhash)
                            this will return false if the generated bytecode is empty (asbtract contract cannot be deployed)
  *
  * @return {bool}
  */

function compareByteCode(code1, code2) {
  if (code1 === code2) return true;
  if (code2 === '0x') return false; // abstract contract. see comment

  if (code2.substr(2, 46) === '7300000000000000000000000000000000000000003014') {
    // testing the following signature: PUSH20 00..00 ADDRESS EQ
    // in the context of a library, that slot contains the address of the library (pushed by the compiler to avoid calling library other than with a DELEGATECALL)
    // if code2 is not a library, well we still suppose that the comparison remain relevant even if we remove some information from `code1`
    code1 = replaceLibReference(code1, 4);
  }

  let pos = -1;

  while ((pos = code2.search(/__(.*)__/)) !== -1) {
    code2 = replaceLibReference(code2, pos);
    code1 = replaceLibReference(code1, pos);
  }

  code1 = this.extractSwarmHash(code1);
  code1 = this.extractcborMetadata(code1);
  code2 = this.extractSwarmHash(code2);
  code2 = this.extractcborMetadata(code2);

  if (code1 && code2 && code1.indexOf(code2) === 0) {
    return true;
  }

  return false;
}

exports.compareByteCode = compareByteCode;
/* util extracted out from remix-ide. @TODO split this file, cause it mix real util fn with solidity related stuff ... */

function groupBy(arr, key) {
  return arr.reduce((sum, item) => {
    const groupByVal = item[key];
    const groupedItems = sum[groupByVal] || [];
    groupedItems.push(item);
    sum[groupByVal] = groupedItems;
    return sum;
  }, {});
}

exports.groupBy = groupBy;

function concatWithSeperator(list, seperator) {
  return list.reduce((sum, item) => sum + item + seperator, '').slice(0, -seperator.length);
}

exports.concatWithSeperator = concatWithSeperator;

function escapeRegExp(str) {
  return str.replace(/[-[\]/{}()+?.\\^$|]/g, '\\$&');
}

exports.escapeRegExp = escapeRegExp;

function replaceLibReference(code, pos) {
  return code.substring(0, pos) + '0000000000000000000000000000000000000000' + code.substring(pos + 40);
}

function findCallInternal(index, rootCall, callsPath) {
  const calls = Object.keys(rootCall.calls);
  const ret = rootCall;
  callsPath.push(rootCall);

  for (const k in calls) {
    const subCall = rootCall.calls[calls[k]];

    if (index >= subCall.start && index <= subCall.return) {
      findCallInternal(index, subCall, callsPath);
      break;
    }
  }

  return ret;
}

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/web3Provider/dummyProvider.js":
/*!******************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/web3Provider/dummyProvider.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class DummyProvider {
  constructor() {
    this.eth = {};
    this.debug = {};

    this.eth.getCode = (address, cb) => {
      return this.getCode(address, cb);
    };

    this.eth.getTransaction = (hash, cb) => {
      return this.getTransaction(hash, cb);
    };

    this.eth.getTransactionFromBlock = (blockNumber, txIndex, cb) => {
      return this.getTransactionFromBlock(blockNumber, txIndex, cb);
    };

    this.eth.getBlockNumber = cb => {
      return this.getBlockNumber(cb);
    };

    this.debug.traceTransaction = (hash, options, cb) => {
      return this.traceTransaction(hash, options, cb);
    };

    this.debug.storageRangeAt = (blockNumber, txIndex, address, start, end, maxLength, cb) => {
      return this.storageRangeAt(blockNumber, txIndex, address, start, end, maxLength, cb);
    };

    this.providers = {
      HttpProvider: function (url) {}
    };
    this.currentProvider = {
      host: ''
    };
  }

  getCode(address, cb) {
    cb(null, '');
  }

  setProvider(provider) {}

  traceTransaction(txHash, options, cb) {
    if (cb) {
      cb(null, {});
    }

    return {};
  }

  storageRangeAt(blockNumber, txIndex, address, start, end, maxLength, cb) {
    if (cb) {
      cb(null, {});
    }

    return {};
  }

  getBlockNumber(cb) {
    cb(null, '');
  }

  getTransaction(txHash, cb) {
    if (cb) {
      cb(null, {});
    }

    return {};
  }

  getTransactionFromBlock(blockNumber, txIndex, cb) {
    if (cb) {
      cb(null, {});
    }

    return {};
  }

}

exports.DummyProvider = DummyProvider;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/web3Provider/web3Providers.js":
/*!******************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/web3Provider/web3Providers.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const web3VmProvider_1 = __webpack_require__(/*! ./web3VmProvider */ "../../../dist/libs/remix-lib/src/web3Provider/web3VmProvider.js");

const init_1 = __webpack_require__(/*! ../init */ "../../../dist/libs/remix-lib/src/init.js");

class Web3Providers {
  constructor() {
    this.modes = {};
  }

  addProvider(type, obj) {
    if (type === 'INTERNAL') {
      const web3 = init_1.loadWeb3();
      this.addWeb3(type, web3);
    } else if (type === 'vm') {
      this.addVM(type, obj);
    } else {
      init_1.extendWeb3(obj);
      this.addWeb3(type, obj);
    }
  }

  get(type, cb) {
    if (this.modes[type]) {
      return cb(null, this.modes[type]);
    }

    cb('error: this provider has not been setup (' + type + ')', null);
  }

  addWeb3(type, web3) {
    this.modes[type] = web3;
  }

  addVM(type, vm) {
    const vmProvider = new web3VmProvider_1.Web3VmProvider();
    vmProvider.setVM(vm);
    this.modes[type] = vmProvider;
  }

}

exports.Web3Providers = Web3Providers;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/web3Provider/web3VmProvider.js":
/*!*******************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/web3Provider/web3VmProvider.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const util_1 = __webpack_require__(/*! ../util */ "../../../dist/libs/remix-lib/src/util.js");

const uiHelper_1 = __webpack_require__(/*! ../helpers/uiHelper */ "../../../dist/libs/remix-lib/src/helpers/uiHelper.js");

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const web3_1 = tslib_1.__importDefault(__webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js"));

class Web3VmProvider {
  constructor() {
    this.web3 = new web3_1.default();
    this.vm = null;
    this.vmTraces = {};
    this.txs = {};
    this.txsReceipt = {};
    this.processingHash = null;
    this.processingAddress = null;
    this.processingIndex = null;
    this.previousDepth = 0;
    this.incr = 0;
    this.eth = {};
    this.debug = {};

    this.eth.getCode = (address, cb) => this.getCode(address, cb);

    this.eth.getTransaction = (txHash, cb) => this.getTransaction(txHash, cb);

    this.eth.getTransactionReceipt = (txHash, cb) => this.getTransactionReceipt(txHash, cb);

    this.eth.getTransactionFromBlock = (blockNumber, txIndex, cb) => this.getTransactionFromBlock(blockNumber, txIndex, cb);

    this.eth.getBlockNumber = cb => this.getBlockNumber(cb);

    this.debug.traceTransaction = (txHash, options, cb) => this.traceTransaction(txHash, options, cb);

    this.debug.storageRangeAt = (blockNumber, txIndex, address, start, maxLength, cb) => this.storageRangeAt(blockNumber, txIndex, address, start, maxLength, cb);

    this.debug.preimage = (hashedKey, cb) => this.preimage(hashedKey, cb);

    this.providers = {
      HttpProvider: function (url) {}
    };
    this.currentProvider = {
      host: 'vm provider'
    };
    this.storageCache = {};
    this.lastProcessedStorageTxHash = {};
    this.sha3Preimages = {}; // util

    this.sha3 = (...args) => this.web3.utils.sha3(...args);

    this.toHex = (...args) => this.web3.utils.toHex(...args);

    this.toAscii = (...args) => this.web3.utils.hexToAscii(...args);

    this.fromAscii = (...args) => this.web3.utils.asciiToHex(...args);

    this.fromDecimal = (...args) => this.web3.utils.numberToHex(...args);

    this.fromWei = (...args) => this.web3.utils.fromWei(...args);

    this.toWei = (...args) => this.web3.utils.toWei(...args);

    this.toBigNumber = (...args) => this.web3.utils.toBN(...args);

    this.isAddress = (...args) => this.web3.utils.isAddress(...args);

    this.utils = web3_1.default.utils || [];
  }

  setVM(vm) {
    if (this.vm === vm) return;
    this.vm = vm;
    this.vm.on('step', data => {
      this.pushTrace(data);
    });
    this.vm.on('afterTx', data => {
      this.txProcessed(data);
    });
    this.vm.on('beforeTx', data => {
      this.txWillProcess(data);
    });
  }

  releaseCurrentHash() {
    const ret = this.processingHash;
    this.processingHash = undefined;
    return ret;
  }

  txWillProcess(data) {
    this.incr++;
    this.processingHash = util_1.hexConvert(data.hash());
    this.vmTraces[this.processingHash] = {
      gas: '0x0',
      return: '0x0',
      structLogs: []
    };
    const tx = {};
    tx['hash'] = this.processingHash;
    tx['from'] = ethereumjs_util_1.toChecksumAddress(util_1.hexConvert(data.getSenderAddress()));

    if (data.to && data.to.length) {
      tx['to'] = ethereumjs_util_1.toChecksumAddress(util_1.hexConvert(data.to));
    }

    this.processingAddress = tx['to'];
    tx['data'] = util_1.hexConvert(data.data);
    tx['input'] = util_1.hexConvert(data.input);
    tx['gas'] = new ethereumjs_util_1.BN(util_1.hexConvert(data.gas).replace('0x', ''), 16).toString(10);

    if (data.value) {
      tx['value'] = util_1.hexConvert(data.value);
    }

    this.txs[this.processingHash] = tx;
    this.txsReceipt[this.processingHash] = tx;
    this.storageCache[this.processingHash] = {};

    if (tx['to']) {
      const account = ethereumjs_util_1.toBuffer(tx['to']);
      this.vm.stateManager.dumpStorage(account, storage => {
        this.storageCache[this.processingHash][tx['to']] = storage;
        this.lastProcessedStorageTxHash[tx['to']] = this.processingHash;
      });
    }

    this.processingIndex = 0;
  }

  txProcessed(data) {
    const lastOp = this.vmTraces[this.processingHash].structLogs[this.processingIndex - 1];

    if (lastOp) {
      lastOp.error = lastOp.op !== 'RETURN' && lastOp.op !== 'STOP' && lastOp.op !== 'thisDESTRUCT';
    }

    this.vmTraces[this.processingHash].gas = '0x' + data.gasUsed.toString(16);
    const logs = [];

    for (const l in data.execResult.logs) {
      const log = data.execResult.logs[l];
      const topics = [];

      if (log[1].length > 0) {
        for (var k in log[1]) {
          topics.push('0x' + log[1][k].toString('hex'));
        }
      } else {
        topics.push('0x');
      }

      logs.push({
        address: '0x' + log[0].toString('hex'),
        data: '0x' + log[2].toString('hex'),
        topics: topics,
        rawVMResponse: log
      });
    }

    this.txsReceipt[this.processingHash].logs = logs;
    this.txsReceipt[this.processingHash].transactionHash = this.processingHash;
    const status = data.execResult.exceptionError ? 0 : 1;
    this.txsReceipt[this.processingHash].status = `0x${status}`;

    if (data.createdAddress) {
      const address = util_1.hexConvert(data.createdAddress);
      this.vmTraces[this.processingHash].return = ethereumjs_util_1.toChecksumAddress(address);
      this.txsReceipt[this.processingHash].contractAddress = ethereumjs_util_1.toChecksumAddress(address);
    } else if (data.execResult.returnValue) {
      this.vmTraces[this.processingHash].return = util_1.hexConvert(data.execResult.returnValue);
    } else {
      this.vmTraces[this.processingHash].return = '0x';
    }

    this.processingIndex = null;
    this.processingAddress = null;
    this.previousDepth = 0;
  }

  pushTrace(data) {
    const depth = data.depth + 1; // geth starts the depth from 1

    if (!this.processingHash) {
      console.log('no tx processing');
      return;
    }

    let previousopcode;

    if (this.vmTraces[this.processingHash] && this.vmTraces[this.processingHash].structLogs[this.processingIndex - 1]) {
      previousopcode = this.vmTraces[this.processingHash].structLogs[this.processingIndex - 1];
    }

    if (this.previousDepth > depth && previousopcode) {
      // returning from context, set error it is not STOP, RETURN
      previousopcode.invalidDepthChange = previousopcode.op !== 'RETURN' && previousopcode.op !== 'STOP';
    }

    const step = {
      stack: util_1.hexListFromBNs(data.stack),
      memory: util_1.formatMemory(data.memory),
      storage: data.storage,
      op: data.opcode.name,
      pc: data.pc,
      gasCost: data.opcode.fee.toString(),
      gas: data.gasLeft.toString(),
      depth: depth,
      error: data.error === false ? undefined : data.error
    };
    this.vmTraces[this.processingHash].structLogs.push(step);

    if (step.op === 'CREATE' || step.op === 'CALL') {
      if (step.op === 'CREATE') {
        this.processingAddress = '(Contract Creation - Step ' + this.processingIndex + ')';
        this.storageCache[this.processingHash][this.processingAddress] = {};
        this.lastProcessedStorageTxHash[this.processingAddress] = this.processingHash;
      } else {
        this.processingAddress = uiHelper_1.normalizeHexAddress(step.stack[step.stack.length - 2]);
        this.processingAddress = ethereumjs_util_1.toChecksumAddress(this.processingAddress);

        if (!this.storageCache[this.processingHash][this.processingAddress]) {
          const account = ethereumjs_util_1.toBuffer(this.processingAddress);
          this.vm.stateManager.dumpStorage(account, storage => {
            this.storageCache[this.processingHash][this.processingAddress] = storage;
            this.lastProcessedStorageTxHash[this.processingAddress] = this.processingHash;
          });
        }
      }
    }

    if (previousopcode && previousopcode.op === 'SHA3') {
      const preimage = this.getSha3Input(previousopcode.stack, previousopcode.memory);
      const imageHash = step.stack[step.stack.length - 1].replace('0x', '');
      this.sha3Preimages[imageHash] = {
        preimage: preimage
      };
    }

    this.processingIndex++;
    this.previousDepth = depth;
  }

  getCode(address, cb) {
    address = ethereumjs_util_1.toChecksumAddress(address);
    const account = ethereumjs_util_1.toBuffer(address);
    this.vm.stateManager.getContractCode(account, (error, result) => {
      cb(error, util_1.hexConvert(result));
    });
  }

  setProvider(provider) {}

  traceTransaction(txHash, options, cb) {
    if (this.vmTraces[txHash]) {
      if (cb) {
        cb(null, this.vmTraces[txHash]);
      }

      return this.vmTraces[txHash];
    }

    if (cb) {
      cb('unable to retrieve traces ' + txHash, null);
    }
  }

  storageRangeAt(blockNumber, txIndex, address, start, maxLength, cb) {
    // we don't use the range params here
    address = ethereumjs_util_1.toChecksumAddress(address);

    if (txIndex === 'latest') {
      txIndex = this.lastProcessedStorageTxHash[address];
    }

    if (this.storageCache[txIndex] && this.storageCache[txIndex][address]) {
      const storage = this.storageCache[txIndex][address];
      return cb(null, {
        storage: JSON.parse(JSON.stringify(storage)),
        nextKey: null
      });
    }

    cb('unable to retrieve storage ' + txIndex + ' ' + address);
  }

  getBlockNumber(cb) {
    cb(null, 'vm provider');
  }

  getTransaction(txHash, cb) {
    if (this.txs[txHash]) {
      if (cb) {
        cb(null, this.txs[txHash]);
      }

      return this.txs[txHash];
    }

    if (cb) {
      cb('unable to retrieve tx ' + txHash, null);
    }
  }

  getTransactionReceipt(txHash, cb) {
    // same as getTransaction but return the created address also
    if (this.txsReceipt[txHash]) {
      if (cb) {
        cb(null, this.txsReceipt[txHash]);
      }

      return this.txsReceipt[txHash];
    }

    if (cb) {
      cb('unable to retrieve txReceipt ' + txHash, null);
    }
  }

  getTransactionFromBlock(blockNumber, txIndex, cb) {
    const mes = 'not supposed to be needed by remix in vmmode';
    console.log(mes);

    if (cb) {
      cb(mes, null);
    }
  }

  preimage(hashedKey, cb) {
    hashedKey = hashedKey.replace('0x', '');
    cb(null, this.sha3Preimages[hashedKey] !== undefined ? this.sha3Preimages[hashedKey].preimage : null);
  }

  getSha3Input(stack, memory) {
    let memoryStart = stack[stack.length - 1];
    let memoryLength = stack[stack.length - 2];
    const memStartDec = new ethereumjs_util_1.BN(memoryStart.replace('0x', ''), 16).toString(10);
    memoryStart = parseInt(memStartDec) * 2;
    const memLengthDec = new ethereumjs_util_1.BN(memoryLength.replace('0x', ''), 16).toString(10);
    memoryLength = parseInt(memLengthDec) * 2;
    let i = Math.floor(memoryStart / 32);
    const maxIndex = Math.floor(memoryLength / 32) + i;

    if (!memory[i]) {
      return this.emptyFill(memoryLength);
    }

    let sha3Input = memory[i].slice(memoryStart - 32 * i);
    i++;

    while (i < maxIndex) {
      sha3Input += memory[i] ? memory[i] : this.emptyFill(32);
      i++;
    }

    if (sha3Input.length < memoryLength) {
      const leftSize = memoryLength - sha3Input.length;
      sha3Input += memory[i] ? memory[i].slice(0, leftSize) : this.emptyFill(leftSize);
    }

    return sha3Input;
  }

  emptyFill(size) {
    return new Array(size).join('0');
  }

}

exports.Web3VmProvider = Web3VmProvider;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/package.json":
/*!***************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/package.json ***!
  \***************************************************************************/
/*! exports provided: name, version, description, contributors, main, dependencies, devDependencies, scripts, publishConfig, bin, repository, author, license, bugs, homepage, typings, gitHead, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@remix-project/remix-simulator\",\"version\":\"0.1.9-beta.10\",\"description\":\"Ethereum IDE and tools for the web\",\"contributors\":[{\"name\":\"Iuri Matias\",\"email\":\"iuri@ethereum.org\"},{\"name\":\"Yann Levreau\",\"email\":\"yann@ethdev.com\"}],\"main\":\"src/index.js\",\"dependencies\":{\"@remix-project/remix-lib\":\"^0.4.33\",\"ansi-gray\":\"^0.1.1\",\"async\":\"^3.1.0\",\"body-parser\":\"^1.18.2\",\"color-support\":\"^1.1.3\",\"commander\":\"^2.19.0\",\"cors\":\"^2.8.5\",\"ethereumjs-block\":\"^2.2.2\",\"ethereumjs-tx\":\"^2.1.2\",\"ethereumjs-util\":\"^6.2.0\",\"ethereumjs-vm\":\"4.1.3\",\"express\":\"^4.16.3\",\"express-ws\":\"^4.0.0\",\"merge\":\"^1.2.0\",\"time-stamp\":\"^2.0.0\",\"web3\":\"^1.2.4\"},\"devDependencies\":{\"@babel/core\":\"^7.4.5\",\"@babel/plugin-transform-object-assign\":\"^7.2.0\",\"@babel/preset-env\":\"^7.4.5\",\"@babel/preset-es2015\":\"latest\",\"@babel/preset-es2017\":\"latest\",\"@babel/preset-stage-0\":\"^7.0.0\",\"babel-eslint\":\"^7.1.1\",\"babelify\":\"^10.0.0\",\"mocha\":\"^5.2.0\"},\"scripts\":{\"test\":\"./../../node_modules/.bin/ts-node --require tsconfig-paths/register ./../../node_modules/.bin/mocha test/*.ts\"},\"publishConfig\":{\"access\":\"public\"},\"bin\":{\"ethsim\":\"./bin/ethsim\",\"remix-simulator\":\"./bin/ethsim\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/ethereum/remix-project.git\"},\"author\":\"Remix Team\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/ethereum/remix-project/issues\"},\"homepage\":\"https://github.com/ethereum/remix-project/tree/master/libs/remix-simulator#readme\",\"typings\":\"src/index.d.ts\",\"gitHead\":\"74b85ce5b385c7a5f24f8df5681638b7c2019b48\"}");

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/genesis.js":
/*!*****************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/genesis.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const ethereumjs_block_1 = tslib_1.__importDefault(__webpack_require__(/*! ethereumjs-block */ "../../../node_modules/ethereumjs-block/index.js"));

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

function generateBlock(executionContext) {
  const block = new ethereumjs_block_1.default({
    header: {
      timestamp: new Date().getTime() / 1000 | 0,
      number: 0,
      coinbase: '0x0e9281e9c6a0808672eaba6bd1220e144c9bb07a',
      difficulty: new ethereumjs_util_1.BN('69762765929000', 10),
      gasLimit: new ethereumjs_util_1.BN('8000000').imuln(1)
    },
    transactions: [],
    uncleHeaders: []
  });
  executionContext.vm().runBlock({
    block: block,
    generate: true,
    skipBlockValidation: true,
    skipBalance: false
  }).then(() => {
    executionContext.addBlock(block);
  });
}

exports.generateBlock = generateBlock;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/index.js":
/*!***************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var provider_1 = __webpack_require__(/*! ./provider */ "../../../dist/libs/remix-simulator/src/provider.js");

exports.Provider = provider_1.Provider;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/methods/accounts.js":
/*!**************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/methods/accounts.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const ethjs_util_1 = __webpack_require__(/*! ethjs-util */ "../../../node_modules/ethjs-util/lib/index.js");

const web3_1 = tslib_1.__importDefault(__webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js"));

const crypto = tslib_1.__importStar(__webpack_require__(/*! crypto */ "../../../node_modules/crypto-browserify/index.js"));

class Accounts {
  constructor(executionContext) {
    this.web3 = new web3_1.default();
    this.executionContext = executionContext; // TODO: make it random and/or use remix-libs

    this.accounts = {};
    this.accountsKeys = {};
    this.executionContext.init({
      get: () => {
        return true;
      }
    });
  }

  resetAccounts() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      // TODO: setting this to {} breaks the app currently, unclear why still
      // this.accounts = {}
      // this.accountsKeys = {}
      yield this._addAccount('503f38a9c967ed597e47fe25643985f032b072db8075426a92110f82df48dfcb', '0x56BC75E2D63100000');
      yield this._addAccount('7e5bfb82febc4c2c8529167104271ceec190eafdca277314912eaabdb67c6e5f', '0x56BC75E2D63100000');
      yield this._addAccount('cc6d63f85de8fef05446ebdd3c537c72152d0fc437fd7aa62b3019b79bd1fdd4', '0x56BC75E2D63100000');
      yield this._addAccount('638b5c6c8c5903b15f0d3bf5d3f175c64e6e98a10bdb9768a2003bf773dcb86a', '0x56BC75E2D63100000');
      yield this._addAccount('f49bf239b6e554fdd08694fde6c67dac4d01c04e0dda5ee11abee478983f3bc0', '0x56BC75E2D63100000');
      yield this._addAccount('adeee250542d3790253046eee928d8058fd544294a5219bea152d1badbada395', '0x56BC75E2D63100000');
      yield this._addAccount('097ffe12069dcb3c3d99e6771e2cbf491a9b8b2f93ff4d3468f550c5e8264755', '0x56BC75E2D63100000');
      yield this._addAccount('5f58e8b9f1867ef00578b6f03e159428ab168f776aa445bc3ecdb02c7db8e865', '0x56BC75E2D63100000');
      yield this._addAccount('290e721ac87c7b3f31bef7b70104b9280ed3fa1425a59451490c9c02bf50d08f', '0x56BC75E2D63100000');
      yield this._addAccount('27efe944ff128cf510ab447b529eec28772f13bf65ebf1cbd504192c4f26e9d8', '0x56BC75E2D63100000');
      yield this._addAccount('3cd7232cd6f3fc66a57a6bedc1a8ed6c228fff0a327e169c2bcc5e869ed49511', '0x56BC75E2D63100000');
      yield this._addAccount('2ac6c190b09897cd8987869cc7b918cfea07ee82038d492abce033c75c1b1d0c', '0x56BC75E2D63100000');
      yield this._addAccount('dae9801649ba2d95a21e688b56f77905e5667c44ce868ec83f82e838712a2c7a', '0x56BC75E2D63100000');
      yield this._addAccount('d74aa6d18aa79a05f3473dd030a97d3305737cbc8337d940344345c1f6b72eea', '0x56BC75E2D63100000');
      yield this._addAccount('71975fbf7fe448e004ac7ae54cad0a383c3906055a65468714156a07385e96ce', '0x56BC75E2D63100000');
    });
  }

  _addAccount(privateKey, balance) {
    return new Promise((resolve, reject) => {
      privateKey = Buffer.from(privateKey, 'hex');
      const address = ethereumjs_util_1.privateToAddress(privateKey);
      this.accounts[ethereumjs_util_1.toChecksumAddress('0x' + address.toString('hex'))] = {
        privateKey,
        nonce: 0
      };
      this.accountsKeys[ethereumjs_util_1.toChecksumAddress('0x' + address.toString('hex'))] = '0x' + privateKey.toString('hex');
      const stateManager = this.executionContext.vm().stateManager;
      stateManager.getAccount(address, (error, account) => {
        if (error) {
          console.log(error);
          reject(error);
          return;
        }

        account.balance = balance || '0xf00000000000000001';
        resolve();
      });
    });
  }

  newAccount(cb) {
    let privateKey;

    do {
      privateKey = crypto.randomBytes(32);
    } while (!ethereumjs_util_1.isValidPrivate(privateKey));

    this._addAccount(privateKey, '0x56BC75E2D63100000');

    return cb(null, '0x' + ethereumjs_util_1.privateToAddress(privateKey).toString('hex'));
  }

  methods() {
    return {
      eth_accounts: this.eth_accounts.bind(this),
      eth_getBalance: this.eth_getBalance.bind(this),
      eth_sign: this.eth_sign.bind(this)
    };
  }

  eth_accounts(_payload, cb) {
    return cb(null, Object.keys(this.accounts));
  }

  eth_getBalance(payload, cb) {
    let address = payload.params[0];
    address = ethjs_util_1.stripHexPrefix(address);
    this.executionContext.vm().stateManager.getAccount(Buffer.from(address, 'hex'), (err, account) => {
      if (err) {
        return cb(err);
      }

      cb(null, new ethereumjs_util_1.BN(account.balance).toString(10));
    });
  }

  eth_sign(payload, cb) {
    const address = payload.params[0];
    const message = payload.params[1];
    const privateKey = this.accountsKeys[ethereumjs_util_1.toChecksumAddress(address)];

    if (!privateKey) {
      return cb(new Error('unknown account'));
    }

    const account = this.web3.eth.accounts.privateKeyToAccount(privateKey);
    const data = account.sign(message);
    cb(null, data.signature);
  }

}

exports.Accounts = Accounts;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/methods/blocks.js":
/*!************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/methods/blocks.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class Blocks {
  constructor(executionContext, _options) {
    this.executionContext = executionContext;
    const options = _options || {};
    this.coinbase = options.coinbase || '0x0000000000000000000000000000000000000000';
    this.blockNumber = 0;
  }

  methods() {
    return {
      eth_getBlockByNumber: this.eth_getBlockByNumber.bind(this),
      eth_gasPrice: this.eth_gasPrice.bind(this),
      eth_coinbase: this.eth_coinbase.bind(this),
      eth_blockNumber: this.eth_blockNumber.bind(this),
      eth_getBlockByHash: this.eth_getBlockByHash.bind(this),
      eth_getBlockTransactionCountByHash: this.eth_getBlockTransactionCountByHash.bind(this),
      eth_getBlockTransactionCountByNumber: this.eth_getBlockTransactionCountByNumber.bind(this),
      eth_getUncleCountByBlockHash: this.eth_getUncleCountByBlockHash.bind(this),
      eth_getUncleCountByBlockNumber: this.eth_getUncleCountByBlockNumber.bind(this),
      eth_getStorageAt: this.eth_getStorageAt.bind(this)
    };
  }

  eth_getBlockByNumber(payload, cb) {
    let blockIndex = payload.params[0];

    if (blockIndex === 'latest') {
      blockIndex = this.executionContext.latestBlockNumber;
    }

    const block = this.executionContext.blocks[blockIndex];

    if (!block) {
      return cb(new Error('block not found'));
    }

    const b = {
      number: this.toHex(block.header.number),
      hash: this.toHex(block.hash()),
      parentHash: this.toHex(block.header.parentHash),
      nonce: this.toHex(block.header.nonce),
      sha3Uncles: '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
      logsBloom: '0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331',
      transactionsRoot: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
      stateRoot: this.toHex(block.header.stateRoot),
      miner: this.coinbase,
      difficulty: this.toHex(block.header.difficulty),
      totalDifficulty: this.toHex(block.header.totalDifficulty),
      extraData: this.toHex(block.header.extraData),
      size: '0x027f07',
      gasLimit: this.toHex(block.header.gasLimit),
      gasUsed: this.toHex(block.header.gasUsed),
      timestamp: this.toHex(block.header.timestamp),
      transactions: block.transactions.map(t => '0x' + t.hash().toString('hex')),
      uncles: []
    };
    cb(null, b);
  }

  toHex(value) {
    if (!value) return '0x0';
    const v = value.toString('hex');
    return v === '0x' || v === '' ? '0x0' : '0x' + v;
  }

  eth_getBlockByHash(payload, cb) {
    const block = this.executionContext.blocks[payload.params[0]];
    const b = {
      number: this.toHex(block.header.number),
      hash: this.toHex(block.hash()),
      parentHash: this.toHex(block.header.parentHash),
      nonce: this.toHex(block.header.nonce),
      sha3Uncles: '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
      logsBloom: '0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331',
      transactionsRoot: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
      stateRoot: this.toHex(block.header.stateRoot),
      miner: this.coinbase,
      difficulty: this.toHex(block.header.difficulty),
      totalDifficulty: this.toHex(block.header.totalDifficulty),
      extraData: this.toHex(block.header.extraData),
      size: '0x027f07',
      gasLimit: this.toHex(block.header.gasLimit),
      gasUsed: this.toHex(block.header.gasUsed),
      timestamp: this.toHex(block.header.timestamp),
      transactions: block.transactions.map(t => '0x' + t.hash().toString('hex')),
      uncles: []
    };
    cb(null, b);
  }

  eth_gasPrice(payload, cb) {
    cb(null, 1);
  }

  eth_coinbase(payload, cb) {
    cb(null, this.coinbase);
  }

  eth_blockNumber(payload, cb) {
    cb(null, this.blockNumber);
  }

  eth_getBlockTransactionCountByHash(payload, cb) {
    const block = this.executionContext.blocks[payload.params[0]];
    cb(null, block.transactions.length);
  }

  eth_getBlockTransactionCountByNumber(payload, cb) {
    const block = this.executionContext.blocks[payload.params[0]];
    cb(null, block.transactions.length);
  }

  eth_getUncleCountByBlockHash(payload, cb) {
    cb(null, 0);
  }

  eth_getUncleCountByBlockNumber(payload, cb) {
    cb(null, 0);
  }

  eth_getStorageAt(payload, cb) {
    const [address, position, blockNumber] = payload.params;
    this.executionContext.web3().debug.storageRangeAt(blockNumber, 'latest', address.toLowerCase(), position, 1, (err, result) => {
      if (err || result.storage && Object.values(result.storage).length === 0) {
        return cb(err, '');
      }

      const value = Object.values(result.storage)[0]['value'];
      cb(err, value);
    });
  }

}

exports.Blocks = Blocks;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/methods/debug.js":
/*!***********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/methods/debug.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class Debug {
  constructor(executionContext) {
    this.executionContext = executionContext;
  }

  methods() {
    return {
      debug_traceTransaction: this.debug_traceTransaction.bind(this),
      debug_preimage: this.debug_preimage.bind(this),
      debug_storageRangeAt: this.debug_storageRangeAt.bind(this)
    };
  }

  debug_traceTransaction(payload, cb) {
    this.executionContext.web3().debug.traceTransaction(payload.params[0], {}, cb);
  }

  debug_preimage(payload, cb) {
    this.executionContext.web3().debug.preimage(payload.params[0], cb);
  }

  debug_storageRangeAt(payload, cb) {
    this.executionContext.web3().debug.storageRangeAt(payload.params[0], payload.params[1], payload.params[2], payload.params[3], payload.params[4], cb);
  }

}

exports.Debug = Debug;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/methods/filters.js":
/*!*************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/methods/filters.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class Filters {
  constructor(executionContext) {
    this.executionContext = executionContext;
  }

  methods() {
    return {
      eth_getLogs: this.eth_getLogs.bind(this),
      eth_subscribe: this.eth_subscribe.bind(this),
      eth_unsubscribe: this.eth_unsubscribe.bind(this)
    };
  }

  eth_getLogs(payload, cb) {
    const results = this.executionContext.logsManager.getLogsFor(payload.params[0]);
    cb(null, results);
  }

  eth_subscribe(payload, cb) {
    const subscriptionId = this.executionContext.logsManager.subscribe(payload.params);
    cb(null, subscriptionId);
  }

  eth_unsubscribe(payload, cb) {
    this.executionContext.logsManager.unsubscribe(payload.params[0]);
    cb(null, true);
  }

  eth_newFilter(payload, cb) {
    const filterId = this.executionContext.logsManager.newFilter('filter', payload.params[0]);
    cb(null, filterId);
  }

  eth_newBlockFilter(payload, cb) {
    const filterId = this.executionContext.logsManager.newFilter('block');
    cb(null, filterId);
  }

  eth_newPendingTransactionFilter(payload, cb) {
    const filterId = this.executionContext.logsManager.newFilter('pendingTransactions');
    cb(null, filterId);
  }

  eth_uninstallfilter(payload, cb) {
    const result = this.executionContext.logsManager.uninstallFilter(payload.params[0]);
    cb(null, result);
  }

  eth_getFilterChanges(payload, cb) {
    const filterId = payload.params[0];
    const results = this.executionContext.logsManager.getLogsForFilter(filterId);
    cb(null, results);
  }

  eth_getFilterLogs(payload, cb) {
    const filterId = payload.params[0];
    const results = this.executionContext.logsManager.getLogsForFilter(filterId, true);
    cb(null, results);
  }

}

exports.Filters = Filters;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/methods/misc.js":
/*!**********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/methods/misc.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const version = __webpack_require__(/*! ../../package.json */ "../../../dist/libs/remix-simulator/package.json").version;

const web3_1 = tslib_1.__importDefault(__webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js"));

function methods() {
  return {
    web3_clientVersion: this.web3_clientVersion.bind(this),
    eth_protocolVersion: this.eth_protocolVersion.bind(this),
    eth_syncing: this.eth_syncing.bind(this),
    eth_mining: this.eth_mining.bind(this),
    eth_hashrate: this.eth_hashrate.bind(this),
    web3_sha3: this.web3_sha3.bind(this),
    eth_getCompilers: this.eth_getCompilers.bind(this),
    eth_compileSolidity: this.eth_compileSolidity.bind(this),
    eth_compileLLL: this.eth_compileLLL.bind(this),
    eth_compileSerpent: this.eth_compileSerpent.bind(this)
  };
}

exports.methods = methods;

function web3_clientVersion(payload, cb) {
  cb(null, 'Remix Simulator/' + version);
}

exports.web3_clientVersion = web3_clientVersion;

function eth_protocolVersion(payload, cb) {
  cb(null, '0x3f');
}

exports.eth_protocolVersion = eth_protocolVersion;

function eth_syncing(payload, cb) {
  cb(null, false);
}

exports.eth_syncing = eth_syncing;

function eth_mining(payload, cb) {
  // TODO: should depend on the state
  cb(null, false);
}

exports.eth_mining = eth_mining;

function eth_hashrate(payload, cb) {
  cb(null, '0x0');
}

exports.eth_hashrate = eth_hashrate;

function web3_sha3(payload, cb) {
  const str = payload.params[0];
  cb(null, web3_1.default.utils.sha3(str));
}

exports.web3_sha3 = web3_sha3;

function eth_getCompilers(payload, cb) {
  cb(null, []);
}

exports.eth_getCompilers = eth_getCompilers;

function eth_compileSolidity(payload, cb) {
  cb(null, 'unsupported');
}

exports.eth_compileSolidity = eth_compileSolidity;

function eth_compileLLL(payload, cb) {
  cb(null, 'unsupported');
}

exports.eth_compileLLL = eth_compileLLL;

function eth_compileSerpent(payload, cb) {
  cb(null, 'unsupported');
}

exports.eth_compileSerpent = eth_compileSerpent;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/methods/net.js":
/*!*********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/methods/net.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function methods() {
  return {
    net_version: this.net_version,
    net_listening: this.net_listening,
    net_peerCount: this.net_peerCount
  };
}

exports.methods = methods;

function net_version(payload, cb) {
  // should be configured networkId
  cb(null, 1337);
}

exports.net_version = net_version;

function net_listening(payload, cb) {
  cb(null, true);
}

exports.net_listening = net_listening;

function net_peerCount(payload, cb) {
  cb(null, 0);
}

exports.net_peerCount = net_peerCount;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/methods/transactions.js":
/*!******************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/methods/transactions.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const web3_1 = tslib_1.__importDefault(__webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js"));

const ethereumjs_util_1 = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const txProcess_1 = __webpack_require__(/*! ./txProcess */ "../../../dist/libs/remix-simulator/src/methods/txProcess.js");

class Transactions {
  constructor(executionContext) {
    this.executionContext = executionContext;
  }

  init(accounts) {
    this.accounts = accounts;
  }

  methods() {
    return {
      eth_sendTransaction: this.eth_sendTransaction.bind(this),
      eth_getTransactionReceipt: this.eth_getTransactionReceipt.bind(this),
      eth_getCode: this.eth_getCode.bind(this),
      eth_call: this.eth_call.bind(this),
      eth_estimateGas: this.eth_estimateGas.bind(this),
      eth_getTransactionCount: this.eth_getTransactionCount.bind(this),
      eth_getTransactionByHash: this.eth_getTransactionByHash.bind(this),
      eth_getTransactionByBlockHashAndIndex: this.eth_getTransactionByBlockHashAndIndex.bind(this),
      eth_getTransactionByBlockNumberAndIndex: this.eth_getTransactionByBlockNumberAndIndex.bind(this)
    };
  }

  eth_sendTransaction(payload, cb) {
    // from might be lowercased address (web3)
    if (payload.params && payload.params.length > 0 && payload.params[0].from) {
      payload.params[0].from = ethereumjs_util_1.toChecksumAddress(payload.params[0].from);
    }

    txProcess_1.processTx(this.executionContext, this.accounts, payload, false, cb);
  }

  eth_getTransactionReceipt(payload, cb) {
    this.executionContext.web3().eth.getTransactionReceipt(payload.params[0], (error, receipt) => {
      if (error) {
        return cb(error);
      }

      const txBlock = this.executionContext.txs[receipt.hash];
      const r = {
        transactionHash: receipt.hash,
        transactionIndex: '0x00',
        blockHash: '0x' + txBlock.hash().toString('hex'),
        blockNumber: '0x' + txBlock.header.number.toString('hex'),
        gasUsed: web3_1.default.utils.toHex(receipt.gas),
        cumulativeGasUsed: web3_1.default.utils.toHex(receipt.gas),
        contractAddress: receipt.contractAddress,
        logs: receipt.logs,
        status: receipt.status,
        to: receipt.to
      };

      if (r.blockNumber === '0x') {
        r.blockNumber = '0x0';
      }

      cb(null, r);
    });
  }

  eth_estimateGas(payload, cb) {
    cb(null, 3000000);
  }

  eth_getCode(payload, cb) {
    const address = payload.params[0];
    this.executionContext.web3().eth.getCode(address, (error, result) => {
      if (error) {
        console.dir('error getting code');
        console.dir(error);
      }

      cb(error, result);
    });
  }

  eth_call(payload, cb) {
    // from might be lowercased address (web3)
    if (payload.params && payload.params.length > 0 && payload.params[0].from) {
      payload.params[0].from = ethereumjs_util_1.toChecksumAddress(payload.params[0].from);
    }

    if (payload.params && payload.params.length > 0 && payload.params[0].to) {
      payload.params[0].to = ethereumjs_util_1.toChecksumAddress(payload.params[0].to);
    }

    payload.params[0].value = undefined;
    txProcess_1.processTx(this.executionContext, this.accounts, payload, true, cb);
  }

  eth_getTransactionCount(payload, cb) {
    const address = payload.params[0];
    this.executionContext.vm().stateManager.getAccount(address, (err, account) => {
      if (err) {
        return cb(err);
      }

      const nonce = new ethereumjs_util_1.BN(account.nonce).toString(10);
      cb(null, nonce);
    });
  }

  eth_getTransactionByHash(payload, cb) {
    const address = payload.params[0];
    this.executionContext.web3().eth.getTransactionReceipt(address, (error, receipt) => {
      if (error) {
        return cb(error);
      }

      const txBlock = this.executionContext.txs[receipt.transactionHash]; // TODO: params to add later

      const r = {
        blockHash: '0x' + txBlock.hash().toString('hex'),
        blockNumber: '0x' + txBlock.header.number.toString('hex'),
        from: receipt.from,
        gas: web3_1.default.utils.toHex(receipt.gas),
        // 'gasPrice': '2000000000000', // 0x123
        gasPrice: '0x4a817c800',
        hash: receipt.transactionHash,
        input: receipt.input,
        nonce: 2,
        // "transactionIndex": 0,
        value: receipt.value // "value":"0xf3dbb76162000" // 4290000000000000
        // "v": "0x25", // 37
        // "r": "0x1b5e176d927f8e9ab405058b2d2457392da3e20f328b16ddabcebc33eaac5fea",
        // "s": "0x4ba69724e8f69de52f0125ad8b3c5c2cef33019bac3249e2c0a2192766d1721c"

      };

      if (receipt.to) {
        r['to'] = receipt.to;
      }

      if (r.value === '0x') {
        r.value = '0x0';
      }

      if (r.blockNumber === '0x') {
        r.blockNumber = '0x0';
      }

      cb(null, r);
    });
  }

  eth_getTransactionByBlockHashAndIndex(payload, cb) {
    const txIndex = payload.params[1];
    const txBlock = this.executionContext.blocks[payload.params[0]];
    const txHash = '0x' + txBlock.transactions[web3_1.default.utils.toDecimal(txIndex)].hash().toString('hex');
    this.executionContext.web3().eth.getTransactionReceipt(txHash, (error, receipt) => {
      if (error) {
        return cb(error);
      } // TODO: params to add later


      const r = {
        blockHash: '0x' + txBlock.hash().toString('hex'),
        blockNumber: '0x' + txBlock.header.number.toString('hex'),
        from: receipt.from,
        gas: web3_1.default.utils.toHex(receipt.gas),
        // 'gasPrice': '2000000000000', // 0x123
        gasPrice: '0x4a817c800',
        hash: receipt.transactionHash,
        input: receipt.input,
        nonce: 2,
        // "transactionIndex": 0,
        value: receipt.value // "value":"0xf3dbb76162000" // 4290000000000000
        // "v": "0x25", // 37
        // "r": "0x1b5e176d927f8e9ab405058b2d2457392da3e20f328b16ddabcebc33eaac5fea",
        // "s": "0x4ba69724e8f69de52f0125ad8b3c5c2cef33019bac3249e2c0a2192766d1721c"

      };

      if (receipt.to) {
        r['to'] = receipt.to;
      }

      if (r.value === '0x') {
        r.value = '0x0';
      }

      cb(null, r);
    });
  }

  eth_getTransactionByBlockNumberAndIndex(payload, cb) {
    const txIndex = payload.params[1];
    const txBlock = this.executionContext.blocks[payload.params[0]];
    const txHash = '0x' + txBlock.transactions[web3_1.default.utils.toDecimal(txIndex)].hash().toString('hex');
    this.executionContext.web3().eth.getTransactionReceipt(txHash, (error, receipt) => {
      if (error) {
        return cb(error);
      } // TODO: params to add later


      const r = {
        blockHash: '0x' + txBlock.hash().toString('hex'),
        blockNumber: '0x' + txBlock.header.number.toString('hex'),
        from: receipt.from,
        gas: web3_1.default.utils.toHex(receipt.gas),
        // 'gasPrice': '2000000000000', // 0x123
        gasPrice: '0x4a817c800',
        hash: receipt.transactionHash,
        input: receipt.input,
        nonce: 2,
        // "transactionIndex": 0,
        value: receipt.value // "value":"0xf3dbb76162000" // 4290000000000000
        // "v": "0x25", // 37
        // "r": "0x1b5e176d927f8e9ab405058b2d2457392da3e20f328b16ddabcebc33eaac5fea",
        // "s": "0x4ba69724e8f69de52f0125ad8b3c5c2cef33019bac3249e2c0a2192766d1721c"

      };

      if (receipt.to) {
        r['to'] = receipt.to;
      }

      if (r.value === '0x') {
        r.value = '0x0';
      }

      cb(null, r);
    });
  }

}

exports.Transactions = Transactions;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/methods/txProcess.js":
/*!***************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/methods/txProcess.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

const TxExecution = remix_lib_1.execution.txExecution;
const TxRunner = remix_lib_1.execution.txRunner;

function runCall(payload, from, to, data, value, gasLimit, txRunner, callbacks, callback) {
  const finalCallback = function (err, result) {
    if (err) {
      return callback(err);
    }

    const returnValue = result.result.execResult.returnValue.toString('hex');
    const toReturn = `0x${returnValue || '0'}`;
    return callback(null, toReturn);
  };

  TxExecution.callFunction(from, to, data, value, gasLimit, {
    constant: true
  }, txRunner, callbacks, finalCallback);
}

function runTx(payload, from, to, data, value, gasLimit, txRunner, callbacks, callback) {
  const finalCallback = function (err, result) {
    if (err) {
      return callback(err);
    }

    callback(null, result.transactionHash);
  };

  TxExecution.callFunction(from, to, data, value, gasLimit, {
    constant: false
  }, txRunner, callbacks, finalCallback);
}

function createContract(payload, from, data, value, gasLimit, txRunner, callbacks, callback) {
  const finalCallback = function (err, result) {
    if (err) {
      return callback(err);
    }

    callback(null, result.transactionHash);
  };

  TxExecution.createContract(from, data, value, gasLimit, txRunner, callbacks, finalCallback);
}

let txRunnerInstance;

function processTx(executionContext, accounts, payload, isCall, callback) {
  const api = {
    logMessage: msg => {},
    logHtmlMessage: msg => {},
    config: {
      getUnpersistedProperty: key => {
        return true;
      },
      get: () => {
        return true;
      }
    },
    detectNetwork: cb => {
      cb();
    },
    personalMode: () => {
      return false;
    }
  };
  executionContext.init(api.config); // let txRunner = new TxRunner(accounts, api)

  if (!txRunnerInstance) {
    txRunnerInstance = new TxRunner(accounts, api, executionContext);
  }

  txRunnerInstance.vmaccounts = accounts;
  let {
    from,
    to,
    data,
    value,
    gas
  } = payload.params[0];
  gas = gas || 3000000;
  const callbacks = {
    confirmationCb: (network, tx, gasEstimation, continueTxExecution, cancelCb) => {
      continueTxExecution(null);
    },
    gasEstimationForceSend: (error, continueTxExecution, cancelCb) => {
      if (error) {
        continueTxExecution(error);
      }

      continueTxExecution();
    },
    promptCb: (okCb, cancelCb) => {
      okCb();
    }
  };

  if (isCall) {
    runCall(payload, from, to, data, value, gas, txRunnerInstance, callbacks, callback);
  } else if (to) {
    runTx(payload, from, to, data, value, gas, txRunnerInstance, callbacks, callback);
  } else {
    createContract(payload, from, data, value, gas, txRunnerInstance, callbacks, callback);
  }
}

exports.processTx = processTx;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/provider.js":
/*!******************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/provider.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const blocks_1 = __webpack_require__(/*! ./methods/blocks */ "../../../dist/libs/remix-simulator/src/methods/blocks.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

const {
  executionContext
} = remix_lib_1.execution;

const logs_1 = __webpack_require__(/*! ./utils/logs */ "../../../dist/libs/remix-simulator/src/utils/logs.js");

const merge_1 = tslib_1.__importDefault(__webpack_require__(/*! merge */ "../../../node_modules/merge/merge.js"));

const accounts_1 = __webpack_require__(/*! ./methods/accounts */ "../../../dist/libs/remix-simulator/src/methods/accounts.js");

const filters_1 = __webpack_require__(/*! ./methods/filters */ "../../../dist/libs/remix-simulator/src/methods/filters.js");

const misc_1 = __webpack_require__(/*! ./methods/misc */ "../../../dist/libs/remix-simulator/src/methods/misc.js");

const net_1 = __webpack_require__(/*! ./methods/net */ "../../../dist/libs/remix-simulator/src/methods/net.js");

const transactions_1 = __webpack_require__(/*! ./methods/transactions */ "../../../dist/libs/remix-simulator/src/methods/transactions.js");

const debug_1 = __webpack_require__(/*! ./methods/debug */ "../../../dist/libs/remix-simulator/src/methods/debug.js");

const genesis_1 = __webpack_require__(/*! ./genesis */ "../../../dist/libs/remix-simulator/src/genesis.js");

class Provider {
  constructor(host = 'vm', options = {}) {
    this.options = options;
    this.host = host;
    this.connected = true; // TODO: init executionContext here

    this.executionContext = executionContext;
    this.Accounts = new accounts_1.Accounts(this.executionContext);
    this.Transactions = new transactions_1.Transactions(this.executionContext);
    this.methods = {};
    this.methods = merge_1.default(this.methods, this.Accounts.methods());
    this.methods = merge_1.default(this.methods, new blocks_1.Blocks(this.executionContext, options).methods());
    this.methods = merge_1.default(this.methods, misc_1.methods());
    this.methods = merge_1.default(this.methods, new filters_1.Filters(this.executionContext).methods());
    this.methods = merge_1.default(this.methods, net_1.methods());
    this.methods = merge_1.default(this.methods, this.Transactions.methods());
    this.methods = merge_1.default(this.methods, new debug_1.Debug(this.executionContext).methods());
    genesis_1.generateBlock(this.executionContext);
    this.init();
  }

  init() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      yield this.Accounts.resetAccounts();
      this.Transactions.init(this.Accounts.accounts);
    });
  }

  sendAsync(payload, callback) {
    // log.info('payload method is ', payload.method) // commented because, this floods the IDE console
    const method = this.methods[payload.method];

    if (this.options.logDetails) {
      logs_1.info(payload);
    }

    if (method) {
      return method.call(method, payload, (err, result) => {
        if (this.options.logDetails) {
          logs_1.info(err);
          logs_1.info(result);
        }

        if (err) {
          return callback(err);
        }

        const response = {
          id: payload.id,
          jsonrpc: '2.0',
          result: result
        };
        callback(null, response);
      });
    }

    callback(new Error('unknown method ' + payload.method));
  }

  send(payload, callback) {
    this.sendAsync(payload, callback || function () {});
  }

  isConnected() {
    return true;
  }

  disconnect() {
    return false;
  }

  supportsSubscriptions() {
    return true;
  }

  on(type, cb) {
    this.executionContext.logsManager.addListener(type, cb);
  }

}

exports.Provider = Provider;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/utils/logs.js":
/*!********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/utils/logs.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const ansi_gray_1 = tslib_1.__importDefault(__webpack_require__(/*! ansi-gray */ "../../../node_modules/ansi-gray/index.js"));

const time_stamp_1 = tslib_1.__importDefault(__webpack_require__(/*! time-stamp */ "../../../node_modules/time-stamp/index.js"));

const color_support_1 = tslib_1.__importDefault(__webpack_require__(/*! color-support */ "../../../node_modules/color-support/browser.js"));

function hasFlag(flag) {
  return typeof process !== 'undefined' && process.argv.indexOf('--' + flag) !== -1;
}

function addColor(str) {
  if (this.hasFlag('no-color')) {
    return str;
  }

  if (this.hasFlag('color')) {
    return ansi_gray_1.default(str);
  }

  if (color_support_1.default()) {
    return ansi_gray_1.default(str);
  }

  return str;
}

function stdout(arg) {
  if (typeof process === 'undefined' || !process.stdout) return;
  process.stdout.write(arg);
}

function stderr(arg) {
  if (typeof process === 'undefined' || process.stderr) return;
  process.stderr.write(arg);
}

function getTimestamp() {
  const coloredTimestamp = this.addColor(time_stamp_1.default('HH:mm:ss'));
  return '[' + coloredTimestamp + ']';
}

function log(...args) {
  const time = this.getTimestamp();
  this.stdout(time + ' ');
  console.log(args);
  return this;
}

exports.log = log;

function info(...args) {
  const time = this.getTimestamp();
  this.stdout(time + ' ');
  console.info(args);
  return this;
}

exports.info = info;

function dir(...args) {
  const time = this.getTimestamp();
  this.stdout(time + ' ');
  console.dir(args);
  return this;
}

exports.dir = dir;

function warn(...args) {
  const time = this.getTimestamp();
  this.stderr(time + ' ');
  console.warn(args);
  return this;
}

exports.warn = warn;

function error(...args) {
  const time = this.getTimestamp();
  this.stderr(time + ' ');
  console.error(args);
  return this;
}

exports.error = error;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/process/browser.js */ "../../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../../dist/libs/remix-solidity/compiler/compiler-input.js":
/*!****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-solidity/compiler/compiler-input.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = (sources, opts) => {
  const o = {
    language: 'Solidity',
    sources: sources,
    settings: {
      optimizer: {
        enabled: opts.optimize === true || opts.optimize === 1,
        runs: opts.runs || 200
      },
      libraries: opts.libraries,
      outputSelection: {
        '*': {
          '': ['ast'],
          '*': ['abi', 'metadata', 'devdoc', 'userdoc', 'evm.legacyAssembly', 'evm.bytecode', 'evm.deployedBytecode', 'evm.methodIdentifiers', 'evm.gasEstimates', 'evm.assembly']
        }
      }
    }
  };

  if (opts.evmVersion) {
    o.settings.evmVersion = opts.evmVersion;
  }

  if (opts.language) {
    o.language = opts.language;
  }

  if (opts.language === 'Yul' && o.settings.optimizer.enabled) {
    if (!o.settings.optimizer.details) o.settings.optimizer.details = {};
    o.settings.optimizer.details.yul = true;
  }

  return JSON.stringify(o);
};

/***/ }),

/***/ "../../../dist/libs/remix-solidity/compiler/compiler-worker.js":
/*!*****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-solidity/compiler/compiler-worker.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const solc = __webpack_require__(/*! solc/wrapper */ "../../../node_modules/solc/wrapper.js");

let compileJSON = input => {
  return '';
};

const missingInputs = []; // 'DedicatedWorkerGlobalScope' object (the Worker global scope) is accessible through the self keyword
// 'dom' and 'webworker' library files can't be included together https://github.com/microsoft/TypeScript/issues/20595

function default_1(self) {
  self.addEventListener('message', e => {
    const data = e.data;

    switch (data.cmd) {
      case 'loadVersion':
        {
          delete self.Module; // NOTE: workaround some browsers?

          self.Module = undefined;
          compileJSON = null; //importScripts() method of synchronously imports one or more scripts into the worker's scope

          self.importScripts(data.data);
          const compiler = solc(self.Module);

          compileJSON = input => {
            try {
              const missingInputsCallback = path => {
                missingInputs.push(path);
                return {
                  'error': 'Deferred import'
                };
              };

              return compiler.compile(input, {
                import: missingInputsCallback
              });
            } catch (exception) {
              return JSON.stringify({
                error: 'Uncaught JavaScript exception:\n' + exception
              });
            }
          };

          self.postMessage({
            cmd: 'versionLoaded',
            data: compiler.version()
          });
          break;
        }

      case 'compile':
        missingInputs.length = 0;

        if (data.input && compileJSON) {
          self.postMessage({
            cmd: 'compiled',
            job: data.job,
            data: compileJSON(data.input),
            missingInputs: missingInputs
          });
        }

        break;
    }
  }, false);
}

exports.default = default_1;

/***/ }),

/***/ "../../../dist/libs/remix-solidity/compiler/compiler.js":
/*!**********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-solidity/compiler/compiler.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const abi_1 = __webpack_require__(/*! solc/abi */ "../../../node_modules/solc/abi.js");

const webworkify = __webpack_require__(/*! webworkify-webpack */ "../../../node_modules/webworkify-webpack/index.js");

const compiler_input_1 = __webpack_require__(/*! ./compiler-input */ "../../../dist/libs/remix-solidity/compiler/compiler-input.js");

const eventManager_1 = __webpack_require__(/*! ../lib/eventManager */ "../../../dist/libs/remix-solidity/lib/eventManager.js");

const txHelper_1 = __webpack_require__(/*! ./txHelper */ "../../../dist/libs/remix-solidity/compiler/txHelper.js");

const types_1 = __webpack_require__(/*! ./types */ "../../../dist/libs/remix-solidity/compiler/types.js");
/*
  trigger compilationFinished, compilerLoaded, compilationStarted, compilationDuration
*/


class Compiler {
  constructor(handleImportCall) {
    this.handleImportCall = handleImportCall;
    this.event = new eventManager_1.default();
    this.state = {
      compileJSON: null,
      worker: null,
      currentVersion: null,
      optimize: false,
      runs: 200,
      evmVersion: null,
      language: 'Solidity',
      compilationStartTime: null,
      target: null,
      lastCompilationResult: {
        data: null,
        source: null
      }
    };
    this.event.register('compilationFinished', (success, data, source) => {
      if (success && this.state.compilationStartTime) {
        this.event.trigger('compilationDuration', [new Date().getTime() - this.state.compilationStartTime]);
      }

      this.state.compilationStartTime = null;
    });
    this.event.register('compilationStarted', () => {
      this.state.compilationStartTime = new Date().getTime();
    });
  }
  /**
   * @dev Setter function for CompilerState's properties (used by IDE)
   * @param key key
   * @param value value of key in CompilerState
   */


  set(key, value) {
    this.state[key] = value;
    if (key === 'runs') this.state['runs'] = parseInt(value);
  }
  /**
   * @dev Internal function to compile the contract after gathering imports
   * @param files source file
   * @param missingInputs missing import file path list
   */


  internalCompile(files, missingInputs) {
    this.gatherImports(files, missingInputs, (error, input) => {
      if (error) {
        this.state.lastCompilationResult = null;
        this.event.trigger('compilationFinished', [false, {
          'error': {
            formattedMessage: error,
            severity: 'error'
          }
        }, files]);
      } else if (this.state.compileJSON && input) this.state.compileJSON(input);
    });
  }
  /**
   * @dev Compile source files (used by IDE)
   * @param files source files
   * @param target target file name (This is passed as it is to IDE)
   */


  compile(files, target) {
    this.state.target = target;
    this.event.trigger('compilationStarted', []);
    this.internalCompile(files);
  }
  /**
   * @dev Called when compiler is loaded, set current compiler version
   * @param version compiler version
   */


  onCompilerLoaded(version) {
    this.state.currentVersion = version;
    this.event.trigger('compilerLoaded', [version]);
  }
  /**
   * @dev Called when compiler is loaded internally (without worker)
   */


  onInternalCompilerLoaded() {
    if (this.state.worker === null) {
      const compiler = typeof window !== 'undefined' && window['Module'] ? __webpack_require__(/*! solc/wrapper */ "../../../node_modules/solc/wrapper.js")(window['Module']) : __webpack_require__(/*! solc */ "../../../node_modules/solc/index.js");

      this.state.compileJSON = source => {
        const missingInputs = [];

        const missingInputsCallback = path => {
          missingInputs.push(path);
          return {
            error: 'Deferred import'
          };
        };

        let result = {};

        try {
          if (source && source.sources) {
            const {
              optimize,
              runs,
              evmVersion,
              language
            } = this.state;
            const input = compiler_input_1.default(source.sources, {
              optimize,
              runs,
              evmVersion,
              language
            });
            result = JSON.parse(compiler.compile(input, {
              import: missingInputsCallback
            }));
          }
        } catch (exception) {
          result = {
            error: {
              formattedMessage: 'Uncaught JavaScript exception:\n' + exception,
              severity: 'error',
              mode: 'panic'
            }
          };
        }

        this.onCompilationFinished(result, missingInputs, source);
      };

      this.onCompilerLoaded(compiler.version());
    }
  }
  /**
   * @dev Called when compilation is finished
   * @param data compilation result data
   * @param missingInputs missing imports
   * @param source Source
   */


  onCompilationFinished(data, missingInputs, source) {
    let noFatalErrors = true; // ie warnings are ok

    const checkIfFatalError = error => {
      // Ignore warnings and the 'Deferred import' error as those are generated by us as a workaround
      const isValidError = error.message && error.message.includes('Deferred import') ? false : error.severity !== 'warning';
      if (isValidError) noFatalErrors = false;
    };

    if (data.error) checkIfFatalError(data.error);
    if (data.errors) data.errors.forEach(err => checkIfFatalError(err));

    if (!noFatalErrors) {
      // There are fatal errors, abort here
      this.state.lastCompilationResult = null;
      this.event.trigger('compilationFinished', [false, data, source]);
    } else if (missingInputs !== undefined && missingInputs.length > 0 && source && source.sources) {
      // try compiling again with the new set of inputs
      this.internalCompile(source.sources, missingInputs);
    } else {
      data = this.updateInterface(data);

      if (source) {
        source.target = this.state.target;
        this.state.lastCompilationResult = {
          data: data,
          source: source
        };
      }

      this.event.trigger('compilationFinished', [true, data, source]);
    }
  }
  /**
   * @dev Load compiler using given version (used by remix-tests CLI)
   * @param version compiler version
   */


  loadRemoteVersion(version) {
    console.log(`Loading remote solc version ${version} ...`);

    const compiler = __webpack_require__(/*! solc */ "../../../node_modules/solc/index.js");

    compiler.loadRemoteVersion(version, (err, remoteCompiler) => {
      if (err) {
        console.error('Error in loading remote solc compiler: ', err);
      } else {
        this.state.compileJSON = source => {
          const missingInputs = [];

          const missingInputsCallback = path => {
            missingInputs.push(path);
            return {
              error: 'Deferred import'
            };
          };

          let result = {};

          try {
            if (source && source.sources) {
              const {
                optimize,
                runs,
                evmVersion,
                language
              } = this.state;
              const input = compiler_input_1.default(source.sources, {
                optimize,
                runs,
                evmVersion,
                language
              });
              result = JSON.parse(remoteCompiler.compile(input, {
                import: missingInputsCallback
              }));
            }
          } catch (exception) {
            result = {
              error: {
                formattedMessage: 'Uncaught JavaScript exception:\n' + exception,
                severity: 'error',
                mode: 'panic'
              }
            };
          }

          this.onCompilationFinished(result, missingInputs, source);
        };

        this.onCompilerLoaded(version);
      }
    });
  }
  /**
   * @dev Load compiler using given URL (used by IDE)
   * @param usingWorker if true, load compiler using worker
   * @param url URL to load compiler from
   */


  loadVersion(usingWorker, url) {
    console.log('Loading ' + url + ' ' + (usingWorker ? 'with worker' : 'without worker'));
    this.event.trigger('loadingCompiler', [url, usingWorker]);

    if (this.state.worker) {
      this.state.worker.terminate();
      this.state.worker = null;
    }

    if (usingWorker) {
      this.loadWorker(url);
    } else {
      this.loadInternal(url);
    }
  }
  /**
   * @dev Load compiler using 'script' element (without worker)
   * @param url URL to load compiler from
   */


  loadInternal(url) {
    delete window['Module']; // NOTE: workaround some browsers?

    window['Module'] = undefined; // Set a safe fallback until the new one is loaded

    this.state.compileJSON = source => {
      this.onCompilationFinished({
        error: {
          formattedMessage: 'Compiler not yet loaded.'
        }
      });
    };

    const newScript = document.createElement('script');
    newScript.type = 'text/javascript';
    newScript.src = url;
    document.getElementsByTagName('head')[0].appendChild(newScript);
    const check = window.setInterval(() => {
      if (!window['Module']) {
        return;
      }

      window.clearInterval(check);
      this.onInternalCompilerLoaded();
    }, 200);
  }
  /**
   * @dev Load compiler using web worker
   * @param url URL to load compiler from
   */


  loadWorker(url) {
    this.state.worker = webworkify(/*require.resolve*/(/*! ./compiler-worker */ "../../../dist/libs/remix-solidity/compiler/compiler-worker.js"));
    const jobs = [];
    this.state.worker.addEventListener('message', msg => {
      const data = msg.data;

      switch (data.cmd) {
        case 'versionLoaded':
          if (data.data) this.onCompilerLoaded(data.data);
          break;

        case 'compiled':
          {
            let result;

            if (data.data && data.job !== undefined && data.job >= 0) {
              try {
                result = JSON.parse(data.data);
              } catch (exception) {
                result = {
                  error: {
                    formattedMessage: 'Invalid JSON output from the compiler: ' + exception
                  }
                };
              }

              let sources = {};

              if (data.job in jobs !== undefined) {
                sources = jobs[data.job].sources;
                delete jobs[data.job];
              }

              this.onCompilationFinished(result, data.missingInputs, sources);
            }

            break;
          }
      }
    });
    this.state.worker.addEventListener('error', msg => {
      this.onCompilationFinished({
        error: {
          formattedMessage: 'Worker error: ' + msg.data
        }
      });
    });

    this.state.compileJSON = source => {
      if (source && source.sources) {
        const {
          optimize,
          runs,
          evmVersion,
          language
        } = this.state;
        jobs.push({
          sources: source
        });
        this.state.worker.postMessage({
          cmd: 'compile',
          job: jobs.length - 1,
          input: compiler_input_1.default(source.sources, {
            optimize,
            runs,
            evmVersion,
            language
          })
        });
      }
    };

    this.state.worker.postMessage({
      cmd: 'loadVersion',
      data: url
    });
  }
  /**
   * @dev Gather imports for compilation
   * @param files file sources
   * @param importHints import file list
   * @param cb callback
   */


  gatherImports(files, importHints, cb) {
    importHints = importHints || []; // FIXME: This will only match imports if the file begins with one '.'
    // It should tokenize by lines and check each.

    const importRegex = /^\s*import\s*['"]([^'"]+)['"];/g;

    for (const fileName in files) {
      let match;

      while (match = importRegex.exec(files[fileName].content)) {
        let importFilePath = match[1];

        if (importFilePath.startsWith('./')) {
          const path = /(.*\/).*/.exec(fileName);
          importFilePath = path ? importFilePath.replace('./', path[1]) : importFilePath.slice(2);
        }

        if (!importHints.includes(importFilePath)) importHints.push(importFilePath);
      }
    }

    while (importHints.length > 0) {
      const m = importHints.pop();
      if (m && m in files) continue;

      if (this.handleImportCall) {
        this.handleImportCall(m, (err, content) => {
          if (err && cb) cb(err);else {
            files[m] = {
              content
            };
            this.gatherImports(files, importHints, cb);
          }
        });
      }

      return;
    }

    if (cb) cb(null, {
      'sources': files
    });
  }
  /**
   * @dev Truncate version string
   * @param version version
   */


  truncateVersion(version) {
    const tmp = /^(\d+.\d+.\d+)/.exec(version);
    return tmp ? tmp[1] : version;
  }
  /**
   * @dev Update ABI according to current compiler version
   * @param data Compilation result
   */


  updateInterface(data) {
    txHelper_1.default.visitContracts(data.contracts, contract => {
      if (!contract.object.abi) contract.object.abi = [];

      if (this.state.language === 'Yul' && contract.object.abi.length === 0) {
        // yul compiler does not return any abi,
        // we default to accept the fallback function (which expect raw data as argument).
        contract.object.abi.push({
          'payable': true,
          'stateMutability': 'payable',
          'type': 'fallback'
        });
      }

      if (data && data.contracts && this.state.currentVersion) {
        const version = this.truncateVersion(this.state.currentVersion);
        data.contracts[contract.file][contract.name].abi = abi_1.update(version, contract.object.abi); // if "constant" , payable must not be true and stateMutability must be view.
        // see https://github.com/ethereum/solc-js/issues/500

        for (const item of data.contracts[contract.file][contract.name].abi) {
          if (types_1.isFunctionDescription(item) && item.constant) {
            item.payable = false;
            item.stateMutability = 'view';
          }
        }
      }
    });
    return data;
  }
  /**
   * @dev Get contract obj of the given contract name from last compilation result.
   * @param name contract name
   */


  getContract(name) {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.contracts) {
      return txHelper_1.default.getContract(name, this.state.lastCompilationResult.data.contracts);
    }

    return null;
  }
  /**
   * @dev Call the given callback for all the contracts from last compilation result
   * @param cb callback
   */


  visitContracts(cb) {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.contracts) {
      return txHelper_1.default.visitContracts(this.state.lastCompilationResult.data.contracts, cb);
    }

    return null;
  }
  /**
   * @dev Get the compiled contracts data from last compilation result
   */


  getContracts() {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.contracts) {
      return this.state.lastCompilationResult.data.contracts;
    }

    return null;
  }
  /**
   * @dev Get sources from last compilation result
   */


  getSources() {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.source) {
      return this.state.lastCompilationResult.source.sources;
    }

    return null;
  }
  /**
   * @dev Get sources of passed file name from last compilation result
   * @param fileName file name
   */


  getSource(fileName) {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.source && this.state.lastCompilationResult.source.sources) {
      return this.state.lastCompilationResult.source.sources[fileName];
    }

    return null;
  }
  /**
   * @dev Get source name at passed index from last compilation result
   * @param index    - index of the source
   */


  getSourceName(index) {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.sources) {
      return Object.keys(this.state.lastCompilationResult.data.sources)[index];
    }

    return null;
  }

}

exports.Compiler = Compiler;

/***/ }),

/***/ "../../../dist/libs/remix-solidity/compiler/txHelper.js":
/*!**********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-solidity/compiler/txHelper.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  /**
   * @dev Get contract obj of given contract name from last compilation result.
   * @param name contract name
   * @param contracts 'contracts' object from last compilation result
   */
  getContract: (contractName, contracts) => {
    for (const file in contracts) {
      if (contracts[file][contractName]) {
        return {
          object: contracts[file][contractName],
          file: file
        };
      }
    }

    return null;
  },

  /**
   * @dev call the given callback for all contracts from last compilation result, stop visiting when cb return true
   * @param contracts - 'contracts' object from last compilation result
   * @param cb    - callback
   */
  visitContracts: (contracts, cb) => {
    for (const file in contracts) {
      for (const name in contracts[file]) {
        const param = {
          name: name,
          object: contracts[file][name],
          file: file
        };
        if (cb(param)) return;
      }
    }
  }
};

/***/ }),

/***/ "../../../dist/libs/remix-solidity/compiler/types.js":
/*!*******************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-solidity/compiler/types.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.isFunctionDescription = item => item.stateMutability !== undefined;

exports.isEventDescription = item => item.type === 'event';

/***/ }),

/***/ "../../../dist/libs/remix-solidity/index.js":
/*!**********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-solidity/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

var compiler_1 = __webpack_require__(/*! ./compiler/compiler */ "../../../dist/libs/remix-solidity/compiler/compiler.js");

exports.Compiler = compiler_1.Compiler;

var compiler_input_1 = __webpack_require__(/*! ./compiler/compiler-input */ "../../../dist/libs/remix-solidity/compiler/compiler-input.js");

exports.CompilerInput = compiler_input_1.default;

tslib_1.__exportStar(__webpack_require__(/*! ./compiler/types */ "../../../dist/libs/remix-solidity/compiler/types.js"), exports);

/***/ }),

/***/ "../../../dist/libs/remix-solidity/lib/eventManager.js":
/*!*********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-solidity/lib/eventManager.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class EventManager {
  constructor() {
    this.registered = {}; // eslint-disable-line

    this.anonymous = {}; // eslint-disable-line
  }
  /*
   * Unregister a listener.
   * Note that if obj is a function. the unregistration will be applied to the dummy obj {}.
   *
   * @param {String} eventName  - the event name
   * @param {Object or Func} obj - object that will listen on this event
   * @param {Func} func         - function of the listeners that will be executed
  */


  unregister(eventName, obj, func) {
    if (!this.registered[eventName]) {
      return;
    }

    if (obj instanceof Function) {
      func = obj;
      obj = this.anonymous;
    }

    for (const reg in this.registered[eventName]) {
      if (this.registered[eventName][reg].obj === obj && this.registered[eventName][reg].func === func) {
        this.registered[eventName].splice(reg, 1);
      }
    }
  }
  /*
   * Register a new listener.
   * Note that if obj is a function, the function registration will be associated with the dummy object {}
   *
   * @param {String} eventName  - the event name
   * @param {Object or Func} obj - object that will listen on this event
   * @param {Func} func         - function of the listeners that will be executed
  */


  register(eventName, obj, func) {
    if (!this.registered[eventName]) {
      this.registered[eventName] = [];
    }

    if (obj instanceof Function) {
      func = obj;
      obj = this.anonymous;
    }

    this.registered[eventName].push({
      obj: obj,
      func: func
    });
  }
  /*
   * trigger event.
   * Every listener have their associated function executed
   *
   * @param {String} eventName  - the event name
   * @param {Array}j - argument that will be passed to the executed function.
  */


  trigger(eventName, args) {
    if (!this.registered[eventName]) {
      return;
    }

    for (const listener in this.registered[eventName]) {
      const l = this.registered[eventName][listener];
      l.func.apply(l.obj === this.anonymous ? {} : l.obj, args);
    }
  }

}

exports.default = EventManager;

/***/ }),

/***/ "../../../dist/libs/remix-tests/sol/tests.sol.js":
/*!***************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/sol/tests.sol.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = `// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.4.22 <0.8.0;

library Assert {

  event AssertionEvent(
    bool passed,
    string message,
    string methodName
  );

  event AssertionEventUint(
    bool passed,
    string message,
    string methodName,
    uint256 returned,
    uint256 expected
  );

  event AssertionEventInt(
    bool passed,
    string message,
    string methodName,
    int256 returned,
    int256 expected
  );

  event AssertionEventBool(
    bool passed,
    string message,
    string methodName,
    bool returned,
    bool expected
  );

  event AssertionEventAddress(
    bool passed,
    string message,
    string methodName,
    address returned,
    address expected
  );

  event AssertionEventBytes32(
    bool passed,
    string message,
    string methodName,
    bytes32 returned,
    bytes32 expected
  );

  event AssertionEventString(
    bool passed,
    string message,
    string methodName,
    string returned,
    string expected
  );

  event AssertionEventUintInt(
    bool passed,
    string message,
    string methodName,
    uint256 returned,
    int256 expected
  );

  event AssertionEventIntUint(
    bool passed,
    string message,
    string methodName,
    int256 returned,
    uint256 expected
  );

  function ok(bool a, string memory message) public returns (bool result) {
    result = a;
    emit AssertionEvent(result, message, "ok");
  }

  function equal(uint256 a, uint256 b, string memory message) public returns (bool result) {
    result = (a == b);
    emit AssertionEventUint(result, message, "equal", a, b);
  }

  function equal(int256 a, int256 b, string memory message) public returns (bool result) {
    result = (a == b);
    emit AssertionEventInt(result, message, "equal", a, b);
  }

  function equal(bool a, bool b, string memory message) public returns (bool result) {
    result = (a == b);
    emit AssertionEventBool(result, message, "equal", a, b);
  }

  // TODO: only for certain versions of solc
  //function equal(fixed a, fixed b, string message) public returns (bool result) {
  //  result = (a == b);
  //  emit AssertionEvent(result, message);
  //}

  // TODO: only for certain versions of solc
  //function equal(ufixed a, ufixed b, string message) public returns (bool result) {
  //  result = (a == b);
  //  emit AssertionEvent(result, message);
  //}

  function equal(address a, address b, string memory message) public returns (bool result) {
    result = (a == b);
    emit AssertionEventAddress(result, message, "equal", a, b);
  }

  function equal(bytes32 a, bytes32 b, string memory message) public returns (bool result) {
    result = (a == b);
    emit AssertionEventBytes32(result, message, "equal", a, b);
  }

  function equal(string memory a, string memory b, string memory message) public returns (bool result) {
     result = (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b)));
     emit AssertionEventString(result, message, "equal", a, b);
  }

  function notEqual(uint256 a, uint256 b, string memory message) public returns (bool result) {
    result = (a != b);
    emit AssertionEventUint(result, message, "notEqual", a, b);
  }

  function notEqual(int256 a, int256 b, string memory message) public returns (bool result) {
    result = (a != b);
    emit AssertionEventInt(result, message, "notEqual", a, b);
  }

  function notEqual(bool a, bool b, string memory message) public returns (bool result) {
    result = (a != b);
    emit AssertionEventBool(result, message, "notEqual", a, b);
  }

  // TODO: only for certain versions of solc
  //function notEqual(fixed a, fixed b, string message) public returns (bool result) {
  //  result = (a != b);
  //  emit AssertionEvent(result, message);
  //}

  // TODO: only for certain versions of solc
  //function notEqual(ufixed a, ufixed b, string message) public returns (bool result) {
  //  result = (a != b);
  //  emit AssertionEvent(result, message);
  //}

  function notEqual(address a, address b, string memory message) public returns (bool result) {
    result = (a != b);
    emit AssertionEventAddress(result, message, "notEqual", a, b);
  }

  function notEqual(bytes32 a, bytes32 b, string memory message) public returns (bool result) {
    result = (a != b);
    emit AssertionEventBytes32(result, message, "notEqual", a, b);
  }

  function notEqual(string memory a, string memory b, string memory message) public returns (bool result) {
    result = (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b)));
    emit AssertionEventString(result, message, "notEqual", a, b);
  }

  /*----------------- Greater than --------------------*/
  function greaterThan(uint256 a, uint256 b, string memory message) public returns (bool result) {
    result = (a > b);
    emit AssertionEventUint(result, message, "greaterThan", a, b);
  }

  function greaterThan(int256 a, int256 b, string memory message) public returns (bool result) {
    result = (a > b);
    emit AssertionEventInt(result, message, "greaterThan", a, b);
  }
  // TODO: safely compare between uint and int
  function greaterThan(uint256 a, int256 b, string memory message) public returns (bool result) {
    if(b < int(0)) {
      // int is negative uint "a" always greater
      result = true;
    } else {
      result = (a > uint(b));
    }
    emit AssertionEventUintInt(result, message, "greaterThan", a, b);
  }
  function greaterThan(int256 a, uint256 b, string memory message) public returns (bool result) {
    if(a < int(0)) {
      // int is negative uint "b" always greater
      result = false;
    } else {
      result = (uint(a) > b);
    }
    emit AssertionEventIntUint(result, message, "greaterThan", a, b);
  }
  /*----------------- Lesser than --------------------*/
  function lesserThan(uint256 a, uint256 b, string memory message) public returns (bool result) {
    result = (a < b);
    emit AssertionEventUint(result, message, "lesserThan", a, b);
  }

  function lesserThan(int256 a, int256 b, string memory message) public returns (bool result) {
    result = (a < b);
    emit AssertionEventInt(result, message, "lesserThan", a, b);
  }
  // TODO: safely compare between uint and int
  function lesserThan(uint256 a, int256 b, string memory message) public returns (bool result) {
    if(b < int(0)) {
      // int is negative int "b" always lesser
      result = false;
    } else {
      result = (a < uint(b));
    }
    emit AssertionEventUintInt(result, message, "lesserThan", a, b);
  }

  function lesserThan(int256 a, uint256 b, string memory message) public returns (bool result) {
    if(a < int(0)) {
      // int is negative int "a" always lesser
      result = true;
    } else {
      result = (uint(a) < b);
    }
    emit AssertionEventIntUint(result, message, "lesserThan", a, b);
  }
}
`;

/***/ }),

/***/ "../../../dist/libs/remix-tests/sol/tests_accounts.sol.js":
/*!************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/sol/tests_accounts.sol.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = `// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.4.22 <0.8.0;

library TestsAccounts {
    function getAccount(uint index) public returns (address) {
        >accounts<
        return accounts[index];
    }
}
`;

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/assertionEvents.js":
/*!*********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/assertionEvents.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const assertionEvents = [{
  name: 'AssertionEvent',
  params: ['bool', 'string', 'string']
}, {
  name: 'AssertionEventUint',
  params: ['bool', 'string', 'string', 'uint256', 'uint256']
}, {
  name: 'AssertionEventInt',
  params: ['bool', 'string', 'string', 'int256', 'int256']
}, {
  name: 'AssertionEventBool',
  params: ['bool', 'string', 'string', 'bool', 'bool']
}, {
  name: 'AssertionEventAddress',
  params: ['bool', 'string', 'string', 'address', 'address']
}, {
  name: 'AssertionEventBytes32',
  params: ['bool', 'string', 'string', 'bytes32', 'bytes32']
}, {
  name: 'AssertionEventString',
  params: ['bool', 'string', 'string', 'string', 'string']
}, {
  name: 'AssertionEventUintInt',
  params: ['bool', 'string', 'string', 'uint256', 'int256']
}, {
  name: 'AssertionEventIntUint',
  params: ['bool', 'string', 'string', 'int256', 'uint256']
}];
exports.default = assertionEvents;

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/compiler.js":
/*!**************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/compiler.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const fileSystem_1 = tslib_1.__importDefault(__webpack_require__(/*! ./fileSystem */ "../../../dist/libs/remix-tests/src/fileSystem.js"));

const async_1 = tslib_1.__importDefault(__webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js"));

const path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ "../../../node_modules/path-browserify/index.js"));

const logger_1 = tslib_1.__importDefault(__webpack_require__(/*! ./logger */ "../../../dist/libs/remix-tests/src/logger.js"));

const logger = new logger_1.default();
const log = logger.logger;

const remix_solidity_1 = __webpack_require__(/*! @remix-project/remix-solidity */ "../../../dist/libs/remix-solidity/index.js");

const types_1 = __webpack_require__(/*! ./types */ "../../../dist/libs/remix-tests/src/types.js");

function regexIndexOf(inputString, regex, startpos = 0) {
  const indexOf = inputString.substring(startpos).search(regex);
  return indexOf >= 0 ? indexOf + startpos : indexOf;
}

function writeTestAccountsContract(accounts) {
  const testAccountContract = __webpack_require__(/*! ../sol/tests_accounts.sol */ "../../../dist/libs/remix-tests/sol/tests_accounts.sol.js");

  let body = `address[${accounts.length}] memory accounts;`;
  if (!accounts.length) body += ';';else {
    accounts.map((address, index) => {
      body += `\naccounts[${index}] = ${address};\n`;
    });
  }
  return testAccountContract.replace('>accounts<', body);
}
/**
 * @dev Check if path includes name of a remix test file
 * @param path file path to check
 */


function isRemixTestFile(path) {
  return ['tests.sol', 'remix_tests.sol', 'remix_accounts.sol'].some(name => path.includes(name));
}
/**
 * @dev Process file to prepare sources object to be passed in solc compiler input
 *
 * See: https://solidity.readthedocs.io/en/latest/using-the-compiler.html#input-description
 *
 * @param filePath path of file to process
 * @param sources existing 'sources' object in which keys are the "global" names of the source files and
 *                value is object containing content of corresponding file with under key 'content'
 * @param isRoot True, If file is a root test contract file which is getting processed, not an imported file
 */


function processFile(filePath, sources, isRoot = false) {
  const importRegEx = /import ['"](.+?)['"];/g;
  let group = null;
  const isFileAlreadyInSources = Object.keys(sources).includes(filePath); // Return if file is a remix test file or already processed

  if (isRemixTestFile(filePath) || isFileAlreadyInSources) return;
  let content = fileSystem_1.default.readFileSync(filePath, {
    encoding: 'utf-8'
  });
  const testFileImportRegEx = /^(import)\s['"](remix_tests.sol|tests.sol)['"];/gm; // import 'remix_tests.sol', if file is a root test contract file and doesn't already have it 

  if (isRoot && filePath.endsWith('_test.sol') && regexIndexOf(content, testFileImportRegEx) < 0) {
    const includeTestLibs = '\nimport \'remix_tests.sol\';\n';
    content = includeTestLibs.concat(content);
  }

  sources[filePath] = {
    content
  };
  importRegEx.exec(''); // Resetting state of RegEx
  // Process each 'import' in file content

  while (group = importRegEx.exec(content)) {
    const importedFile = group[1];
    const importedFilePath = path_1.default.join(path_1.default.dirname(filePath), importedFile);
    processFile(importedFilePath, sources);
  }
}

const userAgent = typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '-';
const isBrowser = !(typeof window === 'undefined' || userAgent.indexOf(' electron/') > -1);
/**
 * @dev Compile file or files before running tests (used for CLI execution)
 * @param filename Name of file
 * @param isDirectory True, if path is a directory
 * @param opts Options
 * @param cb Callback
 *
 * TODO: replace this with remix's own compiler code
 */

function compileFileOrFiles(filename, isDirectory, opts, compilerConfig, cb) {
  let compiler;
  const accounts = opts.accounts || [];
  const sources = {
    'tests.sol': {
      content: __webpack_require__(/*! ../sol/tests.sol */ "../../../dist/libs/remix-tests/sol/tests.sol.js")
    },
    'remix_tests.sol': {
      content: __webpack_require__(/*! ../sol/tests.sol */ "../../../dist/libs/remix-tests/sol/tests.sol.js")
    },
    'remix_accounts.sol': {
      content: writeTestAccountsContract(accounts)
    }
  };
  const filepath = isDirectory ? filename : path_1.default.dirname(filename);

  try {
    if (!isDirectory && fileSystem_1.default.existsSync(filename)) {
      if (filename.split('.').pop() === 'sol') {
        processFile(filename, sources, true);
      } else {
        throw new Error('Not a solidity file');
      }
    } else {
      // walkSync only if it is a directory
      let testFileCount = 0;
      fileSystem_1.default.walkSync(filepath, foundpath => {
        // only process .sol files
        if (foundpath.split('.').pop() === 'sol' && foundpath.endsWith('_test.sol')) {
          testFileCount++;
          processFile(foundpath, sources, true);
        }
      });

      if (testFileCount > 0) {
        log.info(`${testFileCount} Solidity test file${testFileCount === 1 ? '' : 's'} found`);
      } else {
        log.error(`No Solidity test file found. Make sure your test file ends with '_test.sol'`);
        process.exit();
      }
    }
  } catch (e) {
    // eslint-disable-line no-useless-catch
    throw e;
  } finally {
    async_1.default.waterfall([function loadCompiler(next) {
      compiler = new remix_solidity_1.Compiler();

      if (compilerConfig) {
        const {
          currentCompilerUrl,
          evmVersion,
          optimize,
          runs
        } = compilerConfig;
        evmVersion ? compiler.set('evmVersion', evmVersion) : null;
        optimize ? compiler.set('optimize', optimize) : null;
        runs ? compiler.set('runs', runs) : null;

        if (currentCompilerUrl) {
          compiler.loadRemoteVersion(currentCompilerUrl);
          compiler.event.register('compilerLoaded', this, function (version) {
            next();
          });
        } else {
          compiler.onInternalCompilerLoaded();
          next();
        }
      } else {
        compiler.onInternalCompilerLoaded();
        next();
      }
    }, function doCompilation(next) {
      // @ts-ignore
      compiler.event.register('compilationFinished', this, (success, data, source) => {
        next(null, data);
      });
      compiler.compile(sources, filepath);
    }], function (err, result) {
      const error = [];
      if (result.error) error.push(result.error);
      const errors = (result.errors || error).filter(e => e.type === 'Error' || e.severity === 'error');

      if (errors.length > 0) {
        if (!isBrowser) __webpack_require__(/*! signale */ "../../../node_modules/signale/index.js").fatal(errors);
        return cb(new types_1.CompilationErrors(errors));
      }

      cb(err, result.contracts, result.sources); //return callback with contract details & ASTs
    });
  }
}

exports.compileFileOrFiles = compileFileOrFiles;
/**
 * @dev Compile contract source before running tests (used for IDE tests execution)
 * @param sources sources
 * @param compilerConfig current compiler configuration
 * @param importFileCb Import file callback
 * @param opts Options
 * @param cb Callback
 */

function compileContractSources(sources, compilerConfig, importFileCb, opts, cb) {
  let compiler, filepath;
  const accounts = opts.accounts || []; // Iterate over sources keys. Inject test libraries. Inject test library import statements.

  if (!('remix_tests.sol' in sources) && !('tests.sol' in sources)) {
    sources['tests.sol'] = {
      content: __webpack_require__(/*! ../sol/tests.sol.js */ "../../../dist/libs/remix-tests/sol/tests.sol.js")
    };
    sources['remix_tests.sol'] = {
      content: __webpack_require__(/*! ../sol/tests.sol.js */ "../../../dist/libs/remix-tests/sol/tests.sol.js")
    };
    sources['remix_accounts.sol'] = {
      content: writeTestAccountsContract(accounts)
    };
  }

  const testFileImportRegEx = /^(import)\s['"](remix_tests.sol|tests.sol)['"];/gm;
  const includeTestLibs = '\nimport \'remix_tests.sol\';\n';

  for (const file in sources) {
    const c = sources[file].content;

    if (file.endsWith('_test.sol') && c && regexIndexOf(c, testFileImportRegEx) < 0) {
      sources[file].content = includeTestLibs.concat(c);
    }
  }

  async_1.default.waterfall([function loadCompiler(next) {
    const {
      currentCompilerUrl,
      evmVersion,
      optimize,
      runs,
      usingWorker
    } = compilerConfig;
    compiler = new remix_solidity_1.Compiler(importFileCb);
    compiler.set('evmVersion', evmVersion);
    compiler.set('optimize', optimize);
    compiler.set('runs', runs);
    compiler.loadVersion(usingWorker, currentCompilerUrl); // @ts-ignore

    compiler.event.register('compilerLoaded', this, version => {
      next();
    });
  }, function doCompilation(next) {
    // @ts-ignore
    compiler.event.register('compilationFinished', this, (success, data, source) => {
      next(null, data);
    });
    compiler.compile(sources, filepath);
  }], function (err, result) {
    const error = [];
    if (result.error) error.push(result.error);
    const errors = (result.errors || error).filter(e => e.type === 'Error' || e.severity === 'error');

    if (errors.length > 0) {
      if (!isBrowser) __webpack_require__(/*! signale */ "../../../node_modules/signale/index.js").fatal(errors);
      return cb(new types_1.CompilationErrors(errors));
    }

    cb(err, result.contracts, result.sources); // return callback with contract details & ASTs
  });
}

exports.compileContractSources = compileContractSources;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "../../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/deployer.js":
/*!**************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/deployer.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const async_1 = tslib_1.__importDefault(__webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js"));

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");
/**
 * @dev Deploy all contracts from compilation result
 * @param compileResult compilation result
 * @param web3 web3 object
 * @param withDoubleGas If true, try deployment with gas double of estimation (used for Out-of-gas error only)
 * @param callback Callback
 */


function deployAll(compileResult, web3, withDoubleGas, callback) {
  const compiledObject = {};
  const contracts = {};
  let accounts = [];
  async_1.default.waterfall([function getAccountList(next) {
    web3.eth.getAccounts((_err, _accounts) => {
      accounts = _accounts;
      next();
    });
  }, function getContractData(next) {
    for (const contractFile in compileResult) {
      for (const contractName in compileResult[contractFile]) {
        const contract = compileResult[contractFile][contractName];
        const className = contractName;
        const filename = contractFile;
        const abi = contract.abi;
        const code = contract.evm.bytecode.object;
        compiledObject[className] = {};
        compiledObject[className].abi = abi;
        compiledObject[className].code = code;
        compiledObject[className].filename = filename;
        compiledObject[className].className = className;
        compiledObject[className].raw = contract;

        if (contractFile.endsWith('_test.sol')) {
          compiledObject[className].isTest = true;
        }
      }
    }

    next();
  }, function determineContractsToDeploy(next) {
    const contractsToDeploy = ['Assert'];
    const allContracts = Object.keys(compiledObject);

    for (const contractName of allContracts) {
      if (contractName === 'Assert') {
        continue;
      }

      if (compiledObject[contractName].isTest) {
        contractsToDeploy.push(contractName);
      }
    }

    next(null, contractsToDeploy);
  }, function deployContracts(contractsToDeploy, next) {
    const deployRunner = (deployObject, contractObject, contractName, filename, callback) => {
      deployObject.estimateGas().then(gasValue => {
        const gasBase = Math.ceil(gasValue * 1.2);
        const gas = withDoubleGas ? gasBase * 2 : gasBase;
        deployObject.send({
          from: accounts[0],
          gas: gas
        }).on('receipt', function (receipt) {
          contractObject.options.address = receipt.contractAddress;
          contractObject.options.from = accounts[0];
          contractObject.options.gas = 5000 * 1000;
          compiledObject[contractName].deployedAddress = receipt.contractAddress;
          contracts[contractName] = contractObject;
          contracts[contractName].filename = filename;
          callback(null, {
            result: {
              createdAddress: receipt.contractAddress
            }
          }); // TODO this will only work with JavaScriptV VM
        }).on('error', function (err) {
          console.error(err);
          callback(err);
        });
      });
    };

    async_1.default.eachOfLimit(contractsToDeploy, 1, function (contractName, index, nextEach) {
      const contract = compiledObject[contractName];

      const encodeDataFinalCallback = (error, contractDeployData) => {
        if (error) return nextEach(error);
        const contractObject = new web3.eth.Contract(contract.abi);
        const deployObject = contractObject.deploy({
          arguments: [],
          data: '0x' + contractDeployData.dataHex
        });
        deployRunner(deployObject, contractObject, contractName, contract.filename, error => {
          nextEach(error);
        });
      };

      const encodeDataStepCallback = msg => {
        console.dir(msg);
      };

      const encodeDataDeployLibraryCallback = (libData, callback) => {
        const abi = compiledObject[libData.data.contractName].abi;
        const code = compiledObject[libData.data.contractName].code;
        const libraryObject = new web3.eth.Contract(abi);
        const deployObject = libraryObject.deploy({
          arguments: [],
          data: '0x' + code
        });
        deployRunner(deployObject, libraryObject, libData.data.contractName, contract.filename, callback);
      };

      const funAbi = null; // no need to set the abi for encoding the constructor

      const params = ''; // we suppose that the test contract does not have any param in the constructor

      remix_lib_1.execution.txFormat.encodeConstructorCallAndDeployLibraries(contractName, contract.raw, compileResult, params, funAbi, encodeDataFinalCallback, encodeDataStepCallback, encodeDataDeployLibraryCallback);
    }, function (err) {
      if (err) next(err);
      next(null, contracts);
    });
  }], callback);
}

exports.deployAll = deployAll;

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/fileSystem.js":
/*!****************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/fileSystem.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js"); // Extend fs


const fs = __webpack_require__(/*! fs */ "../../../node_modules/node-libs-browser/mock/empty.js");

const path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ "../../../node_modules/path-browserify/index.js")); // https://github.com/mikeal/node-utils/blob/master/file/lib/main.js


fs.walkSync = function (start, callback) {
  fs.readdirSync(start).forEach(name => {
    if (name === 'node_modules') {
      return; // hack
    }

    const abspath = path_1.default.join(start, name);

    if (fs.statSync(abspath).isDirectory()) {
      fs.walkSync(abspath, callback);
    } else {
      callback(abspath);
    }
  });
};

module.exports = fs;

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/index.js":
/*!***********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

var runTestFiles_1 = __webpack_require__(/*! ./runTestFiles */ "../../../dist/libs/remix-tests/src/runTestFiles.js");

exports.runTestFiles = runTestFiles_1.runTestFiles;

var runTestSources_1 = __webpack_require__(/*! ./runTestSources */ "../../../dist/libs/remix-tests/src/runTestSources.js");

exports.runTestSources = runTestSources_1.runTestSources;

var testRunner_1 = __webpack_require__(/*! ./testRunner */ "../../../dist/libs/remix-tests/src/testRunner.js");

exports.runTest = testRunner_1.runTest;

tslib_1.__exportStar(__webpack_require__(/*! ./types */ "../../../dist/libs/remix-tests/src/types.js"), exports);

exports.assertLibCode = __webpack_require__(/*! ../sol/tests.sol */ "../../../dist/libs/remix-tests/sol/tests.sol.js");

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/logger.js":
/*!************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/logger.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const colors_1 = tslib_1.__importDefault(__webpack_require__(/*! colors */ "../../../node_modules/colors/lib/index.js"));

const winston_1 = tslib_1.__importDefault(__webpack_require__(/*! winston */ "../../../node_modules/winston/dist/winston.js"));

const time_stamp_1 = tslib_1.__importDefault(__webpack_require__(/*! time-stamp */ "../../../node_modules/time-stamp/index.js"));

const color_support_1 = tslib_1.__importDefault(__webpack_require__(/*! color-support */ "../../../node_modules/color-support/browser.js"));

function hasFlag(flag) {
  return typeof process !== 'undefined' && process.argv.indexOf('--' + flag) !== -1;
}

function addColor(str) {
  if (hasFlag('no-color')) {
    return str;
  }

  if (hasFlag('color')) {
    return colors_1.default.gray(str);
  }

  if (color_support_1.default()) {
    return colors_1.default.gray(str);
  }

  return str;
}

function getTimestamp() {
  return '[' + addColor(time_stamp_1.default('HH:mm:ss')) + ']';
} // create winston logger format


const logFmt = winston_1.default.format.printf(info => {
  return `${getTimestamp()} ${info.level}: ${info.message}`;
});

class Log {
  constructor() {
    this.logger = winston_1.default.createLogger({
      level: 'info',
      transports: [new winston_1.default.transports.Console()],
      format: winston_1.default.format.combine(winston_1.default.format.colorize({
        all: true
      }), logFmt)
    });
  }

  setVerbosity(v) {
    this.logger.configure({
      level: v,
      transports: [new winston_1.default.transports.Console()],
      format: winston_1.default.format.combine(winston_1.default.format.colorize({
        all: true
      }), logFmt)
    });
  }

}

module.exports = Log;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "../../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/runTestFiles.js":
/*!******************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/runTestFiles.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const async_1 = tslib_1.__importDefault(__webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js"));

const fileSystem_1 = tslib_1.__importDefault(__webpack_require__(/*! ./fileSystem */ "../../../dist/libs/remix-tests/src/fileSystem.js"));

const testRunner_1 = __webpack_require__(/*! ./testRunner */ "../../../dist/libs/remix-tests/src/testRunner.js");

const colors_1 = tslib_1.__importDefault(__webpack_require__(/*! colors */ "../../../node_modules/colors/lib/index.js"));

const compiler_1 = __webpack_require__(/*! ./compiler */ "../../../dist/libs/remix-tests/src/compiler.js");

const deployer_1 = __webpack_require__(/*! ./deployer */ "../../../dist/libs/remix-tests/src/deployer.js");
/**
 * @dev run test contract files (used for CLI)
 * @param filepath Path of file
 * @param isDirectory True, if path is a directory
 * @param web3 Web3
 * @param finalCallback optional callback to run finally
 * @param opts Options
 */
// eslint-disable-next-line @typescript-eslint/no-empty-function


function runTestFiles(filepath, isDirectory, web3, compilerConfig, finalCallback = () => {}, opts) {
  opts = opts || {};
  compilerConfig = compilerConfig || {};
  const sourceASTs = {};

  const {
    Signale
  } = __webpack_require__(/*! signale */ "../../../node_modules/signale/index.js"); // signale configuration


  const options = {
    types: {
      result: {
        badge: '\t',
        label: '',
        color: 'greenBright'
      },
      name: {
        badge: '\n\t',
        label: '',
        color: 'white'
      },
      error: {
        badge: '\t',
        label: '',
        color: 'redBright'
      }
    }
  };
  const signale = new Signale(options);
  let accounts = opts['accounts'] || null;
  async_1.default.waterfall([function getAccountList(next) {
    if (accounts) return next(null);
    web3.eth.getAccounts((_err, _accounts) => {
      accounts = _accounts;
      next(null);
    });
  }, function compile(next) {
    compiler_1.compileFileOrFiles(filepath, isDirectory, {
      accounts
    }, compilerConfig, next);
  }, function deployAllContracts(compilationResult, asts, next) {
    // Extract AST of test contract file source
    for (const filename in asts) {
      if (filename.endsWith('_test.sol')) sourceASTs[filename] = asts[filename].ast;
    }

    deployer_1.deployAll(compilationResult, web3, false, (err, contracts) => {
      if (err) {
        next(err);
      }

      next(null, compilationResult, contracts);
    });
  }, function determineTestContractsToRun(compilationResult, contracts, next) {
    const contractsToTest = [];
    const contractsToTestDetails = [];

    const gatherContractsFrom = function (filename) {
      if (!filename.endsWith('_test.sol')) {
        return;
      }

      try {
        Object.keys(compilationResult[filename]).forEach(contractName => {
          contractsToTest.push(contractName);
          contractsToTestDetails.push(compilationResult[filename][contractName]);
        });
      } catch (e) {
        console.error(e);
      }
    };

    if (isDirectory) {
      fileSystem_1.default.walkSync(filepath, foundpath => {
        gatherContractsFrom(foundpath);
      });
    } else {
      gatherContractsFrom(filepath);
    }

    next(null, contractsToTest, contractsToTestDetails, contracts);
  }, function runTests(contractsToTest, contractsToTestDetails, contracts, next) {
    let totalPassing = 0;
    let totalFailing = 0;
    let totalTime = 0;
    const errors = [];

    const _testCallback = function (err, result) {
      if (err) throw err;

      if (result.type === 'contract') {
        signale.name(result.value.white);
      } else if (result.type === 'testPass') {
        signale.result(result.value);
      } else if (result.type === 'testFailure') {
        signale.error(result.value.red);
        errors.push(result);
      }
    };

    const _resultsCallback = (_err, result, cb) => {
      totalPassing += result.passingNum;
      totalFailing += result.failureNum;
      totalTime += result.timePassed;
      cb();
    };

    async_1.default.eachOfLimit(contractsToTest, 1, (contractName, index, cb) => {
      try {
        const fileAST = sourceASTs[contracts[contractName]['filename']];
        testRunner_1.runTest(contractName, contracts[contractName], contractsToTestDetails[index], fileAST, {
          accounts
        }, _testCallback, (err, result) => {
          if (err) {
            console.log(err);
            return cb(err);
          }

          _resultsCallback(null, result, cb);
        });
      } catch (e) {
        console.error(e);
      }
    }, function (err) {
      if (err) {
        return next(err);
      }

      console.log('\n');

      if (totalPassing > 0) {
        console.log(colors_1.default.green(totalPassing + ' passing ') + colors_1.default.grey('(' + totalTime + 's)'));
      }

      if (totalFailing > 0) {
        console.log(colors_1.default.red(totalFailing + ' failing'));
      }

      console.log('');
      errors.forEach((error, index) => {
        console.log('  ' + (index + 1) + ') ' + colors_1.default.bold(error.context + ': ') + error.value);
        console.log('');
        console.log(colors_1.default.red('\t error: ' + error.errMsg));
        console.log(colors_1.default.green('\t expected value to be ' + error.assertMethod + ' to: ' + error.expected));
        console.log(colors_1.default.red('\t returned: ' + error.returned));
      });
      console.log('');
      next();
    });
  }], finalCallback);
}

exports.runTestFiles = runTestFiles;

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/runTestSources.js":
/*!********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/runTestSources.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const async_1 = tslib_1.__importDefault(__webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js"));

__webpack_require__(/*! colors */ "../../../node_modules/colors/lib/index.js");

const compiler_1 = __webpack_require__(/*! ./compiler */ "../../../dist/libs/remix-tests/src/compiler.js");

const deployer_1 = __webpack_require__(/*! ./deployer */ "../../../dist/libs/remix-tests/src/deployer.js");

const testRunner_1 = __webpack_require__(/*! ./testRunner */ "../../../dist/libs/remix-tests/src/testRunner.js");

const web3_1 = tslib_1.__importDefault(__webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js"));

const remix_simulator_1 = __webpack_require__(/*! @remix-project/remix-simulator */ "../../../dist/libs/remix-simulator/src/index.js");

const createWeb3Provider = function () {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    const web3 = new web3_1.default();
    const provider = new remix_simulator_1.Provider();
    yield provider.init();
    web3.setProvider(provider);
    return web3;
  });
};
/**
 * @dev Run tests from source of a test contract file (used for IDE)
 * @param contractSources Sources of contract
 * @param compilerConfig current compiler configuration
 * @param testCallback Test callback
 * @param resultCallback Result Callback
 * @param finalCallback Final Callback
 * @param importFileCb Import file callback
 * @param opts Options
 */


function runTestSources(contractSources, compilerConfig, testCallback, resultCallback, finalCallback, importFileCb, opts) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    opts = opts || {};
    const sourceASTs = {};
    const web3 = opts.web3 || (yield createWeb3Provider());
    let accounts = opts.accounts || null;
    async_1.default.waterfall([function getAccountList(next) {
      if (accounts) return next();
      web3.eth.getAccounts((_err, _accounts) => {
        accounts = _accounts;
        next();
      });
    }, function compile(next) {
      compiler_1.compileContractSources(contractSources, compilerConfig, importFileCb, {
        accounts
      }, next);
    }, function deployAllContracts(compilationResult, asts, next) {
      for (const filename in asts) {
        if (filename.endsWith('_test.sol')) sourceASTs[filename] = asts[filename].ast;
      }

      deployer_1.deployAll(compilationResult, web3, false, (err, contracts) => {
        if (err) {
          // If contract deployment fails because of 'Out of Gas' error, try again with double gas
          // This is temporary, should be removed when remix-tests will have a dedicated UI to 
          // accept deployment params from UI
          if (err.message.includes('The contract code couldn\'t be stored, please check your gas limit')) {
            deployer_1.deployAll(compilationResult, web3, true, (error, contracts) => {
              if (error) next([{
                message: 'contract deployment failed after trying twice: ' + error.message,
                severity: 'error'
              }]); // IDE expects errors in array
              else next(null, compilationResult, contracts);
            });
          } else next([{
            message: 'contract deployment failed: ' + err.message,
            severity: 'error'
          }]); // IDE expects errors in array

        } else next(null, compilationResult, contracts);
      });
    }, function determineTestContractsToRun(compilationResult, contracts, next) {
      const contractsToTest = [];
      const contractsToTestDetails = [];

      for (const filename in compilationResult) {
        if (!filename.endsWith('_test.sol')) {
          continue;
        }

        Object.keys(compilationResult[filename]).forEach(contractName => {
          contractsToTestDetails.push(compilationResult[filename][contractName]);
          contractsToTest.push(contractName);
        });
      }

      next(null, contractsToTest, contractsToTestDetails, contracts);
    }, function runTests(contractsToTest, contractsToTestDetails, contracts, next) {
      let totalPassing = 0;
      let totalFailing = 0;
      let totalTime = 0;
      const errors = [];

      const _testCallback = function (err, result) {
        if (result.type === 'testFailure') {
          errors.push(result);
        }

        testCallback(result);
      };

      const _resultsCallback = function (_err, result, cb) {
        resultCallback(_err, result, () => {}); //eslint-disable-line @typescript-eslint/no-empty-function

        totalPassing += result.passingNum;
        totalFailing += result.failureNum;
        totalTime += result.timePassed;
        cb();
      };

      async_1.default.eachOfLimit(contractsToTest, 1, (contractName, index, cb) => {
        const fileAST = sourceASTs[contracts[contractName]['filename']];
        testRunner_1.runTest(contractName, contracts[contractName], contractsToTestDetails[index], fileAST, {
          accounts
        }, _testCallback, (err, result) => {
          if (err) {
            return cb(err);
          }

          _resultsCallback(null, result, cb);
        });
      }, function (err) {
        if (err) {
          return next(err);
        }

        const finalResults = {
          totalPassing: 0,
          totalFailing: 0,
          totalTime: 0,
          errors: []
        };
        finalResults.totalPassing = totalPassing || 0;
        finalResults.totalFailing = totalFailing || 0;
        finalResults.totalTime = totalTime || 0;
        finalResults.errors = [];
        errors.forEach((error, _index) => {
          finalResults.errors.push({
            context: error.context,
            value: error.value,
            message: error.errMsg
          });
        });
        next(null, finalResults);
      });
    }], finalCallback);
  });
}

exports.runTestSources = runTestSources;

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/testRunner.js":
/*!****************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/testRunner.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const async_1 = tslib_1.__importDefault(__webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js"));

const changeCase = tslib_1.__importStar(__webpack_require__(/*! change-case */ "../../../node_modules/change-case/dist.es2015/index.js"));

const web3_1 = tslib_1.__importDefault(__webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js"));

const assertionEvents_1 = tslib_1.__importDefault(__webpack_require__(/*! ./assertionEvents */ "../../../dist/libs/remix-tests/src/assertionEvents.js"));
/**
 * @dev Get function name using method signature
 * @param signature siganture
 * @param methodIdentifiers Object containing all methods identifier
 */


function getFunctionFullName(signature, methodIdentifiers) {
  for (const method in methodIdentifiers) {
    if (signature.replace('0x', '') === methodIdentifiers[method].replace('0x', '')) {
      return method;
    }
  }

  return null;
}
/**
 * @dev Check if function is constant using function ABI
 * @param funcABI function ABI
 */


function isConstant(funcABI) {
  return funcABI.constant || funcABI.stateMutability === 'view' || funcABI.stateMutability === 'pure';
}
/**
 * @dev Check if function is payable using function ABI
 * @param funcABI function ABI
 */


function isPayable(funcABI) {
  return funcABI.payable || funcABI.stateMutability === 'payable';
}
/**
 * @dev Check node name
 * @param node AST node
 * @param name name
 */


function isNodeName(node, name) {
  return node.name === name;
}
/**
 * @dev Check node type
 * @param node AST node
 * @param type type
 */


function isNodeType(node, type) {
  return node.nodeType === type;
}
/**
 * @dev Check if node type is from the typesList
 * @param node AST node to be checked
 * @param typesList list of types
 */


function isNodeTypeIn(node, typesList) {
  return typesList.includes(node.nodeType);
}
/**
 * @dev Get overrided sender provided using natspec
 * @param userdoc method user documentaion
 * @param signature signature
 * @param methodIdentifiers Object containing all methods identifier
 */


function getOverridedSender(userdoc, signature, methodIdentifiers) {
  const fullName = getFunctionFullName(signature, methodIdentifiers);
  const senderRegex = /#sender: account-+(\d)/g;
  const accountIndex = fullName && userdoc.methods[fullName] ? senderRegex.exec(userdoc.methods[fullName].notice) : null;
  return fullName && accountIndex ? accountIndex[1] : null;
}
/**
 * @dev Get value provided using natspec
 * @param userdoc method user documentaion
 * @param signature signature
 * @param methodIdentifiers Object containing all methods identifier
 */


function getProvidedValue(userdoc, signature, methodIdentifiers) {
  const fullName = getFunctionFullName(signature, methodIdentifiers);
  const valueRegex = /#value: (\d+)/g;
  const value = fullName && userdoc.methods[fullName] ? valueRegex.exec(userdoc.methods[fullName].notice) : null;
  return fullName && value ? value[1] : null;
}
/**
 * @dev returns functions of a test contract file in same sequence they appear in file (using passed AST)
 * @param fileAST AST of test contract file source
 * @param testContractName Name of test contract
 */


function getAvailableFunctions(fileAST, testContractName) {
  let funcList = [];

  if (fileAST.nodes && fileAST.nodes.length > 0) {
    const contractAST = fileAST.nodes.filter(node => isNodeName(node, testContractName) && isNodeType(node, 'ContractDefinition'));

    if (contractAST.length > 0 && contractAST[0].nodes) {
      const funcNodes = contractAST[0].nodes.filter(node => node.kind === "function" && isNodeType(node, 'FunctionDefinition') || isNodeType(node, 'FunctionDefinition'));
      funcList = funcNodes.map(node => node.name);
    }
  }

  return funcList;
}

function getAssertMethodLocation(fileAST, testContractName, functionName, assertMethod) {
  var _a, _b, _c;

  if ((_a = fileAST.nodes) === null || _a === void 0 ? void 0 : _a.length) {
    const contractAST = fileAST.nodes.find(node => isNodeName(node, testContractName) && isNodeType(node, 'ContractDefinition'));

    if ((_b = contractAST === null || contractAST === void 0 ? void 0 : contractAST.nodes) === null || _b === void 0 ? void 0 : _b.length) {
      const funcNode = contractAST.nodes.find(node => isNodeName(node, functionName) && isNodeType(node, 'FunctionDefinition')); // Check if statement nodeType is 'ExpressionStatement' or 'Return', for examples:
      // Assert.equal(foo.get(), 100, "initial value is not correct");
      // return Assert.equal(foo.get(), 100, "initial value is not correct");

      const expressions = funcNode.body.statements.filter(s => isNodeTypeIn(s, ['ExpressionStatement', 'Return']) && isNodeType(s.expression, 'FunctionCall'));
      const assetExpression = expressions.find(e => e.expression.expression && isNodeType(e.expression.expression, 'MemberAccess') && e.expression.expression.memberName === assertMethod && isNodeName(e.expression.expression.expression, 'Assert'));
      return (_c = assetExpression === null || assetExpression === void 0 ? void 0 : assetExpression.expression) === null || _c === void 0 ? void 0 : _c.src;
    }
  }
}
/**
 * @dev returns ABI of passed method list from passed interface
 * @param jsonInterface Json Interface
 * @param funcList Methods to extract the interface of
 */


function getTestFunctionsInterface(jsonInterface, funcList) {
  const functionsInterface = [];
  const specialFunctions = ['beforeAll', 'beforeEach', 'afterAll', 'afterEach'];

  for (const func of funcList) {
    if (!specialFunctions.includes(func)) {
      const funcInterface = jsonInterface.find(node => node.type === 'function' && node.name === func);
      if (funcInterface) functionsInterface.push(funcInterface);
    }
  }

  return functionsInterface;
}
/**
 * @dev returns ABI of special functions from passed interface
 * @param jsonInterface Json Interface
 */


function getSpecialFunctionsInterface(jsonInterface) {
  const specialFunctionsInterface = {};
  const funcList = ['beforeAll', 'beforeEach', 'afterAll', 'afterEach'];

  for (const func of funcList) {
    const funcInterface = jsonInterface.find(node => node.type === 'function' && node.name === func);

    if (funcInterface) {
      specialFunctionsInterface[func] = funcInterface;
    }
  }

  return specialFunctionsInterface;
}
/**
 * @dev Prepare a list of tests to run using test contract file ABI, AST & contract name
 * @param jsonInterface File JSON interface
 * @param fileAST File AST
 * @param testContractName Test contract name
 */


function createRunList(jsonInterface, fileAST, testContractName) {
  const availableFunctions = getAvailableFunctions(fileAST, testContractName);
  const testFunctionsInterface = getTestFunctionsInterface(jsonInterface, availableFunctions);
  const specialFunctionsInterface = getSpecialFunctionsInterface(jsonInterface);
  const runList = [];

  if (availableFunctions.includes('beforeAll')) {
    const func = specialFunctionsInterface['beforeAll'];
    runList.push({
      name: 'beforeAll',
      inputs: func.inputs,
      signature: func.signature,
      type: 'internal',
      constant: isConstant(func),
      payable: isPayable(func)
    });
  }

  for (const func of testFunctionsInterface) {
    if (availableFunctions.includes('beforeEach')) {
      const func = specialFunctionsInterface['beforeEach'];
      runList.push({
        name: 'beforeEach',
        inputs: func.inputs,
        signature: func.signature,
        type: 'internal',
        constant: isConstant(func),
        payable: isPayable(func)
      });
    }

    if (func.name && func.inputs) runList.push({
      name: func.name,
      inputs: func.inputs,
      signature: func.signature,
      type: 'test',
      constant: isConstant(func),
      payable: isPayable(func)
    });

    if (availableFunctions.indexOf('afterEach') >= 0) {
      const func = specialFunctionsInterface['afterEach'];
      runList.push({
        name: 'afterEach',
        inputs: func.inputs,
        signature: func.signature,
        type: 'internal',
        constant: isConstant(func),
        payable: isPayable(func)
      });
    }
  }

  if (availableFunctions.indexOf('afterAll') >= 0) {
    const func = specialFunctionsInterface['afterAll'];
    runList.push({
      name: 'afterAll',
      inputs: func.inputs,
      signature: func.signature,
      type: 'internal',
      constant: isConstant(func),
      payable: isPayable(func)
    });
  }

  return runList;
}

function runTest(testName, testObject, contractDetails, fileAST, opts, testCallback, resultsCallback) {
  let passingNum = 0;
  let failureNum = 0;
  let timePassed = 0;
  const isJSONInterfaceAvailable = testObject && testObject.options && testObject.options.jsonInterface;
  if (!isJSONInterfaceAvailable) return resultsCallback(new Error('Contract interface not available'), {
    passingNum,
    failureNum,
    timePassed
  });
  const runList = createRunList(testObject.options.jsonInterface, fileAST, testName);
  const web3 = new web3_1.default();
  const accts = {
    type: 'accountList',
    value: opts.accounts
  };
  testCallback(undefined, accts);
  const resp = {
    type: 'contract',
    value: testName,
    filename: testObject.filename
  };
  testCallback(undefined, resp);
  async_1.default.eachOfLimit(runList, 1, function (func, index, next) {
    let sender = null;

    if (func.signature) {
      sender = getOverridedSender(contractDetails.userdoc, func.signature, contractDetails.evm.methodIdentifiers);

      if (opts.accounts && sender) {
        sender = opts.accounts[sender];
      }
    }

    let sendParams = null;
    if (sender) sendParams = {
      from: sender
    };
    if (func.inputs && func.inputs.length > 0) return resultsCallback(new Error(`Method '${func.name}' can not have parameters inside a test contract`), {
      passingNum,
      failureNum,
      timePassed
    });
    const method = testObject.methods[func.name].apply(testObject.methods[func.name], []);
    const startTime = Date.now();

    if (func.constant) {
      method.call(sendParams).then(result => {
        const time = (Date.now() - startTime) / 1000.0;

        if (result) {
          const resp = {
            type: 'testPass',
            value: changeCase.sentenceCase(func.name),
            filename: testObject.filename,
            time: time,
            context: testName
          };
          testCallback(undefined, resp);
          passingNum += 1;
          timePassed += time;
        } else {
          const resp = {
            type: 'testFailure',
            value: changeCase.sentenceCase(func.name),
            filename: testObject.filename,
            time: time,
            errMsg: 'function returned false',
            context: testName
          };
          testCallback(undefined, resp);
          failureNum += 1;
          timePassed += time;
        }

        next();
      });
    } else {
      if (func.payable) {
        const value = getProvidedValue(contractDetails.userdoc, func.signature, contractDetails.evm.methodIdentifiers);

        if (value) {
          if (sendParams) sendParams.value = value;else sendParams = {
            value
          };
        }
      }

      method.send(sendParams).on('receipt', receipt => {
        try {
          const time = (Date.now() - startTime) / 1000.0;
          const assertionEventHashes = assertionEvents_1.default.map(e => web3_1.default.utils.sha3(e.name + '(' + e.params.join() + ')'));
          let testPassed = false;

          for (const i in receipt.events) {
            let events = receipt.events[i];
            if (!Array.isArray(events)) events = [events];

            for (const event of events) {
              const eIndex = assertionEventHashes.indexOf(event.raw.topics[0]); // event name topic will always be at index 0

              if (eIndex >= 0) {
                const testEvent = web3.eth.abi.decodeParameters(assertionEvents_1.default[eIndex].params, event.raw.data);

                if (!testEvent[0]) {
                  const assertMethod = testEvent[2];

                  if (assertMethod === 'ok') {
                    // for 'Assert.ok' method
                    testEvent[3] = 'false';
                    testEvent[4] = 'true';
                  }

                  const location = getAssertMethodLocation(fileAST, testName, func.name, assertMethod);
                  const resp = {
                    type: 'testFailure',
                    value: changeCase.sentenceCase(func.name),
                    filename: testObject.filename,
                    time: time,
                    errMsg: testEvent[1],
                    context: testName,
                    assertMethod,
                    returned: testEvent[3],
                    expected: testEvent[4],
                    location
                  };
                  testCallback(undefined, resp);
                  failureNum += 1;
                  timePassed += time;
                  return next();
                }

                testPassed = true;
              }
            }
          }

          if (testPassed) {
            const resp = {
              type: 'testPass',
              value: changeCase.sentenceCase(func.name),
              filename: testObject.filename,
              time: time,
              context: testName
            };
            testCallback(undefined, resp);
            passingNum += 1;
            timePassed += time;
          }

          return next();
        } catch (err) {
          console.error(err);
          return next(err);
        }
      }).on('error', function (err) {
        const time = (Date.now() - startTime) / 1000.0;
        const resp = {
          type: 'testFailure',
          value: changeCase.sentenceCase(func.name),
          filename: testObject.filename,
          time: time,
          errMsg: err.message,
          context: testName
        };
        testCallback(undefined, resp);
        failureNum += 1;
        timePassed += time;
        return next();
      });
    }
  }, function (error) {
    resultsCallback(error, {
      passingNum,
      failureNum,
      timePassed
    });
  });
}

exports.runTest = runTest;

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/types.js":
/*!***********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/types.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class CompilationErrors extends Error {
  constructor(errors) {
    const mapError = errors.map(e => {
      return e.formattedMessage || e.message;
    });
    super(mapError.join('\n'));
    this.errors = errors;
    this.name = 'CompilationErrors';
  }

}

exports.CompilationErrors = CompilationErrors;

/***/ }),

/***/ "../../../dist/libs/remix-url-resolver/index.js":
/*!**************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-url-resolver/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var resolve_1 = __webpack_require__(/*! ./resolve */ "../../../dist/libs/remix-url-resolver/resolve.js");

exports.RemixURLResolver = resolve_1.RemixURLResolver;

/***/ }),

/***/ "../../../dist/libs/remix-url-resolver/resolve.js":
/*!****************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-url-resolver/resolve.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const axios_1 = tslib_1.__importDefault(__webpack_require__(/*! axios */ "../../../node_modules/axios/index.js"));

const bzz_node_1 = __webpack_require__(/*! @erebos/bzz-node */ "../../../node_modules/@erebos/bzz-node/lib/index.js");

class RemixURLResolver {
  constructor(gistToken, protocol = 'http:') {
    this.previouslyHandled = {};
    this.gistAccessToken = gistToken ? gistToken : '';
    this.protocol = protocol;
  }
  /**
  * Handle an import statement based on github
  * @param root The root of the github import statement
  * @param filePath path of the file in github
  */


  handleGithubCall(root, filePath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      let param = '?';
      param += this.gistAccessToken ? 'access_token=' + this.gistAccessToken : '';
      const regex = filePath.match(/blob\/([^/]+)\/(.*)/);
      let reference = 'master';

      if (regex) {
        // if we have /blob/master/+path we extract the branch name "master" and add it as a parameter to the github api
        // the ref can be branch name, tag, commit id
        reference = regex[1];
        param += '&ref=' + reference;
        filePath = filePath.replace(`blob/${reference}/`, '');
      } //eslint-disable-next-line no-useless-catch


      try {
        const req = `https://raw.githubusercontent.com/${root}/${reference}/${filePath}`;
        const response = yield axios_1.default.get(req);
        return {
          content: response.data,
          cleanUrl: root + '/' + filePath
        };
      } catch (e) {
        throw e;
      }
    });
  }
  /**
  * Handle an import statement based on http
  * @param url The url of the import statement
  * @param cleanUrl
  */


  handleHttp(url, cleanUrl) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      //eslint-disable-next-line no-useless-catch
      try {
        const response = yield axios_1.default.get(url);
        return {
          content: response.data,
          cleanUrl
        };
      } catch (e) {
        throw e;
      }
    });
  }
  /**
  * Handle an import statement based on https
  * @param url The url of the import statement
  * @param cleanUrl
  */


  handleHttps(url, cleanUrl) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      //eslint-disable-next-line no-useless-catch
      try {
        const response = yield axios_1.default.get(url);
        return {
          content: response.data,
          cleanUrl
        };
      } catch (e) {
        throw e;
      }
    });
  }

  handleSwarm(url, cleanUrl) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      //eslint-disable-next-line no-useless-catch
      try {
        const bzz = new bzz_node_1.BzzNode({
          url: this.protocol + '//swarm-gateways.net'
        });
        const url = bzz.getDownloadURL(cleanUrl, {
          mode: 'raw'
        });
        const response = yield axios_1.default.get(url);
        return {
          content: response.data,
          cleanUrl
        };
      } catch (e) {
        throw e;
      }
    });
  }
  /**
  * Handle an import statement based on IPFS
  * @param url The url of the IPFS import statement
  */


  handleIPFS(url) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      // replace ipfs:// with /ipfs/
      url = url.replace(/^ipfs:\/\/?/, 'ipfs/'); //eslint-disable-next-line no-useless-catch

      try {
        const req = 'https://ipfsgw.komputing.org/' + url; // If you don't find greeter.sol on ipfs gateway use local
        // const req = 'http://localhost:8080/' + url

        const response = yield axios_1.default.get(req);
        return {
          content: response.data,
          cleanUrl: url
        };
      } catch (e) {
        throw e;
      }
    });
  }

  getHandlers() {
    return [{
      type: 'github',
      match: url => {
        return /^(https?:\/\/)?(www.)?github.com\/([^/]*\/[^/]*)\/(.*)/.exec(url);
      },
      handle: match => this.handleGithubCall(match[3], match[4])
    }, {
      type: 'http',
      match: url => {
        return /^(http?:\/\/?(.*))$/.exec(url);
      },
      handle: match => this.handleHttp(match[1], match[2])
    }, {
      type: 'https',
      match: url => {
        return /^(https?:\/\/?(.*))$/.exec(url);
      },
      handle: match => this.handleHttps(match[1], match[2])
    }, {
      type: 'swarm',
      match: url => {
        return /^(bzz-raw?:\/\/?(.*))$/.exec(url);
      },
      handle: match => this.handleSwarm(match[1], match[2])
    }, {
      type: 'ipfs',
      match: url => {
        return /^(ipfs:\/\/?.+)/.exec(url);
      },
      handle: match => this.handleIPFS(match[1])
    }];
  }

  resolve(filePath, customHandlers) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      let imported = this.previouslyHandled[filePath];

      if (imported) {
        return imported;
      }

      const builtinHandlers = this.getHandlers();
      const handlers = customHandlers ? [...builtinHandlers, ...customHandlers] : [...builtinHandlers];
      const matchedHandler = handlers.filter(handler => handler.match(filePath));
      const handler = matchedHandler[0];
      const match = handler.match(filePath);
      const {
        content,
        cleanUrl
      } = yield handler.handle(match);
      imported = {
        content,
        cleanUrl: cleanUrl ? cleanUrl : filePath,
        type: handler.type
      };
      this.previouslyHandled[filePath] = imported;
      return imported;
    });
  }

}

exports.RemixURLResolver = RemixURLResolver;

/***/ }),

/***/ "../../../libs/remix-ui/clipboard/src/index.ts":
/*!*************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/clipboard/src/index.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _copyToClipboard = __webpack_require__(/*! ./lib/copy-to-clipboard/copy-to-clipboard */ "../../../libs/remix-ui/clipboard/src/lib/copy-to-clipboard/copy-to-clipboard.tsx");

Object.keys(_copyToClipboard).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _copyToClipboard[key];
    }
  });
});

/***/ }),

/***/ "../../../libs/remix-ui/clipboard/src/lib/copy-to-clipboard/copy-to-clipboard.css":
/*!************************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/clipboard/src/lib/copy-to-clipboard/copy-to-clipboard.css ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../../../../../node_modules/postcss-loader/src??embedded!./copy-to-clipboard.css */ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/clipboard/src/lib/copy-to-clipboard/copy-to-clipboard.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "../../../libs/remix-ui/clipboard/src/lib/copy-to-clipboard/copy-to-clipboard.tsx":
/*!************************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/clipboard/src/lib/copy-to-clipboard/copy-to-clipboard.tsx ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CopyToClipboard = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _copyTextToClipboard = _interopRequireDefault(__webpack_require__(/*! copy-text-to-clipboard */ "../../../node_modules/copy-text-to-clipboard/index.js"));

var _reactBootstrap = __webpack_require__(/*! react-bootstrap */ "../../../node_modules/react-bootstrap/esm/index.js");

__webpack_require__(/*! ./copy-to-clipboard.css */ "../../../libs/remix-ui/clipboard/src/lib/copy-to-clipboard/copy-to-clipboard.css");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const CopyToClipboard = ({
  content,
  tip = 'Copy',
  icon = 'fa-copy',
  ...otherProps
}) => {
  const [message, setMessage] = (0, _react.useState)(tip);

  const handleClick = () => {
    if (content && content !== '') {
      // module `copy` keeps last copied thing in the memory, so don't show tooltip if nothing is copied, because nothing was added to memory
      try {
        if (typeof content !== 'string') {
          content = JSON.stringify(content, null, '\t');
        }
      } catch (e) {
        console.error(e);
      }

      (0, _copyTextToClipboard.default)(content);
      setMessage('Copied');
    } else {
      setMessage('Cannot copy empty content!');
    }
  };

  const reset = () => {
    setTimeout(() => setMessage('Copy'), 500);
  };

  return /*#__PURE__*/_react.default.createElement("a", {
    href: "#",
    onClick: handleClick,
    onMouseLeave: reset
  }, /*#__PURE__*/_react.default.createElement(_reactBootstrap.OverlayTrigger, {
    placement: "right",
    overlay: /*#__PURE__*/_react.default.createElement(_reactBootstrap.Tooltip, {
      id: "overlay-tooltip"
    }, message)
  }, /*#__PURE__*/_react.default.createElement("i", Object.assign({
    className: `far ${icon} ml-1 p-2`,
    "aria-hidden": "true"
  }, otherProps))));
};

exports.CopyToClipboard = CopyToClipboard;
var _default = CopyToClipboard;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/index.ts":
/*!***************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/index.ts ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debuggerUi = __webpack_require__(/*! ./lib/debugger-ui */ "../../../libs/remix-ui/debugger-ui/src/lib/debugger-ui.tsx");

Object.keys(_debuggerUi).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _debuggerUi[key];
    }
  });
});

var _idebuggerApi = __webpack_require__(/*! ./lib/idebugger-api */ "../../../libs/remix-ui/debugger-ui/src/lib/idebugger-api.ts");

Object.keys(_idebuggerApi).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _idebuggerApi[key];
    }
  });
});

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/button-navigator/button-navigator.css":
/*!************************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/button-navigator/button-navigator.css ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../../../../../node_modules/postcss-loader/src??embedded!./button-navigator.css */ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/debugger-ui/src/lib/button-navigator/button-navigator.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/button-navigator/button-navigator.tsx":
/*!************************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/button-navigator/button-navigator.tsx ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ButtonNavigation = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

__webpack_require__(/*! ./button-navigator.css */ "../../../libs/remix-ui/debugger-ui/src/lib/button-navigator/button-navigator.css");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
const ButtonNavigation = ({
  stepOverBack,
  stepIntoBack,
  stepIntoForward,
  stepOverForward,
  jumpOut,
  jumpPreviousBreakpoint,
  jumpNextBreakpoint,
  jumpToException,
  revertedReason,
  stepState,
  jumpOutDisabled
}) => {
  const [state, setState] = (0, _react.useState)({
    intoBackDisabled: true,
    overBackDisabled: true,
    intoForwardDisabled: true,
    overForwardDisabled: true,
    jumpOutDisabled: true,
    jumpNextBreakpointDisabled: true,
    jumpPreviousBreakpointDisabled: true
  });
  (0, _react.useEffect)(() => {
    stepChanged(stepState, jumpOutDisabled);
  }, [stepState, jumpOutDisabled]);

  const reset = () => {
    setState(() => {
      return {
        intoBackDisabled: true,
        overBackDisabled: true,
        intoForwardDisabled: true,
        overForwardDisabled: true,
        jumpOutDisabled: true,
        jumpNextBreakpointDisabled: true,
        jumpPreviousBreakpointDisabled: true
      };
    });
  };

  const stepChanged = (stepState, jumpOutDisabled) => {
    if (stepState === 'invalid') {
      // TODO: probably not necessary, already implicit done in the next steps
      reset();
      return;
    }

    setState(() => {
      return {
        intoBackDisabled: stepState === 'initial',
        overBackDisabled: stepState === 'initial',
        jumpPreviousBreakpointDisabled: stepState === 'initial',
        intoForwardDisabled: stepState === 'end',
        overForwardDisabled: stepState === 'end',
        jumpNextBreakpointDisabled: stepState === 'end',
        jumpOutDisabled: jumpOutDisabled || true
      };
    });
  };

  return /*#__PURE__*/_react.default.createElement("div", {
    className: "buttons"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "stepButtons btn-group py-1"
  }, /*#__PURE__*/_react.default.createElement("button", {
    id: "overback",
    className: "btn btn-primary btn-sm navigator stepButton fas fa-reply",
    title: "Step over back",
    onClick: () => {
      stepOverBack && stepOverBack();
    },
    disabled: state.overBackDisabled
  }), /*#__PURE__*/_react.default.createElement("button", {
    id: "intoback",
    "data-id": "buttonNavigatorIntoBack",
    className: "btn btn-primary btn-sm navigator stepButton fas fa-level-up-alt",
    title: "Step back",
    onClick: () => {
      stepIntoBack && stepIntoBack();
    },
    disabled: state.intoBackDisabled
  }), /*#__PURE__*/_react.default.createElement("button", {
    id: "intoforward",
    "data-id": "buttonNavigatorIntoForward",
    className: "btn btn-primary btn-sm navigator stepButton fas fa-level-down-alt",
    title: "Step into",
    onClick: () => {
      stepIntoForward && stepIntoForward();
    },
    disabled: state.intoForwardDisabled
  }), /*#__PURE__*/_react.default.createElement("button", {
    id: "overforward",
    className: "btn btn-primary btn-sm navigator stepButton fas fa-share",
    title: "Step over forward",
    onClick: () => {
      stepOverForward && stepOverForward();
    },
    disabled: state.overForwardDisabled
  })), /*#__PURE__*/_react.default.createElement("div", {
    className: "jumpButtons btn-group py-1"
  }, /*#__PURE__*/_react.default.createElement("button", {
    className: "btn btn-primary btn-sm navigator jumpButton fas fa-step-backward",
    id: "jumppreviousbreakpoint",
    "data-id": "buttonNavigatorJumpPreviousBreakpoint",
    title: "Jump to the previous breakpoint",
    onClick: () => {
      jumpPreviousBreakpoint && jumpPreviousBreakpoint();
    },
    disabled: state.jumpPreviousBreakpointDisabled
  }), /*#__PURE__*/_react.default.createElement("button", {
    className: "btn btn-primary btn-sm navigator jumpButton fas fa-eject",
    id: "jumpout",
    title: "Jump out",
    onClick: () => {
      jumpOut && jumpOut();
    },
    disabled: state.jumpOutDisabled
  }), /*#__PURE__*/_react.default.createElement("button", {
    className: "btn btn-primary btn-sm navigator jumpButton fas fa-step-forward",
    id: "jumpnextbreakpoint",
    "data-id": "buttonNavigatorJumpNextBreakpoint",
    title: "Jump to the next breakpoint",
    onClick: () => {
      jumpNextBreakpoint && jumpNextBreakpoint();
    },
    disabled: state.jumpNextBreakpointDisabled
  })), /*#__PURE__*/_react.default.createElement("div", {
    id: "reverted",
    style: {
      display: revertedReason === '' ? 'none' : 'block'
    }
  }, /*#__PURE__*/_react.default.createElement("button", {
    id: "jumptoexception",
    title: "Jump to exception",
    className: "btn btn-danger btn-sm navigator button fas fa-exclamation-triangle",
    onClick: () => {
      jumpToException && jumpToException();
    },
    disabled: state.jumpOutDisabled
  }), /*#__PURE__*/_react.default.createElement("span", null, "State changes made during this call will be reverted."), /*#__PURE__*/_react.default.createElement("span", {
    id: "outofgas",
    style: {
      display: revertedReason === 'outofgas' ? 'inline' : 'none'
    }
  }, "This call will run out of gas."), /*#__PURE__*/_react.default.createElement("span", {
    id: "parenthasthrown",
    style: {
      display: revertedReason === 'parenthasthrown' ? 'inline' : 'none'
    }
  }, "The parent call will throw an exception")));
};

exports.ButtonNavigation = ButtonNavigation;
var _default = ButtonNavigation;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/debugger-ui.css":
/*!**************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/debugger-ui.css ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../../../../node_modules/postcss-loader/src??embedded!./debugger-ui.css */ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/debugger-ui/src/lib/debugger-ui.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/debugger-ui.tsx":
/*!**************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/debugger-ui.tsx ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DebuggerUI = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _txBrowser = _interopRequireDefault(__webpack_require__(/*! ./tx-browser/tx-browser */ "../../../libs/remix-ui/debugger-ui/src/lib/tx-browser/tx-browser.tsx"));

var _stepManager = _interopRequireDefault(__webpack_require__(/*! ./step-manager/step-manager */ "../../../libs/remix-ui/debugger-ui/src/lib/step-manager/step-manager.tsx"));

var _vmDebugger = _interopRequireDefault(__webpack_require__(/*! ./vm-debugger/vm-debugger */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/vm-debugger.tsx"));

var _vmDebuggerHead = _interopRequireDefault(__webpack_require__(/*! ./vm-debugger/vm-debugger-head */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/vm-debugger-head.tsx"));

var _remixDebug = __webpack_require__(/*! @remix-project/remix-debug */ "../../../dist/libs/remix-debug/src/index.js");

var _toaster = __webpack_require__(/*! @remix-ui/toaster */ "../../../libs/remix-ui/toaster/src/index.ts");

__webpack_require__(/*! ./debugger-ui.css */ "../../../libs/remix-ui/debugger-ui/src/lib/debugger-ui.css");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line

/* eslint-disable-next-line */
const helper = __webpack_require__(/*! ../../../../../apps/remix-ide/src/lib/helper */ "./lib/helper.js");

const DebuggerUI = props => {
  const debuggerModule = props.debuggerAPI;
  const [state, setState] = (0, _react.useState)({
    isActive: false,
    statusMessage: '',
    debugger: null,
    currentReceipt: {
      contractAddress: null,
      to: null
    },
    blockNumber: null,
    txNumber: '',
    debugging: false,
    opt: {
      debugWithGeneratedSources: false
    },
    toastMessage: '',
    validationError: '',
    txNumberIsEmpty: true
  });
  (0, _react.useEffect)(() => {
    return unLoad();
  }, []);
  debuggerModule.onDebugRequested(hash => {
    if (hash) debug(hash);
  });
  debuggerModule.onRemoveHighlights(async () => {
    await debuggerModule.discardHighlight();
  });
  (0, _react.useEffect)(() => {
    const setEditor = () => {
      debuggerModule.onBreakpointCleared((fileName, row) => {
        if (state.debugger) state.debugger.breakPointManager.remove({
          fileName: fileName,
          row: row
        });
      });
      debuggerModule.onBreakpointAdded((fileName, row) => {
        if (state.debugger) state.debugger.breakPointManager.add({
          fileName: fileName,
          row: row
        });
      });
      debuggerModule.onEditorContentChanged(() => {
        if (state.debugger) unLoad();
      });
    };

    setEditor();
  }, [state.debugger]);

  const listenToEvents = (debuggerInstance, currentReceipt) => {
    if (!debuggerInstance) return;
    debuggerInstance.event.register('debuggerStatus', async isActive => {
      await debuggerModule.discardHighlight();
      setState(prevState => {
        return { ...prevState,
          isActive
        };
      });
    });
    debuggerInstance.event.register('newSourceLocation', async (lineColumnPos, rawLocation, generatedSources, address) => {
      if (!lineColumnPos) return;
      const contracts = await debuggerModule.fetchContractAndCompile(address || currentReceipt.contractAddress || currentReceipt.to, currentReceipt);

      if (contracts) {
        let path = contracts.getSourceName(rawLocation.file);

        if (!path) {
          // check in generated sources
          for (const source of generatedSources) {
            if (source.id === rawLocation.file) {
              path = `browser/.debugger/generated-sources/${source.name}`;
              let content;

              try {
                content = await debuggerModule.getFile(path);
              } catch (e) {
                const message = 'Unable to fetch generated sources, the file probably doesn\'t exist yet.';
                console.log(message, ' ', e);
              }

              if (content !== source.contents) {
                await debuggerModule.setFile(path, source.contents);
              }

              break;
            }
          }
        }

        if (path) {
          await debuggerModule.discardHighlight();
          await debuggerModule.highlight(lineColumnPos, path);
        }
      }
    });
    debuggerInstance.event.register('debuggerUnloaded', () => unLoad());
  };

  const requestDebug = (blockNumber, txNumber, tx) => {
    startDebugging(blockNumber, txNumber, tx);
  };

  const updateTxNumberFlag = empty => {
    setState(prevState => {
      return { ...prevState,
        txNumberIsEmpty: empty,
        validationError: ''
      };
    });
  };

  const unloadRequested = (blockNumber, txIndex, tx) => {
    unLoad();
  };

  const unLoad = () => {
    if (state.debugger) state.debugger.unload();
    setState(prevState => {
      return { ...prevState,
        isActive: false,
        statusMessage: '',
        debugger: null,
        currentReceipt: {
          contractAddress: null,
          to: null
        },
        blockNumber: null,
        ready: {
          vmDebugger: false,
          vmDebuggerHead: false
        },
        debugging: false
      };
    });
  };

  const startDebugging = async (blockNumber, txNumber, tx) => {
    if (state.debugger) unLoad();
    if (!txNumber) return;
    setState(prevState => {
      return { ...prevState,
        txNumber: txNumber
      };
    });

    if (!helper.isValidHash(txNumber)) {
      setState(prevState => {
        return { ...prevState,
          validationError: 'Invalid transaction hash.'
        };
      });
      return;
    }

    const web3 = await debuggerModule.getDebugWeb3();
    let currentReceipt;

    try {
      currentReceipt = await web3.eth.getTransactionReceipt(txNumber);
    } catch (e) {
      setState(prevState => {
        return { ...prevState,
          validationError: e.message
        };
      });
      console.log(e.message);
    }

    const debuggerInstance = new _remixDebug.TransactionDebugger({
      web3,
      offsetToLineColumnConverter: debuggerModule.offsetToLineColumnConverter,
      compilationResult: async address => {
        try {
          const ret = await debuggerModule.fetchContractAndCompile(address, currentReceipt);
          return ret;
        } catch (e) {
          debuggerModule.showMessage('Debugging error', 'Unable to fetch a transaction.');
          console.error(e);
        }

        return null;
      },
      debugWithGeneratedSources: state.opt.debugWithGeneratedSources
    });
    debuggerInstance.debug(blockNumber, txNumber, tx, () => {
      listenToEvents(debuggerInstance, currentReceipt);
      setState(prevState => {
        return { ...prevState,
          blockNumber,
          txNumber,
          debugging: true,
          currentReceipt,
          debugger: debuggerInstance,
          toastMessage: `debugging ${txNumber}`,
          validationError: ''
        };
      });
    }).catch(error => {
      if (JSON.stringify(error) !== '{}') {
        let message = 'Error: ' + JSON.stringify(error);
        message = message.split('\\"').join('\'');
        setState(prevState => {
          return { ...prevState,
            validationError: message
          };
        });
      }

      unLoad();
    });
  };

  const debug = txHash => {
    setState(prevState => {
      return { ...prevState,
        validationError: '',
        txNumber: txHash
      };
    });
    startDebugging(null, txHash, null);
  };

  const stepManager = {
    jumpTo: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.jumpTo.bind(state.debugger.step_manager) : null,
    stepOverBack: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.stepOverBack.bind(state.debugger.step_manager) : null,
    stepIntoBack: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.stepIntoBack.bind(state.debugger.step_manager) : null,
    stepIntoForward: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.stepIntoForward.bind(state.debugger.step_manager) : null,
    stepOverForward: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.stepOverForward.bind(state.debugger.step_manager) : null,
    jumpOut: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.jumpOut.bind(state.debugger.step_manager) : null,
    jumpPreviousBreakpoint: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.jumpPreviousBreakpoint.bind(state.debugger.step_manager) : null,
    jumpNextBreakpoint: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.jumpNextBreakpoint.bind(state.debugger.step_manager) : null,
    jumpToException: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.jumpToException.bind(state.debugger.step_manager) : null,
    traceLength: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.traceLength : null,
    registerEvent: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.event.register.bind(state.debugger.step_manager.event) : null
  };
  const vmDebugger = {
    registerEvent: state.debugger && state.debugger.vmDebuggerLogic ? state.debugger.vmDebuggerLogic.event.register.bind(state.debugger.vmDebuggerLogic.event) : null,
    triggerEvent: state.debugger && state.debugger.vmDebuggerLogic ? state.debugger.vmDebuggerLogic.event.trigger.bind(state.debugger.vmDebuggerLogic.event) : null
  };
  return /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement(_toaster.Toaster, {
    message: state.toastMessage
  }), /*#__PURE__*/_react.default.createElement("div", {
    className: "px-2"
  }, /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("p", {
    className: "my-2 debuggerLabel"
  }, "Debugger Configuration"), /*#__PURE__*/_react.default.createElement("div", {
    className: "mt-2 debuggerConfig custom-control custom-checkbox"
  }, /*#__PURE__*/_react.default.createElement("input", {
    className: "custom-control-input",
    id: "debugGeneratedSourcesInput",
    onChange: ({
      target: {
        checked
      }
    }) => {
      setState(prevState => {
        return { ...prevState,
          opt: {
            debugWithGeneratedSources: checked
          }
        };
      });
    },
    type: "checkbox",
    title: "Debug with generated sources"
  }), /*#__PURE__*/_react.default.createElement("label", {
    "data-id": "debugGeneratedSourcesLabel",
    className: "form-check-label custom-control-label",
    htmlFor: "debugGeneratedSourcesInput"
  }, "Use generated sources (from Solidity v0.7.2)")), state.validationError && !state.txNumberIsEmpty && /*#__PURE__*/_react.default.createElement("span", {
    className: "w-100 py-1 text-danger validationError"
  }, state.validationError)), /*#__PURE__*/_react.default.createElement(_txBrowser.default, {
    requestDebug: requestDebug,
    unloadRequested: unloadRequested,
    updateTxNumberFlag: updateTxNumberFlag,
    transactionNumber: state.txNumber,
    debugging: state.debugging
  }), state.debugging && /*#__PURE__*/_react.default.createElement(_stepManager.default, {
    stepManager: stepManager
  }), state.debugging && /*#__PURE__*/_react.default.createElement(_vmDebuggerHead.default, {
    vmDebugger: vmDebugger
  })), state.debugging && /*#__PURE__*/_react.default.createElement("div", {
    className: "statusMessage"
  }, state.statusMessage), state.debugging && /*#__PURE__*/_react.default.createElement(_vmDebugger.default, {
    vmDebugger: vmDebugger
  }));
};

exports.DebuggerUI = DebuggerUI;
var _default = DebuggerUI;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/idebugger-api.ts":
/*!***************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/idebugger-api.ts ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/slider/slider.tsx":
/*!****************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/slider/slider.tsx ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Slider = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
const Slider = ({
  jumpTo,
  sliderValue,
  traceLength
}) => {
  const [state, setState] = (0, _react.useState)({
    currentValue: 0
  });
  (0, _react.useEffect)(() => {
    setValue(sliderValue);
  }, [sliderValue]);

  const setValue = value => {
    if (value === state.currentValue) return;
    setState(prevState => {
      return { ...prevState,
        currentValue: value
      };
    });
    jumpTo && jumpTo(value);
  };

  const handleChange = e => {
    const value = parseInt(e.target.value);
    setValue(value);
  };

  return /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("input", {
    id: "slider",
    "data-id": "slider",
    className: "w-100 my-0",
    type: "range",
    min: 0,
    max: traceLength ? traceLength - 1 : 0,
    value: state.currentValue,
    onChange: handleChange,
    disabled: traceLength ? traceLength === 0 : true
  }));
};

exports.Slider = Slider;
var _default = Slider;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/step-manager/step-manager.tsx":
/*!****************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/step-manager/step-manager.tsx ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.StepManager = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _slider = _interopRequireDefault(__webpack_require__(/*! ../slider/slider */ "../../../libs/remix-ui/debugger-ui/src/lib/slider/slider.tsx"));

var _buttonNavigator = _interopRequireDefault(__webpack_require__(/*! ../button-navigator/button-navigator */ "../../../libs/remix-ui/debugger-ui/src/lib/button-navigator/button-navigator.tsx"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const StepManager = ({
  stepManager: {
    jumpTo,
    traceLength,
    stepIntoBack,
    stepIntoForward,
    stepOverBack,
    stepOverForward,
    jumpOut,
    jumpNextBreakpoint,
    jumpPreviousBreakpoint,
    jumpToException,
    registerEvent
  }
}) => {
  const [state, setState] = (0, _react.useState)({
    sliderValue: 0,
    revertWarning: '',
    stepState: '',
    jumpOutDisabled: true
  });
  (0, _react.useEffect)(() => {
    registerEvent && registerEvent('revertWarning', setRevertWarning);
    registerEvent && registerEvent('stepChanged', updateStep);
  }, [registerEvent]);

  const setRevertWarning = warning => {
    setState(prevState => {
      return { ...prevState,
        revertWarning: warning
      };
    });
  };

  const updateStep = (step, stepState, jumpOutDisabled) => {
    setState(prevState => {
      return { ...prevState,
        sliderValue: step,
        stepState,
        jumpOutDisabled
      };
    });
  };

  const {
    sliderValue,
    revertWarning,
    stepState,
    jumpOutDisabled
  } = state;
  return /*#__PURE__*/_react.default.createElement("div", {
    className: "py-1"
  }, /*#__PURE__*/_react.default.createElement(_slider.default, {
    jumpTo: jumpTo,
    sliderValue: sliderValue,
    traceLength: traceLength
  }), /*#__PURE__*/_react.default.createElement(_buttonNavigator.default, {
    stepIntoBack: stepIntoBack,
    stepIntoForward: stepIntoForward,
    stepOverBack: stepOverBack,
    stepOverForward: stepOverForward,
    revertedReason: revertWarning,
    stepState: stepState,
    jumpOutDisabled: jumpOutDisabled,
    jumpOut: jumpOut,
    jumpNextBreakpoint: jumpNextBreakpoint,
    jumpPreviousBreakpoint: jumpPreviousBreakpoint,
    jumpToException: jumpToException
  }));
};

exports.StepManager = StepManager;
var _default = StepManager;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/tx-browser/tx-browser.css":
/*!************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/tx-browser/tx-browser.css ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../../../../../node_modules/postcss-loader/src??embedded!./tx-browser.css */ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/debugger-ui/src/lib/tx-browser/tx-browser.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/tx-browser/tx-browser.tsx":
/*!************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/tx-browser/tx-browser.tsx ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TxBrowser = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

__webpack_require__(/*! ./tx-browser.css */ "../../../libs/remix-ui/debugger-ui/src/lib/tx-browser/tx-browser.css");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

//eslint-disable-line
const TxBrowser = ({
  requestDebug,
  updateTxNumberFlag,
  unloadRequested,
  transactionNumber,
  debugging
}) => {
  const [state, setState] = (0, _react.useState)({
    txNumber: ''
  });
  const inputValue = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    setState(prevState => {
      return { ...prevState,
        txNumber: transactionNumber
      };
    });
  }, [transactionNumber]);

  const handleSubmit = () => {
    if (debugging) {
      unload();
    } else {
      requestDebug(undefined, state.txNumber);
    }
  };

  const unload = () => {
    unloadRequested();
  };

  const txInputChanged = value => {
    // todo check validation of txnumber in the input element, use
    // required
    // oninvalid="setCustomValidity('Please provide a valid transaction number, must start with 0x and have length of 22')"
    // pattern="^0[x,X]+[0-9a-fA-F]{22}"
    // this.state.txNumberInput.setCustomValidity('')
    setState(prevState => {
      return { ...prevState,
        txNumber: value
      };
    });
  };

  const txInputOnInput = () => {
    updateTxNumberFlag(!inputValue.current.value);
  };

  return /*#__PURE__*/_react.default.createElement("div", {
    className: "container px-0"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "txContainer"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "py-1 d-flex justify-content-center w-100 input-group"
  }, /*#__PURE__*/_react.default.createElement("input", {
    ref: inputValue,
    value: state.txNumber,
    className: "form-control m-0 txinput",
    id: "txinput",
    type: "text",
    onChange: ({
      target: {
        value
      }
    }) => txInputChanged(value),
    onInput: txInputOnInput,
    placeholder: 'Transaction hash, should start with 0x',
    "data-id": "debuggerTransactionInput",
    disabled: debugging
  })), /*#__PURE__*/_react.default.createElement("div", {
    className: "d-flex justify-content-center w-100 btn-group py-1"
  }, /*#__PURE__*/_react.default.createElement("button", {
    className: "btn btn-primary btn-sm txbutton",
    id: "load",
    title: debugging ? 'Stop debugging' : 'Start debugging',
    onClick: handleSubmit,
    "data-id": "debuggerTransactionStartButton",
    disabled: !state.txNumber
  }, debugging ? 'Stop' : 'Start', " debugging"))), /*#__PURE__*/_react.default.createElement("span", {
    id: "error"
  }));
};

exports.TxBrowser = TxBrowser;
var _default = TxBrowser;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/assembly-items.tsx":
/*!*****************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/assembly-items.tsx ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.AssemblyItems = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _assemblyItems = __webpack_require__(/*! ../../reducers/assembly-items */ "../../../libs/remix-ui/debugger-ui/src/reducers/assembly-items.ts");

__webpack_require__(/*! ./styles/assembly-items.css */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/styles/assembly-items.css");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
const AssemblyItems = ({
  registerEvent
}) => {
  const [assemblyItems, dispatch] = (0, _react.useReducer)(_assemblyItems.reducer, _assemblyItems.initialState);
  const [selectedItem, setSelectedItem] = (0, _react.useState)(0);
  const refs = (0, _react.useRef)({});
  const asmItemsRef = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    registerEvent && registerEvent('codeManagerChanged', (code, address, index) => {
      dispatch({
        type: 'FETCH_OPCODES_SUCCESS',
        payload: {
          code,
          address,
          index
        }
      });
    });
  }, []);
  (0, _react.useEffect)(() => {
    if (selectedItem !== assemblyItems.index) {
      indexChanged(assemblyItems.index);
    }
  }, [assemblyItems.index]);

  const indexChanged = index => {
    if (index < 0) return;
    let currentItem = refs.current[selectedItem] ? refs.current[selectedItem] : null;

    if (currentItem) {
      currentItem.removeAttribute('selected');
      currentItem.removeAttribute('style');

      if (currentItem.firstChild) {
        currentItem.firstChild.removeAttribute('style');
      }

      const codeView = asmItemsRef.current;
      currentItem = codeView.children[index];
      currentItem.style.setProperty('border-color', 'var(--primary)');
      currentItem.style.setProperty('border-style', 'solid');
      currentItem.setAttribute('selected', 'selected');
      codeView.scrollTop = currentItem.offsetTop - parseInt(codeView.offsetTop);
      setSelectedItem(index);
    }
  };

  return /*#__PURE__*/_react.default.createElement("div", {
    className: "border rounded px-1 mt-1 bg-light"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "dropdownpanel"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "dropdowncontent"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "pl-2 my-1 small instructions",
    id: "asmitems",
    ref: asmItemsRef
  }, assemblyItems.display.map((item, i) => {
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "px-1",
      key: i,
      ref: ref => {
        refs.current[i] = ref;
      }
    }, /*#__PURE__*/_react.default.createElement("span", null, item));
  })))));
};

exports.AssemblyItems = AssemblyItems;
var _default = AssemblyItems;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/calldata-panel.tsx":
/*!*****************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/calldata-panel.tsx ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CalldataPanel = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(/*! ./dropdown-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/dropdown-panel.tsx"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
// eslint-disable-line
const CalldataPanel = ({
  calldata
}) => {
  return /*#__PURE__*/_react.default.createElement("div", {
    id: "calldatapanel"
  }, /*#__PURE__*/_react.default.createElement(_dropdownPanel.default, {
    dropdownName: "Call Data",
    calldata: calldata || {}
  }));
};

exports.CalldataPanel = CalldataPanel;
var _default = CalldataPanel;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/callstack-panel.tsx":
/*!******************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/callstack-panel.tsx ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CallstackPanel = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(/*! ./dropdown-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/dropdown-panel.tsx"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
// eslint-disable-line
const CallstackPanel = ({
  calldata
}) => {
  return /*#__PURE__*/_react.default.createElement("div", {
    id: "callstackpanel"
  }, /*#__PURE__*/_react.default.createElement(_dropdownPanel.default, {
    dropdownName: "Call Stack",
    calldata: calldata || {}
  }));
};

exports.CallstackPanel = CallstackPanel;
var _default = CallstackPanel;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/code-list-view.tsx":
/*!*****************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/code-list-view.tsx ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CodeListView = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _assemblyItems = _interopRequireDefault(__webpack_require__(/*! ./assembly-items */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/assembly-items.tsx"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
// eslint-disable-line
const CodeListView = ({
  registerEvent
}) => {
  return /*#__PURE__*/_react.default.createElement("div", {
    id: "asmcodes"
  }, /*#__PURE__*/_react.default.createElement(_assemblyItems.default, {
    registerEvent: registerEvent
  }));
};

exports.CodeListView = CodeListView;
var _default = CodeListView;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/dropdown-panel.tsx":
/*!*****************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/dropdown-panel.tsx ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DropdownPanel = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _treeView = __webpack_require__(/*! @remix-ui/tree-view */ "../../../libs/remix-ui/tree-view/src/index.ts");

var _clipboard = __webpack_require__(/*! @remix-ui/clipboard */ "../../../libs/remix-ui/clipboard/src/index.ts");

var _calldata = __webpack_require__(/*! ../../reducers/calldata */ "../../../libs/remix-ui/debugger-ui/src/reducers/calldata.ts");

__webpack_require__(/*! ./styles/dropdown-panel.css */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/styles/dropdown-panel.css");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const DropdownPanel = props => {
  const [calldataObj, dispatch] = (0, _react.useReducer)(_calldata.reducer, _calldata.initialState);
  const {
    dropdownName,
    dropdownMessage,
    calldata,
    header,
    loading,
    extractFunc,
    formatSelfFunc,
    registerEvent,
    triggerEvent,
    loadMoreEvent,
    loadMoreCompletedEvent
  } = props;

  const extractDataDefault = (item, parent) => {
    const ret = {};

    if (item instanceof Array) {
      ret.children = item.map((item, index) => {
        return {
          key: index,
          value: item
        };
      });
      ret.self = 'Array';
      ret.isNode = true;
      ret.isLeaf = false;
    } else if (item instanceof Object) {
      ret.children = Object.keys(item).map(key => {
        return {
          key: key,
          value: item[key]
        };
      });
      ret.self = 'Object';
      ret.isNode = true;
      ret.isLeaf = false;
    } else {
      ret.self = item;
      ret.children = null;
      ret.isNode = false;
      ret.isLeaf = true;
    }

    return ret;
  };

  const formatSelfDefault = (key, data) => {
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "d-flex mr-1 flex-row label_item"
    }, /*#__PURE__*/_react.default.createElement("label", {
      className: "small font-weight-bold mb-0 pr-1 label_key"
    }, key, ":"), /*#__PURE__*/_react.default.createElement("label", {
      className: "m-0 label_value"
    }, data.self));
  };

  const [state, setState] = (0, _react.useState)({
    header: '',
    toggleDropdown: false,
    message: {
      innerText: 'No data available.',
      display: 'block'
    },
    dropdownContent: {
      innerText: '',
      display: 'none'
    },
    title: {
      innerText: '',
      display: 'none'
    },
    copiableContent: '',
    updating: false,
    expandPath: [],
    data: null
  });
  (0, _react.useEffect)(() => {
    registerEvent && registerEvent(loadMoreCompletedEvent, updatedCalldata => {
      dispatch({
        type: 'UPDATE_CALLDATA_SUCCESS',
        payload: updatedCalldata
      });
    });
  }, []);
  (0, _react.useEffect)(() => {
    dispatch({
      type: 'FETCH_CALLDATA_SUCCESS',
      payload: calldata
    });
  }, [calldata]);
  (0, _react.useEffect)(() => {
    update(calldata);
  }, [calldataObj.calldata]);
  (0, _react.useEffect)(() => {
    message(dropdownMessage);
  }, [dropdownMessage]);
  (0, _react.useEffect)(() => {
    if (loading && !state.updating) setLoading();
  }, [loading]);

  const handleToggle = () => {
    setState(prevState => {
      return { ...prevState,
        toggleDropdown: !prevState.toggleDropdown
      };
    });
  };

  const handleExpand = keyPath => {
    if (!state.expandPath.includes(keyPath)) {
      state.expandPath.push(keyPath);
    } else {
      state.expandPath = state.expandPath.filter(path => !path.startsWith(keyPath));
    }
  };

  const message = message => {
    if (message === state.message.innerText) return;
    setState(prevState => {
      return { ...prevState,
        message: {
          innerText: message,
          display: message ? 'block' : ''
        },
        updating: false
      };
    });
  };

  const setLoading = () => {
    setState(prevState => {
      return { ...prevState,
        message: {
          innerText: '',
          display: 'none'
        },
        dropdownContent: { ...prevState.dropdownContent,
          display: 'none'
        },
        copiableContent: '',
        updating: true
      };
    });
  };

  const update = function (calldata) {
    let isEmpty = !calldata;
    if (calldata && Array.isArray(calldata) && calldata.length === 0) isEmpty = true;else if (calldata && Object.keys(calldata).length === 0 && calldata.constructor === Object) isEmpty = true;
    setState(prevState => {
      return { ...prevState,
        dropdownContent: { ...prevState.dropdownContent,
          display: 'block'
        },
        copiableContent: JSON.stringify(calldata, null, '\t'),
        message: {
          innerText: isEmpty ? 'No data available' : '',
          display: isEmpty ? 'block' : 'none'
        },
        updating: false,
        toggleDropdown: !isEmpty,
        data: calldata
      };
    });
  };

  const renderData = (item, parent, key, keyPath) => {
    const data = extractFunc ? extractFunc(item, parent) : extractDataDefault(item, parent);
    const children = (data.children || []).map(child => {
      return renderData(child.value, data, child.key, keyPath + '/' + child.key);
    });

    if (children && children.length > 0) {
      return /*#__PURE__*/_react.default.createElement(_treeView.TreeViewItem, {
        id: `treeViewItem${key}`,
        key: keyPath,
        label: formatSelfFunc ? formatSelfFunc(key, data) : formatSelfDefault(key, data),
        onClick: () => handleExpand(keyPath),
        expand: state.expandPath.includes(keyPath)
      }, /*#__PURE__*/_react.default.createElement(_treeView.TreeView, {
        id: `treeView${key}`,
        key: keyPath
      }, children, data.hasNext && /*#__PURE__*/_react.default.createElement(_treeView.TreeViewItem, {
        id: 'treeViewLoadMore',
        "data-id": 'treeViewLoadMore',
        className: "cursor_pointer",
        label: "Load more",
        onClick: () => {
          triggerEvent(loadMoreEvent, [data.cursor]);
        }
      })));
    } else {
      return /*#__PURE__*/_react.default.createElement(_treeView.TreeViewItem, {
        id: key.toString(),
        key: keyPath,
        label: formatSelfFunc ? formatSelfFunc(key, data) : formatSelfDefault(key, data),
        onClick: () => handleExpand(keyPath),
        expand: state.expandPath.includes(keyPath)
      });
    }
  };

  const uniquePanelName = dropdownName.split(' ').join('');
  return /*#__PURE__*/_react.default.createElement("div", {
    className: "border rounded px-1 mt-1 bg-light"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "py-0 px-1 title"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: state.toggleDropdown ? 'icon fas fa-caret-down' : 'icon fas fa-caret-right',
    onClick: handleToggle
  }), /*#__PURE__*/_react.default.createElement("div", {
    className: "name",
    "data-id": `dropdownPanel${uniquePanelName}`,
    onClick: handleToggle
  }, dropdownName), /*#__PURE__*/_react.default.createElement("span", {
    className: "nameDetail",
    onClick: handleToggle
  }, header), /*#__PURE__*/_react.default.createElement(_clipboard.CopyToClipboard, {
    content: state.copiableContent,
    "data-id": `dropdownPanelCopyToClipboard${uniquePanelName}`
  })), /*#__PURE__*/_react.default.createElement("div", {
    className: "dropdownpanel",
    style: {
      display: state.toggleDropdown ? 'block' : 'none'
    }
  }, /*#__PURE__*/_react.default.createElement("i", {
    className: "refresh fas fa-sync",
    style: {
      display: state.updating ? 'inline-block' : 'none'
    },
    "aria-hidden": "true"
  }), /*#__PURE__*/_react.default.createElement("div", {
    className: "dropdowncontent",
    style: {
      display: state.dropdownContent.display
    }
  }, state.data && /*#__PURE__*/_react.default.createElement(_treeView.TreeView, {
    id: "treeView"
  }, Object.keys(state.data).map(innerkey => renderData(state.data[innerkey], state.data, innerkey, innerkey)))), /*#__PURE__*/_react.default.createElement("div", {
    className: "dropdownrawcontent",
    hidden: true
  }, state.copiableContent), /*#__PURE__*/_react.default.createElement("div", {
    className: "message",
    style: {
      display: state.message.display
    }
  }, state.message.innerText)));
};

exports.DropdownPanel = DropdownPanel;
var _default = DropdownPanel;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/full-storages-changes.tsx":
/*!************************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/full-storages-changes.tsx ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FullStoragesChanges = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _dropdownPanel = __webpack_require__(/*! ./dropdown-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/dropdown-panel.tsx");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
// eslint-disable-line
const FullStoragesChanges = ({
  calldata
}) => {
  return /*#__PURE__*/_react.default.createElement("div", {
    id: "fullstorageschangespanel"
  }, /*#__PURE__*/_react.default.createElement(_dropdownPanel.DropdownPanel, {
    dropdownName: "Full Storages Changes",
    calldata: calldata || {}
  }));
};

exports.FullStoragesChanges = FullStoragesChanges;
var _default = FullStoragesChanges;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/function-panel.tsx":
/*!*****************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/function-panel.tsx ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FunctionPanel = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(/*! ./dropdown-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/dropdown-panel.tsx"));

var _deepEqual = _interopRequireDefault(__webpack_require__(/*! deep-equal */ "../../../node_modules/deep-equal/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const FunctionPanel = ({
  data
}) => {
  const [calldata, setCalldata] = (0, _react.useState)(null);
  (0, _react.useEffect)(() => {
    if (!(0, _deepEqual.default)(calldata, data)) setCalldata(data);
  }, [data]);
  return /*#__PURE__*/_react.default.createElement("div", {
    id: "FunctionPanel"
  }, /*#__PURE__*/_react.default.createElement(_dropdownPanel.default, {
    dropdownName: "Function Stack",
    calldata: calldata || {}
  }));
};

exports.FunctionPanel = FunctionPanel;
var _default = FunctionPanel;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/memory-panel.tsx":
/*!***************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/memory-panel.tsx ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MemoryPanel = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(/*! ./dropdown-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/dropdown-panel.tsx"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
// eslint-disable-line
const MemoryPanel = ({
  calldata
}) => {
  return /*#__PURE__*/_react.default.createElement(_dropdownPanel.default, {
    dropdownName: "Memory",
    calldata: calldata || {}
  });
};

exports.MemoryPanel = MemoryPanel;
var _default = MemoryPanel;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/solidity-locals.tsx":
/*!******************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/solidity-locals.tsx ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SolidityLocals = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(/*! ./dropdown-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/dropdown-panel.tsx"));

var _solidityTypeFormatter = __webpack_require__(/*! ../../utils/solidityTypeFormatter */ "../../../libs/remix-ui/debugger-ui/src/utils/solidityTypeFormatter.ts");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const SolidityLocals = ({
  data,
  message,
  registerEvent,
  triggerEvent
}) => {
  const [calldata, setCalldata] = (0, _react.useState)(null);
  (0, _react.useEffect)(() => {
    data && setCalldata(data);
  }, [data]);

  const formatSelf = (key, data) => {
    let color = 'var(--primary)';

    if (data.isArray || data.isStruct || data.isMapping) {
      color = 'var(--info)';
    } else if (data.type.indexOf('uint') === 0 || data.type.indexOf('int') === 0 || data.type.indexOf('bool') === 0 || data.type.indexOf('enum') === 0) {
      color = 'var(--green)';
    } else if (data.type === 'string') {
      color = 'var(--teal)';
    } else if (data.self == 0x0) {
      // eslint-disable-line
      color = 'var(--gray)';
    }

    if (data.type === 'string') {
      data.self = JSON.stringify(data.self);
    }

    return /*#__PURE__*/_react.default.createElement("label", {
      className: "mb-0",
      style: {
        color: data.isProperty ? 'var(--info)' : '',
        whiteSpace: 'pre-wrap'
      }
    }, ' ' + key, ":", /*#__PURE__*/_react.default.createElement("label", {
      className: "mb-0",
      style: {
        color
      }
    }, ' ' + data.self), /*#__PURE__*/_react.default.createElement("label", {
      style: {
        fontStyle: 'italic'
      }
    }, data.isProperty || !data.type ? '' : ' ' + data.type));
  };

  return /*#__PURE__*/_react.default.createElement("div", {
    id: "soliditylocals",
    "data-id": "solidityLocals"
  }, /*#__PURE__*/_react.default.createElement(_dropdownPanel.default, {
    dropdownName: "Solidity Locals",
    dropdownMessage: message,
    calldata: calldata || {},
    extractFunc: _solidityTypeFormatter.extractData,
    formatSelfFunc: formatSelf,
    registerEvent: registerEvent,
    triggerEvent: triggerEvent,
    loadMoreEvent: "solidityLocalsLoadMore",
    loadMoreCompletedEvent: "solidityLocalsLoadMoreCompleted"
  }));
};

exports.SolidityLocals = SolidityLocals;
var _default = SolidityLocals;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/solidity-state.tsx":
/*!*****************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/solidity-state.tsx ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SolidityState = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(/*! ./dropdown-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/dropdown-panel.tsx"));

var _solidityTypeFormatter = __webpack_require__(/*! ../../utils/solidityTypeFormatter */ "../../../libs/remix-ui/debugger-ui/src/utils/solidityTypeFormatter.ts");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const SolidityState = ({
  calldata,
  message
}) => {
  const formatSelf = (key, data) => {
    let color = 'var(--primary)';

    if (data.isArray || data.isStruct || data.isMapping) {
      color = 'var(--info)';
    } else if (data.type.indexOf('uint') === 0 || data.type.indexOf('int') === 0 || data.type.indexOf('bool') === 0 || data.type.indexOf('enum') === 0) {
      color = 'var(--green)';
    } else if (data.type === 'string') {
      color = 'var(--teal)';
    } else if (data.self == 0x0) {
      // eslint-disable-line
      color = 'var(--gray)';
    }

    return /*#__PURE__*/_react.default.createElement("label", {
      className: "mb-0",
      style: {
        color: data.isProperty ? 'var(--info)' : '',
        whiteSpace: 'pre-wrap'
      }
    }, ' ' + key, ":", /*#__PURE__*/_react.default.createElement("label", {
      className: "mb-0",
      style: {
        color
      }
    }, ' ' + data.self), /*#__PURE__*/_react.default.createElement("label", {
      style: {
        fontStyle: 'italic'
      }
    }, data.isProperty || !data.type ? '' : ' ' + data.type));
  };

  return /*#__PURE__*/_react.default.createElement("div", {
    id: "soliditystate",
    "data-id": "soliditystate"
  }, /*#__PURE__*/_react.default.createElement(_dropdownPanel.default, {
    dropdownName: "Solidity State",
    calldata: calldata || {},
    formatSelfFunc: formatSelf,
    extractFunc: _solidityTypeFormatter.extractData
  }));
};

exports.SolidityState = SolidityState;
var _default = SolidityState;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/stack-panel.tsx":
/*!**************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/stack-panel.tsx ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.StackPanel = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(/*! ./dropdown-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/dropdown-panel.tsx"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
// eslint-disable-line
const StackPanel = ({
  calldata
}) => {
  return /*#__PURE__*/_react.default.createElement("div", {
    id: "stackpanel"
  }, /*#__PURE__*/_react.default.createElement(_dropdownPanel.default, {
    dropdownName: "Stack",
    calldata: calldata || {}
  }));
};

exports.StackPanel = StackPanel;
var _default = StackPanel;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/step-detail.tsx":
/*!**************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/step-detail.tsx ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.StepDetail = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(/*! ./dropdown-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/dropdown-panel.tsx"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
// eslint-disable-line
const StepDetail = ({
  stepDetail
}) => {
  return /*#__PURE__*/_react.default.createElement("div", {
    id: "stepdetail",
    "data-id": "stepdetail"
  }, /*#__PURE__*/_react.default.createElement(_dropdownPanel.default, {
    dropdownName: "Step details",
    calldata: stepDetail || {}
  }));
};

exports.StepDetail = StepDetail;
var _default = StepDetail;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/storage-panel.tsx":
/*!****************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/storage-panel.tsx ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.StoragePanel = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(/*! ./dropdown-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/dropdown-panel.tsx"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
// eslint-disable-line
const StoragePanel = ({
  calldata,
  header
}) => {
  return /*#__PURE__*/_react.default.createElement("div", {
    id: "storagepanel"
  }, /*#__PURE__*/_react.default.createElement(_dropdownPanel.default, {
    dropdownName: "Storage",
    calldata: calldata || {},
    header: header
  }));
};

exports.StoragePanel = StoragePanel;
var _default = StoragePanel;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/styles/assembly-items.css":
/*!************************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/styles/assembly-items.css ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../../../../../../node_modules/postcss-loader/src??embedded!./assembly-items.css */ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/styles/assembly-items.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/styles/dropdown-panel.css":
/*!************************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/styles/dropdown-panel.css ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../../../../../../node_modules/postcss-loader/src??embedded!./dropdown-panel.css */ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/styles/dropdown-panel.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/vm-debugger-head.tsx":
/*!*******************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/vm-debugger-head.tsx ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.VmDebuggerHead = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _codeListView = _interopRequireDefault(__webpack_require__(/*! ./code-list-view */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/code-list-view.tsx"));

var _functionPanel = _interopRequireDefault(__webpack_require__(/*! ./function-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/function-panel.tsx"));

var _stepDetail = _interopRequireDefault(__webpack_require__(/*! ./step-detail */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/step-detail.tsx"));

var _solidityState = _interopRequireDefault(__webpack_require__(/*! ./solidity-state */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/solidity-state.tsx"));

var _solidityLocals = _interopRequireDefault(__webpack_require__(/*! ./solidity-locals */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/solidity-locals.tsx"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const VmDebuggerHead = ({
  vmDebugger: {
    registerEvent,
    triggerEvent
  }
}) => {
  const [functionPanel, setFunctionPanel] = (0, _react.useState)(null);
  const [stepDetail, setStepDetail] = (0, _react.useState)({
    'vm trace step': '-',
    'execution step': '-',
    'add memory': '',
    gas: '',
    'remaining gas': '-',
    'loaded address': '-'
  });
  const [solidityState, setSolidityState] = (0, _react.useState)({
    calldata: null,
    message: null
  });
  const [solidityLocals, setSolidityLocals] = (0, _react.useState)({
    calldata: null,
    message: null
  });
  (0, _react.useEffect)(() => {
    registerEvent && registerEvent('functionsStackUpdate', stack => {
      if (stack === null || stack.length === 0) return;
      const functions = [];

      for (const func of stack) {
        functions.push(func.functionDefinition.name + '(' + func.inputs.join(', ') + ')');
      }

      setFunctionPanel(() => functions);
    });
    registerEvent && registerEvent('traceUnloaded', () => {
      setStepDetail(() => {
        return {
          'vm trace step': '-',
          'execution step': '-',
          'add memory': '',
          gas: '',
          'remaining gas': '-',
          'loaded address': '-'
        };
      });
    });
    registerEvent && registerEvent('newTraceLoaded', () => {
      setStepDetail(() => {
        return {
          'vm trace step': '-',
          'execution step': '-',
          'add memory': '',
          gas: '',
          'remaining gas': '-',
          'loaded address': '-'
        };
      });
    });
    registerEvent && registerEvent('traceCurrentStepUpdate', (error, step) => {
      setStepDetail(prevState => {
        return { ...prevState,
          'execution step': error ? '-' : step
        };
      });
    });
    registerEvent && registerEvent('traceMemExpandUpdate', (error, addmem) => {
      setStepDetail(prevState => {
        return { ...prevState,
          'add memory': error ? '-' : addmem
        };
      });
    });
    registerEvent && registerEvent('traceStepCostUpdate', (error, gas) => {
      setStepDetail(prevState => {
        return { ...prevState,
          gas: error ? '-' : gas
        };
      });
    });
    registerEvent && registerEvent('traceCurrentCalledAddressAtUpdate', (error, address) => {
      setStepDetail(prevState => {
        return { ...prevState,
          'loaded address': error ? '-' : address
        };
      });
    });
    registerEvent && registerEvent('traceRemainingGasUpdate', (error, remainingGas) => {
      setStepDetail(prevState => {
        return { ...prevState,
          'remaining gas': error ? '-' : remainingGas
        };
      });
    });
    registerEvent && registerEvent('indexUpdate', index => {
      setStepDetail(prevState => {
        return { ...prevState,
          'vm trace step': index
        };
      });
    });
    registerEvent && registerEvent('solidityState', calldata => {
      setSolidityState(() => {
        return { ...solidityState,
          calldata
        };
      });
    });
    registerEvent && registerEvent('solidityStateMessage', message => {
      setSolidityState(() => {
        return { ...solidityState,
          message
        };
      });
    });
    registerEvent && registerEvent('solidityLocals', calldata => {
      setSolidityLocals(() => {
        return { ...solidityLocals,
          calldata
        };
      });
    });
    registerEvent && registerEvent('solidityLocalsMessage', message => {
      setSolidityLocals(() => {
        return { ...solidityLocals,
          message
        };
      });
    });
  }, [registerEvent]);
  return /*#__PURE__*/_react.default.createElement("div", {
    id: "vmheadView",
    className: "mt-1 px-0"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "d-flex flex-column"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "w-100"
  }, /*#__PURE__*/_react.default.createElement(_functionPanel.default, {
    data: functionPanel
  }), /*#__PURE__*/_react.default.createElement(_solidityLocals.default, {
    data: solidityLocals.calldata,
    message: solidityLocals.message,
    registerEvent: registerEvent,
    triggerEvent: triggerEvent
  }), /*#__PURE__*/_react.default.createElement(_solidityState.default, {
    calldata: solidityState.calldata,
    message: solidityState.message
  })), /*#__PURE__*/_react.default.createElement("div", {
    className: "w-100"
  }, /*#__PURE__*/_react.default.createElement(_codeListView.default, {
    registerEvent: registerEvent
  })), /*#__PURE__*/_react.default.createElement("div", {
    className: "w-100"
  }, /*#__PURE__*/_react.default.createElement(_stepDetail.default, {
    stepDetail: stepDetail
  }))));
};

exports.VmDebuggerHead = VmDebuggerHead;
var _default = VmDebuggerHead;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/vm-debugger.tsx":
/*!**************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/vm-debugger.tsx ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.VmDebugger = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _calldataPanel = _interopRequireDefault(__webpack_require__(/*! ./calldata-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/calldata-panel.tsx"));

var _memoryPanel = _interopRequireDefault(__webpack_require__(/*! ./memory-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/memory-panel.tsx"));

var _callstackPanel = _interopRequireDefault(__webpack_require__(/*! ./callstack-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/callstack-panel.tsx"));

var _stackPanel = _interopRequireDefault(__webpack_require__(/*! ./stack-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/stack-panel.tsx"));

var _storagePanel = _interopRequireDefault(__webpack_require__(/*! ./storage-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/storage-panel.tsx"));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(/*! ./dropdown-panel */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/dropdown-panel.tsx"));

var _fullStoragesChanges = _interopRequireDefault(__webpack_require__(/*! ./full-storages-changes */ "../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/full-storages-changes.tsx"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const VmDebugger = ({
  vmDebugger: {
    registerEvent
  }
}) => {
  const [calldataPanel, setCalldataPanel] = (0, _react.useState)(null);
  const [memoryPanel, setMemoryPanel] = (0, _react.useState)(null);
  const [callStackPanel, setCallStackPanel] = (0, _react.useState)(null);
  const [stackPanel, setStackPanel] = (0, _react.useState)(null);
  const [storagePanel, setStoragePanel] = (0, _react.useState)({
    calldata: null,
    header: null
  });
  const [returnValuesPanel, setReturnValuesPanel] = (0, _react.useState)(null);
  const [fullStoragesChangesPanel, setFullStoragesChangesPanel] = (0, _react.useState)(null);
  (0, _react.useEffect)(() => {
    registerEvent && registerEvent('traceManagerCallDataUpdate', calldata => {
      setCalldataPanel(() => calldata);
    });
    registerEvent && registerEvent('traceManagerMemoryUpdate', calldata => {
      setMemoryPanel(() => calldata);
    });
    registerEvent && registerEvent('traceManagerCallStackUpdate', calldata => {
      setCallStackPanel(() => calldata);
    });
    registerEvent && registerEvent('traceManagerStackUpdate', calldata => {
      setStackPanel(() => calldata);
    });
    registerEvent && registerEvent('traceManagerStorageUpdate', (calldata, header) => {
      setStoragePanel(() => {
        return {
          calldata,
          header
        };
      });
    });
    registerEvent && registerEvent('traceReturnValueUpdate', calldata => {
      setReturnValuesPanel(() => calldata);
    });
    registerEvent && registerEvent('traceAddressesUpdate', calldata => {
      setFullStoragesChangesPanel(() => {
        return {};
      });
    });
    registerEvent && registerEvent('traceStorageUpdate', calldata => {
      setFullStoragesChangesPanel(() => calldata);
    });
  }, [registerEvent]);
  return /*#__PURE__*/_react.default.createElement("div", {
    id: "vmdebugger",
    className: "px-2"
  }, /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement(_stackPanel.default, {
    calldata: stackPanel
  }), /*#__PURE__*/_react.default.createElement(_memoryPanel.default, {
    calldata: memoryPanel
  }), /*#__PURE__*/_react.default.createElement(_storagePanel.default, {
    calldata: storagePanel.calldata,
    header: storagePanel.header
  }), /*#__PURE__*/_react.default.createElement(_callstackPanel.default, {
    calldata: callStackPanel
  }), /*#__PURE__*/_react.default.createElement(_calldataPanel.default, {
    calldata: calldataPanel
  }), /*#__PURE__*/_react.default.createElement(_dropdownPanel.default, {
    dropdownName: "Return Value",
    calldata: returnValuesPanel || {}
  }), /*#__PURE__*/_react.default.createElement(_fullStoragesChanges.default, {
    calldata: fullStoragesChangesPanel
  })));
};

exports.VmDebugger = VmDebugger;
var _default = VmDebugger;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/reducers/assembly-items.ts":
/*!*********************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/reducers/assembly-items.ts ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reducer = exports.initialState = void 0;

var _deepEqual = _interopRequireDefault(__webpack_require__(/*! deep-equal */ "../../../node_modules/deep-equal/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const initialState = {
  opCodes: {
    code: [],
    index: 0,
    address: ''
  },
  display: [],
  index: 0,
  top: 0,
  bottom: 0,
  isRequesting: false,
  isSuccessful: false,
  hasError: null
};
exports.initialState = initialState;

const reducer = (state = initialState, action) => {
  switch (action.type) {
    case 'FETCH_OPCODES_REQUEST':
      {
        return { ...state,
          isRequesting: true,
          isSuccessful: false,
          hasError: null
        };
      }

    case 'FETCH_OPCODES_SUCCESS':
      {
        const opCodes = action.payload.address === state.opCodes.address ? { ...state.opCodes,
          index: action.payload.index
        } : (0, _deepEqual.default)(action.payload.code, state.opCodes.code) ? state.opCodes : action.payload;
        const top = opCodes.index - 3 > 0 ? opCodes.index - 3 : 0;
        const bottom = opCodes.index + 4 < opCodes.code.length ? opCodes.index + 4 : opCodes.code.length;
        const display = opCodes.code.slice(top, bottom);
        return {
          opCodes,
          display,
          index: display.findIndex(code => code === opCodes.code[opCodes.index]),
          top,
          bottom,
          isRequesting: false,
          isSuccessful: true,
          hasError: null
        };
      }

    case 'FETCH_OPCODES_ERROR':
      {
        return { ...state,
          isRequesting: false,
          isSuccessful: false,
          hasError: action.payload
        };
      }

    default:
      throw new Error();
  }
};

exports.reducer = reducer;

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/reducers/calldata.ts":
/*!***************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/reducers/calldata.ts ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reducer = exports.initialState = void 0;
const initialState = {
  calldata: {},
  isRequesting: false,
  isSuccessful: false,
  hasError: null
};
exports.initialState = initialState;

const reducer = (state = initialState, action) => {
  switch (action.type) {
    case 'FETCH_CALLDATA_REQUEST':
      return { ...state,
        isRequesting: true,
        isSuccessful: false,
        hasError: null
      };

    case 'FETCH_CALLDATA_SUCCESS':
      return {
        calldata: action.payload,
        isRequesting: false,
        isSuccessful: true,
        hasError: null
      };

    case 'FETCH_CALLDATA_ERROR':
      return { ...state,
        isRequesting: false,
        isSuccessful: false,
        hasError: action.payload
      };

    case 'UPDATE_CALLDATA_REQUEST':
      return { ...state,
        isRequesting: true,
        isSuccessful: false,
        hasError: null
      };

    case 'UPDATE_CALLDATA_SUCCESS':
      return {
        calldata: mergeLocals(action.payload, state.calldata),
        isRequesting: false,
        isSuccessful: true,
        hasError: null
      };

    case 'UPDATE_CALLDATA_ERROR':
      return { ...state,
        isRequesting: false,
        isSuccessful: false,
        hasError: action.payload
      };

    default:
      throw new Error();
  }
};

exports.reducer = reducer;

function mergeLocals(locals1, locals2) {
  Object.keys(locals2).map(item => {
    if (locals2[item].cursor && parseInt(locals2[item].cursor) < parseInt(locals1[item].cursor)) {
      locals2[item] = { ...locals1[item],
        value: [...locals2[item].value, ...locals1[item].value]
      };
    }
  });
  return locals2;
}

/***/ }),

/***/ "../../../libs/remix-ui/debugger-ui/src/utils/solidityTypeFormatter.ts":
/*!*************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/debugger-ui/src/utils/solidityTypeFormatter.ts ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractData = extractData;

var _ethereumjsUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

// eslint-disable-line
function extractData(item, parent) {
  const ret = {};

  if (item.isProperty) {
    return item;
  }

  if (item.type.lastIndexOf(']') === item.type.length - 1) {
    ret.children = (item.value || []).map(function (item, index) {
      return {
        key: index,
        value: item
      };
    });
    ret.children.unshift({
      key: 'length',
      value: {
        self: new _ethereumjsUtil.BN(item.length.replace('0x', ''), 16).toString(10),
        type: 'uint',
        isProperty: true
      }
    });
    ret.isArray = true;
    ret.self = parent.isArray ? '' : item.type;
    ret.cursor = item.cursor;
    ret.hasNext = item.hasNext;
  } else if (item.type.indexOf('struct') === 0) {
    ret.children = Object.keys(item.value || {}).map(function (key) {
      return {
        key: key,
        value: item.value[key]
      };
    });
    ret.self = item.type;
    ret.isStruct = true;
  } else if (item.type.indexOf('mapping') === 0) {
    ret.children = Object.keys(item.value || {}).map(function (key) {
      return {
        key: key,
        value: item.value[key]
      };
    });
    ret.isMapping = true;
    ret.self = item.type;
  } else {
    ret.children = null;
    ret.self = item.value;
    ret.type = item.type;
  }

  return ret;
}

/***/ }),

/***/ "../../../libs/remix-ui/file-explorer/src/index.ts":
/*!*****************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/file-explorer/src/index.ts ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fileExplorer = __webpack_require__(/*! ./lib/file-explorer */ "../../../libs/remix-ui/file-explorer/src/lib/file-explorer.tsx");

Object.keys(_fileExplorer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _fileExplorer[key];
    }
  });
});

/***/ }),

/***/ "../../../libs/remix-ui/file-explorer/src/lib/css/file-explorer-context-menu.css":
/*!***********************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/file-explorer/src/lib/css/file-explorer-context-menu.css ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../../../../../node_modules/postcss-loader/src??embedded!./file-explorer-context-menu.css */ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/file-explorer/src/lib/css/file-explorer-context-menu.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "../../../libs/remix-ui/file-explorer/src/lib/css/file-explorer.css":
/*!**********************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/file-explorer/src/lib/css/file-explorer.css ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../../../../../node_modules/postcss-loader/src??embedded!./file-explorer.css */ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/file-explorer/src/lib/css/file-explorer.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "../../../libs/remix-ui/file-explorer/src/lib/file-explorer-context-menu.tsx":
/*!*******************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/file-explorer/src/lib/file-explorer-context-menu.tsx ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FileExplorerContextMenu = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

__webpack_require__(/*! ./css/file-explorer-context-menu.css */ "../../../libs/remix-ui/file-explorer/src/lib/css/file-explorer-context-menu.css");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const FileExplorerContextMenu = props => {
  const {
    actions,
    createNewFile,
    createNewFolder,
    deletePath,
    renamePath,
    hideContextMenu,
    publishToGist,
    runScript,
    emit,
    pageX,
    pageY,
    path,
    type,
    ...otherProps
  } = props;
  const contextMenuRef = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    contextMenuRef.current.focus();
  }, []);
  (0, _react.useEffect)(() => {
    const menuItemsContainer = contextMenuRef.current;
    const boundary = menuItemsContainer.getBoundingClientRect();

    if (boundary.bottom > (window.innerHeight || document.documentElement.clientHeight)) {
      menuItemsContainer.style.position = 'absolute';
      menuItemsContainer.style.bottom = '10px';
      menuItemsContainer.style.top = null;
    }
  }, [pageX, pageY]);

  const menu = () => {
    return actions.filter(item => {
      if (item.type && Array.isArray(item.type) && item.type.findIndex(name => name === type) !== -1) return true;else if (item.path && Array.isArray(item.path) && item.path.findIndex(key => key === path) !== -1) return true;else if (item.extension && Array.isArray(item.extension) && item.extension.findIndex(ext => path.endsWith(ext)) !== -1) return true;else if (item.pattern && Array.isArray(item.pattern) && item.pattern.filter(value => path.match(new RegExp(value))).length > 0) return true;else return false;
    }).map((item, index) => {
      return /*#__PURE__*/_react.default.createElement("li", {
        id: `menuitem${item.name.toLowerCase()}`,
        key: index,
        className: "remixui_liitem",
        onClick: e => {
          e.stopPropagation();

          switch (item.name) {
            case 'New File':
              createNewFile(path);
              break;

            case 'New Folder':
              createNewFolder(path);
              break;

            case 'Rename':
              renamePath(path, type);
              break;

            case 'Delete':
              deletePath(path);
              break;

            case 'Push changes to gist':
              publishToGist();
              break;

            case 'Run':
              runScript(path);
              break;

            default:
              emit && emit(item.id, path);
              break;
          }

          hideContextMenu();
        }
      }, item.name);
    });
  };

  return /*#__PURE__*/_react.default.createElement("div", Object.assign({
    id: "menuItemsContainer",
    className: "p-1 remixui_contextContainer bg-light shadow border",
    style: {
      left: pageX,
      top: pageY
    },
    ref: contextMenuRef,
    onBlur: hideContextMenu,
    tabIndex: 500
  }, otherProps), /*#__PURE__*/_react.default.createElement("ul", {
    id: "remixui_menuitems"
  }, menu()));
};

exports.FileExplorerContextMenu = FileExplorerContextMenu;
var _default = FileExplorerContextMenu;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/file-explorer/src/lib/file-explorer-menu.tsx":
/*!***********************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/file-explorer/src/lib/file-explorer-menu.tsx ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FileExplorerMenu = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const FileExplorerMenu = props => {
  const [state, setState] = (0, _react.useState)({
    menuItems: [{
      action: 'createNewFile',
      title: 'Create New File',
      icon: 'far fa-file'
    }, {
      action: 'createNewFolder',
      title: 'Create New Folder',
      icon: 'far fa-folder'
    }, {
      action: 'publishToGist',
      title: 'Publish all [browser] explorer files to a github gist',
      icon: 'fab fa-github'
    }, {
      action: 'uploadFile',
      title: 'Load a local file into Remix\'s browser folder',
      icon: 'fa fa-upload'
    }, {
      action: 'updateGist',
      title: 'Update the current [gist] explorer',
      icon: 'fab fa-github'
    }].filter(item => props.menuItems && props.menuItems.find(name => {
      return name === item.action;
    })),
    actions: {}
  });
  (0, _react.useEffect)(() => {
    const actions = {
      updateGist: () => {}
    };
    setState(prevState => {
      return { ...prevState,
        actions
      };
    });
  }, []);
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement("span", {
    className: "remixui_label",
    title: props.title,
    "data-path": props.title,
    style: {
      fontWeight: 'bold'
    }
  }, props.title), /*#__PURE__*/_react.default.createElement("span", {
    className: "remixui_menu"
  }, state.menuItems.map(({
    action,
    title,
    icon
  }, index) => {
    if (action === 'uploadFile') {
      return /*#__PURE__*/_react.default.createElement("label", {
        id: action,
        "data-id": 'fileExplorerUploadFile' + action,
        className: icon + ' mb-0 remixui_newFile',
        title: title,
        key: index
      }, /*#__PURE__*/_react.default.createElement("input", {
        id: "fileUpload",
        "data-id": "fileExplorerFileUpload",
        type: "file",
        onChange: e => {
          e.stopPropagation();
          props.uploadFile(e.target);
          e.target.value = null;
        },
        multiple: true
      }));
    } else {
      return /*#__PURE__*/_react.default.createElement("span", {
        id: action,
        "data-id": 'fileExplorerNewFile' + action,
        onClick: e => {
          e.stopPropagation();

          if (action === 'createNewFile') {
            props.createNewFile();
          } else if (action === 'createNewFolder') {
            props.createNewFolder();
          } else if (action === 'publishToGist') {
            props.publishToGist();
          } else {
            state.actions[action]();
          }
        },
        className: 'newFile ' + icon + ' remixui_newFile',
        title: title,
        key: index
      });
    }
  })));
};

exports.FileExplorerMenu = FileExplorerMenu;
var _default = FileExplorerMenu;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/file-explorer/src/lib/file-explorer.tsx":
/*!******************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/file-explorer/src/lib/file-explorer.tsx ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FileExplorer = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _treeView = __webpack_require__(/*! @remix-ui/tree-view */ "../../../libs/remix-ui/tree-view/src/index.ts");

var _modalDialog = __webpack_require__(/*! @remix-ui/modal-dialog */ "../../../libs/remix-ui/modal-dialog/src/index.ts");

var _toaster = __webpack_require__(/*! @remix-ui/toaster */ "../../../libs/remix-ui/toaster/src/index.ts");

var async = _interopRequireWildcard(__webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js"));

var _gists = _interopRequireDefault(__webpack_require__(/*! gists */ "../../../node_modules/gists/index.js"));

var _fileExplorerMenu = __webpack_require__(/*! ./file-explorer-menu */ "../../../libs/remix-ui/file-explorer/src/lib/file-explorer-menu.tsx");

var _fileExplorerContextMenu = __webpack_require__(/*! ./file-explorer-context-menu */ "../../../libs/remix-ui/file-explorer/src/lib/file-explorer-context-menu.tsx");

var helper = _interopRequireWildcard(__webpack_require__(/*! ../../../../../apps/remix-ide/src/lib/helper */ "./lib/helper.js"));

var _queryParams = _interopRequireDefault(__webpack_require__(/*! ../../../../../apps/remix-ide/src/lib/query-params */ "./lib/query-params.js"));

__webpack_require__(/*! ./css/file-explorer.css */ "../../../libs/remix-ui/file-explorer/src/lib/css/file-explorer.css");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd' // eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const queryParams = new _queryParams.default();

const FileExplorer = props => {
  const {
    filesProvider,
    name,
    registry,
    plugin,
    focusRoot,
    contextMenuItems,
    displayInput,
    externalUploads
  } = props;
  const [state, setState] = (0, _react.useState)({
    focusElement: [{
      key: name,
      type: 'folder'
    }],
    focusPath: null,
    files: [],
    fileManager: null,
    ctrlKey: false,
    newFileName: '',
    actions: [],
    focusContext: {
      element: null,
      x: null,
      y: null
    },
    focusEdit: {
      element: null,
      type: '',
      isNew: false,
      lastEdit: ''
    },
    expandPath: [name],
    focusModal: {
      hide: true,
      title: '',
      message: '',
      ok: {
        label: '',
        fn: () => {}
      },
      cancel: {
        label: '',
        fn: () => {}
      },
      handleHide: null
    },
    modals: [],
    toasterMsg: ''
  });
  const editRef = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    if (state.focusEdit.element) {
      setTimeout(() => {
        if (editRef && editRef.current) {
          editRef.current.focus();
        }
      }, 150);
    }
  }, [state.focusEdit.element]);
  (0, _react.useEffect)(() => {
    (async () => {
      const fileManager = registry.get('filemanager').api;
      const files = await fetchDirectoryContent(name);
      const actions = [{
        id: 'newFile',
        name: 'New File',
        type: ['folder'],
        path: [],
        extension: [],
        pattern: []
      }, {
        id: 'newFolder',
        name: 'New Folder',
        type: ['folder'],
        path: [],
        extension: [],
        pattern: []
      }, {
        id: 'rename',
        name: 'Rename',
        type: ['file', 'folder'],
        path: [],
        extension: [],
        pattern: []
      }, {
        id: 'delete',
        name: 'Delete',
        type: ['file', 'folder'],
        path: [],
        extension: [],
        pattern: []
      }, {
        id: 'pushChangesToGist',
        name: 'Push changes to gist',
        type: [],
        path: [],
        extension: [],
        pattern: ['^browser/gists/([0-9]|[a-z])*$']
      }, {
        id: 'run',
        name: 'Run',
        type: [],
        path: [],
        extension: ['.js'],
        pattern: []
      }];
      setState(prevState => {
        return { ...prevState,
          fileManager,
          files,
          actions
        };
      });
    })();
  }, []);
  (0, _react.useEffect)(() => {
    if (state.fileManager) {
      filesProvider.event.register('fileExternallyChanged', fileExternallyChanged);
      filesProvider.event.register('fileRenamedError', fileRenamedError);
      filesProvider.event.register('rootFolderChanged', rootFolderChanged);
    }
  }, [state.fileManager]);
  (0, _react.useEffect)(() => {
    const {
      expandPath
    } = state;

    const expandFn = async () => {
      let files = state.files;

      for (let i = 0; i < expandPath.length; i++) {
        files = await resolveDirectory(expandPath[i], files);
        await setState(prevState => {
          return { ...prevState,
            files
          };
        });
      }
    };

    if (expandPath && expandPath.length > 0) {
      expandFn();
    }
  }, [state.expandPath]);
  (0, _react.useEffect)(() => {
    // unregister event to update state in callback
    if (filesProvider.event.registered.fileAdded) filesProvider.event.unregister('fileAdded', fileAdded);
    if (filesProvider.event.registered.folderAdded) filesProvider.event.unregister('folderAdded', folderAdded);
    if (filesProvider.event.registered.fileRemoved) filesProvider.event.unregister('fileRemoved', fileRemoved);
    if (filesProvider.event.registered.fileRenamed) filesProvider.event.unregister('fileRenamed', fileRenamed);
    filesProvider.event.register('fileAdded', fileAdded);
    filesProvider.event.register('folderAdded', folderAdded);
    filesProvider.event.register('fileRemoved', fileRemoved);
    filesProvider.event.register('fileRenamed', fileRenamed);
  }, [state.files]);
  (0, _react.useEffect)(() => {
    if (focusRoot) {
      setState(prevState => {
        return { ...prevState,
          focusElement: [{
            key: name,
            type: 'folder'
          }]
        };
      });
      plugin.resetFocus(false);
    }
  }, [focusRoot]);
  (0, _react.useEffect)(() => {
    if (contextMenuItems) {
      setState(prevState => {
        // filter duplicate items
        const items = contextMenuItems.filter(({
          name
        }) => prevState.actions.findIndex(action => action.name === name) === -1);
        return { ...prevState,
          actions: [...prevState.actions, ...items]
        };
      });
    }
  }, [contextMenuItems]);
  (0, _react.useEffect)(() => {
    if (displayInput) {
      handleNewFileInput();
      plugin.resetNewFile();
    }
  }, [displayInput]);
  (0, _react.useEffect)(() => {
    if (externalUploads) {
      uploadFile(externalUploads);
      plugin.resetUploadFile();
    }
  }, [externalUploads]);
  (0, _react.useEffect)(() => {
    if (state.modals.length > 0) {
      setState(prevState => {
        const focusModal = {
          hide: false,
          title: prevState.modals[0].title,
          message: prevState.modals[0].message,
          ok: prevState.modals[0].ok,
          cancel: prevState.modals[0].cancel,
          handleHide: prevState.modals[0].handleHide
        };
        prevState.modals.shift();
        return { ...prevState,
          focusModal,
          modals: prevState.modals
        };
      });
    }
  }, [state.modals]);

  const resolveDirectory = async (folderPath, dir, isChild = false) => {
    if (!isChild && state.focusEdit.element === `${name}/blank` && state.focusEdit.isNew && dir.findIndex(({
      path
    }) => path === `${name}/blank`) === -1) {
      dir = state.focusEdit.type === 'file' ? [...dir, {
        path: state.focusEdit.element,
        name: '',
        isDirectory: false
      }] : [{
        path: state.focusEdit.element,
        name: '',
        isDirectory: true
      }, ...dir];
    }

    dir = await Promise.all(dir.map(async file => {
      if (file.path === folderPath) {
        if (extractParentFromKey(state.focusEdit.element) === folderPath && state.focusEdit.isNew) {
          file.child = state.focusEdit.type === 'file' ? [...(await fetchDirectoryContent(folderPath)), {
            path: state.focusEdit.element,
            name: '',
            isDirectory: false
          }] : [{
            path: state.focusEdit.element,
            name: '',
            isDirectory: true
          }, ...(await fetchDirectoryContent(folderPath))];
        } else {
          file.child = await fetchDirectoryContent(folderPath);
        }

        return file;
      } else if (file.child) {
        file.child = await resolveDirectory(folderPath, file.child, true);
        return file;
      } else {
        return file;
      }
    }));
    return dir;
  };

  const fetchDirectoryContent = async folderPath => {
    return new Promise(resolve => {
      filesProvider.resolveDirectory(folderPath, (error, fileTree) => {
        if (error) console.error(error);
        const files = normalize(folderPath, fileTree);
        resolve(files);
      });
    });
  };

  const normalize = (path, filesList) => {
    const folders = [];
    const files = [];
    const prefix = path.split('/')[0];
    Object.keys(filesList || {}).forEach(key => {
      const path = prefix + '/' + key;

      if (filesList[key].isDirectory) {
        folders.push({
          path,
          name: extractNameFromKey(path),
          isDirectory: filesList[key].isDirectory
        });
      } else {
        files.push({
          path,
          name: extractNameFromKey(path),
          isDirectory: filesList[key].isDirectory
        });
      }
    });
    return [...folders, ...files];
  };

  const extractNameFromKey = key => {
    const keyPath = key.split('/');
    return keyPath[keyPath.length - 1];
  };

  const extractParentFromKey = key => {
    if (!key) return;
    const keyPath = key.split('/');
    keyPath.pop();
    return keyPath.join('/');
  };

  const createNewFile = newFilePath => {
    const fileManager = state.fileManager;
    helper.createNonClashingName(newFilePath, filesProvider, async (error, newName) => {
      if (error) {
        modal('Create File Failed', error, {
          label: 'Close',
          fn: async () => {}
        }, null);
      } else {
        const createFile = await fileManager.writeFile(newName, '');

        if (!createFile) {
          return toast('Failed to create file ' + newName);
        } else {
          await fileManager.open(newName);
          setState(prevState => {
            return { ...prevState,
              focusElement: [{
                key: newName,
                type: 'file'
              }]
            };
          });
        }
      }
    });
  };

  const createNewFolder = async newFolderPath => {
    const fileManager = state.fileManager;
    const dirName = newFolderPath + '/';

    try {
      const exists = await fileManager.exists(dirName);
      if (exists) return;
      await fileManager.mkdir(dirName);
      setState(prevState => {
        return { ...prevState,
          focusElement: [{
            key: newFolderPath,
            type: 'folder'
          }]
        };
      });
    } catch (e) {
      console.log('error: ', e);
      toast('Failed to create folder: ' + newFolderPath);
    }
  };

  const deletePath = async path => {
    if (filesProvider.isReadOnly(path)) {
      return toast('cannot delete file. ' + name + ' is a read only explorer');
    }

    const isDir = state.fileManager.isDirectory(path);
    modal(`Delete ${isDir ? 'folder' : 'file'}`, `Are you sure you want to delete ${path} ${isDir ? 'folder' : 'file'}?`, {
      label: 'Ok',
      fn: async () => {
        try {
          const fileManager = state.fileManager;
          await fileManager.remove(path);
        } catch (e) {
          toast(`Failed to remove ${isDir ? 'folder' : 'file'} ${path}.`);
        }
      }
    }, {
      label: 'Cancel',
      fn: () => {}
    });
  };

  const renamePath = async (oldPath, newPath) => {
    try {
      const fileManager = state.fileManager;
      const exists = await fileManager.exists(newPath);

      if (exists) {
        modal('Rename File Failed', 'File name already exists', {
          label: 'Close',
          fn: () => {}
        }, null);
      } else {
        await fileManager.rename(oldPath, newPath);
      }
    } catch (error) {
      modal('Rename File Failed', 'Unexpected error while renaming: ' + error, {
        label: 'Close',
        fn: async () => {}
      }, null);
    }
  };

  const removePath = (path, files) => {
    return files.map(file => {
      if (file.path === path) {
        return null;
      } else if (file.child) {
        const childFiles = removePath(path, file.child);
        file.child = childFiles.filter(file => file);
        return file;
      } else {
        return file;
      }
    });
  };

  const fileAdded = async filePath => {
    const pathArr = filePath.split('/');
    const expandPath = pathArr.map((path, index) => {
      return [...pathArr.slice(0, index)].join('/');
    }).filter(path => path && path !== props.name);
    const files = await fetchDirectoryContent(props.name);
    setState(prevState => {
      const uniquePaths = [...new Set([...prevState.expandPath, ...expandPath])];
      return { ...prevState,
        files,
        expandPath: uniquePaths
      };
    });

    if (filePath.includes('_test.sol')) {
      plugin.event.trigger('newTestFileCreated', [filePath]);
    }
  };

  const folderAdded = async folderPath => {
    const pathArr = folderPath.split('/');
    const expandPath = pathArr.map((path, index) => {
      return [...pathArr.slice(0, index)].join('/');
    }).filter(path => path && path !== props.name);
    const files = await fetchDirectoryContent(props.name);
    setState(prevState => {
      const uniquePaths = [...new Set([...prevState.expandPath, ...expandPath])];
      return { ...prevState,
        files,
        expandPath: uniquePaths
      };
    });
  };

  const fileExternallyChanged = (path, file) => {
    const config = registry.get('config').api;
    const editor = registry.get('editor').api;

    if (config.get('currentFile') === path && editor.currentContent() !== file.content) {
      if (filesProvider.isReadOnly(path)) return editor.setText(file.content);
      modal(path + ' changed', 'This file has been changed outside of Remix IDE.', {
        label: 'Replace by the new content',
        fn: () => {
          editor.setText(file.content);
        }
      }, {
        label: 'Keep the content displayed in Remix',
        fn: () => {}
      });
    }
  };

  const fileRemoved = filePath => {
    const files = removePath(filePath, state.files);
    const updatedFiles = files.filter(file => file);
    setState(prevState => {
      return { ...prevState,
        files: updatedFiles
      };
    });
  };

  const fileRenamed = async () => {
    const files = await fetchDirectoryContent(props.name);
    setState(prevState => {
      return { ...prevState,
        files,
        expandPath: [...prevState.expandPath]
      };
    });
  }; // register to event of the file provider
  // files.event.register('fileRenamed', fileRenamed)


  const fileRenamedError = error => {
    modal('File Renamed Failed', error, {
      label: 'Close',
      fn: () => {}
    }, null);
  }; // register to event of the file provider
  // files.event.register('rootFolderChanged', rootFolderChanged)


  const rootFolderChanged = async () => {
    const files = await fetchDirectoryContent(name);
    setState(prevState => {
      return { ...prevState,
        files
      };
    });
  };

  const uploadFile = target => {
    // TODO The file explorer is merely a view on the current state of
    // the files module. Please ask the user here if they want to overwrite
    // a file and then just use `files.add`. The file explorer will
    // pick that up via the 'fileAdded' event from the files module.
    [...target.files].forEach(file => {
      const loadFile = name => {
        const fileReader = new FileReader();

        fileReader.onload = async function (event) {
          if (helper.checkSpecialChars(file.name)) {
            modal('File Upload Failed', 'Special characters are not allowed', {
              label: 'Close',
              fn: async () => {}
            }, null);
            return;
          }

          const success = await filesProvider.set(name, event.target.result);

          if (!success) {
            return modal('File Upload Failed', 'Failed to create file ' + name, {
              label: 'Close',
              fn: async () => {}
            }, null);
          }

          const config = registry.get('config').api;
          const editor = registry.get('editor').api;

          if (config.get('currentFile') === name && editor.currentContent() !== event.target.result) {
            editor.setText(event.target.result);
          }
        };

        fileReader.readAsText(file);
      };

      const name = filesProvider.type + '/' + file.name;
      filesProvider.exists(name, (error, exist) => {
        if (error) console.log(error);

        if (!exist) {
          loadFile(name);
        } else {
          modal('Confirm overwrite', `The file ${name} already exists! Would you like to overwrite it?`, {
            label: 'Ok',
            fn: () => {
              loadFile(name);
            }
          }, {
            label: 'Cancel',
            fn: () => {}
          });
        }
      });
    });
  };

  const publishToGist = () => {
    modal('Create a public gist', 'Are you sure you want to publish all your files in browser directory anonymously as a public gist on github.com? Note: this will not include directories.', {
      label: 'Ok',
      fn: toGist
    }, {
      label: 'Cancel',
      fn: () => {}
    });
  };

  const toGist = id => {
    const proccedResult = function (error, data) {
      if (error) {
        modal('Publish to gist Failed', 'Failed to manage gist: ' + error, {
          label: 'Close',
          fn: async () => {}
        }, null);
      } else {
        if (data.html_url) {
          modal('Gist is ready', `The gist is at ${data.html_url}. Would you like to open it in a new window?`, {
            label: 'Ok',
            fn: () => {
              window.open(data.html_url, '_blank');
            }
          }, {
            label: 'Cancel',
            fn: () => {}
          });
        } else {
          modal('Publish to gist Failed', data.message + ' ' + data.documentation_url + ' ' + JSON.stringify(data.errors, null, '\t'), {
            label: 'Close',
            fn: async () => {}
          }, null);
        }
      }
    };
    /**
       * This function is to get the original content of given gist
       * @params id is the gist id to fetch
       */


    const getOriginalFiles = async id => {
      if (!id) {
        return [];
      }

      const url = `https://api.github.com/gists/${id}`;
      const res = await fetch(url);
      const data = await res.json();
      return data.files || [];
    }; // If 'id' is not defined, it is not a gist update but a creation so we have to take the files from the browser explorer.


    const folder = id ? 'browser/gists/' + id : 'browser/';
    packageFiles(filesProvider, folder, async (error, packaged) => {
      if (error) {
        console.log(error);
        modal('Publish to gist Failed', 'Failed to create gist: ' + error.message, {
          label: 'Close',
          fn: async () => {}
        }, null);
      } else {
        // check for token
        const config = registry.get('config').api;
        const accessToken = config.get('settings/gist-access-token');

        if (!accessToken) {
          modal('Authorize Token', 'Remix requires an access token (which includes gists creation permission). Please go to the settings tab to create one.', {
            label: 'Close',
            fn: async () => {}
          }, null);
        } else {
          const description = 'Created using remix-ide: Realtime Ethereum Contract Compiler and Runtime. \n Load this file by pasting this gists URL or ID at https://remix.ethereum.org/#version=' + queryParams.get().version + '&optimize=' + queryParams.get().optimize + '&runs=' + queryParams.get().runs + '&gist=';
          const gists = new _gists.default({
            token: accessToken
          });

          if (id) {
            const originalFileList = await getOriginalFiles(id); // Telling the GIST API to remove files

            const updatedFileList = Object.keys(packaged);
            const allItems = Object.keys(originalFileList).filter(fileName => updatedFileList.indexOf(fileName) === -1).reduce((acc, deleteFileName) => ({ ...acc,
              [deleteFileName]: null
            }), originalFileList); // adding new files

            updatedFileList.forEach(file => {
              const _items = file.split('/');

              const _fileName = _items[_items.length - 1];
              allItems[_fileName] = packaged[file];
            });
            toast('Saving gist (' + id + ') ...');
            gists.edit({
              description: description,
              public: true,
              files: allItems,
              id: id
            }, (error, result) => {
              proccedResult(error, result);

              if (!error) {
                for (const key in allItems) {
                  if (allItems[key] === null) delete allItems[key];
                }
              }
            });
          } else {
            // id is not existing, need to create a new gist
            toast('Creating a new gist ...');
            gists.create({
              description: description,
              public: true,
              files: packaged
            }, (error, result) => {
              proccedResult(error, result);
            });
          }
        }
      }
    });
  };

  const runScript = async path => {
    filesProvider.get(path, (error, content) => {
      if (error) return console.log(error);
      plugin.call('scriptRunner', 'execute', content);
    });
  };

  const emitContextMenuEvent = (id, path) => {
    plugin.emit(id, path);
  };

  const handleHideModal = () => {
    setState(prevState => {
      return { ...prevState,
        focusModal: { ...state.focusModal,
          hide: true
        }
      };
    });
  };

  const modal = (title, message, ok, cancel) => {
    setState(prevState => {
      return { ...prevState,
        modals: [...prevState.modals, {
          message,
          title,
          ok,
          cancel,
          handleHide: handleHideModal
        }]
      };
    });
  };

  const toast = message => {
    setState(prevState => {
      return { ...prevState,
        toasterMsg: message
      };
    });
  };

  const handleClickFile = path => {
    state.fileManager.open(path);
    setState(prevState => {
      return { ...prevState,
        focusElement: [{
          key: path,
          type: 'file'
        }]
      };
    });
  };

  const handleClickFolder = async path => {
    if (state.ctrlKey) {
      if (state.focusElement.findIndex(item => item.key === path) !== -1) {
        setState(prevState => {
          return { ...prevState,
            focusElement: [...prevState.focusElement.filter(item => item.key !== path)]
          };
        });
      } else {
        setState(prevState => {
          return { ...prevState,
            focusElement: [...prevState.focusElement, {
              key: path,
              type: 'folder'
            }]
          };
        });
      }
    } else {
      let expandPath = [];

      if (!state.expandPath.includes(path)) {
        expandPath = [...new Set([...state.expandPath, path])];
      } else {
        expandPath = [...new Set(state.expandPath.filter(key => key && typeof key === 'string' && !key.startsWith(path)))];
      }

      setState(prevState => {
        return { ...prevState,
          focusElement: [{
            key: path,
            type: 'folder'
          }],
          expandPath
        };
      });
    }
  };

  const handleContextMenuFile = (pageX, pageY, path, content) => {
    if (!content) return;
    setState(prevState => {
      return { ...prevState,
        focusContext: {
          element: path,
          x: pageX,
          y: pageY
        },
        focusEdit: { ...prevState.focusEdit,
          lastEdit: content
        }
      };
    });
  };

  const handleContextMenuFolder = (pageX, pageY, path, content) => {
    if (!content) return;
    setState(prevState => {
      return { ...prevState,
        focusContext: {
          element: path,
          x: pageX,
          y: pageY
        },
        focusEdit: { ...prevState.focusEdit,
          lastEdit: content
        }
      };
    });
  };

  const hideContextMenu = () => {
    setState(prevState => {
      return { ...prevState,
        focusContext: {
          element: null,
          x: 0,
          y: 0
        }
      };
    });
  };

  const editModeOn = (path, type, isNew = false) => {
    if (filesProvider.isReadOnly(path)) return;
    setState(prevState => {
      return { ...prevState,
        focusEdit: { ...prevState.focusEdit,
          element: path,
          isNew,
          type
        }
      };
    });
  };

  const editModeOff = async content => {
    if (typeof content === 'string') content = content.trim();
    const parentFolder = extractParentFromKey(state.focusEdit.element);

    if (!content || content.trim() === '') {
      if (state.focusEdit.isNew) {
        const files = removePath(state.focusEdit.element, state.files);
        const updatedFiles = files.filter(file => file);
        setState(prevState => {
          return { ...prevState,
            files: updatedFiles,
            focusEdit: {
              element: null,
              isNew: false,
              type: '',
              lastEdit: ''
            }
          };
        });
      } else {
        editRef.current.textContent = state.focusEdit.lastEdit;
        setState(prevState => {
          return { ...prevState,
            focusEdit: {
              element: null,
              isNew: false,
              type: '',
              lastEdit: ''
            }
          };
        });
      }
    } else {
      if (state.focusEdit.lastEdit === content) {
        editRef.current.textContent = content;
        return setState(prevState => {
          return { ...prevState,
            focusEdit: {
              element: null,
              isNew: false,
              type: '',
              lastEdit: ''
            }
          };
        });
      }

      if (helper.checkSpecialChars(content)) {
        modal('Validation Error', 'Special characters are not allowed', {
          label: 'Ok',
          fn: () => {}
        }, null);
      } else {
        if (state.focusEdit.isNew) {
          state.focusEdit.type === 'file' ? createNewFile(parentFolder + '/' + content) : createNewFolder(parentFolder + '/' + content);
          const files = removePath(state.focusEdit.element, state.files);
          const updatedFiles = files.filter(file => file);
          setState(prevState => {
            return { ...prevState,
              files: updatedFiles
            };
          });
        } else {
          const oldPath = state.focusEdit.element;
          const oldName = extractNameFromKey(oldPath);
          const newPath = oldPath.replace(oldName, content);
          editRef.current.textContent = extractNameFromKey(oldPath);
          renamePath(oldPath, newPath);
        }

        setState(prevState => {
          return { ...prevState,
            focusEdit: {
              element: null,
              isNew: false,
              type: '',
              lastEdit: ''
            }
          };
        });
      }
    }
  };

  const handleNewFileInput = async parentFolder => {
    if (!parentFolder) parentFolder = state.focusElement[0] ? state.focusElement[0].type === 'folder' ? state.focusElement[0].key : extractParentFromKey(state.focusElement[0].key) : name;
    const expandPath = [...new Set([...state.expandPath, parentFolder])];
    setState(prevState => {
      return { ...prevState,
        expandPath
      };
    });
    editModeOn(parentFolder + '/blank', 'file', true);
  };

  const handleNewFolderInput = async parentFolder => {
    if (!parentFolder) parentFolder = state.focusElement[0] ? state.focusElement[0].type === 'folder' ? state.focusElement[0].key : extractParentFromKey(state.focusElement[0].key) : name;else if (parentFolder.indexOf('.sol') !== -1 || parentFolder.indexOf('.js') !== -1) parentFolder = extractParentFromKey(parentFolder);
    const expandPath = [...new Set([...state.expandPath, parentFolder])];
    setState(prevState => {
      return { ...prevState,
        expandPath
      };
    });
    editModeOn(parentFolder + '/blank', 'folder', true);
  };

  const handleEditInput = event => {
    if (event.which === 13) {
      event.preventDefault();
      editModeOff(editRef.current.innerText);
    }
  };

  const label = file => {
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "remixui_items d-inline-block w-100",
      ref: state.focusEdit.element === file.path ? editRef : null,
      suppressContentEditableWarning: true,
      contentEditable: state.focusEdit.element === file.path,
      onKeyDown: handleEditInput,
      onBlur: e => {
        e.stopPropagation();
        editModeOff(editRef.current.innerText);
      }
    }, /*#__PURE__*/_react.default.createElement("span", {
      title: file.path,
      className: 'remixui_label ' + (file.isDirectory ? 'folder' : 'remixui_leaf'),
      "data-path": file.path
    }, file.name));
  };

  const renderFiles = (file, index) => {
    if (file.isDirectory) {
      return /*#__PURE__*/_react.default.createElement("div", {
        key: index
      }, /*#__PURE__*/_react.default.createElement(_treeView.TreeViewItem, {
        id: `treeViewItem${file.path}`,
        iconX: "pr-3 fa fa-folder",
        iconY: "pr-3 fa fa-folder-open",
        key: `${file.path + index}`,
        label: label(file),
        onClick: e => {
          e.stopPropagation();
          if (state.focusEdit.element !== file.path) handleClickFolder(file.path);
        },
        onContextMenu: e => {
          e.preventDefault();
          e.stopPropagation();
          handleContextMenuFolder(e.pageX, e.pageY, file.path, e.target.textContent);
        },
        labelClass: state.focusEdit.element === file.path ? 'bg-light' : state.focusElement.findIndex(item => item.key === file.path) !== -1 ? 'bg-secondary' : '',
        controlBehaviour: state.ctrlKey,
        expand: state.expandPath.includes(file.path)
      }, file.child ? /*#__PURE__*/_react.default.createElement(_treeView.TreeView, {
        id: `treeView${file.path}`,
        key: index
      }, file.child.map((file, index) => {
        return renderFiles(file, index);
      })) : /*#__PURE__*/_react.default.createElement(_treeView.TreeView, {
        id: `treeView${file.path}`,
        key: index
      })), state.focusContext.element === file.path && state.focusEdit.element !== file.path && /*#__PURE__*/_react.default.createElement(_fileExplorerContextMenu.FileExplorerContextMenu, {
        actions: state.actions,
        hideContextMenu: hideContextMenu,
        createNewFile: handleNewFileInput,
        createNewFolder: handleNewFolderInput,
        deletePath: deletePath,
        renamePath: editModeOn,
        publishToGist: publishToGist,
        emit: emitContextMenuEvent,
        pageX: state.focusContext.x,
        pageY: state.focusContext.y,
        path: file.path,
        type: "folder"
      }));
    } else {
      return /*#__PURE__*/_react.default.createElement("div", {
        key: index
      }, /*#__PURE__*/_react.default.createElement(_treeView.TreeViewItem, {
        id: `treeViewItem${file.path}`,
        key: index,
        label: label(file),
        onClick: e => {
          e.stopPropagation();
          if (state.focusEdit.element !== file.path) handleClickFile(file.path);
        },
        onContextMenu: e => {
          e.preventDefault();
          e.stopPropagation();
          handleContextMenuFile(e.pageX, e.pageY, file.path, e.target.textContent);
        },
        icon: "far fa-file",
        labelClass: state.focusEdit.element === file.path ? 'bg-light' : state.focusElement.findIndex(item => item.key === file.path) !== -1 ? 'bg-secondary' : ''
      }), state.focusContext.element === file.path && state.focusEdit.element !== file.path && /*#__PURE__*/_react.default.createElement(_fileExplorerContextMenu.FileExplorerContextMenu, {
        actions: state.actions,
        hideContextMenu: hideContextMenu,
        createNewFile: handleNewFileInput,
        createNewFolder: handleNewFolderInput,
        deletePath: deletePath,
        renamePath: editModeOn,
        runScript: runScript,
        emit: emitContextMenuEvent,
        pageX: state.focusContext.x,
        pageY: state.focusContext.y,
        path: file.path,
        type: "file"
      }));
    }
  };

  return /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement(_treeView.TreeView, {
    id: "treeView"
  }, /*#__PURE__*/_react.default.createElement(_treeView.TreeViewItem, {
    id: "treeViewItem",
    label: /*#__PURE__*/_react.default.createElement("div", {
      onClick: e => {
        e.stopPropagation();
        let expandPath = [];

        if (!state.expandPath.includes(props.name)) {
          expandPath = [props.name, ...new Set([...state.expandPath])];
        } else {
          expandPath = [...new Set(state.expandPath.filter(key => key && typeof key === 'string' && !key.startsWith(props.name)))];
        }

        setState(prevState => {
          return { ...prevState,
            expandPath
          };
        });
        plugin.resetFocus(true);
      }
    }, /*#__PURE__*/_react.default.createElement(_fileExplorerMenu.FileExplorerMenu, {
      title: name,
      menuItems: props.menuItems,
      createNewFile: handleNewFileInput,
      createNewFolder: handleNewFolderInput,
      publishToGist: publishToGist,
      uploadFile: uploadFile,
      fileManager: state.fileManager
    })),
    expand: state.expandPath.includes(props.name)
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "pb-2"
  }, /*#__PURE__*/_react.default.createElement(_treeView.TreeView, {
    id: "treeViewMenu"
  }, state.files.map((file, index) => {
    return renderFiles(file, index);
  }))))), props.name && /*#__PURE__*/_react.default.createElement(_modalDialog.ModalDialog, {
    id: props.name,
    title: state.focusModal.title,
    message: state.focusModal.message,
    hide: state.focusModal.hide,
    ok: state.focusModal.ok,
    cancel: state.focusModal.cancel,
    handleHide: handleHideModal
  }), /*#__PURE__*/_react.default.createElement(_toaster.Toaster, {
    message: state.toasterMsg
  }));
};

exports.FileExplorer = FileExplorer;
var _default = FileExplorer;
exports.default = _default;

function packageFiles(filesProvider, directory, callback) {
  const ret = {};
  filesProvider.resolveDirectory(directory, (error, files) => {
    if (error) callback(error);else {
      async.eachSeries(Object.keys(files), (path, cb) => {
        if (filesProvider.isDirectory(path)) {
          cb();
        } else {
          filesProvider.get(path, (error, content) => {
            if (error) return cb(error);

            if (/^\s+$/.test(content) || !content.length) {
              content = '// this line is added to create a gist. Empty file is not allowed.';
            }

            ret[path] = {
              content
            };
            cb();
          });
        }
      }, error => {
        callback(error, ret);
      });
    }
  });
}

/***/ }),

/***/ "../../../libs/remix-ui/modal-dialog/src/index.ts":
/*!****************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/modal-dialog/src/index.ts ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _modalDialogCustom = __webpack_require__(/*! ./lib/modal-dialog-custom */ "../../../libs/remix-ui/modal-dialog/src/lib/modal-dialog-custom.tsx");

Object.keys(_modalDialogCustom).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _modalDialogCustom[key];
    }
  });
});

var _remixUiModalDialog = __webpack_require__(/*! ./lib/remix-ui-modal-dialog */ "../../../libs/remix-ui/modal-dialog/src/lib/remix-ui-modal-dialog.tsx");

Object.keys(_remixUiModalDialog).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _remixUiModalDialog[key];
    }
  });
});

/***/ }),

/***/ "../../../libs/remix-ui/modal-dialog/src/lib/modal-dialog-custom.css":
/*!***********************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/modal-dialog/src/lib/modal-dialog-custom.css ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../../../../node_modules/postcss-loader/src??embedded!./modal-dialog-custom.css */ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/modal-dialog/src/lib/modal-dialog-custom.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "../../../libs/remix-ui/modal-dialog/src/lib/modal-dialog-custom.tsx":
/*!***********************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/modal-dialog/src/lib/modal-dialog-custom.tsx ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ModalDialogCustom = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

__webpack_require__(/*! ./modal-dialog-custom.css */ "../../../libs/remix-ui/modal-dialog/src/lib/modal-dialog-custom.css");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
const ModalDialogCustom = props => {
  return /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("h1", null, "Welcome to modal-dialog-custom!"));
};

exports.ModalDialogCustom = ModalDialogCustom;
var _default = ModalDialogCustom;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/modal-dialog/src/lib/remix-ui-modal-dialog.css":
/*!*************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/modal-dialog/src/lib/remix-ui-modal-dialog.css ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../../../../node_modules/postcss-loader/src??embedded!./remix-ui-modal-dialog.css */ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/modal-dialog/src/lib/remix-ui-modal-dialog.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "../../../libs/remix-ui/modal-dialog/src/lib/remix-ui-modal-dialog.tsx":
/*!*************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/modal-dialog/src/lib/remix-ui-modal-dialog.tsx ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ModalDialog = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

__webpack_require__(/*! ./remix-ui-modal-dialog.css */ "../../../libs/remix-ui/modal-dialog/src/lib/remix-ui-modal-dialog.css");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
const ModalDialog = props => {
  const [state, setState] = (0, _react.useState)({
    toggleBtn: true
  });
  const modal = (0, _react.useRef)(null);

  const handleHide = () => {
    props.handleHide();
  };

  (0, _react.useEffect)(() => {
    modal.current.focus();
  }, [props.hide]);

  const modalKeyEvent = keyCode => {
    if (keyCode === 27) {
      // Esc
      if (props.cancel && props.cancel.fn) props.cancel.fn();
      handleHide();
    } else if (keyCode === 13) {
      // Enter
      enterHandler();
    } else if (keyCode === 37) {
      // todo && footerIsActive) { // Arrow Left
      setState(prevState => {
        return { ...prevState,
          toggleBtn: true
        };
      });
    } else if (keyCode === 39) {
      // todo && footerIsActive) { // Arrow Right
      setState(prevState => {
        return { ...prevState,
          toggleBtn: false
        };
      });
    }
  };

  const enterHandler = () => {
    if (state.toggleBtn) {
      if (props.ok && props.ok.fn) props.ok.fn();
    } else {
      if (props.cancel && props.cancel.fn) props.cancel.fn();
    }

    handleHide();
  };

  return /*#__PURE__*/_react.default.createElement("div", {
    "data-id": `${props.id}ModalDialogContainer-react`,
    "data-backdrop": "static",
    "data-keyboard": "false",
    className: "modal",
    style: {
      display: props.hide ? 'none' : 'block'
    },
    role: "dialog"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "modal-dialog",
    role: "document"
  }, /*#__PURE__*/_react.default.createElement("div", {
    onBlur: e => {
      e.stopPropagation();
      handleHide();
    },
    ref: modal,
    tabIndex: -1,
    className: 'modal-content remixModalContent ' + (props.modalClass ? props.modalClass : ''),
    onKeyDown: ({
      keyCode
    }) => {
      modalKeyEvent(keyCode);
    }
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "modal-header"
  }, /*#__PURE__*/_react.default.createElement("h6", {
    className: "modal-title",
    "data-id": `${props.id}ModalDialogModalTitle-react`
  }, props.title && props.title), !props.showCancelIcon && /*#__PURE__*/_react.default.createElement("span", {
    className: "modal-close",
    onClick: () => handleHide()
  }, /*#__PURE__*/_react.default.createElement("i", {
    title: "Close",
    className: "fas fa-times",
    "aria-hidden": "true"
  }))), /*#__PURE__*/_react.default.createElement("div", {
    className: "modal-body text-break remixModalBody",
    "data-id": `${props.id}ModalDialogModalBody-react`
  }, props.children ? props.children : props.message), /*#__PURE__*/_react.default.createElement("div", {
    className: "modal-footer",
    "data-id": `${props.id}ModalDialogModalFooter-react`
  }, props.ok && /*#__PURE__*/_react.default.createElement("span", {
    "data-id": `${props.id}-modal-footer-ok-react`,
    className: 'modal-ok btn btn-sm ' + (state.toggleBtn ? 'btn-dark' : 'btn-light'),
    onClick: () => {
      if (props.ok.fn) props.ok.fn();
      handleHide();
    }
  }, props.ok.label ? props.ok.label : 'OK'), props.cancel && /*#__PURE__*/_react.default.createElement("span", {
    "data-id": `${props.id}-modal-footer-cancel-react`,
    className: 'modal-cancel btn btn-sm ' + (state.toggleBtn ? 'btn-light' : 'btn-dark'),
    "data-dismiss": "modal",
    onClick: () => {
      if (props.cancel.fn) props.cancel.fn();
      handleHide();
    }
  }, props.cancel.label ? props.cancel.label : 'Cancel')))));
};

exports.ModalDialog = ModalDialog;
var _default = ModalDialog;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/toaster/src/index.ts":
/*!***********************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/toaster/src/index.ts ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toaster = __webpack_require__(/*! ./lib/toaster */ "../../../libs/remix-ui/toaster/src/lib/toaster.tsx");

Object.keys(_toaster).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _toaster[key];
    }
  });
});

/***/ }),

/***/ "../../../libs/remix-ui/toaster/src/lib/toaster.css":
/*!******************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/toaster/src/lib/toaster.css ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../../../../node_modules/postcss-loader/src??embedded!./toaster.css */ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/toaster/src/lib/toaster.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "../../../libs/remix-ui/toaster/src/lib/toaster.tsx":
/*!******************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/toaster/src/lib/toaster.tsx ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Toaster = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _modalDialog = __webpack_require__(/*! @remix-ui/modal-dialog */ "../../../libs/remix-ui/modal-dialog/src/index.ts");

__webpack_require__(/*! ./toaster.css */ "../../../libs/remix-ui/toaster/src/lib/toaster.css");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// eslint-disable-line
const Toaster = props => {
  const [state, setState] = (0, _react.useState)({
    message: '',
    hide: true,
    hiding: false,
    timeOutId: null,
    timeOut: props.timeOut || 7000,
    showModal: false
  });
  (0, _react.useEffect)(() => {
    if (props.message) {
      const timeOutId = setTimeout(() => {
        setState(prevState => {
          return { ...prevState,
            hiding: true
          };
        });
      }, state.timeOut);
      setState(prevState => {
        const shortTooltipText = props.message.length > 201 ? props.message.substring(0, 200) + '...' : props.message;
        return { ...prevState,
          hide: false,
          hiding: false,
          timeOutId,
          message: shortTooltipText
        };
      });
    }
  }, [props.message]);
  (0, _react.useEffect)(() => {
    if (state.hiding) {
      setTimeout(() => {
        closeTheToaster();
      }, 1800);
    }
  }, [state.hiding]);

  const showFullMessage = () => {
    setState(prevState => {
      return { ...prevState,
        showModal: true
      };
    });
  };

  const hideFullMessage = () => {
    //eslint-disable-line
    setState(prevState => {
      return { ...prevState,
        showModal: false
      };
    });
  };

  const closeTheToaster = () => {
    if (state.timeOutId) {
      clearTimeout(state.timeOutId);
    }

    setState(prevState => {
      return { ...prevState,
        message: '',
        hide: true,
        hiding: false,
        timeOutId: null,
        showModal: false
      };
    });
  };

  const handleMouseEnter = () => {
    if (state.timeOutId) {
      clearTimeout(state.timeOutId);
    }

    setState(prevState => {
      return { ...prevState,
        timeOutId: null
      };
    });
  };

  const handleMouseLeave = () => {
    if (!state.timeOutId) {
      const timeOutId = setTimeout(() => {
        setState(prevState => {
          return { ...prevState,
            hiding: true
          };
        });
      }, state.timeOut);
      setState(prevState => {
        return { ...prevState,
          timeOutId
        };
      });
    }
  };

  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_modalDialog.ModalDialog, {
    message: props.message,
    cancel: {
      label: 'Close',
      fn: () => {}
    },
    hide: !state.showModal,
    handleHide: hideFullMessage
  }), !state.hide && /*#__PURE__*/_react.default.createElement("div", {
    "data-shared": "tooltipPopup",
    className: `remixui_tooltip alert alert-info p-2 ${state.hiding ? 'remixui_animateTop' : 'remixui_animateBottom'}`,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave
  }, /*#__PURE__*/_react.default.createElement("span", {
    className: "px-2"
  }, state.message, props.message.length > 201 && /*#__PURE__*/_react.default.createElement("button", {
    className: "btn btn-secondary btn-sm mx-3",
    style: {
      whiteSpace: 'nowrap'
    },
    onClick: showFullMessage
  }, "Show full message")), /*#__PURE__*/_react.default.createElement("span", {
    style: {
      alignSelf: 'baseline'
    }
  }, /*#__PURE__*/_react.default.createElement("button", {
    "data-id": "tooltipCloseButton",
    className: "fas fa-times btn-info mx-1 p-0",
    onClick: closeTheToaster
  }))));
};

exports.Toaster = Toaster;
var _default = Toaster;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/tree-view/src/index.ts":
/*!*************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/tree-view/src/index.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _treeViewItem = __webpack_require__(/*! ./lib/tree-view-item/tree-view-item */ "../../../libs/remix-ui/tree-view/src/lib/tree-view-item/tree-view-item.tsx");

Object.keys(_treeViewItem).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _treeViewItem[key];
    }
  });
});

var _remixUiTreeView = __webpack_require__(/*! ./lib/remix-ui-tree-view */ "../../../libs/remix-ui/tree-view/src/lib/remix-ui-tree-view.tsx");

Object.keys(_remixUiTreeView).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _remixUiTreeView[key];
    }
  });
});

/***/ }),

/***/ "../../../libs/remix-ui/tree-view/src/lib/remix-ui-tree-view.css":
/*!*******************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/tree-view/src/lib/remix-ui-tree-view.css ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../../../../node_modules/postcss-loader/src??embedded!./remix-ui-tree-view.css */ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/tree-view/src/lib/remix-ui-tree-view.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "../../../libs/remix-ui/tree-view/src/lib/remix-ui-tree-view.tsx":
/*!*******************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/tree-view/src/lib/remix-ui-tree-view.tsx ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TreeView = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

__webpack_require__(/*! ./remix-ui-tree-view.css */ "../../../libs/remix-ui/tree-view/src/lib/remix-ui-tree-view.css");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TreeView = props => {
  const {
    children,
    id,
    ...otherProps
  } = props;
  return /*#__PURE__*/_react.default.createElement("ul", Object.assign({
    "data-id": `treeViewUl${id}`,
    className: "ul_tv ml-0 px-2"
  }, otherProps), children);
};

exports.TreeView = TreeView;
var _default = TreeView;
exports.default = _default;

/***/ }),

/***/ "../../../libs/remix-ui/tree-view/src/lib/tree-view-item/tree-view-item.css":
/*!******************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/tree-view/src/lib/tree-view-item/tree-view-item.css ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../../../../../node_modules/postcss-loader/src??embedded!./tree-view-item.css */ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/tree-view/src/lib/tree-view-item/tree-view-item.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "../../../libs/remix-ui/tree-view/src/lib/tree-view-item/tree-view-item.tsx":
/*!******************************************************************************************************!*\
  !*** /home/circleci/remix-project/libs/remix-ui/tree-view/src/lib/tree-view-item/tree-view-item.tsx ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TreeViewItem = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

__webpack_require__(/*! ./tree-view-item.css */ "../../../libs/remix-ui/tree-view/src/lib/tree-view-item/tree-view-item.css");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const TreeViewItem = props => {
  const {
    id,
    children,
    label,
    labelClass,
    expand,
    iconX = 'fas fa-caret-right',
    iconY = 'fas fa-caret-down',
    icon,
    controlBehaviour = false,
    innerRef,
    ...otherProps
  } = props;
  const [isExpanded, setIsExpanded] = (0, _react.useState)(false);
  (0, _react.useEffect)(() => {
    setIsExpanded(expand);
  }, [expand]);
  return /*#__PURE__*/_react.default.createElement("li", Object.assign({
    ref: innerRef,
    key: `treeViewLi${id}`,
    "data-id": `treeViewLi${id}`,
    className: "li_tv"
  }, otherProps), /*#__PURE__*/_react.default.createElement("div", {
    key: `treeViewDiv${id}`,
    "data-id": `treeViewDiv${id}`,
    className: `d-flex flex-row align-items-center ${labelClass}`,
    onClick: () => !controlBehaviour && setIsExpanded(!isExpanded)
  }, children ? /*#__PURE__*/_react.default.createElement("div", {
    className: isExpanded ? `px-1 ${iconY} caret caret_tv` : `px-1 ${iconX} caret caret_tv`,
    style: {
      visibility: children ? 'visible' : 'hidden'
    }
  }) : icon ? /*#__PURE__*/_react.default.createElement("div", {
    className: `pr-3 pl-1 ${icon} caret caret_tv`
  }) : null, /*#__PURE__*/_react.default.createElement("span", {
    className: "w-100 pl-1"
  }, label)), isExpanded ? children : null);
};

exports.TreeViewItem = TreeViewItem;
var _default = TreeViewItem;
exports.default = _default;

/***/ }),

/***/ "../../../node_modules/@nrwl/web/node_modules/regenerator-runtime/runtime.js":
/*!*******************************************************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/@nrwl/web/node_modules/regenerator-runtime/runtime.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "../../../node_modules/colors/lib sync recursive":
/*!*****************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/colors/lib sync ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "../../../node_modules/colors/lib sync recursive";

/***/ }),

/***/ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/clipboard/src/lib/copy-to-clipboard/copy-to-clipboard.css":
/*!***********************************************************************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/postcss-loader/src??embedded!/home/circleci/remix-project/libs/remix-ui/clipboard/src/lib/copy-to-clipboard/copy-to-clipboard.css ***!
  \***********************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".copyIcon {\n    margin-left: 5px;\n    cursor: pointer;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYnMvcmVtaXgtdWkvY2xpcGJvYXJkL3NyYy9saWIvY29weS10by1jbGlwYm9hcmQvY29weS10by1jbGlwYm9hcmQuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0lBQ0ksZ0JBQWdCO0lBQ2hCLGVBQWU7QUFDbkIiLCJmaWxlIjoibGlicy9yZW1peC11aS9jbGlwYm9hcmQvc3JjL2xpYi9jb3B5LXRvLWNsaXBib2FyZC9jb3B5LXRvLWNsaXBib2FyZC5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuY29weUljb24ge1xuICAgIG1hcmdpbi1sZWZ0OiA1cHg7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xufSJdfQ== */"

/***/ }),

/***/ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/debugger-ui/src/lib/button-navigator/button-navigator.css":
/*!***********************************************************************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/postcss-loader/src??embedded!/home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/button-navigator/button-navigator.css ***!
  \***********************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".buttons {\n    display: flex;\n    flex-wrap: wrap;\n}\n.stepButtons {\n    width: 100%;\n    display: flex;\n    justify-content: center;\n}\n.stepButton {\n}\n.jumpButtons {\n    width: 100%;\n    display: flex;\n    justify-content: center;\n}\n.jumpButton {\n}\n.navigator {\n}\n.navigator:hover {\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYnMvcmVtaXgtdWkvZGVidWdnZXItdWkvc3JjL2xpYi9idXR0b24tbmF2aWdhdG9yL2J1dHRvbi1uYXZpZ2F0b3IuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0lBQ0ksYUFBYTtJQUNiLGVBQWU7QUFDbkI7QUFDQTtJQUNJLFdBQVc7SUFDWCxhQUFhO0lBQ2IsdUJBQXVCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0lBQ0ksV0FBVztJQUNYLGFBQWE7SUFDYix1QkFBdUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoibGlicy9yZW1peC11aS9kZWJ1Z2dlci11aS9zcmMvbGliL2J1dHRvbi1uYXZpZ2F0b3IvYnV0dG9uLW5hdmlnYXRvci5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuYnV0dG9ucyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG59XG4uc3RlcEJ1dHRvbnMge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG4uc3RlcEJ1dHRvbiB7XG59XG4uanVtcEJ1dHRvbnMge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG4uanVtcEJ1dHRvbiB7XG59XG4ubmF2aWdhdG9yIHtcbn1cbi5uYXZpZ2F0b3I6aG92ZXIge1xufSJdfQ== */"

/***/ }),

/***/ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/debugger-ui/src/lib/debugger-ui.css":
/*!*************************************************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/postcss-loader/src??embedded!/home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/debugger-ui.css ***!
  \*************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".statusMessage {\n  margin-left: 15px;\n}\n.debuggerLabel {\n  margin-bottom: 2px;\n  font-size: 11px;\n  line-height: 12px;\n  text-transform: uppercase;\n}\n.debuggerConfig {\n  display: flex;\n  align-items: center;\n}\n.debuggerConfig label {\n  margin: 0;\n}\n.validationError {\n  overflow-wrap: break-word;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYnMvcmVtaXgtdWkvZGVidWdnZXItdWkvc3JjL2xpYi9kZWJ1Z2dlci11aS5jc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRSxpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLGtCQUFrQjtFQUNsQixlQUFlO0VBQ2YsaUJBQWlCO0VBQ2pCLHlCQUF5QjtBQUMzQjtBQUNBO0VBQ0UsYUFBYTtFQUNiLG1CQUFtQjtBQUNyQjtBQUNBO0VBQ0UsU0FBUztBQUNYO0FBQ0E7RUFDRSx5QkFBeUI7QUFDM0IiLCJmaWxlIjoibGlicy9yZW1peC11aS9kZWJ1Z2dlci11aS9zcmMvbGliL2RlYnVnZ2VyLXVpLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi5zdGF0dXNNZXNzYWdlIHtcbiAgbWFyZ2luLWxlZnQ6IDE1cHg7XG59XG4uZGVidWdnZXJMYWJlbCB7XG4gIG1hcmdpbi1ib3R0b206IDJweDtcbiAgZm9udC1zaXplOiAxMXB4O1xuICBsaW5lLWhlaWdodDogMTJweDtcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbn1cbi5kZWJ1Z2dlckNvbmZpZyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG4uZGVidWdnZXJDb25maWcgbGFiZWwge1xuICBtYXJnaW46IDA7XG59XG4udmFsaWRhdGlvbkVycm9yIHtcbiAgb3ZlcmZsb3ctd3JhcDogYnJlYWstd29yZDtcbn0iXX0= */"

/***/ }),

/***/ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/debugger-ui/src/lib/tx-browser/tx-browser.css":
/*!***********************************************************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/postcss-loader/src??embedded!/home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/tx-browser/tx-browser.css ***!
  \***********************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".container {\n    display: flex;\n    flex-direction: column;\n}\n.txContainer {\n    display: flex;\n    flex-direction: column;\n}\n.txinput {\n    width: inherit;\n    font-size: small;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n.txbutton {\n    width: inherit;\n}\n.txbutton:hover {\n}\n.vmargin {\n    margin-top: 10px;\n    margin-bottom: 10px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYnMvcmVtaXgtdWkvZGVidWdnZXItdWkvc3JjL2xpYi90eC1icm93c2VyL3R4LWJyb3dzZXIuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0lBQ0ksYUFBYTtJQUNiLHNCQUFzQjtBQUMxQjtBQUNBO0lBQ0ksYUFBYTtJQUNiLHNCQUFzQjtBQUMxQjtBQUNBO0lBQ0ksY0FBYztJQUNkLGdCQUFnQjtJQUNoQixtQkFBbUI7SUFDbkIsZ0JBQWdCO0lBQ2hCLHVCQUF1QjtBQUMzQjtBQUNBO0lBQ0ksY0FBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtJQUNJLGdCQUFnQjtJQUNoQixtQkFBbUI7QUFDdkIiLCJmaWxlIjoibGlicy9yZW1peC11aS9kZWJ1Z2dlci11aS9zcmMvbGliL3R4LWJyb3dzZXIvdHgtYnJvd3Nlci5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuY29udGFpbmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG59XG4udHhDb250YWluZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cbi50eGlucHV0IHtcbiAgICB3aWR0aDogaW5oZXJpdDtcbiAgICBmb250LXNpemU6IHNtYWxsO1xuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbn1cbi50eGJ1dHRvbiB7XG4gICAgd2lkdGg6IGluaGVyaXQ7XG59XG4udHhidXR0b246aG92ZXIge1xufVxuLnZtYXJnaW4ge1xuICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgbWFyZ2luLWJvdHRvbTogMTBweDtcbn0iXX0= */"

/***/ }),

/***/ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/styles/assembly-items.css":
/*!***********************************************************************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/postcss-loader/src??embedded!/home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/styles/assembly-items.css ***!
  \***********************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".instructions {\n    overflow-y: scroll;\n    max-height: 130px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYnMvcmVtaXgtdWkvZGVidWdnZXItdWkvc3JjL2xpYi92bS1kZWJ1Z2dlci9zdHlsZXMvYXNzZW1ibHktaXRlbXMuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0lBQ0ksa0JBQWtCO0lBQ2xCLGlCQUFpQjtBQUNyQiIsImZpbGUiOiJsaWJzL3JlbWl4LXVpL2RlYnVnZ2VyLXVpL3NyYy9saWIvdm0tZGVidWdnZXIvc3R5bGVzL2Fzc2VtYmx5LWl0ZW1zLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi5pbnN0cnVjdGlvbnMge1xuICAgIG92ZXJmbG93LXk6IHNjcm9sbDtcbiAgICBtYXgtaGVpZ2h0OiAxMzBweDtcbn0iXX0= */"

/***/ }),

/***/ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/debugger-ui/src/lib/vm-debugger/styles/dropdown-panel.css":
/*!***********************************************************************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/postcss-loader/src??embedded!/home/circleci/remix-project/libs/remix-ui/debugger-ui/src/lib/vm-debugger/styles/dropdown-panel.css ***!
  \***********************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".title {\n    display: flex;\n    align-items: center;\n  }\n  .name {\n    font-weight: bold;\n  }\n  .nameDetail {\n    font-weight: bold;\n    margin-left: 3px;\n  }\n  .icon {\n    margin-right: 5%;\n  }\n  .eyeButton {\n    margin: 3px;\n  }\n  .dropdownpanel {\n    width: 100%;\n    word-break: break-word;\n  }\n  .dropdownrawcontent {\n    padding: 2px;\n    word-break: break-word;\n  }\n  .message {\n    padding: 2px;\n    word-break: break-word;\n  }\n  .refresh {\n    display: none;\n    margin-left: 4px;\n    margin-top: 4px; \n    -webkit-animation: spin 2s linear infinite; \n            animation: spin 2s linear infinite;\n  }\n  .cursor_pointer {\n    cursor: pointer;\n  }\n  @-webkit-keyframes spin {\n    to { -webkit-transform: rotate(359deg); }\n  }\n  @keyframes spin {\n    to {transform:rotate(359deg);}\n  }\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYnMvcmVtaXgtdWkvZGVidWdnZXItdWkvc3JjL2xpYi92bS1kZWJ1Z2dlci9zdHlsZXMvZHJvcGRvd24tcGFuZWwuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0lBQ0ksYUFBYTtJQUNiLG1CQUFtQjtFQUNyQjtFQUNBO0lBQ0UsaUJBQWlCO0VBQ25CO0VBQ0E7SUFDRSxpQkFBaUI7SUFDakIsZ0JBQWdCO0VBQ2xCO0VBQ0E7SUFDRSxnQkFBZ0I7RUFDbEI7RUFDQTtJQUNFLFdBQVc7RUFDYjtFQUNBO0lBQ0UsV0FBVztJQUNYLHNCQUFzQjtFQUN4QjtFQUNBO0lBQ0UsWUFBWTtJQUNaLHNCQUFzQjtFQUN4QjtFQUNBO0lBQ0UsWUFBWTtJQUNaLHNCQUFzQjtFQUN4QjtFQUNBO0lBQ0UsYUFBYTtJQUNiLGdCQUFnQjtJQUNoQixlQUFlO0lBQ2YsMENBQWtDO1lBQWxDLGtDQUFrQztFQUNwQztFQUNBO0lBQ0UsZUFBZTtFQUNqQjtFQUlBO0lBQ0UsS0FBSyxpQ0FBaUMsRUFBRTtFQUMxQztFQUNBO0lBQ0UsSUFBSSx3QkFBd0IsQ0FBQztFQUMvQiIsImZpbGUiOiJsaWJzL3JlbWl4LXVpL2RlYnVnZ2VyLXVpL3NyYy9saWIvdm0tZGVidWdnZXIvc3R5bGVzL2Ryb3Bkb3duLXBhbmVsLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi50aXRsZSB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB9XG4gIC5uYW1lIHtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgfVxuICAubmFtZURldGFpbCB7XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgbWFyZ2luLWxlZnQ6IDNweDtcbiAgfVxuICAuaWNvbiB7XG4gICAgbWFyZ2luLXJpZ2h0OiA1JTtcbiAgfVxuICAuZXllQnV0dG9uIHtcbiAgICBtYXJnaW46IDNweDtcbiAgfVxuICAuZHJvcGRvd25wYW5lbCB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgd29yZC1icmVhazogYnJlYWstd29yZDtcbiAgfVxuICAuZHJvcGRvd25yYXdjb250ZW50IHtcbiAgICBwYWRkaW5nOiAycHg7XG4gICAgd29yZC1icmVhazogYnJlYWstd29yZDtcbiAgfVxuICAubWVzc2FnZSB7XG4gICAgcGFkZGluZzogMnB4O1xuICAgIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG4gIH1cbiAgLnJlZnJlc2gge1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgbWFyZ2luLWxlZnQ6IDRweDtcbiAgICBtYXJnaW4tdG9wOiA0cHg7IFxuICAgIGFuaW1hdGlvbjogc3BpbiAycyBsaW5lYXIgaW5maW5pdGU7XG4gIH1cbiAgLmN1cnNvcl9wb2ludGVyIHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gIH1cbiAgQC1tb3ota2V5ZnJhbWVzIHNwaW4ge1xuICAgIHRvIHsgLW1vei10cmFuc2Zvcm06IHJvdGF0ZSgzNTlkZWcpOyB9XG4gIH1cbiAgQC13ZWJraXQta2V5ZnJhbWVzIHNwaW4ge1xuICAgIHRvIHsgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNTlkZWcpOyB9XG4gIH1cbiAgQGtleWZyYW1lcyBzcGluIHtcbiAgICB0byB7dHJhbnNmb3JtOnJvdGF0ZSgzNTlkZWcpO31cbiAgfSJdfQ== */"

/***/ }),

/***/ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/file-explorer/src/lib/css/file-explorer-context-menu.css":
/*!**********************************************************************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/postcss-loader/src??embedded!/home/circleci/remix-project/libs/remix-ui/file-explorer/src/lib/css/file-explorer-context-menu.css ***!
  \**********************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".remixui_contextContainer\n{\n  display: block;\n  position: fixed;\n  border-radius: 2px;\n  z-index: 1000;\n  box-shadow: 0 0 4px var(--dark);\n}\n.remixui_contextContainer:focus {\n    outline: none;\n}\n.remixui_liitem\n{\n  padding: 2px;\n  padding-left: 6px;\n  cursor: pointer;\n  color: var(--text-dark);\n  background-color: var(--light);\n}\n.remixui_liitem:hover\n{\n  background-color:  var(--secondary);\n}\n#remixui_menuitems\n{\n  list-style: none;\n  margin: 0px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYnMvcmVtaXgtdWkvZmlsZS1leHBsb3Jlci9zcmMvbGliL2Nzcy9maWxlLWV4cGxvcmVyLWNvbnRleHQtbWVudS5jc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0VBRUUsY0FBYztFQUNkLGVBQWU7RUFDZixrQkFBa0I7RUFDbEIsYUFBYTtFQUNiLCtCQUErQjtBQUNqQztBQUNBO0lBQ0ksYUFBYTtBQUNqQjtBQUNBOztFQUVFLFlBQVk7RUFDWixpQkFBaUI7RUFDakIsZUFBZTtFQUNmLHVCQUF1QjtFQUN2Qiw4QkFBOEI7QUFDaEM7QUFDQTs7RUFFRSxtQ0FBbUM7QUFDckM7QUFDQTs7RUFFRSxnQkFBZ0I7RUFDaEIsV0FBVztBQUNiIiwiZmlsZSI6ImxpYnMvcmVtaXgtdWkvZmlsZS1leHBsb3Jlci9zcmMvbGliL2Nzcy9maWxlLWV4cGxvcmVyLWNvbnRleHQtbWVudS5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIucmVtaXh1aV9jb250ZXh0Q29udGFpbmVyXG57XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgei1pbmRleDogMTAwMDtcbiAgYm94LXNoYWRvdzogMCAwIDRweCB2YXIoLS1kYXJrKTtcbn1cbi5yZW1peHVpX2NvbnRleHRDb250YWluZXI6Zm9jdXMge1xuICAgIG91dGxpbmU6IG5vbmU7XG59XG4ucmVtaXh1aV9saWl0ZW1cbntcbiAgcGFkZGluZzogMnB4O1xuICBwYWRkaW5nLWxlZnQ6IDZweDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBjb2xvcjogdmFyKC0tdGV4dC1kYXJrKTtcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbGlnaHQpO1xufVxuLnJlbWl4dWlfbGlpdGVtOmhvdmVyXG57XG4gIGJhY2tncm91bmQtY29sb3I6ICB2YXIoLS1zZWNvbmRhcnkpO1xufVxuI3JlbWl4dWlfbWVudWl0ZW1zXG57XG4gIGxpc3Qtc3R5bGU6IG5vbmU7XG4gIG1hcmdpbjogMHB4O1xufSJdfQ== */"

/***/ }),

/***/ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/file-explorer/src/lib/css/file-explorer.css":
/*!*********************************************************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/postcss-loader/src??embedded!/home/circleci/remix-project/libs/remix-ui/file-explorer/src/lib/css/file-explorer.css ***!
  \*********************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".remixui_label {\n    margin-top        : 4px;\n}\n.remixui_leaf {\n    overflow          : hidden;\n    text-overflow     : ellipsis;\n    width             : 90%;\n    margin-bottom     : 0px;\n}\n.remixui_fileexplorer       {\n    box-sizing        : border-box;\n    -webkit-user-select       : none;\n       -moz-user-select       : none;\n        -ms-user-select       : none;\n            user-select       : none;\n}\ninput[type=\"file\"] {\n    display: none;\n}\n.remixui_folder,\n.remixui_file               {\n    font-size         : 14px;\n    cursor            : pointer;\n}\n.remixui_file               {\n    padding           : 4px;\n}\n.remixui_newFile            {\n    padding-right     : 10px;\n}\n.remixui_newFile i          {\n    cursor            : pointer;\n}\n.remixui_newFile:hover    {\n    transform         : scale(1.3);\n}\n.remixui_menu               {\n    margin-left       : 20px;\n}\n.remixui_items              {\n    display           : inline\n}\n.remixui_remove             {\n    margin-left       : auto;\n    padding-left      : 5px;\n    padding-right     : 5px;\n}\n.remixui_activeMode         {\n    display           : flex;\n    width             : 100%;\n    margin-right      : 10px;\n    padding-right     : 19px;\n}\n.remixui_activeMode > div   {\n    min-width         : 10px;\n}\nul                  {\n    padding           : 0;\n}\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYnMvcmVtaXgtdWkvZmlsZS1leHBsb3Jlci9zcmMvbGliL2Nzcy9maWxlLWV4cGxvcmVyLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtJQUNJLHVCQUF1QjtBQUMzQjtBQUNBO0lBQ0ksMEJBQTBCO0lBQzFCLDRCQUE0QjtJQUM1Qix1QkFBdUI7SUFDdkIsdUJBQXVCO0FBQzNCO0FBQ0E7SUFDSSw4QkFBOEI7SUFDOUIsZ0NBQXdCO09BQXhCLDZCQUF3QjtRQUF4Qiw0QkFBd0I7WUFBeEIsd0JBQXdCO0FBQzVCO0FBQ0E7SUFDSSxhQUFhO0FBQ2pCO0FBQ0E7O0lBRUksd0JBQXdCO0lBQ3hCLDJCQUEyQjtBQUMvQjtBQUNBO0lBQ0ksdUJBQXVCO0FBQzNCO0FBQ0E7SUFDSSx3QkFBd0I7QUFDNUI7QUFDQTtJQUNJLDJCQUEyQjtBQUMvQjtBQUNBO0lBQ0ksOEJBQThCO0FBQ2xDO0FBQ0E7SUFDSSx3QkFBd0I7QUFDNUI7QUFDQTtJQUNJO0FBQ0o7QUFDQTtJQUNJLHdCQUF3QjtJQUN4Qix1QkFBdUI7SUFDdkIsdUJBQXVCO0FBQzNCO0FBQ0E7SUFDSSx3QkFBd0I7SUFDeEIsd0JBQXdCO0lBQ3hCLHdCQUF3QjtJQUN4Qix3QkFBd0I7QUFDNUI7QUFDQTtJQUNJLHdCQUF3QjtBQUM1QjtBQUNBO0lBQ0kscUJBQXFCO0FBQ3pCIiwiZmlsZSI6ImxpYnMvcmVtaXgtdWkvZmlsZS1leHBsb3Jlci9zcmMvbGliL2Nzcy9maWxlLWV4cGxvcmVyLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi5yZW1peHVpX2xhYmVsIHtcbiAgICBtYXJnaW4tdG9wICAgICAgICA6IDRweDtcbn1cbi5yZW1peHVpX2xlYWYge1xuICAgIG92ZXJmbG93ICAgICAgICAgIDogaGlkZGVuO1xuICAgIHRleHQtb3ZlcmZsb3cgICAgIDogZWxsaXBzaXM7XG4gICAgd2lkdGggICAgICAgICAgICAgOiA5MCU7XG4gICAgbWFyZ2luLWJvdHRvbSAgICAgOiAwcHg7XG59XG4ucmVtaXh1aV9maWxlZXhwbG9yZXIgICAgICAge1xuICAgIGJveC1zaXppbmcgICAgICAgIDogYm9yZGVyLWJveDtcbiAgICB1c2VyLXNlbGVjdCAgICAgICA6IG5vbmU7XG59XG5pbnB1dFt0eXBlPVwiZmlsZVwiXSB7XG4gICAgZGlzcGxheTogbm9uZTtcbn1cbi5yZW1peHVpX2ZvbGRlcixcbi5yZW1peHVpX2ZpbGUgICAgICAgICAgICAgICB7XG4gICAgZm9udC1zaXplICAgICAgICAgOiAxNHB4O1xuICAgIGN1cnNvciAgICAgICAgICAgIDogcG9pbnRlcjtcbn1cbi5yZW1peHVpX2ZpbGUgICAgICAgICAgICAgICB7XG4gICAgcGFkZGluZyAgICAgICAgICAgOiA0cHg7XG59XG4ucmVtaXh1aV9uZXdGaWxlICAgICAgICAgICAge1xuICAgIHBhZGRpbmctcmlnaHQgICAgIDogMTBweDtcbn1cbi5yZW1peHVpX25ld0ZpbGUgaSAgICAgICAgICB7XG4gICAgY3Vyc29yICAgICAgICAgICAgOiBwb2ludGVyO1xufVxuLnJlbWl4dWlfbmV3RmlsZTpob3ZlciAgICB7XG4gICAgdHJhbnNmb3JtICAgICAgICAgOiBzY2FsZSgxLjMpO1xufVxuLnJlbWl4dWlfbWVudSAgICAgICAgICAgICAgIHtcbiAgICBtYXJnaW4tbGVmdCAgICAgICA6IDIwcHg7XG59XG4ucmVtaXh1aV9pdGVtcyAgICAgICAgICAgICAge1xuICAgIGRpc3BsYXkgICAgICAgICAgIDogaW5saW5lXG59XG4ucmVtaXh1aV9yZW1vdmUgICAgICAgICAgICAge1xuICAgIG1hcmdpbi1sZWZ0ICAgICAgIDogYXV0bztcbiAgICBwYWRkaW5nLWxlZnQgICAgICA6IDVweDtcbiAgICBwYWRkaW5nLXJpZ2h0ICAgICA6IDVweDtcbn1cbi5yZW1peHVpX2FjdGl2ZU1vZGUgICAgICAgICB7XG4gICAgZGlzcGxheSAgICAgICAgICAgOiBmbGV4O1xuICAgIHdpZHRoICAgICAgICAgICAgIDogMTAwJTtcbiAgICBtYXJnaW4tcmlnaHQgICAgICA6IDEwcHg7XG4gICAgcGFkZGluZy1yaWdodCAgICAgOiAxOXB4O1xufVxuLnJlbWl4dWlfYWN0aXZlTW9kZSA+IGRpdiAgIHtcbiAgICBtaW4td2lkdGggICAgICAgICA6IDEwcHg7XG59XG51bCAgICAgICAgICAgICAgICAgIHtcbiAgICBwYWRkaW5nICAgICAgICAgICA6IDA7XG59XG4iXX0= */"

/***/ }),

/***/ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/modal-dialog/src/lib/modal-dialog-custom.css":
/*!**********************************************************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/postcss-loader/src??embedded!/home/circleci/remix-project/libs/remix-ui/modal-dialog/src/lib/modal-dialog-custom.css ***!
  \**********************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJsaWJzL3JlbWl4LXVpL21vZGFsLWRpYWxvZy9zcmMvbGliL21vZGFsLWRpYWxvZy1jdXN0b20uY3NzIn0= */"

/***/ }),

/***/ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/modal-dialog/src/lib/remix-ui-modal-dialog.css":
/*!************************************************************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/postcss-loader/src??embedded!/home/circleci/remix-project/libs/remix-ui/modal-dialog/src/lib/remix-ui-modal-dialog.css ***!
  \************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".remixModalContent {\n  box-shadow: 0 0 8px 10000px rgba(0,0,0,0.6),0 6px 20px 0 rgba(0,0,0,0.19);\n  -webkit-animation-name: animatetop;\n  -webkit-animation-duration: 0.4s;\n  animation-name: animatetop;\n  animation-duration: 0.4s\n}\n.remixModalBody {\n  overflow-y: auto;\n  max-height: 600px;\n}\n@-webkit-keyframes animatetop {\n  from {top: -300px; opacity: 0}\n  to {top: 0; opacity: 1}\n}\n@keyframes animatetop {\n  from {top: -300px; opacity: 0}\n  to {top: 0; opacity: 1}\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYnMvcmVtaXgtdWkvbW9kYWwtZGlhbG9nL3NyYy9saWIvcmVtaXgtdWktbW9kYWwtZGlhbG9nLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLHlFQUF5RTtFQUN6RSxrQ0FBa0M7RUFDbEMsZ0NBQWdDO0VBQ2hDLDBCQUEwQjtFQUMxQjtBQUNGO0FBQ0E7RUFDRSxnQkFBZ0I7RUFDaEIsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxNQUFNLFdBQVcsRUFBRSxVQUFVO0VBQzdCLElBQUksTUFBTSxFQUFFLFVBQVU7QUFDeEI7QUFDQTtFQUNFLE1BQU0sV0FBVyxFQUFFLFVBQVU7RUFDN0IsSUFBSSxNQUFNLEVBQUUsVUFBVTtBQUN4QiIsImZpbGUiOiJsaWJzL3JlbWl4LXVpL21vZGFsLWRpYWxvZy9zcmMvbGliL3JlbWl4LXVpLW1vZGFsLWRpYWxvZy5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIucmVtaXhNb2RhbENvbnRlbnQge1xuICBib3gtc2hhZG93OiAwIDAgOHB4IDEwMDAwcHggcmdiYSgwLDAsMCwwLjYpLDAgNnB4IDIwcHggMCByZ2JhKDAsMCwwLDAuMTkpO1xuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBhbmltYXRldG9wO1xuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC40cztcbiAgYW5pbWF0aW9uLW5hbWU6IGFuaW1hdGV0b3A7XG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC40c1xufVxuLnJlbWl4TW9kYWxCb2R5IHtcbiAgb3ZlcmZsb3cteTogYXV0bztcbiAgbWF4LWhlaWdodDogNjAwcHg7XG59XG5ALXdlYmtpdC1rZXlmcmFtZXMgYW5pbWF0ZXRvcCB7XG4gIGZyb20ge3RvcDogLTMwMHB4OyBvcGFjaXR5OiAwfVxuICB0byB7dG9wOiAwOyBvcGFjaXR5OiAxfVxufVxuQGtleWZyYW1lcyBhbmltYXRldG9wIHtcbiAgZnJvbSB7dG9wOiAtMzAwcHg7IG9wYWNpdHk6IDB9XG4gIHRvIHt0b3A6IDA7IG9wYWNpdHk6IDF9XG59Il19 */"

/***/ }),

/***/ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/toaster/src/lib/toaster.css":
/*!*****************************************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/postcss-loader/src??embedded!/home/circleci/remix-project/libs/remix-ui/toaster/src/lib/toaster.css ***!
  \*****************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".remixui_tooltip {\n    z-index: 1001;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    position: fixed;\n    min-height: 50px;\n    padding: 16px 24px 12px;\n    border-radius: 3px;\n    left: 40%;\n    font-size: 14px;\n    text-align: center;\n    bottom: -0px;\n    flex-direction: row;\n}\n@-webkit-keyframes remixui_animatebottom  {\n  0% {bottom: -300px}\n  100% {bottom: 0px}\n}\n@keyframes remixui_animatebottom  {\n  0% {bottom: -300px}\n  100% {bottom: 0px}\n}\n@-webkit-keyframes remixui_animatetop  {\n  0% {bottom: 0px}\n  100% {bottom: -300px}\n}\n@keyframes remixui_animatetop  {\n  0% {bottom: 0px}\n  100% {bottom: -300px}\n}\n.remixui_animateTop {\n  -webkit-animation-name: remixui_animatetop;\n  -webkit-animation-duration: 2s;\n  animation-name: remixui_animatetop;\n  animation-duration: 2s;\n}\n.remixui_animateBottom {\n  -webkit-animation-name: remixui_animatebottom;\n  -webkit-animation-duration: 2s;\n  animation-name: remixui_animatebottom;\n  animation-duration: 2s;    \n}\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYnMvcmVtaXgtdWkvdG9hc3Rlci9zcmMvbGliL3RvYXN0ZXIuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0lBQ0ksYUFBYTtJQUNiLGFBQWE7SUFDYiw4QkFBOEI7SUFDOUIsbUJBQW1CO0lBQ25CLGVBQWU7SUFDZixnQkFBZ0I7SUFDaEIsdUJBQXVCO0lBQ3ZCLGtCQUFrQjtJQUNsQixTQUFTO0lBQ1QsZUFBZTtJQUNmLGtCQUFrQjtJQUNsQixZQUFZO0lBQ1osbUJBQW1CO0FBQ3ZCO0FBQ0E7RUFDRSxJQUFJLGNBQWM7RUFDbEIsTUFBTSxXQUFXO0FBQ25CO0FBQ0E7RUFDRSxJQUFJLGNBQWM7RUFDbEIsTUFBTSxXQUFXO0FBQ25CO0FBQ0E7RUFDRSxJQUFJLFdBQVc7RUFDZixNQUFNLGNBQWM7QUFDdEI7QUFDQTtFQUNFLElBQUksV0FBVztFQUNmLE1BQU0sY0FBYztBQUN0QjtBQUNBO0VBQ0UsMENBQTBDO0VBQzFDLDhCQUE4QjtFQUM5QixrQ0FBa0M7RUFDbEMsc0JBQXNCO0FBQ3hCO0FBQ0E7RUFDRSw2Q0FBNkM7RUFDN0MsOEJBQThCO0VBQzlCLHFDQUFxQztFQUNyQyxzQkFBc0I7QUFDeEIiLCJmaWxlIjoibGlicy9yZW1peC11aS90b2FzdGVyL3NyYy9saWIvdG9hc3Rlci5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIucmVtaXh1aV90b29sdGlwIHtcbiAgICB6LWluZGV4OiAxMDAxO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIG1pbi1oZWlnaHQ6IDUwcHg7XG4gICAgcGFkZGluZzogMTZweCAyNHB4IDEycHg7XG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgIGxlZnQ6IDQwJTtcbiAgICBmb250LXNpemU6IDE0cHg7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGJvdHRvbTogLTBweDtcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xufVxuQC13ZWJraXQta2V5ZnJhbWVzIHJlbWl4dWlfYW5pbWF0ZWJvdHRvbSAge1xuICAwJSB7Ym90dG9tOiAtMzAwcHh9XG4gIDEwMCUge2JvdHRvbTogMHB4fVxufVxuQGtleWZyYW1lcyByZW1peHVpX2FuaW1hdGVib3R0b20gIHtcbiAgMCUge2JvdHRvbTogLTMwMHB4fVxuICAxMDAlIHtib3R0b206IDBweH1cbn1cbkAtd2Via2l0LWtleWZyYW1lcyByZW1peHVpX2FuaW1hdGV0b3AgIHtcbiAgMCUge2JvdHRvbTogMHB4fVxuICAxMDAlIHtib3R0b206IC0zMDBweH1cbn1cbkBrZXlmcmFtZXMgcmVtaXh1aV9hbmltYXRldG9wICB7XG4gIDAlIHtib3R0b206IDBweH1cbiAgMTAwJSB7Ym90dG9tOiAtMzAwcHh9XG59XG4ucmVtaXh1aV9hbmltYXRlVG9wIHtcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogcmVtaXh1aV9hbmltYXRldG9wO1xuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMnM7XG4gIGFuaW1hdGlvbi1uYW1lOiByZW1peHVpX2FuaW1hdGV0b3A7XG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMnM7XG59XG4ucmVtaXh1aV9hbmltYXRlQm90dG9tIHtcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogcmVtaXh1aV9hbmltYXRlYm90dG9tO1xuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMnM7XG4gIGFuaW1hdGlvbi1uYW1lOiByZW1peHVpX2FuaW1hdGVib3R0b207XG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMnM7ICAgIFxufVxuIl19 */"

/***/ }),

/***/ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/tree-view/src/lib/remix-ui-tree-view.css":
/*!******************************************************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/postcss-loader/src??embedded!/home/circleci/remix-project/libs/remix-ui/tree-view/src/lib/remix-ui-tree-view.css ***!
  \******************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".li_tv {\n    list-style-type: none;\n    -webkit-margin-before: 0px;\n    -webkit-margin-after: 0px;\n    -webkit-margin-start: 0px;\n    -webkit-margin-end: 0px;\n    -webkit-padding-start: 0px;\n  }\n  .ul_tv {\n    list-style-type: none;\n    -webkit-margin-before: 0px;\n    -webkit-margin-after: 0px;\n    -webkit-margin-start: 0px;\n    -webkit-margin-end: 0px;\n    -webkit-padding-start: 0px;\n  }\n  .caret_tv {\n    width: 10px;\n    flex-shrink: 0;\n    padding-right: 5px;\n  }\n  .label_item {\n    word-break: break-all;\n  }\n  .label_key {\n    min-width: 15%;\n    max-width: 80%;\n    word-break: break-word;\n  }\n  .label_value {\n    min-width: 10%;\n  }\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYnMvcmVtaXgtdWkvdHJlZS12aWV3L3NyYy9saWIvcmVtaXgtdWktdHJlZS12aWV3LmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtJQUNJLHFCQUFxQjtJQUNyQiwwQkFBMEI7SUFDMUIseUJBQXlCO0lBQ3pCLHlCQUF5QjtJQUN6Qix1QkFBdUI7SUFDdkIsMEJBQTBCO0VBQzVCO0VBQ0E7SUFDRSxxQkFBcUI7SUFDckIsMEJBQTBCO0lBQzFCLHlCQUF5QjtJQUN6Qix5QkFBeUI7SUFDekIsdUJBQXVCO0lBQ3ZCLDBCQUEwQjtFQUM1QjtFQUNBO0lBQ0UsV0FBVztJQUNYLGNBQWM7SUFDZCxrQkFBa0I7RUFDcEI7RUFDQTtJQUNFLHFCQUFxQjtFQUN2QjtFQUNBO0lBQ0UsY0FBYztJQUNkLGNBQWM7SUFDZCxzQkFBc0I7RUFDeEI7RUFDQTtJQUNFLGNBQWM7RUFDaEIiLCJmaWxlIjoibGlicy9yZW1peC11aS90cmVlLXZpZXcvc3JjL2xpYi9yZW1peC11aS10cmVlLXZpZXcuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLmxpX3R2IHtcbiAgICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XG4gICAgLXdlYmtpdC1tYXJnaW4tYmVmb3JlOiAwcHg7XG4gICAgLXdlYmtpdC1tYXJnaW4tYWZ0ZXI6IDBweDtcbiAgICAtd2Via2l0LW1hcmdpbi1zdGFydDogMHB4O1xuICAgIC13ZWJraXQtbWFyZ2luLWVuZDogMHB4O1xuICAgIC13ZWJraXQtcGFkZGluZy1zdGFydDogMHB4O1xuICB9XG4gIC51bF90diB7XG4gICAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xuICAgIC13ZWJraXQtbWFyZ2luLWJlZm9yZTogMHB4O1xuICAgIC13ZWJraXQtbWFyZ2luLWFmdGVyOiAwcHg7XG4gICAgLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDBweDtcbiAgICAtd2Via2l0LW1hcmdpbi1lbmQ6IDBweDtcbiAgICAtd2Via2l0LXBhZGRpbmctc3RhcnQ6IDBweDtcbiAgfVxuICAuY2FyZXRfdHYge1xuICAgIHdpZHRoOiAxMHB4O1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcbiAgfVxuICAubGFiZWxfaXRlbSB7XG4gICAgd29yZC1icmVhazogYnJlYWstYWxsO1xuICB9XG4gIC5sYWJlbF9rZXkge1xuICAgIG1pbi13aWR0aDogMTUlO1xuICAgIG1heC13aWR0aDogODAlO1xuICAgIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG4gIH1cbiAgLmxhYmVsX3ZhbHVlIHtcbiAgICBtaW4td2lkdGg6IDEwJTtcbiAgfSJdfQ== */"

/***/ }),

/***/ "../../../node_modules/postcss-loader/src/index.js?!../../../libs/remix-ui/tree-view/src/lib/tree-view-item/tree-view-item.css":
/*!*****************************************************************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/postcss-loader/src??embedded!/home/circleci/remix-project/libs/remix-ui/tree-view/src/lib/tree-view-item/tree-view-item.css ***!
  \*****************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJsaWJzL3JlbWl4LXVpL3RyZWUtdmlldy9zcmMvbGliL3RyZWUtdmlldy1pdGVtL3RyZWUtdmlldy1pdGVtLmNzcyJ9 */"

/***/ }),

/***/ "../../../node_modules/postcss-loader/src/index.js?!./app/panels/styles/file-panel-styles.css":
/*!************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/postcss-loader/src??embedded!./app/panels/styles/file-panel-styles.css ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".remixui_container {\n  display           : flex;\n  flex-direction    : row;\n  width             : 100%;\n  height            : 100%;\n  box-sizing        : border-box;\n}\n.remixui_fileexplorer       {\n  display           : flex;\n  flex-direction    : column;\n  position          : relative;\n  width             : 100%;\n  padding-left      : 6px;\n  padding-top       : 6px;\n}\n.remixui_fileExplorerTree   {\n  cursor            : default;\n}\n.remixui_gist            {\n  padding           : 10px;\n}\n.remixui_gist i          {\n  cursor            : pointer;\n}\n.remixui_gist i:hover    {\n  color             : orange;\n}\n.remixui_connectToLocalhost {\n  padding           : 10px;\n}\n.remixui_connectToLocalhost i {\n  cursor            : pointer;\n}\n.remixui_connectToLocalhost i:hover   {\n  color             : var(--secondary)\n}\n.remixui_uploadFile         {\n  padding           : 10px;\n}\n.remixui_uploadFile label:hover   {\n  color             : var(--secondary)\n}\n.remixui_uploadFile label   {\n  cursor            : pointer;\n}\n.remixui_treeview {\n  overflow-y        : auto;\n}\n.remixui_dialog {\n  display: flex;\n  flex-direction: column;\n}\n.remixui_dialogParagraph {\n  margin-bottom: 2em;\n  word-break: break-word;\n}\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcHMvcmVtaXgtaWRlL3NyYy9hcHAvcGFuZWxzL3N0eWxlcy9maWxlLXBhbmVsLXN0eWxlcy5jc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRSx3QkFBd0I7RUFDeEIsdUJBQXVCO0VBQ3ZCLHdCQUF3QjtFQUN4Qix3QkFBd0I7RUFDeEIsOEJBQThCO0FBQ2hDO0FBQ0E7RUFDRSx3QkFBd0I7RUFDeEIsMEJBQTBCO0VBQzFCLDRCQUE0QjtFQUM1Qix3QkFBd0I7RUFDeEIsdUJBQXVCO0VBQ3ZCLHVCQUF1QjtBQUN6QjtBQUNBO0VBQ0UsMkJBQTJCO0FBQzdCO0FBQ0E7RUFDRSx3QkFBd0I7QUFDMUI7QUFDQTtFQUNFLDJCQUEyQjtBQUM3QjtBQUNBO0VBQ0UsMEJBQTBCO0FBQzVCO0FBQ0E7RUFDRSx3QkFBd0I7QUFDMUI7QUFDQTtFQUNFLDJCQUEyQjtBQUM3QjtBQUNBO0VBQ0U7QUFDRjtBQUNBO0VBQ0Usd0JBQXdCO0FBQzFCO0FBQ0E7RUFDRTtBQUNGO0FBQ0E7RUFDRSwyQkFBMkI7QUFDN0I7QUFDQTtFQUNFLHdCQUF3QjtBQUMxQjtBQUNBO0VBQ0UsYUFBYTtFQUNiLHNCQUFzQjtBQUN4QjtBQUNBO0VBQ0Usa0JBQWtCO0VBQ2xCLHNCQUFzQjtBQUN4QiIsImZpbGUiOiJhcHBzL3JlbWl4LWlkZS9zcmMvYXBwL3BhbmVscy9zdHlsZXMvZmlsZS1wYW5lbC1zdHlsZXMuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLnJlbWl4dWlfY29udGFpbmVyIHtcbiAgZGlzcGxheSAgICAgICAgICAgOiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbiAgICA6IHJvdztcbiAgd2lkdGggICAgICAgICAgICAgOiAxMDAlO1xuICBoZWlnaHQgICAgICAgICAgICA6IDEwMCU7XG4gIGJveC1zaXppbmcgICAgICAgIDogYm9yZGVyLWJveDtcbn1cbi5yZW1peHVpX2ZpbGVleHBsb3JlciAgICAgICB7XG4gIGRpc3BsYXkgICAgICAgICAgIDogZmxleDtcbiAgZmxleC1kaXJlY3Rpb24gICAgOiBjb2x1bW47XG4gIHBvc2l0aW9uICAgICAgICAgIDogcmVsYXRpdmU7XG4gIHdpZHRoICAgICAgICAgICAgIDogMTAwJTtcbiAgcGFkZGluZy1sZWZ0ICAgICAgOiA2cHg7XG4gIHBhZGRpbmctdG9wICAgICAgIDogNnB4O1xufVxuLnJlbWl4dWlfZmlsZUV4cGxvcmVyVHJlZSAgIHtcbiAgY3Vyc29yICAgICAgICAgICAgOiBkZWZhdWx0O1xufVxuLnJlbWl4dWlfZ2lzdCAgICAgICAgICAgIHtcbiAgcGFkZGluZyAgICAgICAgICAgOiAxMHB4O1xufVxuLnJlbWl4dWlfZ2lzdCBpICAgICAgICAgIHtcbiAgY3Vyc29yICAgICAgICAgICAgOiBwb2ludGVyO1xufVxuLnJlbWl4dWlfZ2lzdCBpOmhvdmVyICAgIHtcbiAgY29sb3IgICAgICAgICAgICAgOiBvcmFuZ2U7XG59XG4ucmVtaXh1aV9jb25uZWN0VG9Mb2NhbGhvc3Qge1xuICBwYWRkaW5nICAgICAgICAgICA6IDEwcHg7XG59XG4ucmVtaXh1aV9jb25uZWN0VG9Mb2NhbGhvc3QgaSB7XG4gIGN1cnNvciAgICAgICAgICAgIDogcG9pbnRlcjtcbn1cbi5yZW1peHVpX2Nvbm5lY3RUb0xvY2FsaG9zdCBpOmhvdmVyICAge1xuICBjb2xvciAgICAgICAgICAgICA6IHZhcigtLXNlY29uZGFyeSlcbn1cbi5yZW1peHVpX3VwbG9hZEZpbGUgICAgICAgICB7XG4gIHBhZGRpbmcgICAgICAgICAgIDogMTBweDtcbn1cbi5yZW1peHVpX3VwbG9hZEZpbGUgbGFiZWw6aG92ZXIgICB7XG4gIGNvbG9yICAgICAgICAgICAgIDogdmFyKC0tc2Vjb25kYXJ5KVxufVxuLnJlbWl4dWlfdXBsb2FkRmlsZSBsYWJlbCAgIHtcbiAgY3Vyc29yICAgICAgICAgICAgOiBwb2ludGVyO1xufVxuLnJlbWl4dWlfdHJlZXZpZXcge1xuICBvdmVyZmxvdy15ICAgICAgICA6IGF1dG87XG59ICBcbi5yZW1peHVpX2RpYWxvZyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG59XG4ucmVtaXh1aV9kaWFsb2dQYXJhZ3JhcGgge1xuICBtYXJnaW4tYm90dG9tOiAyZW07XG4gIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG59XG4iXX0= */"

/***/ }),

/***/ "../../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../../../package.json":
/*!*************************************************!*\
  !*** /home/circleci/remix-project/package.json ***!
  \*************************************************/
/*! exports provided: name, version, license, description, keywords, repository, author, bugs, homepage, bin, scripts, browserify, dependencies, devDependencies, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"remix-project\",\"version\":\"0.10.10\",\"license\":\"MIT\",\"description\":\"Ethereum Remix Monorepo\",\"keywords\":[\"ethereum\",\"solidity\",\"compiler\"],\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/ethereum/remix-project.git\"},\"author\":\"@yann300\",\"bugs\":{\"url\":\"https://github.com/ethereum/remix-project/issues\"},\"homepage\":\"https://github.com/ethereum/remix-project#readme\",\"bin\":{\"remix-ide\":\"./apps/remix-ide/bin/remix-ide\"},\"scripts\":{\"nx\":\"nx\",\"start\":\"nx start\",\"serve\":\"nx serve\",\"build\":\"nx build\",\"test\":\"nx test\",\"lint\":\"nx lint\",\"affected:apps\":\"nx affected:apps\",\"affected:libs\":\"nx affected:libs\",\"affected:build\":\"nx affected:build\",\"affected:test\":\"nx affected:test\",\"affected:lint\":\"nx affected:lint\",\"affected:dep-graph\":\"nx affected:dep-graph\",\"affected\":\"nx affected\",\"format\":\"nx format:write\",\"format:write\":\"nx format:write\",\"format:check\":\"nx format:check\",\"update\":\"nx migrate latest\",\"workspace-schematic\":\"nx workspace-schematic\",\"dep-graph\":\"nx dep-graph\",\"help\":\"nx help\",\"lint:libs\":\"nx run-many --target=lint --projects=remixd,remix-ui-tree-view,remix-ui-modal-dialog,remix-ui-toaster,remix-ui-file-explorer,remix-ui-debugger-ui\",\"build:libs\":\"nx run-many --target=build --parallel=false --with-deps=true --projects=remix-analyzer,remix-astwalker,remix-debug,remix-lib,remix-simulator,remix-solidity,remix-tests,remix-url-resolver,remixd\",\"test:libs\":\"nx run-many --target=test --projects=remix-analyzer,remix-astwalker,remix-debug,remix-lib,remix-simulator,remix-solidity,remix-tests,remix-url-resolver,remixd\",\"publish:libs\":\"npm run build:libs & lerna publish --skip-git & npm run bumpVersion:libs\",\"build:e2e\":\"tsc -p apps/remix-ide-e2e/tsconfig.e2e.json\",\"bumpVersion:libs\":\"gulp & gulp syncLibVersions;\",\"browsertest\":\"sleep 5 && npm run nightwatch_local\",\"csslint\":\"csslint --ignore=order-alphabetical --errors='errors,duplicate-properties,empty-rules' --exclude-list='apps/remix-ide/src/assets/css/font-awesome.min.css' apps/remix-ide/src/assets/css/\",\"downloadsolc_assets\":\"wget --no-check-certificate https://solc-bin.ethereum.org/bin/soljson-v0.7.4+commit.3f05b770.js -O ./apps/remix-ide/src/assets/js/soljson.js\",\"make-mock-compiler\":\"node apps/remix-ide/ci/makeMockCompiler.js\",\"minify\":\"uglifyjs --in-source-map inline --source-map-inline -c warnings=false\",\"nightwatch_parallel\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js --env=chrome,firefox\",\"nightwatch_local_firefox\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js --env=firefox\",\"nightwatch_local_chrome\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js --env=chrome\",\"nightwatch_local_ballot\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/ballot.test.js --env=chrome\",\"nightwatch_local_ballot_0_4_11\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/ballot_0_4_11.test.js --env=chrome\",\"nightwatch_local_usingWorker\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/usingWebWorker.test.js --env=chrome\",\"nightwatch_local_libraryDeployment\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/libraryDeployment.test.js --env=chrome\",\"nightwatch_local_solidityImport\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/solidityImport.test.js --env=chrome\",\"nightwatch_local_recorder\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/recorder.test.js --env=chrome\",\"nightwatch_local_transactionExecution\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/transactionExecution.test.js --env=chrome\",\"nightwatch_local_staticAnalysis\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/staticAnalysis.test.js --env=chrome\",\"nightwatch_local_signingMessage\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/signingMessage.test.js --env=chrome\",\"nightwatch_local_specialFunctions\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/specialFunctions.test.js --env=chrome\",\"nightwatch_local_solidityUnitTests\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/solidityUnittests.test.js --env=chrome\",\"nightwatch_local_remixd\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/remixd.test.js --env=chrome\",\"nightwatch_local_terminal\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/terminal.test.js --env=chrome\",\"nightwatch_local_gist\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/gist.test.js --env=chrome\",\"nightwatch_local_workspace\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/workspace.test.js --env=chrome\",\"nightwatch_local_defaultLayout\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/defaultLayout.test.js --env=chrome\",\"nightwatch_local_pluginManager\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/pluginManager.test.js --env=chrome\",\"nightwatch_local_publishContract\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/publishContract.test.js --env=chrome\",\"nightwatch_local_generalSettings\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/generalSettings.test.js --env=chrome\",\"nightwatch_local_fileExplorer\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/fileExplorer.test.js --env=chrome\",\"nightwatch_local_debugger\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/debugger.test.js --env=chrome\",\"nightwatch_local_editor\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/editor.test.js --env=chrome\",\"nightwatch_local_compiler\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/compiler_api.test.js --env=chrome\",\"nightwatch_local_txListener\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/txListener.test.js --env=chrome\",\"nightwatch_local_fileManager\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/fileManager_api.test.js --env=chrome\",\"nightwatch_local_runAndDeploy\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/runAndDeploy.js --env=chrome-runAndDeploy\",\"nightwatch_local_url\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/url.test.js --env=chrome\",\"nightwatch_local_verticalIconscontextmenu\":\"npm run build:e2e & nightwatch --config dist/apps/remix-ide-e2e/nightwatch.js dist/apps/remix-ide-e2e/src/tests/verticalIconsPanel.test.js --env=chrome\",\"onchange\":\"onchange apps/remix-ide/build/app.js -- npm-run-all lint\",\"remixd\":\"nx build remixd & nx serve remixd --folder=./apps/remix-ide/contracts --remixide=http://127.0.0.1:8080\",\"selenium\":\"selenium-standalone start\",\"selenium-install\":\"selenium-standalone install\",\"sourcemap\":\"exorcist --root ../ apps/remix-ide/build/app.js.map > apps/remix-ide/build/app.js\",\"test-browser\":\"npm-run-all -lpr selenium make-mock-compiler serve browsertest\",\"watch\":\"watchify apps/remix-ide/src/index.js -dv -p browserify-reload -o apps/remix-ide/build/app.js --exclude solc\",\"reinstall\":\"rm ./node-modules/ -rf & rm package-lock.json & rm ./build/ -rf & npm install & npm run build\",\"ganache-cli\":\"npx ganache-cli\"},\"browserify\":{\"transform\":[[\"babelify\",{\"sourceMapsAbsolute\":false,\"sourceMaps\":true,\"plugins\":[[\"module:fast-async\",{\"runtimePattern\":null,\"compiler\":{\"es7\":true,\"noRuntime\":true,\"promises\":true,\"wrapAwait\":true}}],[\"module:babel-plugin-yo-yoify\"],[\"module:@babel/plugin-transform-object-assign\"]],\"presets\":[\"@babel/preset-env\"]}]]},\"dependencies\":{\"@erebos/bzz-node\":\"^0.13.0\",\"@remixproject/engine\":\"^0.3.3\",\"@remixproject/engine-web\":\"^0.3.3\",\"@remixproject/plugin\":\"^0.3.3\",\"@remixproject/plugin-api\":\"^0.3.2\",\"@remixproject/plugin-utils\":\"^0.3.2\",\"@remixproject/plugin-webview\":\"^0.3.3\",\"@remixproject/plugin-ws\":\"^0.3.3\",\"@types/jest\":\"^26.0.5\",\"@types/tape\":\"^4.2.33\",\"ansi-gray\":\"^0.1.1\",\"axios\":\"^0.20.0\",\"change-case\":\"^4.1.1\",\"chokidar\":\"^2.1.8\",\"color-support\":\"^1.1.3\",\"commander\":\"^2.20.3\",\"document-register-element\":\"1.13.1\",\"ethereumjs-block\":\"^2.2.2\",\"ethereumjs-tx\":\"^2.1.2\",\"ethereumjs-vm\":\"4.1.3\",\"express-ws\":\"^4.0.0\",\"fs-extra\":\"^3.0.1\",\"http-server\":\"^0.11.1\",\"isbinaryfile\":\"^3.0.2\",\"merge\":\"^1.2.0\",\"npm-install-version\":\"^6.0.2\",\"react\":\"16.13.1\",\"react-beautiful-dnd\":\"^13.0.0\",\"react-bootstrap\":\"^1.3.0\",\"react-dom\":\"16.13.1\",\"selenium\":\"^2.20.0\",\"signale\":\"^1.4.0\",\"time-stamp\":\"^2.2.0\",\"winston\":\"^3.3.3\",\"ws\":\"^7.3.0\"},\"devDependencies\":{\"@babel/core\":\"^7.4.5\",\"@babel/plugin-transform-modules-amd\":\"^7.10.4\",\"@babel/plugin-transform-modules-commonjs\":\"^7.10.4\",\"@babel/plugin-transform-object-assign\":\"^7.2.0\",\"@babel/plugin-transform-runtime\":\"^7.10.4\",\"@babel/polyfill\":\"^7.4.4\",\"@babel/preset-env\":\"^7.10.4\",\"@babel/preset-es2015\":\"^7.0.0-beta.53\",\"@babel/preset-es2017\":\"latest\",\"@babel/preset-react\":\"7.9.4\",\"@babel/preset-stage-0\":\"^7.0.0\",\"@babel/preset-typescript\":\"7.9.0\",\"@babel/register\":\"^7.4.4\",\"@fortawesome/fontawesome-free\":\"^5.8.1\",\"@nrwl/eslint-plugin-nx\":\"^10.0.6\",\"@nrwl/jest\":\"10.0.6\",\"@nrwl/linter\":\"^10.0.6\",\"@nrwl/node\":\"^10.0.6\",\"@nrwl/react\":\"10.0.6\",\"@nrwl/web\":\"10.0.6\",\"@nrwl/workspace\":\"10.0.6\",\"@resolver-engine/imports\":\"^0.3.0\",\"@testing-library/react\":\"10.4.1\",\"@types/axios\":\"^0.14.0\",\"@types/chai\":\"^4.2.11\",\"@types/fs-extra\":\"^9.0.1\",\"@types/jest\":\"25.1.4\",\"@types/mocha\":\"^7.0.2\",\"@types/nightwatch\":\"^1.1.6\",\"@types/node\":\"~8.9.4\",\"@types/react\":\"16.9.17\",\"@types/react-beautiful-dnd\":\"^13.0.0\",\"@types/react-dom\":\"16.9.4\",\"@types/react-router-dom\":\"5.1.3\",\"@types/ws\":\"^7.2.4\",\"@typescript-eslint/eslint-plugin\":\"^3.3.0\",\"@typescript-eslint/parser\":\"^3.3.0\",\"ace-mode-lexon\":\"^1.*.*\",\"ace-mode-move\":\"0.0.1\",\"ace-mode-solidity\":\"^0.1.0\",\"ace-mode-zokrates\":\"^1.0.0\",\"async\":\"^2.1.2\",\"babel-eslint\":\"^10.0.0\",\"babel-jest\":\"25.1.0\",\"babel-plugin-add-module-exports\":\"^1.0.2\",\"babel-plugin-fast-async\":\"^6.1.2\",\"babel-plugin-module-resolver\":\"^4.0.0\",\"babel-plugin-transform-object-rest-spread\":\"^6.26.0\",\"babel-plugin-yo-yoify\":\"^2.0.0\",\"babel-preset-env\":\"^1.7.0\",\"babel-preset-typescript\":\"^7.0.0-alpha.19\",\"babelify\":\"^10.0.0\",\"brace\":\"^0.8.0\",\"browserify\":\"^16.2.3\",\"browserify-reload\":\"^1.0.3\",\"component-type\":\"^1.2.1\",\"copy-text-to-clipboard\":\"^1.0.4\",\"csjs-inject\":\"^1.0.1\",\"csslint\":\"^1.0.2\",\"cypress\":\"^4.1.0\",\"deep-equal\":\"^1.0.1\",\"dotenv\":\"^8.2.0\",\"eslint\":\"6.8.0\",\"eslint-config-prettier\":\"^6.11.0\",\"eslint-config-standard\":\"^14.1.1\",\"eslint-plugin-import\":\"2.20.2\",\"eslint-plugin-node\":\"11.1.0\",\"eslint-plugin-promise\":\"4.2.1\",\"eslint-plugin-standard\":\"4.0.1\",\"ethereumjs-util\":\"^6.2.0\",\"ethers\":\"^5.0.13\",\"events\":\"^3.0.0\",\"execr\":\"^1.0.1\",\"exorcist\":\"^0.4.0\",\"exports-loader\":\"^1.1.0\",\"fast-async\":\"^7.0.6\",\"fast-levenshtein\":\"^2.0.6\",\"ganache-cli\":\"^6.8.1\",\"gists\":\"^1.0.1\",\"gulp\":\"^4.0.2\",\"ipfs-http-client\":\"^47.0.1\",\"ipfs-mini\":\"^1.1.5\",\"is-electron\":\"^2.2.0\",\"javascript-serialize\":\"^1.6.1\",\"jest\":\"25.2.3\",\"jquery\":\"^3.3.1\",\"js-base64\":\"^2.1.9\",\"js-beautify\":\"1.6.14\",\"lerna\":\"^3.22.1\",\"minixhr\":\"^3.2.2\",\"mkdirp\":\"^0.5.1\",\"mocha\":\"^8.0.1\",\"nanohtml\":\"^1.6.3\",\"nightwatch\":\"^1.5.1\",\"nodemon\":\"^2.0.4\",\"notify-error\":\"^1.2.0\",\"npm-link-local\":\"^1.1.0\",\"npm-merge-driver\":\"^2.3.5\",\"npm-run-all\":\"^4.0.2\",\"nyc\":\"^13.3.0\",\"onchange\":\"^3.2.1\",\"prettier\":\"1.19.1\",\"remix-tabs\":\"1.0.53\",\"request\":\"^2.83.0\",\"rimraf\":\"^2.6.1\",\"selenium-standalone\":\"^6.17.0\",\"semver\":\"^6.1.2\",\"solc\":\"0.7.4\",\"swarmgw\":\"^0.3.1\",\"tap-spec\":\"^5.0.0\",\"tape\":\"^4.13.3\",\"ts-jest\":\"25.2.1\",\"ts-node\":\"^7.0.1\",\"tslint\":\"~6.0.0\",\"typescript\":\"~3.8.3\",\"uglify-js\":\"^2.8.16\",\"vm-browserify\":\"0.0.4\",\"watchify\":\"^3.9.0\",\"web3\":\"1.2.4\",\"webworkify-webpack\":\"^2.1.5\",\"worker-loader\":\"^2.0.0\",\"yo-yo\":\"github:ioedeveloper/yo-yo\",\"yo-yoify\":\"^3.7.3\"}}");

/***/ }),

/***/ "../../debugger/src/app/debugger-api.ts":
/*!**************************************************************************!*\
  !*** /home/circleci/remix-project/apps/debugger/src/app/debugger-api.ts ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompilerAbstract = exports.DebuggerApiMixin = void 0;

var _web = _interopRequireDefault(__webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js"));

var _remixDebug = _interopRequireWildcard(__webpack_require__(/*! @remix-project/remix-debug */ "../../../dist/libs/remix-debug/src/index.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DebuggerApiMixin = Base => class extends Base {
  initDebuggerApi() {
    this.debugHash = null;
    const self = this;
    this.web3Provider = {
      sendAsync(payload, callback) {
        self.call('web3Provider', 'sendAsync', payload).then(result => callback(null, result)).catch(e => callback(e));
      }

    };
    this._web3 = new _web.default(this.web3Provider);
    this.offsetToLineColumnConverter = {
      async offsetToLineColumn(rawLocation, file, sources, asts) {
        return await self.call('offsetToLineColumnConverter', 'offsetToLineColumn', rawLocation, file, sources, asts);
      }

    };
  } // on()
  // call()
  // onDebugRequested()
  // onRemoveHighlights()


  web3() {
    return this._web3;
  }

  async discardHighlight() {
    await this.call('editor', 'discardHighlight');
  }

  async highlight(lineColumnPos, path) {
    await this.call('editor', 'highlight', lineColumnPos, path);
  }

  async getFile(path) {
    return await this.call('fileManager', 'getFile', path);
  }

  async setFile(path, content) {
    await this.call('fileManager', 'setFile', path, content);
  }

  onBreakpointCleared(listener) {
    this.onBreakpointClearedListener = listener;
  }

  onBreakpointAdded(listener) {
    this.onBreakpointAddedListener = listener;
  }

  onEditorContentChanged(listener) {
    this.onEditorContentChangedListener = listener;
  }

  onDebugRequested(listener) {
    this.onDebugRequestedListener = listener;
  }

  onRemoveHighlights(listener) {
    this.onRemoveHighlightsListener = listener;
  }

  async fetchContractAndCompile(address, receipt) {
    const target = address && _remixDebug.default.traceHelper.isContractCreation(address) ? receipt.contractAddress : address;
    const targetAddress = target || receipt.contractAddress || receipt.to;
    const codeAtAddress = await this._web3.eth.getCode(targetAddress);
    const output = await this.call('fetchAndCompile', 'resolve', targetAddress, codeAtAddress, 'browser/.debug');
    return new CompilerAbstract(output.languageversion, output.data, output.source);
  }

  async getDebugWeb3() {
    let web3;
    let network;

    try {
      network = await this.call('network', 'detectNetwork');
    } catch (e) {
      web3 = this.web3();
    }

    if (!web3) {
      const webDebugNode = _remixDebug.default.init.web3DebugNode(network.name);

      web3 = !webDebugNode ? this.web3() : webDebugNode;
    }

    _remixDebug.default.init.extendWeb3(web3);

    return web3;
  }

  async getTrace(hash) {
    if (!hash) return;
    const web3 = await this.getDebugWeb3();
    const currentReceipt = await web3.eth.getTransactionReceipt(hash);
    const debug = new _remixDebug.TransactionDebugger({
      web3,
      offsetToLineColumnConverter: this.offsetToLineColumnConverter,
      compilationResult: async address => {
        try {
          return await this.fetchContractAndCompile(address, currentReceipt);
        } catch (e) {
          console.error(e);
        }

        return null;
      },
      debugWithGeneratedSources: false
    });
    return await debug.debugger.traceManager.getTrace(hash);
  }

  debug(hash) {
    this.debugHash = hash;
    this.onDebugRequestedListener(hash);
  }

  onActivation() {
    this.on('editor', 'breakpointCleared', (fileName, row) => this.onBreakpointClearedListener(fileName, row));
    this.on('editor', 'breakpointAdded', (fileName, row) => this.onBreakpointAddedListener(fileName, row));
    this.on('editor', 'contentChanged', () => this.onEditorContentChangedListener());
  }

  onDeactivation() {
    this.onRemoveHighlightsListener();
    this.off('editor', 'breakpointCleared');
    this.off('editor', 'breakpointAdded');
    this.off('editor', 'contentChanged');
  }

  showMessage(title, message) {}

};

exports.DebuggerApiMixin = DebuggerApiMixin;

class CompilerAbstract {
  // this is a subset of /remix-ide/src/app/compiler/compiler-abstract.js
  constructor(languageversion, data, source) {
    this.languageversion = languageversion;
    this.data = data;
    this.source = source; // source code
  }

  getSourceName(fileIndex) {
    if (this.data && this.data.sources) {
      return Object.keys(this.data.sources)[fileIndex];
    } else if (Object.keys(this.source.sources).length === 1) {
      // if we don't have ast, we return the only one filename present.
      const sourcesArray = Object.keys(this.source.sources);
      return sourcesArray[0];
    }

    return null;
  }

}

exports.CompilerAbstract = CompilerAbstract;

/***/ }),

/***/ "../../debugger/src/index.ts":
/*!***************************************************************!*\
  !*** /home/circleci/remix-project/apps/debugger/src/index.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debuggerApi = __webpack_require__(/*! ./app/debugger-api */ "../../debugger/src/app/debugger-api.ts");

Object.keys(_debuggerApi).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _debuggerApi[key];
    }
  });
});

/***/ }),

/***/ "./app.js":
/*!****************!*\
  !*** ./app.js ***!
  \****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _svgLogo = __webpack_require__(/*! ./app/ui/svgLogo */ "./app/ui/svgLogo.js");

var _udapp = __webpack_require__(/*! ./app/udapp */ "./app/udapp/index.js");

var _panelsResize = _interopRequireDefault(__webpack_require__(/*! ./lib/panels-resize */ "./lib/panels-resize.js"));

var _remixEngine = __webpack_require__(/*! ./remixEngine */ "./remixEngine.js");

var _remixAppManager = __webpack_require__(/*! ./remixAppManager */ "./remixAppManager.js");

var _framingService = __webpack_require__(/*! ./framingService */ "./framingService.js");

var _mainView = __webpack_require__(/*! ./app/panels/main-view */ "./app/panels/main-view.js");

var _themeModule = __webpack_require__(/*! ./app/tabs/theme-module */ "./app/tabs/theme-module.js");

var _networkModule = __webpack_require__(/*! ./app/tabs/network-module */ "./app/tabs/network-module.js");

var _web3Provider = __webpack_require__(/*! ./app/tabs/web3-provider */ "./app/tabs/web3-provider.js");

var _sidePanel = __webpack_require__(/*! ./app/components/side-panel */ "./app/components/side-panel.js");

var _hiddenPanel = __webpack_require__(/*! ./app/components/hidden-panel */ "./app/components/hidden-panel.js");

var _verticalIcons = __webpack_require__(/*! ./app/components/vertical-icons */ "./app/components/vertical-icons.js");

var _landingPage = __webpack_require__(/*! ./app/ui/landing-page/landing-page */ "./app/ui/landing-page/landing-page.js");

var _mainPanel = __webpack_require__(/*! ./app/components/main-panel */ "./app/components/main-panel.js");

var _compilerSourceVerifierFetchAndCompile = _interopRequireDefault(__webpack_require__(/*! ./app/compiler/compiler-sourceVerifier-fetchAndCompile */ "./app/compiler/compiler-sourceVerifier-fetchAndCompile.js"));

var _migrateFileSystem = _interopRequireDefault(__webpack_require__(/*! ./migrateFileSystem */ "./migrateFileSystem.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n      <div style=\"visibility:hidden\" class=", " data-id=\"remixIDE\">\n        ", "\n        ", "\n        ", "\n        ", "\n      </div>\n    "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n      <div id=\"main-panel\" data-id=\"remixIdeMainPanel\" class=", ">\n        ", "\n      </div>\n    "]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n      <div id=\"side-panel\" data-id=\"remixIdeSidePanel\" style=\"min-width: 320px;\" class=\"", " border-right border-left\">\n        ", "\n      </div>\n    "]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n      <div id=\"icon-panel\" data-id=\"remixIdeIconPanel\" class=\"", " bg-light\">\n      ", "\n      </div>\n    "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n    <div class=", ">\n      ", "\n      <div class=\"info-secondary\" style=\"text-align:center\">\n        REMIX IDE\n      </div>\n      </div>\n    "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  html { box-sizing: border-box; }\n  *, *:before, *:after { box-sizing: inherit; }\n  body                 {\n    /* font: 14px/1.5 Lato, \"Helvetica Neue\", Helvetica, Arial, sans-serif; */\n    font-size          : .8rem;\n  }\n  pre {\n    overflow-x: auto;\n  }\n  .remixIDE            {\n    width              : 100vw;\n    height             : 100vh;\n    overflow           : hidden;\n    flex-direction     : row;\n    display            : flex;\n  }\n  .mainpanel           {\n    display            : flex;\n    flex-direction     : column;\n    overflow           : hidden;\n    flex               : 1;\n  }\n  .iconpanel           {\n    display            : flex;\n    flex-direction     : column;\n    overflow           : hidden;\n    width              : 50px;\n    user-select        : none;\n  }\n  .sidepanel           {\n    display            : flex;\n    flex-direction     : row-reverse;\n    width              : 320px;\n  }\n  .highlightcode       {\n    position           : absolute;\n    z-index            : 20;\n    background-color   : var(--info);\n  }\n  .highlightcode_fullLine {\n    position           : absolute;\n    z-index            : 20;\n    background-color   : var(--info);\n    opacity            : 0.5;\n  }\n  .centered {\n    position           : fixed;\n    top                : 20%;\n    left               : 45%;\n    width              : 200px;\n    height             : 200px;\n  }\n  .centered svg path {\n    fill: var(--secondary);\n  }\n  .centered svg polygon {\n    fill: var(--secondary);\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var isElectron = __webpack_require__(/*! is-electron */ "../../../node_modules/is-electron/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var registry = __webpack_require__(/*! ./global/registry */ "./global/registry.js");

var loadFileFromParent = __webpack_require__(/*! ./loadFilesFromParent */ "./loadFilesFromParent.js");

var _require = __webpack_require__(/*! ./lib/offsetToLineColumnConverter */ "./lib/offsetToLineColumnConverter.js"),
    OffsetToLineColumnConverter = _require.OffsetToLineColumnConverter;

var QueryParams = __webpack_require__(/*! ./lib/query-params */ "./lib/query-params.js");

var GistHandler = __webpack_require__(/*! ./lib/gist-handler */ "./lib/gist-handler.js");

var Storage = remixLib.Storage;

var RemixDProvider = __webpack_require__(/*! ./app/files/remixDProvider */ "./app/files/remixDProvider.js");

var Config = __webpack_require__(/*! ./config */ "./config.js");

var Renderer = __webpack_require__(/*! ./app/ui/renderer */ "./app/ui/renderer.js");

var examples = __webpack_require__(/*! ./app/editor/examples */ "./app/editor/examples.js");

var modalDialogCustom = __webpack_require__(/*! ./app/ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var FileManager = __webpack_require__(/*! ./app/files/fileManager */ "./app/files/fileManager.js");

var FileProvider = __webpack_require__(/*! ./app/files/fileProvider */ "./app/files/fileProvider.js");

var toolTip = __webpack_require__(/*! ./app/ui/tooltip */ "./app/ui/tooltip.js");

var CompilerMetadata = __webpack_require__(/*! ./app/files/compiler-metadata */ "./app/files/compiler-metadata.js");

var CompilerImport = __webpack_require__(/*! ./app/compiler/compiler-imports */ "./app/compiler/compiler-imports.js");

var Blockchain = __webpack_require__(/*! ./blockchain/blockchain.js */ "./blockchain/blockchain.js");

var PluginUDapp = __webpack_require__(/*! ./blockchain/pluginUDapp.js */ "./blockchain/pluginUDapp.js");

var PluginManagerComponent = __webpack_require__(/*! ./app/components/plugin-manager-component */ "./app/components/plugin-manager-component.js");

var CompilersArtefacts = __webpack_require__(/*! ./app/compiler/compiler-artefacts */ "./app/compiler/compiler-artefacts.js");

var CompileTab = __webpack_require__(/*! ./app/tabs/compile-tab */ "./app/tabs/compile-tab.js");

var SettingsTab = __webpack_require__(/*! ./app/tabs/settings-tab */ "./app/tabs/settings-tab.js");

var AnalysisTab = __webpack_require__(/*! ./app/tabs/analysis-tab */ "./app/tabs/analysis-tab.js");

var _require2 = __webpack_require__(/*! ./app/tabs/debugger-tab */ "./app/tabs/debugger-tab.js"),
    DebuggerTab = _require2.DebuggerTab;

var TestTab = __webpack_require__(/*! ./app/tabs/test-tab */ "./app/tabs/test-tab.js");

var FilePanel = __webpack_require__(/*! ./app/panels/file-panel */ "./app/panels/file-panel.js");

var Editor = __webpack_require__(/*! ./app/editor/editor */ "./app/editor/editor.js");

var Terminal = __webpack_require__(/*! ./app/panels/terminal */ "./app/panels/terminal.js");

var ContextualListener = __webpack_require__(/*! ./app/editor/contextualListener */ "./app/editor/contextualListener.js");

var css = csjs(_templateObject());

var App = /*#__PURE__*/function () {
  function App() {
    var api = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, App);

    var self = this;
    self.appManager = new _remixAppManager.RemixAppManager({});
    self._components = {};
    self._view = {};
    self._view.splashScreen = yo(_templateObject2(), css.centered, (0, _svgLogo.basicLogo)());
    document.body.appendChild(self._view.splashScreen); // setup storage

    var configStorage = new Storage('config-v0.8:'); // load app config

    var config = new Config(configStorage);
    registry.put({
      api: config,
      name: 'config'
    }); // load file system

    self._components.filesProviders = {};
    self._components.filesProviders.browser = new FileProvider('browser');
    registry.put({
      api: self._components.filesProviders.browser,
      name: 'fileproviders/browser'
    });
    self._components.filesProviders.localhost = new RemixDProvider(self.appManager);
    registry.put({
      api: self._components.filesProviders.localhost,
      name: 'fileproviders/localhost'
    });
    registry.put({
      api: self._components.filesProviders,
      name: 'fileproviders'
    });
    (0, _migrateFileSystem["default"])(self._components.filesProviders.browser);
  }

  _createClass(App, [{
    key: "init",
    value: function init() {
      var self = this;
      run.apply(self);
    }
  }, {
    key: "render",
    value: function render() {
      var self = this;
      if (self._view.el) return self._view.el; // not resizable

      self._view.iconpanel = yo(_templateObject3(), css.iconpanel, ''); // center panel, resizable

      self._view.sidepanel = yo(_templateObject4(), css.sidepanel, ''); // handle the editor + terminal

      self._view.mainpanel = yo(_templateObject5(), css.mainpanel, '');
      self._components.resizeFeature = new _panelsResize["default"](self._view.sidepanel);
      self._view.el = yo(_templateObject6(), css.remixIDE, self._view.iconpanel, self._view.sidepanel, self._components.resizeFeature.render(), self._view.mainpanel);
      return self._view.el;
    }
  }]);

  return App;
}();

module.exports = App;

function run() {
  return _run.apply(this, arguments);
}

function _run() {
  _run = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
    var self, hosts, appManager, pluginLoader, workspace, engine, themeModule, editor, fileManager, contentImport, blockchain, pluginUdapp, compilerMetadataGenerator, compilersArtefacts, fetchAndCompile, networkModule, web3Provider, offsetToLineColumnConverter, terminal, contextualListener, appPanel, mainview, menuicons, landingPage, sidePanel, hiddenPanel, pluginManagerComponent, filePanel, settings, compileTab, run, analysis, debug, test, queryParams, params, framingService, gistHandler, loadedFromGist;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            self = this; // check the origin and warn message

            if (window.location.hostname === 'yann300.github.io') {
              modalDialogCustom.alert('This UNSTABLE ALPHA branch of Remix has been moved to http://ethereum.github.io/remix-live-alpha.');
            } else if (window.location.hostname === 'remix-alpha.ethereum.org' || window.location.hostname === 'ethereum.github.io' && window.location.pathname.indexOf('/remix-live-alpha') === 0) {
              modalDialogCustom.alert('Welcome to the Remix alpha instance. Please use it to try out latest features. But use preferably https://remix.ethereum.org for any production work.');
            } else if (window.location.protocol.indexOf('http') === 0 && window.location.hostname !== 'remix.ethereum.org' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
              modalDialogCustom.alert("The Remix IDE has moved to http://remix.ethereum.org.\n\nThis instance of Remix you are visiting WILL NOT BE UPDATED.\n\nPlease make a backup of your contracts and start using http://remix.ethereum.org");
            }

            if (window.location.protocol.indexOf('https') === 0) {
              toolTip('You are using an `https` connection. Please switch to `http` if you are using Remix against an `http Web3 provider` or allow Mixed Content in your browser.');
            }

            hosts = ['127.0.0.1:8080', '192.168.0.101:8080', 'localhost:8080']; // workaround for Electron support

            if (!isElectron() && !hosts.includes(window.location.host)) {
              // Oops! Accidentally trigger refresh or bookmark.
              window.onbeforeunload = function () {
                return 'Are you sure you want to leave?';
              };
            } // APP_MANAGER


            appManager = self.appManager;
            pluginLoader = appManager.pluginLoader;
            workspace = pluginLoader.get();
            engine = new _remixEngine.RemixEngine();
            engine.register(appManager); // SERVICES
            // ----------------- theme service ---------------------------------

            themeModule = new _themeModule.ThemeModule(registry);
            registry.put({
              api: themeModule,
              name: 'themeModule'
            });
            themeModule.initTheme(function () {
              setTimeout(function () {
                document.body.removeChild(self._view.splashScreen);
                self._view.el.style.visibility = 'visible';
              }, 1500);
            }); // ----------------- editor service ----------------------------

            editor = new Editor({}, themeModule); // wrapper around ace editor

            registry.put({
              api: editor,
              name: 'editor'
            });
            editor.event.register('requiringToSaveCurrentfile', function () {
              return fileManager.saveCurrentFile();
            }); // ----------------- fileManager service ----------------------------

            fileManager = new FileManager(editor, appManager);
            registry.put({
              api: fileManager,
              name: 'filemanager'
            }); // ----------------- import content service ------------------------

            contentImport = new CompilerImport(fileManager);
            blockchain = new Blockchain(registry.get('config').api);
            pluginUdapp = new PluginUDapp(blockchain); // ----------------- compilation metadata generation service ---------

            compilerMetadataGenerator = new CompilerMetadata(blockchain, fileManager, registry.get('config').api); // ----------------- compilation result service (can keep track of compilation results) ----------------------------

            compilersArtefacts = new CompilersArtefacts(); // store all the compilation results (key represent a compiler name)

            registry.put({
              api: compilersArtefacts,
              name: 'compilersartefacts'
            }); // service which fetch contract artifacts from sourve-verify, put artifacts in remix and compile it

            fetchAndCompile = new _compilerSourceVerifierFetchAndCompile["default"](); // ----------------- network service (resolve network id / name) -----

            networkModule = new _networkModule.NetworkModule(blockchain); // ----------------- represent the current selected web3 provider ----

            web3Provider = new _web3Provider.Web3ProviderModule(blockchain); // ----------------- convert offset to line/column service -----------

            offsetToLineColumnConverter = new OffsetToLineColumnConverter();
            registry.put({
              api: offsetToLineColumnConverter,
              name: 'offsettolinecolumnconverter'
            }); // -------------------Terminal----------------------------------------

            terminal = new Terminal({
              appManager: appManager,
              blockchain: blockchain
            }, {
              getPosition: function getPosition(event) {
                var limitUp = 36;
                var limitDown = 20;
                var height = window.innerHeight;
                var newpos = event.pageY < limitUp ? limitUp : event.pageY;
                newpos = newpos < height - limitDown ? newpos : height - limitDown;
                return height - newpos;
              }
            });
            (0, _udapp.makeUdapp)(blockchain, compilersArtefacts, function (domEl) {
              return terminal.logHtml(domEl);
            });
            contextualListener = new ContextualListener({
              editor: editor
            });
            engine.register([contentImport, themeModule, editor, fileManager, compilerMetadataGenerator, compilersArtefacts, networkModule, offsetToLineColumnConverter, contextualListener, terminal, web3Provider, fetchAndCompile]); // LAYOUT & SYSTEM VIEWS

            appPanel = new _mainPanel.MainPanel();
            mainview = new _mainView.MainView(contextualListener, editor, appPanel, fileManager, appManager, terminal);
            registry.put({
              api: mainview,
              name: 'mainview'
            });
            engine.register([appPanel, mainview.tabProxy]); // those views depend on app_manager

            menuicons = new _verticalIcons.VerticalIcons(appManager);
            landingPage = new _landingPage.LandingPage(appManager, menuicons);
            sidePanel = new _sidePanel.SidePanel(appManager, menuicons);
            hiddenPanel = new _hiddenPanel.HiddenPanel();
            pluginManagerComponent = new PluginManagerComponent(appManager, engine);
            filePanel = new FilePanel(appManager);
            settings = new SettingsTab(registry.get('config').api, editor, appManager); // adding Views to the DOM

            self._view.mainpanel.appendChild(mainview.render());

            self._view.iconpanel.appendChild(menuicons.render());

            self._view.sidepanel.appendChild(sidePanel.render());

            document.body.appendChild(hiddenPanel.render()); // Hidden Panel is display none, it can be directly on body

            engine.register([menuicons, landingPage, hiddenPanel, sidePanel, pluginManagerComponent, filePanel, settings]); // CONTENT VIEWS & DEFAULT PLUGINS

            compileTab = new CompileTab(editor, registry.get('config').api, new Renderer(), registry.get('fileproviders/browser').api, registry.get('filemanager').api, contentImport);
            run = new _udapp.RunTab(blockchain, pluginUdapp, registry.get('config').api, registry.get('filemanager').api, registry.get('editor').api, filePanel, registry.get('compilersartefacts').api, networkModule, mainview, registry.get('fileproviders/browser').api);
            analysis = new AnalysisTab(registry);
            debug = new DebuggerTab();
            test = new TestTab(registry.get('filemanager').api, registry.get('offsettolinecolumnconverter').api, filePanel, compileTab, appManager, new Renderer(), contentImport);
            engine.register([compileTab, run, debug, analysis, test, filePanel.remixdHandle, filePanel.gitHandle]);

            if (isElectron()) {
              appManager.activatePlugin('remixd');
            }

            _context2.prev = 56;
            _context2.t0 = engine;
            _context2.next = 60;
            return appManager.registeredPlugins();

          case 60:
            _context2.t1 = _context2.sent;

            _context2.t0.register.call(_context2.t0, _context2.t1);

            _context2.next = 67;
            break;

          case 64:
            _context2.prev = 64;
            _context2.t2 = _context2["catch"](56);
            console.log('couldn\'t register iframe plugins', _context2.t2.message);

          case 67:
            _context2.next = 69;
            return appManager.activatePlugin(['contentImport', 'theme', 'editor', 'fileManager', 'compilerMetadata', 'compilerArtefacts', 'network', 'web3Provider', 'offsetToLineColumnConverter']);

          case 69:
            _context2.next = 71;
            return appManager.activatePlugin(['mainPanel', 'menuicons']);

          case 71:
            _context2.next = 73;
            return appManager.activatePlugin(['sidePanel']);

          case 73:
            _context2.next = 75;
            return appManager.activatePlugin(['home', 'hiddenPanel', 'pluginManager', 'fileExplorers', 'settings', 'contextualListener', 'terminal', 'fetchAndCompile']);

          case 75:
            queryParams = new QueryParams();
            params = queryParams.get(); // Set workspace after initial activation

            if (Array.isArray(workspace)) {
              appManager.activatePlugin(workspace).then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                var callDetails;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.prev = 0;

                        if (!params.deactivate) {
                          _context.next = 4;
                          break;
                        }

                        _context.next = 4;
                        return appManager.deactivatePlugin(params.deactivate.split(','));

                      case 4:
                        _context.next = 9;
                        break;

                      case 6:
                        _context.prev = 6;
                        _context.t0 = _context["catch"](0);
                        console.log(_context.t0);

                      case 9:
                        // If plugins are loaded from the URL params, we focus on the last one.
                        if (pluginLoader.current === 'queryParams' && workspace.length > 0) menuicons.select(workspace[workspace.length - 1]);

                        if (params.call) {
                          callDetails = params.call.split('//');

                          if (callDetails.length > 1) {
                            toolTip("initiating ".concat(callDetails[0], " ...")); // @todo(remove the timeout when activatePlugin is on 0.3.0)

                            appManager.call.apply(appManager, _toConsumableArray(callDetails))["catch"](console.error);
                          }
                        }

                      case 11:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, null, [[0, 6]]);
              })))["catch"](console.error);
            } else {
              // activate solidity plugin
              appManager.activatePlugin(['solidity', 'udapp']);
            } // Load and start the service who manager layout and frame


            framingService = new _framingService.FramingService(sidePanel, menuicons, mainview, this._components.resizeFeature);
            framingService.start(params); // get the file list from the parent iframe

            loadFileFromParent(fileManager); // get the file from gist

            gistHandler = new GistHandler();
            loadedFromGist = gistHandler.loadFromGist(params, fileManager);

            if (!loadedFromGist) {
              // insert example contracts if there are no files to show
              self._components.filesProviders.browser.resolveDirectory('/', function (error, filesList) {
                if (error) console.error(error);

                if (Object.keys(filesList).length === 0) {
                  for (var file in examples) {
                    fileManager.writeFile(examples[file].name, examples[file].content);
                  }
                }
              });
            }

            if (params.embed) framingService.embed();

          case 85:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[56, 64]]);
  }));
  return _run.apply(this, arguments);
}

/***/ }),

/***/ "./app/compiler/compiler-abstract.js":
/*!*******************************************!*\
  !*** ./app/compiler/compiler-abstract.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var txHelper = remixLib.execution.txHelper;

module.exports = /*#__PURE__*/function () {
  function CompilerAbstract(languageversion, data, source) {
    _classCallCheck(this, CompilerAbstract);

    this.languageversion = languageversion;
    this.data = data;
    this.source = source; // source code
  }

  _createClass(CompilerAbstract, [{
    key: "getContracts",
    value: function getContracts() {
      return this.data.contracts;
    }
  }, {
    key: "getContract",
    value: function getContract(name) {
      return txHelper.getContract(name, this.data.contracts);
    }
  }, {
    key: "visitContracts",
    value: function visitContracts(calllback) {
      return txHelper.visitContracts(this.data.contracts, calllback);
    }
  }, {
    key: "getData",
    value: function getData() {
      return this.data;
    }
  }, {
    key: "getAsts",
    value: function getAsts() {
      return this.data.sources; // ast
    }
  }, {
    key: "getSourceName",
    value: function getSourceName(fileIndex) {
      if (this.data && this.data.sources) {
        return Object.keys(this.data.sources)[fileIndex];
      } else if (Object.keys(this.source.sources).length === 1) {
        // if we don't have ast, we return the only one filename present.
        var sourcesArray = Object.keys(this.source.sources);
        return sourcesArray[0];
      }

      return null;
    }
  }, {
    key: "getSourceCode",
    value: function getSourceCode() {
      return this.source;
    }
  }]);

  return CompilerAbstract;
}();

/***/ }),

/***/ "./app/compiler/compiler-artefacts.js":
/*!********************************************!*\
  !*** ./app/compiler/compiler-artefacts.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

var _compilerAbstract = _interopRequireDefault(__webpack_require__(/*! ./compiler-abstract */ "./app/compiler/compiler-abstract.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var profile = {
  name: 'compilerArtefacts',
  methods: [],
  events: [],
  version: packageJson.version
};

module.exports = /*#__PURE__*/function (_Plugin) {
  _inherits(CompilerArtefacts, _Plugin);

  var _super = _createSuper(CompilerArtefacts);

  function CompilerArtefacts() {
    var _this;

    _classCallCheck(this, CompilerArtefacts);

    _this = _super.call(this, profile);
    _this.compilersArtefacts = {};
    _this.compilersArtefactsPerFile = {};
    return _this;
  }

  _createClass(CompilerArtefacts, [{
    key: "clear",
    value: function clear() {
      this.compilersArtefacts = {};
      this.compilersArtefactsPerFile = {};
    }
  }, {
    key: "onActivation",
    value: function onActivation() {
      var _this2 = this;

      var saveCompilationPerFileResult = function saveCompilationPerFileResult(file, source, languageVersion, data) {
        _this2.compilersArtefactsPerFile[file] = new _compilerAbstract["default"](languageVersion, data, source);
      };

      this.on('solidity', 'compilationFinished', function (file, source, languageVersion, data) {
        _this2.compilersArtefacts.__last = new _compilerAbstract["default"](languageVersion, data, source);
        saveCompilationPerFileResult(file, source, languageVersion, data);
      });
      this.on('vyper', 'compilationFinished', function (file, source, languageVersion, data) {
        _this2.compilersArtefacts.__last = new _compilerAbstract["default"](languageVersion, data, source);
        saveCompilationPerFileResult(file, source, languageVersion, data);
      });
      this.on('lexon', 'compilationFinished', function (file, source, languageVersion, data) {
        _this2.compilersArtefacts.__last = new _compilerAbstract["default"](languageVersion, data, source);
        saveCompilationPerFileResult(file, source, languageVersion, data);
      });
      this.on('yulp', 'compilationFinished', function (file, source, languageVersion, data) {
        _this2.compilersArtefacts.__last = new _compilerAbstract["default"](languageVersion, data, source);
        saveCompilationPerFileResult(file, source, languageVersion, data);
      });
      this.on('optimism-compiler', 'compilationFinished', function (file, source, languageVersion, data) {
        _this2.compilersArtefacts.__last = new _compilerAbstract["default"](languageVersion, data, source);
        saveCompilationPerFileResult(file, source, languageVersion, data);
      });
    }
  }, {
    key: "getAllContractDatas",
    value: function getAllContractDatas() {
      var _this3 = this;

      var contractsData = {};
      Object.keys(this.compilersArtefactsPerFile).map(function (targetFile) {
        var contracts = _this3.compilersArtefactsPerFile[targetFile].getContracts();

        Object.keys(contracts).map(function (file) {
          contractsData[file] = contracts[file];
        });
      }); // making sure we save last compilation result in there

      if (this.compilersArtefacts.__last) {
        var contracts = this.compilersArtefacts.__last.getContracts();

        Object.keys(contracts).map(function (file) {
          contractsData[file] = contracts[file];
        });
      }

      return contractsData;
    }
  }, {
    key: "getCompilerAbstract",
    value: function getCompilerAbstract(file) {
      return this.compilersArtefactsPerFile[file];
    } // compilerData is a CompilerAbstract object

  }, {
    key: "addResolvedContract",
    value: function addResolvedContract(address, compilerData) {
      this.compilersArtefacts[address] = compilerData;
    }
  }, {
    key: "isResolved",
    value: function isResolved(address) {
      return this.compilersArtefacts[address] !== undefined;
    }
  }, {
    key: "get",
    value: function get(key) {
      return this.compilersArtefacts[key];
    }
  }]);

  return CompilerArtefacts;
}(_engine.Plugin);

/***/ }),

/***/ "./app/compiler/compiler-helpers.js":
/*!******************************************!*\
  !*** ./app/compiler/compiler-helpers.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compile = void 0;

var _compilerUtils = __webpack_require__(/*! ./compiler-utils */ "./app/compiler/compiler-utils.js");

var _remixSolidity = __webpack_require__(/*! @remix-project/remix-solidity */ "../../../dist/libs/remix-solidity/index.js");

var _compilerAbstract = _interopRequireDefault(__webpack_require__(/*! ./compiler-abstract */ "./app/compiler/compiler-abstract.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var compile = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(compilationTargets, settings, contentResolverCallback) {
    var res;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return function () {
              return new Promise(function (resolve, reject) {
                var compiler = new _remixSolidity.Compiler(contentResolverCallback);
                compiler.set('evmVersion', settings.evmVersion);
                compiler.set('optimize', settings.optimize);
                compiler.set('language', settings.language);
                compiler.set('runs', settings.runs);
                compiler.loadVersion((0, _compilerUtils.canUseWorker)(settings.version), (0, _compilerUtils.urlFromVersion)(settings.version));
                compiler.event.register('compilationFinished', function (success, compilationData, source) {
                  resolve(new _compilerAbstract["default"](settings.version, compilationData, source));
                });
                compiler.event.register('compilerLoaded', function (_) {
                  return compiler.compile(compilationTargets, '');
                });
              });
            }();

          case 2:
            res = _context.sent;
            return _context.abrupt("return", res);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function compile(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

exports.compile = compile;

/***/ }),

/***/ "./app/compiler/compiler-imports.js":
/*!******************************************!*\
  !*** ./app/compiler/compiler-imports.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

var _remixUrlResolver = __webpack_require__(/*! @remix-project/remix-url-resolver */ "../../../dist/libs/remix-url-resolver/index.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var remixTests = __webpack_require__(/*! @remix-project/remix-tests */ "../../../dist/libs/remix-tests/src/index.js");

var globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var addTooltip = __webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js");

var async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

var resolver = __webpack_require__(/*! @resolver-engine/imports */ "../../../node_modules/@resolver-engine/imports/build/index.js").ImportsEngine();

var profile = {
  name: 'contentImport',
  displayName: 'content import',
  version: packageJson.version,
  methods: ['resolve', 'resolveAndSave', 'isExternalUrl']
};

module.exports = /*#__PURE__*/function (_Plugin) {
  _inherits(CompilerImports, _Plugin);

  var _super = _createSuper(CompilerImports);

  function CompilerImports(fileManager) {
    var _this;

    _classCallCheck(this, CompilerImports);

    _this = _super.call(this, profile);
    _this.fileManager = fileManager; // const token = await this.call('settings', 'getGithubAccessToken')

    var token = globalRegistry.get('config').api.get('settings/gist-access-token'); // TODO replace with the plugin call above https://github.com/ethereum/remix-ide/issues/2288

    var protocol = window.location.protocol;
    _this.urlResolver = new _remixUrlResolver.RemixURLResolver(token, protocol);
    _this.previouslyHandled = {}; // cache import so we don't make the request at each compilation.

    return _this;
  }

  _createClass(CompilerImports, [{
    key: "isRelativeImport",
    value: function isRelativeImport(url) {
      return /^([^/]+)/.exec(url);
    }
  }, {
    key: "isExternalUrl",
    value: function isExternalUrl(url) {
      var handlers = this.urlResolver.getHandlers();
      return handlers.some(function (handler) {
        return handler.match(url);
      });
    }
    /**
      * resolve the content of @arg url. This only resolves external URLs.
      *
      * @param {String} url  - external URL of the content. can be basically anything like raw HTTP, ipfs URL, github address etc...
      * @returns {Promise} - { content, cleanUrl, type, url }
      */

  }, {
    key: "resolve",
    value: function resolve(url) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2["import"](url, null, function (error, content, cleanUrl, type, url) {
          if (error) return reject(error);
          resolve({
            content: content,
            cleanUrl: cleanUrl,
            type: type,
            url: url
          });
        });
      });
    }
  }, {
    key: "import",
    value: function _import(url, force, loadingCb, cb) {
      if (typeof force !== 'boolean') {
        var temp = loadingCb;
        loadingCb = force;
        cb = temp;
        force = false;
      }

      if (!loadingCb) loadingCb = function loadingCb() {};
      if (!cb) cb = function cb() {};
      var self = this;
      if (force) delete this.previouslyHandled[url];
      var imported = this.previouslyHandled[url];

      if (imported) {
        return cb(null, imported.content, imported.cleanUrl, imported.type, url);
      }

      var handlers = this.urlResolver.getHandlers();
      var found = false;
      handlers.forEach(function (handler) {
        if (found) return;
        var match = handler.match(url);

        if (match) {
          found = true;
          loadingCb('Loading ' + url + ' ...');
          handler.handle(match).then(function (result) {
            var content = result.content,
                cleanUrl = result.cleanUrl;
            self.previouslyHandled[url] = {
              content: content,
              cleanUrl: cleanUrl,
              type: handler.type
            };
            cb(null, content, cleanUrl, handler.type, url);
          })["catch"](function (error) {
            cb('Unable to import url : ' + error);
          });
        }
      });
      if (found) return;
      resolver.resolve(url).then(function (result) {
        return resolver.require(url);
      }).then(function (result) {
        if (url.indexOf(result.provider + ':') === 0) {
          url = url.substring(result.provider.length + 1); // remove the github prefix
        }

        cb(null, result.source, url, result.provider, result.url);
      })["catch"](function (err) {
        console.error(err);
        cb('Unable to import "' + url + '": File not found');
      });
    }
  }, {
    key: "importExternal",
    value: function importExternal(url, targetPath, cb) {
      var _this3 = this;

      this["import"](url, // TODO: move to an event that is generated, the UI shouldn't be here
      function (loadingMsg) {
        addTooltip(loadingMsg);
      }, function (error, content, cleanUrl, type, url) {
        if (error) return cb(error);

        if (_this3.fileManager) {
          var browser = _this3.fileManager.fileProviderOf('browser/');

          var path = targetPath || type + '/' + cleanUrl;
          if (browser) browser.addExternal(path, content, url);
        }

        cb(null, content);
      });
    }
    /**
      * import the content of @arg url.
      * first look in the browser localstorage (browser explorer) or locahost explorer. if the url start with `browser/*` or  `localhost/*`
      * then check if the @arg url is located in the localhost, in the node_modules or installed_contracts folder
      * then check if the @arg url match any external url
      *
      * @param {String} url - URL of the content. can be basically anything like file located in the browser explorer, in the localhost explorer, raw HTTP, github address etc...
      * @param {String} targetPath - (optional) internal path where the content should be saved to
      * @returns {Promise} - string content
      */

  }, {
    key: "resolveAndSave",
    value: function resolveAndSave(url, targetPath) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        if (url.indexOf('remix_tests.sol') !== -1) resolve(remixTests.assertLibCode);

        if (!_this4.fileManager) {
          // fallback to just resolving the file, it won't be saved in file manager
          return _this4.importExternal(url, targetPath, function (error, content) {
            if (error) return reject(error);
            resolve(content);
          });
        }

        var provider = _this4.fileManager.fileProviderOf(url);

        if (provider) {
          if (provider.type === 'localhost' && !provider.isConnected()) {
            return reject(new Error("file provider ".concat(provider.type, " not available while trying to resolve ").concat(url)));
          }

          provider.exists(url, function (error, exist) {
            if (error) return reject(error);
            if (!exist && provider.type === 'localhost') return reject(new Error("not found ".concat(url)));
            /*
              if the path is absolute and the file does not exist, we can stop here
              Doesn't make sense to try to resolve "localhost/node_modules/localhost/node_modules/<path>" and we'll end in an infinite loop.
            */

            if (!exist && url.startsWith('browser/')) return reject(new Error("not found ".concat(url)));
            if (!exist && url.startsWith('localhost/')) return reject(new Error("not found ".concat(url)));

            if (exist) {
              return provider.get(url, function (error, content) {
                if (error) return reject(error);
                resolve(content);
              });
            } // try to resolve localhost modules (aka truffle imports) - e.g from the node_modules folder


            var localhostProvider = _this4.fileManager.getProvider('localhost');

            if (localhostProvider.isConnected()) {
              var splitted = /([^/]+)\/(.*)$/g.exec(url);
              return async.tryEach([function (cb) {
                _this4.resolveAndSave('localhost/installed_contracts/' + url).then(function (result) {
                  return cb(null, result);
                })["catch"](function (error) {
                  return cb(error.message);
                });
              }, function (cb) {
                if (!splitted) {
                  cb('URL not parseable: ' + url);
                } else {
                  _this4.resolveAndSave('localhost/installed_contracts/' + splitted[1] + '/contracts/' + splitted[2]).then(function (result) {
                    return cb(null, result);
                  })["catch"](function (error) {
                    return cb(error.message);
                  });
                }
              }, function (cb) {
                _this4.resolveAndSave('localhost/node_modules/' + url).then(function (result) {
                  return cb(null, result);
                })["catch"](function (error) {
                  return cb(error.message);
                });
              }, function (cb) {
                if (!splitted) {
                  cb('URL not parseable: ' + url);
                } else {
                  _this4.resolveAndSave('localhost/node_modules/' + splitted[1] + '/contracts/' + splitted[2]).then(function (result) {
                    return cb(null, result);
                  })["catch"](function (error) {
                    return cb(error.message);
                  });
                }
              }], function (error, result) {
                if (error) {
                  return _this4.importExternal(url, targetPath, function (error, content) {
                    if (error) return reject(error);
                    resolve(content);
                  });
                }

                resolve(result);
              });
            } else {
              // try to resolve external content
              _this4.importExternal(url, targetPath, function (error, content) {
                if (error) return reject(error);
                resolve(content);
              });
            }
          });
        }
      });
    }
  }]);

  return CompilerImports;
}(_engine.Plugin);

/***/ }),

/***/ "./app/compiler/compiler-sourceVerifier-fetchAndCompile.js":
/*!*****************************************************************!*\
  !*** ./app/compiler/compiler-sourceVerifier-fetchAndCompile.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var _compilerHelpers = __webpack_require__(/*! ./compiler-helpers */ "./app/compiler/compiler-helpers.js");

var _registry = _interopRequireDefault(__webpack_require__(/*! ../../global/registry */ "./global/registry.js"));

var _remixLib = _interopRequireDefault(__webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var ethutil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

var profile = {
  name: 'fetchAndCompile',
  methods: ['resolve'],
  version: packageJson.version
};

var FetchAndCompile = /*#__PURE__*/function (_Plugin) {
  _inherits(FetchAndCompile, _Plugin);

  var _super = _createSuper(FetchAndCompile);

  function FetchAndCompile() {
    var _this;

    _classCallCheck(this, FetchAndCompile);

    _this = _super.call(this, profile);
    _this.unresolvedAddresses = [];
    _this.sourceVerifierNetWork = ['Main', 'Rinkeby', 'Ropsten', 'Goerli'];
    return _this;
  }
  /**
   * Fetch compiliation metadata from source-Verify from a given @arg contractAddress - https://github.com/ethereum/source-verify
   * Put the artifacts in the file explorer
   * Compile the code using Solidity compiler
   * Returns compilation data
   *
   * @param {string} contractAddress - Address of the contrac to resolve
   * @param {string} deployedBytecode - deployedBytecode of the contract
   * @param {string} targetPath - Folder where to save the compilation arfefacts
   * @return {CompilerAbstract} - compilation data targeting the given @arg contractAddress
   */


  _createClass(FetchAndCompile, [{
    key: "resolve",
    value: function () {
      var _resolve = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(contractAddress, codeAtAddress, targetPath) {
        var _this2 = this;

        var compilersartefacts, localCompilation, resolved, network, compilation, found, name, data, compilationTargets, file, urls, _iterator, _step, url, stdUrl, source, path, settings, compData;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                contractAddress = ethutil.toChecksumAddress(contractAddress);
                compilersartefacts = _registry["default"].get('compilersartefacts').api;

                localCompilation = function localCompilation() {
                  return compilersartefacts.get(contractAddress) ? compilersartefacts.get(contractAddress) : compilersartefacts.get('__last') ? compilersartefacts.get('__last') : null;
                };

                resolved = compilersartefacts.get(contractAddress);

                if (!resolved) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", resolved);

              case 6:
                if (!this.unresolvedAddresses.includes(contractAddress)) {
                  _context.next = 8;
                  break;
                }

                return _context.abrupt("return", localCompilation());

              case 8:
                _context.prev = 8;
                _context.next = 11;
                return this.call('network', 'detectNetwork');

              case 11:
                network = _context.sent;
                _context.next = 17;
                break;

              case 14:
                _context.prev = 14;
                _context.t0 = _context["catch"](8);
                return _context.abrupt("return", localCompilation());

              case 17:
                if (network) {
                  _context.next = 19;
                  break;
                }

                return _context.abrupt("return", localCompilation());

              case 19:
                if (this.sourceVerifierNetWork.includes(network.name)) {
                  _context.next = 21;
                  break;
                }

                return _context.abrupt("return", localCompilation());

              case 21:
                // check if the contract if part of the local compilation result
                compilation = localCompilation();

                if (!compilation) {
                  _context.next = 29;
                  break;
                }

                found = false;
                compilation.visitContracts(function (contract) {
                  found = _remixLib["default"].util.compareByteCode('0x' + contract.object.evm.deployedBytecode.object, codeAtAddress);
                  return found;
                });

                if (!found) {
                  _context.next = 29;
                  break;
                }

                compilersartefacts.addResolvedContract(contractAddress, compilation);
                setTimeout(function (_) {
                  return _this2.emit('usingLocalCompilation', contractAddress);
                }, 0);
                return _context.abrupt("return", compilation);

              case 29:
                name = network.name.toLowerCase();
                name = name === 'main' ? 'mainnet' : name; // source-verifier api expect "mainnet" and not "main"

                _context.prev = 31;
                _context.next = 34;
                return this.call('source-verification', 'fetchByNetwork', contractAddress, name.toLowerCase());

              case 34:
                data = _context.sent;
                _context.next = 42;
                break;

              case 37:
                _context.prev = 37;
                _context.t1 = _context["catch"](31);
                setTimeout(function (_) {
                  return _this2.emit('notFound', contractAddress);
                }, 0); // plugin framework returns a time out error although it actually didn't find the source...

                this.unresolvedAddresses.push(contractAddress);
                return _context.abrupt("return", localCompilation());

              case 42:
                if (!(!data || !data.metadata)) {
                  _context.next = 46;
                  break;
                }

                setTimeout(function (_) {
                  return _this2.emit('notFound', contractAddress);
                }, 0);
                this.unresolvedAddresses.push(contractAddress);
                return _context.abrupt("return", localCompilation());

              case 46:
                _context.next = 48;
                return this.call('fileManager', 'setFile', "".concat(targetPath, "/").concat(name, "/").concat(contractAddress, "/metadata.json"), JSON.stringify(data.metadata, null, '\t'));

              case 48:
                compilationTargets = {};
                _context.t2 = regeneratorRuntime.keys(data.metadata.sources);

              case 50:
                if ((_context.t3 = _context.t2()).done) {
                  _context.next = 86;
                  break;
                }

                file = _context.t3.value;
                urls = data.metadata.sources[file].urls;
                _iterator = _createForOfIteratorHelper(urls);
                _context.prev = 54;

                _iterator.s();

              case 56:
                if ((_step = _iterator.n()).done) {
                  _context.next = 76;
                  break;
                }

                url = _step.value;

                if (!url.includes('ipfs')) {
                  _context.next = 74;
                  break;
                }

                stdUrl = "ipfs://".concat(url.split('/')[2]);
                _context.next = 62;
                return this.call('contentImport', 'resolve', stdUrl);

              case 62:
                source = _context.sent;
                _context.next = 65;
                return this.call('contentImport', 'isExternalUrl', file);

              case 65:
                if (!_context.sent) {
                  _context.next = 68;
                  break;
                }

                _context.next = 73;
                break;

              case 68:
                file = file.replace('browser/', ''); // should be fixed in the remix IDE end.

                path = "".concat(targetPath, "/").concat(name, "/").concat(contractAddress, "/").concat(file);
                _context.next = 72;
                return this.call('fileManager', 'setFile', path, source.content);

              case 72:
                compilationTargets[path] = {
                  content: source.content
                };

              case 73:
                return _context.abrupt("break", 76);

              case 74:
                _context.next = 56;
                break;

              case 76:
                _context.next = 81;
                break;

              case 78:
                _context.prev = 78;
                _context.t4 = _context["catch"](54);

                _iterator.e(_context.t4);

              case 81:
                _context.prev = 81;

                _iterator.f();

                return _context.finish(81);

              case 84:
                _context.next = 50;
                break;

              case 86:
                // compile
                settings = {
                  version: data.metadata.compiler.version,
                  language: data.metadata.language,
                  evmVersion: data.metadata.settings.evmVersion,
                  optimize: data.metadata.settings.optimizer.enabled,
                  runs: data.metadata.settings.runs
                };
                _context.prev = 87;
                setTimeout(function (_) {
                  return _this2.emit('compiling', settings);
                }, 0);
                _context.next = 91;
                return (0, _compilerHelpers.compile)(compilationTargets, settings, function (url, cb) {
                  return _this2.call('contentImport', 'resolveAndSave', url).then(function (result) {
                    return cb(null, result);
                  })["catch"](function (error) {
                    return cb(error.message);
                  });
                });

              case 91:
                compData = _context.sent;
                compilersartefacts.addResolvedContract(contractAddress, compData);
                return _context.abrupt("return", compData);

              case 96:
                _context.prev = 96;
                _context.t5 = _context["catch"](87);
                this.unresolvedAddresses.push(contractAddress);
                setTimeout(function (_) {
                  return _this2.emit('compilationFailed');
                }, 0);
                return _context.abrupt("return", localCompilation());

              case 101:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[8, 14], [31, 37], [54, 78, 81, 84], [87, 96]]);
      }));

      function resolve(_x, _x2, _x3) {
        return _resolve.apply(this, arguments);
      }

      return resolve;
    }()
  }]);

  return FetchAndCompile;
}(_engine.Plugin);

exports["default"] = FetchAndCompile;

/***/ }),

/***/ "./app/compiler/compiler-utils.js":
/*!****************************************!*\
  !*** ./app/compiler/compiler-utils.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.urlFromVersion = urlFromVersion;
exports.canUseWorker = canUseWorker;
exports.promisedMiniXhr = promisedMiniXhr;
exports.pathToURL = exports.baseURLWasm = exports.baseURLBin = void 0;

var semver = __webpack_require__(/*! semver */ "../../../node_modules/semver/semver.js");

var minixhr = __webpack_require__(/*! minixhr */ "../../../node_modules/minixhr/minixhr.js");
/* global Worker */


var baseURLBin = 'https://solc-bin.ethereum.org/bin';
exports.baseURLBin = baseURLBin;
var baseURLWasm = 'https://solc-bin.ethereum.org/wasm';
exports.baseURLWasm = baseURLWasm;
var pathToURL = {};
/**
 * Retrieves the URL of the given compiler version
 * @param version is the version of compiler with or without 'soljson-v' prefix and .js postfix
 */

exports.pathToURL = pathToURL;

function urlFromVersion(version) {
  if (!version.startsWith('soljson-v')) version = 'soljson-v' + version;
  if (!version.endsWith('.js')) version = version + '.js';
  return "".concat(pathToURL[version], "/").concat(version);
}
/**
 * Checks if the worker can be used to load a compiler.
 * checks a compiler whitelist, browser support and OS.
 */


function canUseWorker(selectedVersion) {
  var version = semver.coerce(selectedVersion);
  var isNightly = selectedVersion.includes('nightly');
  return browserSupportWorker() && (semver.gt(version, '0.6.3') || semver.gt(version, '0.3.6') && !isNightly);
}

function browserSupportWorker() {
  return document.location.protocol !== 'file:' && Worker !== undefined;
} // returns a promise for minixhr


function promisedMiniXhr(url) {
  return new Promise(function (resolve, reject) {
    minixhr(url, function (json, event) {
      resolve({
        json: json,
        event: event
      });
    });
  });
}

/***/ }),

/***/ "./app/components/hidden-panel.js":
/*!****************************************!*\
  !*** ./app/components/hidden-panel.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HiddenPanel = void 0;

var _panel = __webpack_require__(/*! ./panel */ "./app/components/panel.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n      <div class=", ">\n        ", "\n      </div>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .pluginsContainer {\n    display: none;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = csjs(_templateObject());
var profile = {
  name: 'hiddenPanel',
  displayName: 'Hidden Panel',
  description: '',
  version: packageJson.version,
  methods: ['addView', 'removeView']
};

var HiddenPanel = /*#__PURE__*/function (_AbstractPanel) {
  _inherits(HiddenPanel, _AbstractPanel);

  var _super = _createSuper(HiddenPanel);

  function HiddenPanel() {
    _classCallCheck(this, HiddenPanel);

    return _super.call(this, profile);
  }

  _createClass(HiddenPanel, [{
    key: "render",
    value: function render() {
      return yo(_templateObject2(), css.pluginsContainer, this.view);
    }
  }]);

  return HiddenPanel;
}(_panel.AbstractPanel);

exports.HiddenPanel = HiddenPanel;

/***/ }),

/***/ "./app/components/local-plugin.js":
/*!****************************************!*\
  !*** ./app/components/local-plugin.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n    <form id=\"local-plugin-form\">\n      <div class=\"form-group\">\n        <label for=\"plugin-name\">Plugin Name <small>(required)</small></label>\n        <input class=\"form-control\" onchange=\"", "\" value=\"", "\" id=\"plugin-name\" data-id=\"localPluginName\" placeholder=\"Should be camelCase\">\n      </div>\n      <div class=\"form-group\">\n        <label for=\"plugin-displayname\">Display Name</label>\n        <input class=\"form-control\" onchange=\"", "\" value=\"", "\" id=\"plugin-displayname\" data-id=\"localPluginDisplayName\" placeholder=\"Name in the header\">\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"plugin-methods\">Api (comma separated list of methods name)</label>\n        <input class=\"form-control\" onchange=\"", "\" value=\"", "\" id=\"plugin-methods\" data-id=\"localPluginMethods\" placeholder=\"Name in the header\">\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"plugin-url\">Url <small>(required)</small></label>\n        <input class=\"form-control\" onchange=\"", "\" value=\"", "\" id=\"plugin-url\" data-id=\"localPluginUrl\" placeholder=\"ex: https://localhost:8000\">\n      </div>\n      <h6>Type of connection <small>(required)</small></h6>\n      <div class=\"form-check form-group\">\n        ", "\n        ", "\n      </div>\n      <h6>Location in remix <small>(required)</small></h6>\n      <div class=\"form-check form-group\">\n        ", "\n        ", "\n        ", "\n      </div>\n    </form>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<div class=\"radio\">\n          <input class=\"form-check-input\" type=\"radio\" name=\"", "\" onclick=\"", "\" value=\"", "\" id=\"", "\" data-id=\"localPluginRadioButton", "\" />\n          <label class=\"form-check-label\" for=\"", "\">", "</label>\n        </div>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["<div class=\"radio\">\n          <input class=\"form-check-input\" type=\"radio\" name=\"", "\" onclick=\"", "\" value=\"", "\" id=\"", "\" data-id=\"localPluginRadioButton", "\" checked=\"checked\" />\n          <label class=\"form-check-label\" for=\"", "\">", "</label>\n        </div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/* global localStorage */
var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var modalDialog = __webpack_require__(/*! ../ui/modaldialog */ "./app/ui/modaldialog.js");

var defaultProfile = {
  methods: [],
  location: 'sidePanel',
  type: 'iframe'
};

module.exports = /*#__PURE__*/function () {
  function LocalPlugin() {
    _classCallCheck(this, LocalPlugin);
  }

  _createClass(LocalPlugin, [{
    key: "open",

    /**
     * Open a modal to create a local plugin
     * @param {Profile[]} plugins The list of the plugins in the store
     * @returns {Promise<{api: any, profile: any}>} A promise with the new plugin profile
     */
    value: function open(plugins) {
      var _this = this;

      this.profile = JSON.parse(localStorage.getItem('plugins/local')) || defaultProfile;
      return new Promise(function (resolve, reject) {
        var onValidation = function onValidation() {
          try {
            var profile = _this.create();

            resolve(profile);
          } catch (err) {
            reject(err);
          }
        };

        modalDialog('Local Plugin', _this.form(), {
          fn: function fn() {
            return onValidation();
          }
        }, {
          fn: function fn() {
            return resolve();
          }
        });
      });
    }
    /**
     * Create the object to add to the plugin-list
     */

  }, {
    key: "create",
    value: function create() {
      var profile = _objectSpread(_objectSpread({
        icon: 'assets/img/localPlugin.webp',
        methods: [],
        location: 'sidePanel',
        type: 'iframe'
      }, this.profile), {}, {
        hash: "local-".concat(this.profile.name)
      });

      if (!profile.location) throw new Error('Plugin should have a location');
      if (!profile.name) throw new Error('Plugin should have a name');
      if (!profile.url) throw new Error('Plugin should have an URL');
      localStorage.setItem('plugins/local', JSON.stringify(profile));
      return profile;
    }
  }, {
    key: "updateName",
    value: function updateName(_ref) {
      var target = _ref.target;
      this.profile.name = target.value;
    }
  }, {
    key: "updateUrl",
    value: function updateUrl(_ref2) {
      var target = _ref2.target;
      this.profile.url = target.value;
    }
  }, {
    key: "updateDisplayName",
    value: function updateDisplayName(_ref3) {
      var target = _ref3.target;
      this.profile.displayName = target.value;
    }
  }, {
    key: "updateProfile",
    value: function updateProfile(key, e) {
      this.profile[key] = e.target.value;
    }
  }, {
    key: "updateMethods",
    value: function updateMethods(_ref4) {
      var target = _ref4.target;

      if (target.value) {
        try {
          this.profile.methods = target.value.split(',');
        } catch (e) {}
      }
    }
    /** The form to create a local plugin */

  }, {
    key: "form",
    value: function form() {
      var _this2 = this;

      var name = this.profile.name || '';
      var url = this.profile.url || '';
      var displayName = this.profile.displayName || '';
      var methods = this.profile.methods && this.profile.methods.join(',') || '';

      var radioSelection = function radioSelection(key, label, message) {
        return _this2.profile[key] === label ? yo(_templateObject(), key, function (e) {
          return _this2.updateProfile(key, e);
        }, label, label, label, label, message) : yo(_templateObject2(), key, function (e) {
          return _this2.updateProfile(key, e);
        }, label, label, label, label, message);
      };

      return yo(_templateObject3(), function (e) {
        return _this2.updateName(e);
      }, name, function (e) {
        return _this2.updateDisplayName(e);
      }, displayName, function (e) {
        return _this2.updateMethods(e);
      }, methods, function (e) {
        return _this2.updateUrl(e);
      }, url, radioSelection('type', 'iframe', 'Iframe'), radioSelection('type', 'ws', 'Websocket'), radioSelection('location', 'sidePanel', 'Side Panel'), radioSelection('location', 'mainPanel', 'Main Panel'), radioSelection('location', 'none', 'None'));
    }
  }]);

  return LocalPlugin;
}();

/***/ }),

/***/ "./app/components/main-panel.js":
/*!**************************************!*\
  !*** ./app/components/main-panel.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MainPanel = void 0;

var _panel = __webpack_require__(/*! ./panel */ "./app/components/panel.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n      <div class=", " data-id=\"mainPanelPluginsContainer\">\n        ", "\n      </div>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .pluginsContainer {\n    height: 100%;\n    display: flex;\n    overflow-y: hidden;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());
var profile = {
  name: 'mainPanel',
  displayName: 'Main Panel',
  description: '',
  version: packageJson.version,
  methods: ['addView', 'removeView']
};

var MainPanel = /*#__PURE__*/function (_AbstractPanel) {
  _inherits(MainPanel, _AbstractPanel);

  var _super = _createSuper(MainPanel);

  function MainPanel() {
    _classCallCheck(this, MainPanel);

    return _super.call(this, profile);
  }

  _createClass(MainPanel, [{
    key: "focus",
    value: function focus(name) {
      this.emit('focusChanged', name);

      _get(_getPrototypeOf(MainPanel.prototype), "focus", this).call(this, name);
    }
  }, {
    key: "render",
    value: function render() {
      return yo(_templateObject2(), css.pluginsContainer, this.view);
    }
  }]);

  return MainPanel;
}(_panel.AbstractPanel);

exports.MainPanel = MainPanel;

/***/ }),

/***/ "./app/components/panel.js":
/*!*********************************!*\
  !*** ./app/components/panel.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbstractPanel = void 0;

var _events = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

var _engineWeb = __webpack_require__(/*! @remixproject/engine-web */ "../../../node_modules/@remixproject/engine-web/index.js");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<div class=\"", "\" >", "", "</div>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"d-flex justify-content-center align-items-center\">\n        <div class=\"spinner-border\" role=\"status\">\n          <span class=\"sr-only\">Loading...</span>\n        </div>\n      </div>  \n    "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<div id=\"plugins\" class=\"", "\"></div>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .plugins        {\n    height: 100%;\n  }\n  .plugItIn       {\n    display        : none;\n    height         : 100%;\n  }\n  .plugItIn > div {\n    overflow-y     : auto;\n    overflow-x     : hidden;\n    height         : 100%;\n    width          : 100%;\n  }\n  .plugItIn.active     {\n    display        : block;\n  }\n  .pluginsContainer {\n    height         : 100%;\n    overflow-y     : hidden;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = csjs(_templateObject());
/** Abstract class used for hosting the view of a plugin */

var AbstractPanel = /*#__PURE__*/function (_HostPlugin) {
  _inherits(AbstractPanel, _HostPlugin);

  var _super = _createSuper(AbstractPanel);

  function AbstractPanel(profile) {
    var _this;

    _classCallCheck(this, AbstractPanel);

    _this = _super.call(this, profile);
    _this.events = new _events.EventEmitter();
    _this.contents = {};
    _this.active = undefined; // View where the plugin HTMLElement leaves

    _this.view = yo(_templateObject2(), css.plugins);
    return _this;
  }
  /**
   * Add the plugin to the panel
   * @param {String} name the name of the plugin
   * @param {HTMLElement} content the HTMLContent of the plugin
   */


  _createClass(AbstractPanel, [{
    key: "add",
    value: function add(view, name) {
      var _this2 = this;

      if (this.contents[name]) throw new Error("Plugin ".concat(name, " already rendered"));
      view.style.height = '100%';
      view.style.width = '100%';
      view.style.border = '0';
      var isIframe = view.tagName === 'IFRAME';
      view.style.display = isIframe ? 'none' : 'block';
      var loading = isIframe ? yo(_templateObject3()) : '';
      this.contents[name] = yo(_templateObject4(), css.plugItIn, view, loading);

      if (view.tagName === 'IFRAME') {
        view.addEventListener('load', function () {
          if (_this2.contents[name].contains(loading)) {
            _this2.contents[name].removeChild(loading);
          }

          view.style.display = 'block';
        });
      }

      this.contents[name].style.display = 'none';
      this.view.appendChild(this.contents[name]);
    }
  }, {
    key: "addView",
    value: function addView(profile, view) {
      this.add(view, profile.name);
    }
  }, {
    key: "removeView",
    value: function removeView(profile) {
      this.remove(profile.name);
    }
    /**
     * Remove a plugin from the panel
     * @param {String} name The name of the plugin to remove
     */

  }, {
    key: "remove",
    value: function remove(name) {
      var el = this.contents[name];
      delete this.contents[name];
      if (el) el.parentElement.removeChild(el);
      if (name === this.active) this.active = undefined;
    }
    /**
     * Display the content of this specific plugin
     * @param {String} name The name of the plugin to display the content
     */

  }, {
    key: "showContent",
    value: function showContent(name) {
      if (!this.contents[name]) throw new Error("Plugin ".concat(name, " is not yet activated")); // hiding the current view and display the `moduleName`

      if (this.active) {
        this.contents[this.active].style.display = 'none';
      }

      this.contents[name].style.display = 'flex';
      this.active = name;
    }
  }, {
    key: "focus",
    value: function focus(name) {
      this.showContent(name);
    }
  }]);

  return AbstractPanel;
}(_engineWeb.HostPlugin);

exports.AbstractPanel = AbstractPanel;

/***/ }),

/***/ "./app/components/plugin-manager-component.js":
/*!****************************************************!*\
  !*** ./app/components/plugin-manager-component.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engineWeb = __webpack_require__(/*! @remixproject/engine-web */ "../../../node_modules/@remixproject/engine-web/index.js");

var _pluginManagerSettings = __webpack_require__(/*! ./plugin-manager-settings */ "./app/components/plugin-manager-settings.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject9() {
  var data = _taggedTemplateLiteral(["\n      <div id='pluginManager' data-id=\"pluginManagerComponentPluginManager\">\n        <header class=\"form-group ", " plugins-header py-3 px-4 border-bottom\" data-id=\"pluginManagerComponentPluginManagerHeader\">\n          <input onkeyup=\"", "\" class=\"", " form-control\" placeholder=\"Search\" data-id=\"pluginManagerComponentSearchInput\">\n          <button onclick=\"", "\" class=\"", " btn bg-transparent text-dark border-0 mt-2 text-underline\" data-id=\"pluginManagerComponentPluginSearchButton\">\n            Connect to a Local Plugin\n          </button>\n        </header>\n        <section data-id=\"pluginManagerComponentPluginManagerSection\">\n          ", "\n          <div class=\"list-group list-group-flush plugins-list-group\" data-id=\"pluginManagerComponentActiveTile\">\n            ", "\n          </div>\n          ", "\n          <div class=\"list-group list-group-flush plugins-list-group\" data-id=\"pluginManagerComponentInactiveTile\">\n            ", "\n          </div>\n        </section>\n        ", "\n      </div>\n    "]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["\n      <nav class=\"plugins-list-header justify-content-between navbar navbar-expand-lg bg-light navbar-light align-items-center\">\n        <span class=\"navbar-brand plugins-list-title h6 mb-0 mr-2\">Inactive Modules</span>\n        <span class=\"badge badge-primary\" style = \"cursor: default;\" data-id=\"pluginManagerComponentInactiveTilesCount\">", "</span>\n      </nav>"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n      <nav class=\"plugins-list-header justify-content-between navbar navbar-expand-lg bg-light navbar-light align-items-center\">\n        <span class=\"navbar-brand plugins-list-title\">Active Modules</span>\n        <span class=\"badge badge-primary\" data-id=\"pluginManagerComponentActiveTilesCount\">", "</span>\n      </nav>"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n      <article id=\"remixPluginManagerListItem_", "\" class=\"list-group-item py-1 mb-1 plugins-list-group-item\" title=\"", "\" >\n        <div class=\"", " justify-content-between align-items-center mb-2\">\n          <h6 class=\"", " plugin-name\">\n            ", "\n            ", "\n            ", "\n          </h6>\n        </div>\n        <div class=\"", " d-flex text-body plugin-text mb-2\">\n          <img src=\"", "\" class=\"mr-1 mt-1 ", "\" />\n          <span class=\"", "\">", "</span>\n        </div>\n      </article>\n    "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n      <button\n        onclick=\"", "\"\n        class=\"btn btn-success btn-sm\" data-id=\"pluginManagerComponentActivateButton", "\"\n      >\n        Activate\n      </button>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n      <button\n        onclick=\"", "\"\n        class=\"btn btn-secondary btn-sm\" data-id=\"pluginManagerComponentDeactivateButton", "\"\n      >\n        Deactivate\n      </button>\n      "]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<small title=\"Version Beta\" class=\"", " plugin-version\">beta</small>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<small title=\"Version Alpha\" class=\"", " plugin-version\">alpha</small>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .pluginSearch {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    background-color: var(--light);\n    padding: 10px;\n    position: sticky;\n    top: 0;\n    z-index: 2;\n    margin-bottom: 0px;\n  }\n  .pluginSearchInput {\n    height: 38px;\n  }\n  .pluginSearchButton {\n    font-size: 13px;\n  }\n  .displayName {\n    width: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n  }\n  .pluginIcon {\n    height: 0.7rem;\n    width: 0.7rem;\n    filter: invert(0.5);\n  }\n  .description {\n    font-size: 13px;\n    line-height: 18px;\n  }\n  .descriptiontext {\n    display: block;\n  }\n  .descriptiontext:first-letter {\n    text-transform: uppercase;\n  }\n  .row {\n    display: flex;\n    flex-direction: row;\n  }\n  .isStuck {\n    background-color: var(--primary);\n    color: \n  }\n  .versionWarning {\n    padding: 4px;\n    margin: 0 8px;\n    font-weight: 700;\n    font-size: 9px;\n    line-height: 12px;\n    text-transform: uppercase;\n    cursor: default;\n    border: 1px solid;\n    border-radius: 2px;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var EventEmitter = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

var LocalPlugin = __webpack_require__(/*! ./local-plugin */ "./app/components/local-plugin.js");

var addToolTip = __webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js");

var css = csjs(_templateObject());
var profile = {
  name: 'pluginManager',
  displayName: 'Plugin manager',
  methods: [],
  events: [],
  icon: 'assets/img/pluginManager.webp',
  description: 'Start/stop services, modules and plugins',
  kind: 'settings',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/plugin_manager.html',
  version: packageJson.version
};

var PluginManagerComponent = /*#__PURE__*/function (_ViewPlugin) {
  _inherits(PluginManagerComponent, _ViewPlugin);

  var _super = _createSuper(PluginManagerComponent);

  function PluginManagerComponent(appManager, engine) {
    var _this;

    _classCallCheck(this, PluginManagerComponent);

    _this = _super.call(this, profile);
    _this.event = new EventEmitter();
    _this.appManager = appManager;
    _this.views = {
      root: null,
      items: {}
    };
    _this.localPlugin = new LocalPlugin();
    _this.filter = '';

    _this.appManager.event.on('activate', function () {
      _this.reRender();
    });

    _this.appManager.event.on('deactivate', function () {
      _this.reRender();
    });

    _this.engine = engine;

    _this.engine.event.on('onRegistration', function () {
      _this.reRender();
    });

    return _this;
  }

  _createClass(PluginManagerComponent, [{
    key: "isActive",
    value: function isActive(name) {
      return this.appManager.actives.includes(name);
    }
  }, {
    key: "renderItem",
    value: function renderItem(profile) {
      var _this2 = this;

      var displayName = profile.displayName ? profile.displayName : profile.name; // Check version of the plugin

      var versionWarning; // Alpha

      if (profile.version && profile.version.match(/\b(\w*alpha\w*)\b/g)) {
        versionWarning = yo(_templateObject2(), css.versionWarning);
      } // Beta


      if (profile.version && profile.version.match(/\b(\w*beta\w*)\b/g)) {
        versionWarning = yo(_templateObject3(), css.versionWarning);
      }

      var activationButton = this.isActive(profile.name) ? yo(_templateObject4(), function (_) {
        return _this2.appManager.deactivatePlugin(profile.name);
      }, profile.name) : yo(_templateObject5(), function (_) {
        return _this2.appManager.activatePlugin(profile.name);
      }, profile.name);
      return yo(_templateObject6(), profile.name, displayName, css.row, css.displayName, displayName, versionWarning, activationButton, css.description, profile.icon, css.pluginIcon, css.descriptiontext, profile.description);
    }
    /***************
     * SUB-COMPONENT
     */

    /**
     * Add a local plugin to the list of plugins
     */

  }, {
    key: "openLocalPlugin",
    value: function () {
      var _openLocalPlugin = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _profile, plugin;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return this.localPlugin.open(this.appManager.getAll());

              case 3:
                _profile = _context.sent;

                if (_profile) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return");

              case 6:
                if (!this.appManager.getIds().includes(_profile.name)) {
                  _context.next = 8;
                  break;
                }

                throw new Error('This name has already been used');

              case 8:
                plugin = _profile.type === 'iframe' ? new _engineWeb.IframePlugin(_profile) : new _engineWeb.WebsocketPlugin(_profile);
                this.engine.register(plugin);
                _context.next = 12;
                return this.appManager.activatePlugin(plugin.name);

              case 12:
                _context.next = 18;
                break;

              case 14:
                _context.prev = 14;
                _context.t0 = _context["catch"](0);
                // TODO : Use an alert to handle this error instead of a console.log
                console.log("Cannot create Plugin : ".concat(_context.t0.message));
                addToolTip("Cannot create Plugin : ".concat(_context.t0.message));

              case 18:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 14]]);
      }));

      function openLocalPlugin() {
        return _openLocalPlugin.apply(this, arguments);
      }

      return openLocalPlugin;
    }()
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      // Filtering helpers
      var isFiltered = function isFiltered(profile) {
        return (profile.displayName ? profile.displayName : profile.name).toLowerCase().includes(_this3.filter);
      };

      var isNotRequired = function isNotRequired(profile) {
        return !_this3.appManager.isRequired(profile.name);
      };

      var isNotHome = function isNotHome(profile) {
        return profile.name !== 'home';
      };

      var sortByName = function sortByName(profileA, profileB) {
        var nameA = (profileA.displayName ? profileA.displayName : profileA.name).toUpperCase();
        var nameB = (profileB.displayName ? profileB.displayName : profileB.name).toUpperCase();
        return nameA < nameB ? -1 : nameA > nameB ? 1 : 0;
      }; // Filter all active and inactive modules that are not required


      var _this$appManager$getA = this.appManager.getAll().filter(isFiltered).filter(isNotRequired).filter(isNotHome).sort(sortByName).reduce(function (_ref, profile) {
        var actives = _ref.actives,
            inactives = _ref.inactives;
        return _this3.isActive(profile.name) ? {
          actives: [].concat(_toConsumableArray(actives), [profile]),
          inactives: inactives
        } : {
          inactives: [].concat(_toConsumableArray(inactives), [profile]),
          actives: actives
        };
      }, {
        actives: [],
        inactives: []
      }),
          actives = _this$appManager$getA.actives,
          inactives = _this$appManager$getA.inactives;

      var activeTile = actives.length !== 0 ? yo(_templateObject7(), actives.length) : '';
      var inactiveTile = inactives.length !== 0 ? yo(_templateObject8(), inactives.length) : '';
      var settings = new _pluginManagerSettings.PluginManagerSettings().render();
      var rootView = yo(_templateObject9(), css.pluginSearch, function (e) {
        return _this3.filterPlugins(e);
      }, css.pluginSearchInput, function (_) {
        return _this3.openLocalPlugin();
      }, css.pluginSearchButton, activeTile, actives.map(function (profile) {
        return _this3.renderItem(profile);
      }), inactiveTile, inactives.map(function (profile) {
        return _this3.renderItem(profile);
      }), settings);
      if (!this.views.root) this.views.root = rootView;
      return rootView;
    }
  }, {
    key: "reRender",
    value: function reRender() {
      if (this.views.root) {
        yo.update(this.views.root, this.render());
      }
    }
  }, {
    key: "filterPlugins",
    value: function filterPlugins(_ref2) {
      var target = _ref2.target;
      this.filter = target.value.toLowerCase();
      this.reRender();
    }
  }]);

  return PluginManagerComponent;
}(_engineWeb.ViewPlugin);

module.exports = PluginManagerComponent;

/***/ }),

/***/ "./app/components/plugin-manager-settings.js":
/*!***************************************************!*\
  !*** ./app/components/plugin-manager-settings.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PluginManagerSettings = void 0;

function _templateObject9() {
  var data = _taggedTemplateLiteral(["\n    <footer class=\"bg-light ", " remix-bg-opacity\">\n      <button onclick=\"", "\" class=\"btn btn-primary settings-button\" data-id=\"pluginManagerPermissionsButton\">Permissions</button>\n    </footer>"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["<form class=\"", "\" data-id=\"pluginManagerSettingsPermissionForm\">\n      ", "\n      <hr/>\n      ", "\n    </form>"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["<h4>Current Permission settings</h4>"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["<h4>No Permission requested yet.</h4>"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n      <div border p-2>\n        <div class=\"pb-2 ", "\">\n          <h3>", " permissions:</h3>\n          <i onclick=\"", "\" class=\"far fa-trash-alt\" data-id=\"pluginManagerSettingsClearAllPermission-", "\"></i>\n        </div>\n        ", "\n      </div>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n            <div class=\"form-group ", "\">\n              <div class=\"", "\">\n                ", "\n                <label for=\"permission-checkbox-", "-", "-", "\" data-id=\"permission-label-", "-", "-", "\">Allow <u>", "</u> to call <u>", "</u></label>\n              </div>\n              <i onclick=\"", "\" class=\"fa fa-trash-alt\" data-id=\"pluginManagerSettingsRemovePermission-", "-", "-", "\"></i>\n            </div>\n          "]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<input onchange=", " class=\"mr-2\" type=\"checkbox\" id=\"permission-checkbox-", "-", "-", "\" aria-describedby=\"module ", " asks permission for ", "\" />"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<input onchange=", " class=\"mr-2\" type=\"checkbox\" checked id=\"permission-checkbox-", "-", "-", "\" aria-describedby=\"module ", " asks permission for ", "\" />"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _templateObject() {
  var data = _taggedTemplateLiteral([" \n.permissions {\n  position: sticky;\n  bottom: 0;\n  display: flex;\n  justify-content: flex-end;\n  align-items: center;\n  padding: 5px 20px;\n}\n.permissions button {\n  padding: 2px 5px;\n  cursor: pointer;\n}\n.permissionForm h4 {\n  font-size: 1.3rem;\n  text-align: center;\n}\n.permissionForm h6 {\n  font-size: 1.1rem;\n}\n.permissionForm hr {\n  width: 80%;\n}\n.permissionKey {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n.permissionKey i {\n  cursor: pointer;\n}\n.checkbox {\n  display: flex;\n  align-items: center;\n}\n.checkbox label {\n  margin: 0;\n  font-size: 1rem;\n}\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var modalDialog = __webpack_require__(/*! ../ui/modaldialog */ "./app/ui/modaldialog.js");

var css = csjs(_templateObject());

var PluginManagerSettings = /*#__PURE__*/function () {
  function PluginManagerSettings() {
    _classCallCheck(this, PluginManagerSettings);
  }

  _createClass(PluginManagerSettings, [{
    key: "openDialog",
    value: function openDialog() {
      var _this = this;

      var fromLocal = window.localStorage.getItem('plugins/permissions');
      this.permissions = JSON.parse(fromLocal || '{}');
      this.currentSetting = this.settings();
      modalDialog('Plugin Manager Permissions', this.currentSetting, {
        fn: function fn() {
          return _this.onValidation();
        }
      });
    }
  }, {
    key: "onValidation",
    value: function onValidation() {
      var permissions = JSON.stringify(this.permissions);
      window.localStorage.setItem('plugins/permissions', permissions);
    }
    /** Clear one permission from a plugin */

  }, {
    key: "clearPersmission",
    value: function clearPersmission(from, to, method) {
      if (this.permissions[to] && this.permissions[to][method]) {
        delete this.permissions[to][method][from];

        if (Object.keys(this.permissions[to][method]).length === 0) {
          delete this.permissions[to][method];
        }

        if (Object.keys(this.permissions[to]).length === 0) {
          delete this.permissions[to];
        }

        yo.update(this.currentSetting, this.settings());
      }
    }
    /** Clear all persmissions from a plugin */

  }, {
    key: "clearAllPersmission",
    value: function clearAllPersmission(to) {
      if (!this.permissions[to]) return;
      delete this.permissions[to];
      yo.update(this.currentSetting, this.settings());
    }
  }, {
    key: "settings",
    value: function settings() {
      var _this2 = this;

      var permissionByToPlugin = function permissionByToPlugin(toPlugin, funcObj) {
        var permissionByMethod = function permissionByMethod(methodName, fromPlugins) {
          var togglePermission = function togglePermission(fromPlugin) {
            _this2.permissions[toPlugin][methodName][fromPlugin].allow = !_this2.permissions[toPlugin][methodName][fromPlugin].allow;
          };

          return Object.keys(fromPlugins).map(function (fromName) {
            var fromPluginPermission = fromPlugins[fromName];
            var checkbox = fromPluginPermission.allow ? yo(_templateObject2(), function () {
              return togglePermission(fromName);
            }, toPlugin, methodName, toPlugin, fromPluginPermission, methodName) : yo(_templateObject3(), function () {
              return togglePermission(fromName);
            }, toPlugin, methodName, toPlugin, fromPluginPermission, methodName);
            return yo(_templateObject4(), css.permissionKey, css.checkbox, checkbox, toPlugin, methodName, toPlugin, toPlugin, methodName, toPlugin, fromName, methodName, function () {
              return _this2.clearPersmission(fromName, toPlugin, methodName);
            }, toPlugin, methodName, toPlugin);
          });
        };

        var permissionsByFunctions = Object.keys(funcObj).map(function (methodName) {
          return permissionByMethod(methodName, funcObj[methodName]);
        });
        return yo(_templateObject5(), css.permissionKey, toPlugin, function () {
          return _this2.clearAllPersmission(toPlugin);
        }, toPlugin, permissionsByFunctions);
      };

      var byToPlugin = Object.keys(this.permissions).map(function (toPlugin) {
        return permissionByToPlugin(toPlugin, _this2.permissions[toPlugin]);
      });
      var title = byToPlugin.length === 0 ? yo(_templateObject6()) : yo(_templateObject7());
      return yo(_templateObject8(), css.permissionForm, title, byToPlugin);
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      return yo(_templateObject9(), css.permissions, function () {
        return _this3.openDialog();
      });
    }
  }]);

  return PluginManagerSettings;
}();

exports.PluginManagerSettings = PluginManagerSettings;

/***/ }),

/***/ "./app/components/side-panel.js":
/*!**************************************!*\
  !*** ./app/components/side-panel.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SidePanel = void 0;

var _panel = __webpack_require__(/*! ./panel */ "./app/components/panel.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n      <section class=\"", " plugin-manager\">\n        ", "\n        <div class=\"", "\">\n          ", "\n        </div>\n      </section>"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n      <header class=\"", "\">\n        <h6 class=\"", "\" data-id=\"sidePanelSwapitTitle\">", "</h6>\n        ", "\n        ", "\n      </header>\n    "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["<small title=\"Version Beta\" class=\"badge-light ", "\">beta</small>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<small title=\"Version Alpha\" class=\"badge-light ", "\">alpha</small>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<a href=\"", "\" class=\"", "\" title=\"link to documentation\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fas fa-book\"></i></a>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<header></header>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .panel {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n    flex: auto;\n  }\n  .swapitTitle {\n    margin: 0;\n    text-transform: uppercase;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n  .swapitTitle i{\n    padding-left: 6px;\n    font-size: 14px;\n  }\n  .swapitHeader {\n    display: flex;\n    align-items: center;\n    padding: 16px 24px 15px;\n    justify-content: space-between;\n  }\n  .icons i {\n    height: 80%;\n    cursor: pointer;\n  }\n  .pluginsContainer {\n    height: 100%;\n    overflow-y: auto;\n  }\n  .titleInfo {\n    padding-left: 10px;\n  }\n  .versionBadge {\n    background-color: var(--light);\n    padding: 0 7px;\n    font-weight: bolder;\n    margin-left: 5px;\n    text-transform: lowercase;\n    cursor: default;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = csjs(_templateObject());
var sidePanel = {
  name: 'sidePanel',
  displayName: 'Side Panel',
  description: '',
  version: packageJson.version,
  methods: ['addView', 'removeView']
}; // TODO merge with vertical-icons.js

var SidePanel = /*#__PURE__*/function (_AbstractPanel) {
  _inherits(SidePanel, _AbstractPanel);

  var _super = _createSuper(SidePanel);

  function SidePanel(appManager, verticalIcons) {
    var _this;

    _classCallCheck(this, SidePanel);

    _this = _super.call(this, sidePanel);
    _this.appManager = appManager;
    _this.header = yo(_templateObject2());

    _this.renderHeader();

    _this.verticalIcons = verticalIcons; // Toggle content

    verticalIcons.events.on('toggleContent', function (name) {
      if (!_this.contents[name]) return;

      if (_this.active === name) {
        // TODO: Only keep `this.emit` (issue#2210)
        _this.emit('toggle', name);

        _this.events.emit('toggle', name);

        return;
      }

      _this.showContent(name); // TODO: Only keep `this.emit` (issue#2210)


      _this.emit('showing', name);

      _this.events.emit('showing', name);
    }); // Force opening

    verticalIcons.events.on('showContent', function (name) {
      if (!_this.contents[name]) return;

      _this.showContent(name); // TODO: Only keep `this.emit` (issue#2210)


      _this.emit('showing', name);

      _this.events.emit('showing', name);
    });
    return _this;
  }

  _createClass(SidePanel, [{
    key: "focus",
    value: function focus(name) {
      this.emit('focusChanged', name);

      _get(_getPrototypeOf(SidePanel.prototype), "focus", this).call(this, name);
    }
  }, {
    key: "removeView",
    value: function removeView(profile) {
      _get(_getPrototypeOf(SidePanel.prototype), "removeView", this).call(this, profile);

      this.emit('pluginDisabled', profile.name);
      this.verticalIcons.unlinkContent(profile);
    }
  }, {
    key: "addView",
    value: function addView(profile, view) {
      _get(_getPrototypeOf(SidePanel.prototype), "addView", this).call(this, profile, view);

      this.verticalIcons.linkContent(profile);
    }
    /**
     * Display content and update the header
     * @param {String} name The name of the plugin to display
     */

  }, {
    key: "showContent",
    value: function () {
      var _showContent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(name) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _get(_getPrototypeOf(SidePanel.prototype), "showContent", this).call(this, name);

                this.renderHeader();
                this.emit('focusChanged', name);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function showContent(_x) {
        return _showContent.apply(this, arguments);
      }

      return showContent;
    }()
    /** The header of the side panel */

  }, {
    key: "renderHeader",
    value: function () {
      var _renderHeader = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var name, docLink, versionWarning, profile, header;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                name = ' - ';
                docLink = '';

                if (!this.active) {
                  _context2.next = 10;
                  break;
                }

                _context2.next = 5;
                return this.appManager.getProfile(this.active);

              case 5:
                profile = _context2.sent;
                name = profile.displayName ? profile.displayName : profile.name;
                docLink = profile.documentation ? yo(_templateObject3(), profile.documentation, css.titleInfo) : '';

                if (profile.version && profile.version.match(/\b(\w*alpha\w*)\b/g)) {
                  versionWarning = yo(_templateObject4(), css.versionBadge);
                } // Beta


                if (profile.version && profile.version.match(/\b(\w*beta\w*)\b/g)) {
                  versionWarning = yo(_templateObject5(), css.versionBadge);
                }

              case 10:
                header = yo(_templateObject6(), css.swapitHeader, css.swapitTitle, name, docLink, versionWarning);
                yo.update(this.header, header);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function renderHeader() {
        return _renderHeader.apply(this, arguments);
      }

      return renderHeader;
    }()
  }, {
    key: "render",
    value: function render() {
      return yo(_templateObject7(), css.panel, this.header, css.pluginsContainer, this.view);
    }
  }]);

  return SidePanel;
}(_panel.AbstractPanel);

exports.SidePanel = SidePanel;

/***/ }),

/***/ "./app/components/vertical-icons.js":
/*!******************************************!*\
  !*** ./app/components/vertical-icons.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VerticalIcons = void 0;

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

var _svgLogo = __webpack_require__(/*! ../ui/svgLogo */ "./app/ui/svgLogo.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject13() {
  var data = _taggedTemplateLiteral(["\n  .homeIcon {\n      display: block;\n      width: 42px;\n      height: 42px;\n      margin-bottom: 20px;\n      margin-left: -5px;\n      cursor: pointer;\n  }\n  .homeIcon svg path {\n    fill: var(--primary);\n  }\n  .homeIcon svg polygon {\n    fill: var(--primary);\n  }\n  .icons {\n    margin-left: 10px;\n    margin-top: 15px;\n  }\n  .icon {\n    cursor: pointer;\n    margin-bottom: 12px;\n    width: 36px;\n    height: 36px;\n    padding: 3px;\n    position: relative;\n    border-radius: 8px;\n  }\n  .icon img {\n    width: 28px;\n    height: 28px;\n    padding: 4px;\n    filter: invert(0.5);\n  }\n  .image {\n  }\n  .icon svg {\n    width: 28px;\n    height: 28px;\n    padding: 4px;\n  }\n  .icon[title='Settings'] {\n    position: absolute;\n    bottom: 0;\n  }\n  .status {\n    position: absolute;\n    bottom: 0;\n    right: 0;\n  }\n  .statusCheck {\n    font-size: 1.2em;\n  }\n  .statusWithBG\n    border-radius: 8px;\n    background-color: var(--danger);\n    color: var(--light);\n    font-size: 12px;\n    height: 15px;\n    text-align: center;\n    font-weight: bold;\n    padding-left: 5px;\n    padding-right: 5px;\n  }\n"]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteral(["\n      <div class=", ">\n        ", "\n        ", "\n        ", "\n        ", "\n        ", "\n        ", "\n        ", "\n        ", "\n        ", "\n      </div>\n    "]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function _templateObject11() {
  var data = _taggedTemplateLiteral(["<div id='settingsIcons' data-id=\"verticalIconsSettingsIcons\"></div>"]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["<div id='otherIcons'></div>"]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["<div id='debuggingIcons' data-id=\"verticalIconsDebuggingIcons\"></div>"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["<div id='analysisIcons'></div>"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["<div id='testingIcons'></div>"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["<div id='runIcons'></div>"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["<div id='compileIcons'></div>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<div id='fileExplorerIcons' data-id=\"verticalIconsFileExplorerIcons\"></div>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n      <div\n        class=\"", "\"\n        onclick=\"", "\"\n        plugin=\"home\" title=\"Home\"\n        data-id=\"verticalIconsHomeIcon\"\n      >\n        ", "\n      </div>\n    "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<span\n      title=\"", "\"\n      class=\"", "\"\n      aria-hidden=\"true\"\n    >\n    ", "\n    </span>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n      <div\n        class=\"", "\"\n        onclick=\"", "\"\n        plugin=\"", "\"\n        title=\"", "\"\n        oncontextmenu=\"", "\"\n        data-id=\"verticalIconsKind", "\">\n        <img class=\"image\" src=\"", "\" alt=\"", "\" />\n      </div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var helper = __webpack_require__(/*! ../../lib/helper */ "./lib/helper.js");

var globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var contextMenu = __webpack_require__(/*! ../ui/contextMenu */ "./app/ui/contextMenu.js");

var _require = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js"),
    Plugin = _require.Plugin;

var EventEmitter = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

var VERTICALMENU_HANDLE;
var profile = {
  name: 'menuicons',
  displayName: 'Vertical Icons',
  description: '',
  version: packageJson.version,
  methods: ['select']
}; // TODO merge with side-panel.js. VerticalIcons should not be a plugin

var VerticalIcons = /*#__PURE__*/function (_Plugin) {
  _inherits(VerticalIcons, _Plugin);

  var _super = _createSuper(VerticalIcons);

  function VerticalIcons(appManager) {
    var _this;

    _classCallCheck(this, VerticalIcons);

    _this = _super.call(this, profile);
    _this.events = new EventEmitter();
    _this.appManager = appManager;
    _this.icons = {};
    _this.iconKind = {};
    _this.iconStatus = {};
    var themeModule = globalRegistry.get('themeModule').api;
    themeModule.events.on('themeChanged', function (theme) {
      _this.onThemeChanged(theme.quality);
    });
    return _this;
  }

  _createClass(VerticalIcons, [{
    key: "linkContent",
    value: function linkContent(profile) {
      if (!profile.icon) return;
      this.addIcon(profile);
      this.listenOnStatus(profile);
    }
  }, {
    key: "unlinkContent",
    value: function unlinkContent(profile) {
      this.removeIcon(profile);
    }
  }, {
    key: "listenOnStatus",
    value: function listenOnStatus(profile) {
      var _this2 = this;

      // the list of supported keys. 'none' will remove the status
      var keys = ['edited', 'succeed', 'none', 'loading', 'failed'];
      var types = ['error', 'warning', 'success', 'info', ''];

      var fn = function fn(status) {
        if (!types.includes(status.type) && status.type) throw new Error("type should be ".concat(keys.join()));
        if (status.key === undefined) throw new Error('status key should be defined');

        if (typeof status.key === 'string' && !keys.includes(status.key)) {
          throw new Error('key should contain either number or ' + keys.join());
        }

        _this2.setIconStatus(profile.name, status);
      };

      this.iconStatus[profile.name] = fn;
      this.on(profile.name, 'statusChanged', this.iconStatus[profile.name]);
    }
    /**
     * Add an icon to the map
     * @param {ModuleProfile} profile The profile of the module
     */

  }, {
    key: "addIcon",
    value: function addIcon(_ref) {
      var _this3 = this;

      var kind = _ref.kind,
          name = _ref.name,
          icon = _ref.icon,
          displayName = _ref.displayName,
          tooltip = _ref.tooltip,
          documentation = _ref.documentation;
      var title = tooltip || displayName || name;
      title = title.replace(/^\w/, function (c) {
        return c.toUpperCase();
      });
      this.icons[name] = yo(_templateObject(), css.icon, function () {
        _this3.toggle(name);
      }, name, title, function (e) {
        return _this3.itemContextMenu(e, name, documentation);
      }, name, icon, name);
      this.iconKind[kind || 'none'].appendChild(this.icons[name]);
    }
    /**
     * resolve a classes list for @arg key
     * @param {Object} key
     * @param {Object} type
     */

  }, {
    key: "resolveClasses",
    value: function resolveClasses(key, type) {
      var classes = css.status;

      switch (key) {
        case 'succeed':
          classes += ' fas fa-check-circle text-' + type + ' ' + css.statusCheck;
          break;

        case 'edited':
          classes += ' fas fa-sync text-' + type + ' ' + css.statusCheck;
          break;

        case 'loading':
          classes += ' fas fa-spinner text-' + type + ' ' + css.statusCheck;
          break;

        case 'failed':
          classes += ' fas fa-exclamation-triangle text-' + type + ' ' + css.statusCheck;
          break;

        default:
          {
            classes += ' badge badge-pill badge-' + type;
          }
      }

      return classes;
    }
    /**
     * Set a new status for the @arg name
     * @param {String} name
     * @param {Object} status
     */

  }, {
    key: "setIconStatus",
    value: function setIconStatus(name, status) {
      var el = this.icons[name];
      if (!el) return;
      var statusEl = el.querySelector('span');

      if (statusEl) {
        el.removeChild(statusEl);
      }

      if (status.key === 'none') return; // remove status

      var text = '';
      var key = '';

      if (typeof status.key === 'number') {
        key = status.key.toString();
        text = key;
      } else key = helper.checkSpecialChars(status.key) ? '' : status.key;

      var type = '';

      if (status.type === 'error') {
        type = 'danger'; // to use with bootstrap
      } else type = helper.checkSpecialChars(status.type) ? '' : status.type;

      var title = helper.checkSpecialChars(status.title) ? '' : status.title;
      el.appendChild(yo(_templateObject2(), title, this.resolveClasses(key, type), text));
      el.classList.add("".concat(css.icon));
    }
    /**
     * Remove an icon from the map
     * @param {ModuleProfile} profile The profile of the module
     */

  }, {
    key: "removeIcon",
    value: function removeIcon(_ref2) {
      var kind = _ref2.kind,
          name = _ref2.name;
      if (this.icons[name]) this.iconKind[kind || 'none'].removeChild(this.icons[name]);
    }
    /**
     *  Remove active for the current activated icons
     */

  }, {
    key: "removeActive",
    value: function removeActive() {
      // reset filters
      var images = this.view.querySelectorAll('.image');
      images.forEach(function (im) {
        im.style.setProperty('filter', 'invert(0.5)');
      }); // remove active

      var currentActive = this.view.querySelector('.active');

      if (currentActive) {
        currentActive.classList.remove('active');
      }
    }
    /**
     *  Add active for the new activated icon
     * @param {string} name Name of profile of the module to activate
     */

  }, {
    key: "addActive",
    value: function addActive(name) {
      if (name === 'home') return;
      var themeType = globalRegistry.get('themeModule').api.currentTheme().quality;
      var invert = themeType === 'dark' ? 1 : 0;
      var brightness = themeType === 'dark' ? '150' : '0'; // should be >100 for icons with color

      var nextActive = this.view.querySelector("[plugin=\"".concat(name, "\"]"));

      if (nextActive) {
        var image = nextActive.querySelector('.image');
        nextActive.classList.add('active');
        image.style.setProperty('filter', "invert(".concat(invert, ") grayscale(1) brightness(").concat(brightness, "%)"));
      }
    }
    /**
     * Set an icon as active
     * @param {string} name Name of profile of the module to activate
     */

  }, {
    key: "select",
    value: function select(name) {
      this.updateActivations(name); // TODO: Only keep `this.emit` (issue#2210)

      this.emit('showContent', name);
      this.events.emit('showContent', name);
    }
    /**
     * Toggles the side panel for plugin
     * @param {string} name Name of profile of the module to activate
     */

  }, {
    key: "toggle",
    value: function toggle(name) {
      this.updateActivations(name); // TODO: Only keep `this.emit` (issue#2210)

      this.emit('toggleContent', name);
      this.events.emit('toggleContent', name);
    }
  }, {
    key: "updateActivations",
    value: function updateActivations(name) {
      this.removeActive();
      this.addActive(name);
    }
  }, {
    key: "onThemeChanged",
    value: function onThemeChanged(themeType) {
      var invert = themeType === 'dark' ? 1 : 0;
      var active = this.view.querySelector('.active');

      if (active) {
        var image = active.querySelector('.image');
        image.style.setProperty('filter', "invert(".concat(invert, ")"));
      }
    }
  }, {
    key: "itemContextMenu",
    value: function () {
      var _itemContextMenu = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e, name, documentation) {
        var _this4 = this;

        var actions, links;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                actions = {};
                _context.next = 3;
                return this.appManager.canDeactivatePlugin(profile, {
                  name: name
                });

              case 3:
                if (!_context.sent) {
                  _context.next = 5;
                  break;
                }

                actions.Deactivate = function () {
                  // this.call('manager', 'deactivatePlugin', name)
                  _this4.appManager.deactivatePlugin(name);

                  if (e.target.parentElement.classList.contains('active')) {
                    _this4.select('fileExplorers');
                  }
                };

              case 5:
                links = {};

                if (documentation) {
                  links.Documentation = documentation;
                }

                if (Object.keys(actions).length || Object.keys(links).length) {
                  VERTICALMENU_HANDLE && VERTICALMENU_HANDLE.hide(null, true);
                  VERTICALMENU_HANDLE = contextMenu(e, actions, links);
                }

                e.preventDefault();
                e.stopPropagation();

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function itemContextMenu(_x, _x2, _x3) {
        return _itemContextMenu.apply(this, arguments);
      }

      return itemContextMenu;
    }()
  }, {
    key: "render",
    value: function render() {
      var _this5 = this;

      var home = yo(_templateObject3(), css.homeIcon, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _this5.appManager.activatePlugin('home');

              case 2:
                _this5.call('tabs', 'focus', 'home');

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      })), (0, _svgLogo.basicLogo)());
      this.iconKind.fileexplorer = yo(_templateObject4());
      this.iconKind.compiler = yo(_templateObject5());
      this.iconKind.udapp = yo(_templateObject6());
      this.iconKind.testing = yo(_templateObject7());
      this.iconKind.analysis = yo(_templateObject8());
      this.iconKind.debugging = yo(_templateObject9());
      this.iconKind.none = yo(_templateObject10());
      this.iconKind.settings = yo(_templateObject11());
      this.view = yo(_templateObject12(), css.icons, home, this.iconKind.fileexplorer, this.iconKind.compiler, this.iconKind.udapp, this.iconKind.testing, this.iconKind.analysis, this.iconKind.debugging, this.iconKind.none, this.iconKind.settings);
      return this.view;
    }
  }]);

  return VerticalIcons;
}(Plugin);

exports.VerticalIcons = VerticalIcons;
var css = csjs(_templateObject13());

/***/ }),

/***/ "./app/editor/SourceHighlighters.js":
/*!******************************************!*\
  !*** ./app/editor/SourceHighlighters.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var SourceHighlighter = __webpack_require__(/*! ./sourceHighlighter */ "./app/editor/sourceHighlighter.js");

var SourceHighlighters = /*#__PURE__*/function () {
  function SourceHighlighters() {
    _classCallCheck(this, SourceHighlighters);

    this.highlighters = {};
  }

  _createClass(SourceHighlighters, [{
    key: "highlight",
    value: function highlight(position, filePath, hexColor, from) {
      // eslint-disable-next-line
      try {
        if (!this.highlighters[from]) this.highlighters[from] = [];
        var sourceHighlight = new SourceHighlighter();

        if (!this.highlighters[from].length || this.highlighters[from].length && !this.highlighters[from].find(function (el) {
          return el.source === filePath && el.position === position;
        })) {
          sourceHighlight.currentSourceLocationFromfileName(position, filePath, hexColor);
          this.highlighters[from].push(sourceHighlight);
        }
      } catch (e) {
        throw e;
      }
    } // highlights all locations for @from plugin

  }, {
    key: "highlightAllFrom",
    value: function highlightAllFrom(from) {
      // eslint-disable-next-line
      try {
        if (!this.highlighters[from]) return;
        var sourceHighlight;

        for (var index in this.highlighters[from]) {
          sourceHighlight = new SourceHighlighter();
          sourceHighlight.currentSourceLocationFromfileName(this.highlighters[from][index].position, this.highlighters[from][index].source, this.highlighters[from][index].style);
          this.highlighters[from][index] = sourceHighlight;
        }
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: "discardHighlight",
    value: function discardHighlight(from) {
      if (this.highlighters[from]) {
        for (var index in this.highlighters[from]) {
          this.highlighters[from][index].currentSourceLocation(null);
        }
      }

      this.highlighters[from] = [];
    }
  }, {
    key: "discardAllHighlights",
    value: function discardAllHighlights() {
      for (var from in this.highlighters) {
        this.discardHighlight(from);
      }
    }
  }, {
    key: "hideHighlightsExcept",
    value: function hideHighlightsExcept(toStay) {
      for (var highlighter in this.highlighters) {
        for (var index in this.highlighters[highlighter]) {
          this.highlighters[highlighter][index].currentSourceLocation(null);
        }
      }

      this.highlightAllFrom(toStay);
    }
  }, {
    key: "discardHighlightAt",
    value: function discardHighlightAt(line, filePath, from) {
      if (this.highlighters[from]) {
        for (var index in this.highlighters[from]) {
          var highlight = this.highlighters[from][index];

          if (highlight.source === filePath && (highlight.position.start.line === line || highlight.position.end.line === line)) {
            highlight.currentSourceLocation(null);
            this.highlighters[from].splice(index, 1);
          }
        }
      }
    }
  }]);

  return SourceHighlighters;
}();

module.exports = SourceHighlighters;

/***/ }),

/***/ "./app/editor/contextView.js":
/*!***********************************!*\
  !*** ./app/editor/contextView.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _remixDebug = __webpack_require__(/*! @remix-project/remix-debug */ "../../../dist/libs/remix-debug/src/index.js");

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n      <div class=", ">", "\n        <div title=", " class=", ">", "</div>\n        <div title=", " class=", ">", "</div>\n        <i class=\"fas fa-share ", "\" aria-hidden=\"true\" onclick=", "></i>\n        <span class=", ">", "</span>\n        <i data-action='previous' class=\"fas fa-chevron-up ", "\" aria-hidden=\"true\" onclick=", "></i>\n        <i data-action='next' class=\"fas fa-chevron-down ", "\" aria-hidden=\"true\" onclick=", "></i>\n      </div>\n    "]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n          <div class=", ">\n            <i class=\"fas fa-gas-pump ", "\" title='Gas estimation'></i>\n            <span>", "</span>\n          </div>\n        "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<div></div>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", " ", " bg-light text-dark border-0\">\n        <div class=", ">\n          ", "\n        </div>\n      </div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var css = __webpack_require__(/*! ./styles/contextView-styles */ "./app/editor/styles/contextView-styles.js");
/*
  Display information about the current focused code:
   - if it's a reference, display information about the declaration
   - jump to the declaration
   - number of references
   - rename declaration/references
*/


var ContextView = /*#__PURE__*/function () {
  function ContextView(opts, localRegistry) {
    var _this = this;

    _classCallCheck(this, ContextView);

    this._components = {};
    this._components.registry = localRegistry || globalRegistry;
    this.contextualListener = opts.contextualListener;
    this.editor = opts.editor;
    this._deps = {
      compilersArtefacts: this._components.registry.get('compilersartefacts').api,
      offsetToLineColumnConverter: this._components.registry.get('offsettolinecolumnconverter').api,
      config: this._components.registry.get('config').api,
      fileManager: this._components.registry.get('filemanager').api
    };
    this._view = null;
    this._nodes = null;
    this._current = null;
    this.sourceMappingDecoder = _remixDebug.sourceMappingDecoder;
    this.previousElement = null;
    this.contextualListener.event.register('contextChanged', function (nodes) {
      _this.show();

      _this._nodes = nodes;

      _this.update();
    });
    this.contextualListener.event.register('stopHighlighting', function () {});
  }

  _createClass(ContextView, [{
    key: "render",
    value: function render() {
      var view = yo(_templateObject(), css.contextview, css.contextviewcontainer, css.container, this._renderTarget());

      if (!this._view) {
        this._view = view;
      }

      return view;
    }
  }, {
    key: "hide",
    value: function hide() {
      if (this._view) {
        this._view.style.display = 'none';
      }
    }
  }, {
    key: "show",
    value: function show() {
      if (this._view) {
        this._view.style.display = 'block';
      }
    }
  }, {
    key: "update",
    value: function update() {
      if (this._view) {
        yo.update(this._view, this.render());
      }
    }
  }, {
    key: "_renderTarget",
    value: function _renderTarget() {
      var last;
      var previous = this._current;

      if (this._nodes && this._nodes.length) {
        last = this._nodes[this._nodes.length - 1];

        if (isDefinition(last)) {
          this._current = last;
        } else {
          var target = this.contextualListener.declarationOf(last);

          if (target) {
            this._current = target;
          } else {
            this._current = null;
          }
        }
      }

      if (!this._current || !previous || previous.id !== this._current.id || this.previousElement && !this.previousElement.children.length) {
        this.previousElement = this._render(this._current, last);
      }

      return this.previousElement;
    }
  }, {
    key: "_jumpToInternal",
    value: function _jumpToInternal(position) {
      var _this2 = this;

      var jumpToLine = function jumpToLine(lineColumn) {
        if (lineColumn.start && lineColumn.start.line && lineColumn.start.column) {
          _this2.editor.gotoLine(lineColumn.start.line, lineColumn.end.column + 1);
        }
      };

      var lastCompilationResult = this._deps.compilersArtefacts.__last;

      if (lastCompilationResult && lastCompilationResult.languageversion.indexOf('soljson') === 0 && lastCompilationResult.data) {
        var lineColumn = this._deps.offsetToLineColumnConverter.offsetToLineColumn(position, position.file, lastCompilationResult.getSourceCode().sources, lastCompilationResult.getAsts());

        var filename = lastCompilationResult.getSourceName(position.file); // TODO: refactor with rendererAPI.errorClick

        if (filename !== this._deps.config.get('currentFile')) {
          var provider = this._deps.fileManager.fileProviderOf(filename);

          if (provider) {
            provider.exists(filename, function (error, exist) {
              if (error) return console.log(error);

              _this2._deps.fileManager.open(filename);

              jumpToLine(lineColumn);
            });
          }
        } else {
          jumpToLine(lineColumn);
        }
      }
    }
  }, {
    key: "_render",
    value: function _render(node, nodeAtCursorPosition) {
      var _this3 = this;

      if (!node) return yo(_templateObject2());
      var references = this.contextualListener.referencesOf(node);
      var type = node.typeDescriptions && node.typeDescriptions.typeString ? node.typeDescriptions.typeString : node.nodeType;
      references = "".concat(references ? references.length : '0', " reference(s)");
      var ref = 0;
      var nodes = this.contextualListener.getActiveHighlights();

      for (var k in nodes) {
        if (nodeAtCursorPosition.id === nodes[k].nodeId) {
          ref = k;
          break;
        }
      } // JUMP BETWEEN REFERENCES


      var jump = function jump(e) {
        e.target.dataset.action === 'next' ? ref++ : ref--;
        if (ref < 0) ref = nodes.length - 1;
        if (ref >= nodes.length) ref = 0;

        _this3._jumpToInternal(nodes[ref].position);
      };

      var jumpTo = function jumpTo() {
        if (node && node.src) {
          var position = _this3.sourceMappingDecoder.decode(node.src);

          if (position) {
            _this3._jumpToInternal(position);
          }
        }
      };

      var showGasEstimation = function showGasEstimation() {
        if (node.nodeType === 'FunctionDefinition') {
          var result = _this3.contextualListener.gasEstimation(node);

          var executionCost = ' Execution cost: ' + result.executionCost + ' gas';
          var codeDepositCost = 'Code deposit cost: ' + result.codeDepositCost + ' gas';
          var estimatedGas = result.codeDepositCost ? "".concat(codeDepositCost, ", ").concat(executionCost) : "".concat(executionCost);
          return yo(_templateObject3(), css.gasEstimation, css.gasStationIcon, estimatedGas);
        }
      };

      return yo(_templateObject4(), css.line, showGasEstimation(), type, css.type, type, node.name, css.name, node.name, css.jump, jumpTo, css.referencesnb, references, css.jump, jump, css.jump, jump);
    }
  }]);

  return ContextView;
}();

function isDefinition(node) {
  return node.nodeType === 'ContractDefinition' || node.nodeType === 'FunctionDefinition' || node.nodeType === 'ModifierDefinition' || node.nodeType === 'VariableDeclaration' || node.nodeType === 'StructDefinition' || node.nodeType === 'EventDefinition';
}

module.exports = ContextView;

/***/ }),

/***/ "./app/editor/contextualListener.js":
/*!******************************************!*\
  !*** ./app/editor/contextualListener.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

var _remixDebug = __webpack_require__(/*! @remix-project/remix-debug */ "../../../dist/libs/remix-debug/src/index.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n        .highlightref_fullLine {\n          position: absolute;\n          z-index: 2;\n          opacity: 0.1;\n          background-color: var(--info);\n        }\n        "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _require = __webpack_require__(/*! @remix-project/remix-astwalker */ "../../../dist/libs/remix-astwalker/index.js"),
    AstWalker = _require.AstWalker;

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

var globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var profile = {
  name: 'contextualListener',
  methods: [],
  events: [],
  version: packageJson.version
};
/*
  trigger contextChanged(nodes)
*/

var ContextualListener = /*#__PURE__*/function (_Plugin) {
  _inherits(ContextualListener, _Plugin);

  var _super = _createSuper(ContextualListener);

  function ContextualListener(opts) {
    var _this;

    _classCallCheck(this, ContextualListener);

    _this = _super.call(this, profile);
    _this.event = new EventManager();
    _this._components = {};
    _this._components.registry = globalRegistry;
    _this.editor = opts.editor;
    _this.pluginManager = opts.pluginManager;
    _this._deps = {
      compilersArtefacts: _this._components.registry.get('compilersartefacts').api,
      config: _this._components.registry.get('config').api,
      offsetToLineColumnConverter: _this._components.registry.get('offsettolinecolumnconverter').api
    };
    _this._index = {
      Declarations: {},
      FlatReferences: {}
    };
    _this._activeHighlights = [];

    _this.editor.event.register('contentChanged', function () {
      _this._stopHighlighting();
    });

    _this.sourceMappingDecoder = _remixDebug.sourceMappingDecoder;
    _this.astWalker = new AstWalker();
    return _this;
  }

  _createClass(ContextualListener, [{
    key: "onActivation",
    value: function onActivation() {
      var _this2 = this;

      this.on('solidity', 'compilationFinished', function (file, source, languageVersion, data) {
        if (languageVersion.indexOf('soljson') !== 0) return;

        _this2._stopHighlighting();

        _this2._index = {
          Declarations: {},
          FlatReferences: {}
        };

        _this2._buildIndex(data, source);
      });
      setInterval(function () {
        if (_this2._deps.compilersArtefacts.__last && _this2._deps.compilersArtefacts.__last.languageversion.indexOf('soljson') === 0) {
          _this2._highlightItems(_this2.editor.getCursorPosition(), _this2._deps.compilersArtefacts.__last, _this2._deps.config.get('currentFile'));
        }
      }, 1000);
    }
  }, {
    key: "getActiveHighlights",
    value: function getActiveHighlights() {
      return _toConsumableArray(this._activeHighlights);
    }
  }, {
    key: "declarationOf",
    value: function declarationOf(node) {
      if (node && node.referencedDeclaration) {
        return this._index.FlatReferences[node.referencedDeclaration];
      }

      return null;
    }
  }, {
    key: "referencesOf",
    value: function referencesOf(node) {
      return this._index.Declarations[node.id];
    }
  }, {
    key: "_highlightItems",
    value: function _highlightItems(cursorPosition, compilationResult, file) {
      if (this.currentPosition === cursorPosition) return;

      if (this.currentFile !== file) {
        this.currentFile = file;
        this.currentPosition = cursorPosition;
        return;
      }

      this._stopHighlighting();

      this.currentPosition = cursorPosition;
      this.currentFile = file;

      if (compilationResult && compilationResult.data && compilationResult.data.sources[file]) {
        var nodes = this.sourceMappingDecoder.nodesAtPosition(null, cursorPosition, compilationResult.data.sources[file]);
        this.nodes = nodes;

        if (nodes && nodes.length && nodes[nodes.length - 1]) {
          this._highlightExpressions(nodes[nodes.length - 1], compilationResult);
        }

        this.event.trigger('contextChanged', [nodes]);
      }
    }
  }, {
    key: "_buildIndex",
    value: function _buildIndex(compilationResult, source) {
      var _this3 = this;

      if (compilationResult && compilationResult.sources) {
        var callback = function callback(node) {
          if (node && node.referencedDeclaration) {
            if (!_this3._index.Declarations[node.referencedDeclaration]) {
              _this3._index.Declarations[node.referencedDeclaration] = [];
            }

            _this3._index.Declarations[node.referencedDeclaration].push(node);
          }

          _this3._index.FlatReferences[node.id] = node;
        };

        for (var s in compilationResult.sources) {
          this.astWalker.walkFull(compilationResult.sources[s].ast, callback);
        }
      }
    }
  }, {
    key: "_highlight",
    value: function _highlight(node, compilationResult) {
      if (!node) return;
      var position = this.sourceMappingDecoder.decode(node.src);

      var eventId = this._highlightInternal(position, node);

      var lastCompilationResult = this._deps.compilersArtefacts.__last;

      if (eventId && lastCompilationResult && lastCompilationResult.languageversion.indexOf('soljson') === 0) {
        this._activeHighlights.push({
          eventId: eventId,
          position: position,
          fileTarget: lastCompilationResult.getSourceName(position.file),
          nodeId: node.id
        });
      }
    }
  }, {
    key: "_highlightInternal",
    value: function _highlightInternal(position, node) {
      if (node.nodeType === 'Block') return;
      var lastCompilationResult = this._deps.compilersArtefacts.__last;

      if (lastCompilationResult && lastCompilationResult.languageversion.indexOf('soljson') === 0) {
        var lineColumn = this._deps.offsetToLineColumnConverter.offsetToLineColumn(position, position.file, lastCompilationResult.getSourceCode().sources, lastCompilationResult.getAsts());

        var css = csjs(_templateObject());

        if (node.nodes && node.nodes.length) {
          // If node has children, highlight the entire line. if not, just highlight the current source position of the node.
          lineColumn = {
            start: {
              line: lineColumn.start.line,
              column: 0
            },
            end: {
              line: lineColumn.start.line + 1,
              column: 0
            }
          };
        }

        var fileName = lastCompilationResult.getSourceName(position.file);

        if (fileName) {
          return this.editor.addMarker(lineColumn, fileName, css.highlightref_fullLine);
        }
      }

      return null;
    }
  }, {
    key: "_highlightExpressions",
    value: function _highlightExpressions(node, compilationResult) {
      var _this4 = this;

      var highlights = function highlights(id) {
        if (_this4._index.Declarations && _this4._index.Declarations[id]) {
          var refs = _this4._index.Declarations[id];

          for (var ref in refs) {
            var _node = refs[ref];

            _this4._highlight(_node, compilationResult);
          }
        }
      };

      if (node && node.referencedDeclaration) {
        highlights(node.referencedDeclaration);
        var current = this._index.FlatReferences[node.referencedDeclaration];

        this._highlight(current, compilationResult);
      } else {
        highlights(node.id);

        this._highlight(node, compilationResult);
      }

      this.results = compilationResult;
    }
  }, {
    key: "_stopHighlighting",
    value: function _stopHighlighting() {
      for (var eventKey in this._activeHighlights) {
        var event = this._activeHighlights[eventKey];
        this.editor.removeMarker(event.eventId, event.fileTarget);
      }

      this.event.trigger('stopHighlighting', []);
      this._activeHighlights = [];
    }
  }, {
    key: "gasEstimation",
    value: function gasEstimation(node) {
      this._loadContractInfos(node);

      var executionCost, codeDepositCost;

      if (node.nodeType === 'FunctionDefinition') {
        var visibility = node.visibility;

        if (node.kind !== 'constructor') {
          var fnName = node.name;

          var fn = fnName + this._getInputParams(node);

          if (visibility === 'public' || visibility === 'external') {
            executionCost = this.estimationObj.external[fn];
          } else if (visibility === 'private' || visibility === 'internal') {
            executionCost = this.estimationObj.internal[fn];
          }
        } else {
          executionCost = this.creationCost;
          codeDepositCost = this.codeDepositCost;
        }
      } else {
        executionCost = '-';
      }

      return {
        executionCost: executionCost,
        codeDepositCost: codeDepositCost
      };
    }
  }, {
    key: "_loadContractInfos",
    value: function _loadContractInfos(node) {
      for (var i in this.nodes) {
        if (this.nodes[i].id === node.scope) {
          var contract = this.nodes[i];
          this.contract = this.results.data.contracts[this.results.source.target][contract.name];
          this.estimationObj = this.contract.evm.gasEstimates;
          this.creationCost = this.estimationObj.creation.totalCost;
          this.codeDepositCost = this.estimationObj.creation.codeDepositCost;
        }
      }
    }
  }, {
    key: "_getInputParams",
    value: function _getInputParams(node) {
      var params = [];
      var target = node.parameters; // for (const i in node.children) {
      //   if (node.children[i].name === 'ParameterList') {
      //     target = node.children[i]
      //     break
      //   }
      // }

      if (target) {
        var children = target.parameters;

        for (var j in children) {
          if (children[j].nodeType === 'VariableDeclaration') {
            params.push(children[j].typeDescriptions.typeString);
          }
        }
      }

      return '(' + params.toString() + ')';
    }
  }]);

  return ContextualListener;
}(_engine.Plugin);

module.exports = ContextualListener;

/***/ }),

/***/ "./app/editor/editor.js":
/*!******************************!*\
  !*** ./app/editor/editor.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<div id=\"input\" data-id=\"editorInput\"></div>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n  <style>\n    .ace-tm .ace_gutter,\n    .ace-tm .ace_gutter-active-line,\n    .ace-tm .ace_marker-layer .ace_active-line {\n        background-color: var(--secondary);\n    }\n    .ace_gutter-cell.ace_breakpoint{\n      background-color: var(--secondary);\n    }\n  </style>\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .ace-editor {\n    width     : 100%;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var ace = __webpack_require__(/*! brace */ "../../../node_modules/brace/index.js");

var globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var SourceHighlighters = __webpack_require__(/*! ./SourceHighlighters */ "./app/editor/SourceHighlighters.js");

var Range = ace.acequire('ace/range').Range;

__webpack_require__(/*! brace/ext/language_tools */ "../../../node_modules/brace/ext/language_tools.js");

__webpack_require__(/*! brace/ext/searchbox */ "../../../node_modules/brace/ext/searchbox.js");

var langTools = ace.acequire('ace/ext/language_tools');

__webpack_require__(/*! ace-mode-solidity/build/remix-ide/mode-solidity */ "../../../node_modules/ace-mode-solidity/build/remix-ide/mode-solidity.js");

__webpack_require__(/*! ace-mode-move/build/remix-ide/mode-move */ "../../../node_modules/ace-mode-move/build/remix-ide/mode-move.js");

__webpack_require__(/*! ace-mode-zokrates */ "../../../node_modules/ace-mode-zokrates/index.js");

__webpack_require__(/*! ace-mode-lexon */ "../../../node_modules/ace-mode-lexon/index.js");

__webpack_require__(/*! brace/mode/javascript */ "../../../node_modules/brace/mode/javascript.js");

__webpack_require__(/*! brace/mode/python */ "../../../node_modules/brace/mode/python.js");

__webpack_require__(/*! brace/mode/json */ "../../../node_modules/brace/mode/json.js");

__webpack_require__(/*! brace/mode/rust */ "../../../node_modules/brace/mode/rust.js");

__webpack_require__(/*! brace/theme/chrome */ "../../../node_modules/brace/theme/chrome.js"); // for all light themes


__webpack_require__(/*! brace/theme/chaos */ "../../../node_modules/brace/theme/chaos.js"); // for all dark themes


__webpack_require__(/*! ../../assets/js/editor/darkTheme */ "./assets/js/editor/darkTheme.js"); // a custom one for remix 'Dark' theme


var css = csjs(_templateObject());
document.head.appendChild(yo(_templateObject2()));
var profile = {
  displayName: 'Editor',
  name: 'editor',
  description: 'service - editor',
  version: packageJson.version,
  methods: ['highlight', 'discardHighlight', 'discardHighlightAt', 'clearAnnotations', 'addAnnotation']
};

var Editor = /*#__PURE__*/function (_Plugin) {
  _inherits(Editor, _Plugin);

  var _super = _createSuper(Editor);

  function Editor() {
    var _this;

    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var themeModule = arguments.length > 1 ? arguments[1] : undefined;

    _classCallCheck(this, Editor);

    _this = _super.call(this, profile); // Dependancies

    _this._components = {};
    _this._components.registry = globalRegistry;
    _this._deps = {
      config: _this._components.registry.get('config').api
    };
    _this._themes = {
      light: 'chrome',
      dark: 'chaos',
      remixDark: 'remixDark'
    };
    themeModule.events.on('themeChanged', function (theme) {
      _this.setTheme(theme.name === 'Dark' ? 'remixDark' : theme.quality);
    }); // Init

    _this.event = new EventManager();
    _this.sessions = {};
    _this.sourceAnnotations = [];
    _this.readOnlySessions = {};
    _this.previousInput = '';
    _this.saveTimeout = null;
    _this.sourceHighlighters = new SourceHighlighters();
    _this.emptySession = _this._createSession('');
    _this.modes = {
      sol: 'ace/mode/solidity',
      yul: 'ace/mode/solidity',
      mvir: 'ace/mode/move',
      js: 'ace/mode/javascript',
      py: 'ace/mode/python',
      vy: 'ace/mode/python',
      zok: 'ace/mode/zokrates',
      lex: 'ace/mode/lexon',
      txt: 'ace/mode/text',
      json: 'ace/mode/json',
      abi: 'ace/mode/json',
      rs: 'ace/mode/rust'
    }; // Editor Setup

    var el = yo(_templateObject3());
    _this.editor = ace.edit(el);
    ace.acequire('ace/ext/language_tools'); // Unmap ctrl-l & cmd-l

    _this.editor.commands.bindKeys({
      'ctrl-L': null,
      'Command-L': null
    }); // shortcuts for "Ctrl-"" and "Ctrl+"" to increase/decrease font size of the editor


    _this.editor.commands.addCommand({
      name: 'increasefontsizeEqual',
      bindKey: {
        win: 'Ctrl-=',
        mac: 'Command-='
      },
      exec: function exec(editor) {
        _this.editorFontSize(1);
      },
      readOnly: true
    });

    _this.editor.commands.addCommand({
      name: 'increasefontsizePlus',
      bindKey: {
        win: 'Ctrl-+',
        mac: 'Command-+'
      },
      exec: function exec(editor) {
        _this.editorFontSize(1);
      },
      readOnly: true
    });

    _this.editor.commands.addCommand({
      name: 'decreasefontsize',
      bindKey: {
        win: 'Ctrl--',
        mac: 'Command--'
      },
      exec: function exec(editor) {
        _this.editorFontSize(-1);
      },
      readOnly: true
    });

    _this.editor.setShowPrintMargin(false);

    _this.editor.resize(true);

    _this.editor.setOptions({
      enableBasicAutocompletion: true,
      enableLiveAutocompletion: true
    });

    el.className += ' ' + css['ace-editor'];
    el.editor = _this.editor; // required to access the editor during tests

    _this.render = function () {
      return el;
    }; // Completer for editor


    var flowCompleter = {
      getCompletions: function getCompletions(editor, session, pos, prefix, callback) {// @TODO add here other propositions
      }
    };
    langTools.addCompleter(flowCompleter); // zoom with Ctrl+wheel

    window.addEventListener('wheel', function (e) {
      if (e.ctrlKey && Math.abs(e.wheelY) > 5) {
        _this.editorFontSize(e.wheelY > 0 ? 1 : -1);
      }
    }); // EVENTS LISTENERS
    // Gutter Mouse down

    _this.editor.on('guttermousedown', function (e) {
      var target = e.domEvent.target;

      if (target.className.indexOf('ace_gutter-cell') === -1) {
        return;
      }

      var row = e.getDocumentPosition().row;
      var breakpoints = e.editor.session.getBreakpoints();

      for (var k in breakpoints) {
        if (k === row.toString()) {
          _this.triggerEvent('breakpointCleared', [_this.currentSession, row]);

          e.editor.session.clearBreakpoint(row);
          e.stop();
          return;
        }
      }

      _this.setBreakpoint(row);

      _this.triggerEvent('breakpointAdded', [_this.currentSession, row]);

      e.stop();
    }); // Do setup on initialisation here


    _this.editor.on('changeSession', function () {
      _this._onChange();

      _this.triggerEvent('sessionSwitched', []);

      _this.editor.getSession().on('change', function () {
        _this._onChange();

        _this.sourceHighlighters.discardAllHighlights();

        _this.triggerEvent('contentChanged', []);
      });
    });

    return _this;
  }

  _createClass(Editor, [{
    key: "triggerEvent",
    value: function triggerEvent(name, params) {
      this.event.trigger(name, params); // internal stack

      this.emit.apply(this, [name].concat(_toConsumableArray(params))); // plugin stack
    }
  }, {
    key: "onActivation",
    value: function onActivation() {
      var _this2 = this;

      this.on('sidePanel', 'focusChanged', function (name) {
        return _this2.sourceHighlighters.hideHighlightsExcept(name);
      });
      this.on('sidePanel', 'pluginDisabled', function (name) {
        return _this2.sourceHighlighters.discardHighlight(name);
      });
    }
  }, {
    key: "onDeactivation",
    value: function onDeactivation() {
      this.off('sidePanel', 'focusChanged');
      this.off('sidePanel', 'pluginDisabled');
    }
  }, {
    key: "highlight",
    value: function highlight(position, filePath, hexColor) {
      var from = this.currentRequest.from;
      this.sourceHighlighters.highlight(position, filePath, hexColor, from);
    }
  }, {
    key: "discardHighlight",
    value: function discardHighlight() {
      var from = this.currentRequest.from;
      this.sourceHighlighters.discardHighlight(from);
    }
  }, {
    key: "discardHighlightAt",
    value: function discardHighlightAt(line, filePath) {
      var from = this.currentRequest.from;
      this.sourceHighlighters.discardHighlightAt(line, filePath, from);
    }
  }, {
    key: "setTheme",
    value: function setTheme(type) {
      this.editor.setTheme('ace/theme/' + this._themes[type]);
    }
  }, {
    key: "_onChange",
    value: function _onChange() {
      var _this3 = this;

      var currentFile = this._deps.config.get('currentFile');

      if (!currentFile) {
        return;
      }

      var input = this.get(currentFile);

      if (!input) {
        return;
      } // if there's no change, don't do anything


      if (input === this.previousInput) {
        return;
      }

      this.previousInput = input; // fire storage update
      // NOTE: save at most once per 5 seconds

      if (this.saveTimeout) {
        window.clearTimeout(this.saveTimeout);
      }

      this.saveTimeout = window.setTimeout(function () {
        _this3.triggerEvent('requiringToSaveCurrentfile', []);
      }, 5000);
    }
  }, {
    key: "_switchSession",
    value: function _switchSession(path) {
      this.currentSession = path;
      this.editor.setSession(this.sessions[this.currentSession]);
      this.editor.setReadOnly(this.readOnlySessions[this.currentSession]);
      this.editor.focus();
    }
    /**
     * Get Ace mode base of the extension of the session file
     * @param {string} path Path of the file
     */

  }, {
    key: "_getMode",
    value: function _getMode(path) {
      if (!path) return this.modes.txt;
      var root = path.split('#')[0].split('?')[0];
      var ext = root.indexOf('.') !== -1 ? /[^.]+$/.exec(root) : null;
      if (ext) ext = ext[0];else ext = 'txt';
      return ext && this.modes[ext] ? this.modes[ext] : this.modes.txt;
    }
    /**
     * Create an Ace session
     * @param {string} content Content of the file to open
     * @param {string} mode Ace Mode for this file [Default is `text`]
     */

  }, {
    key: "_createSession",
    value: function _createSession(content, mode) {
      var s = new ace.EditSession(content);
      s.setMode(mode || 'ace/mode/text');
      s.setUndoManager(new ace.UndoManager());
      s.setTabSize(4);
      s.setUseSoftTabs(true);
      return s;
    }
    /**
     * Attempts to find the string in the current document
     * @param {string} string
     */

  }, {
    key: "find",
    value: function find(string) {
      return this.editor.find(string);
    }
    /**
     * Display an Empty read-only session
     */

  }, {
    key: "displayEmptyReadOnlySession",
    value: function displayEmptyReadOnlySession() {
      this.currentSession = null;
      this.editor.setSession(this.emptySession);
      this.editor.setReadOnly(true);
    }
    /**
     * Sets a breakpoint on the row number
     * @param {number} row Line index of the breakpoint
     * @param {string} className Class of the breakpoint
     */

  }, {
    key: "setBreakpoint",
    value: function setBreakpoint(row, className) {
      this.editor.session.setBreakpoint(row, className);
    }
    /**
     * Increment the font size (in pixels) for the editor text.
     * @param {number} incr The amount of pixels to add to the font.
     */

  }, {
    key: "editorFontSize",
    value: function editorFontSize(incr) {
      var newSize = this.editor.getFontSize() + incr;

      if (newSize >= 6) {
        this.editor.setFontSize(newSize);
      }
    }
    /**
     * Set the text in the current session, if any.
     * @param {string} text New text to be place.
     */

  }, {
    key: "setText",
    value: function setText(text) {
      if (this.currentSession && this.sessions[this.currentSession]) {
        this.sessions[this.currentSession].setValue(text);
      }
    }
    /**
     * Upsert and open a session.
     * @param {string} path Path of the session to open.
     * @param {string} content Content of the document or update.
     */

  }, {
    key: "open",
    value: function open(path, content) {
      /*
        we have the following cases:
         - URL prepended with "localhost"
         - URL prepended with "browser"
         - URL not prepended with the file explorer. We assume (as it is in the whole app, that this is a "browser" URL
      */
      if (!path.startsWith('localhost') && !path.startsWith('browser')) path = "browser/".concat(path);

      if (!this.sessions[path]) {
        var session = this._createSession(content, this._getMode(path));

        this.sessions[path] = session;
        this.readOnlySessions[path] = false;
      } else if (this.sessions[path].getValue() !== content) {
        this.sessions[path].setValue(content);
      }

      this._switchSession(path);
    }
    /**
     * Upsert and Open a session and set it as Read-only.
     * @param {string} path Path of the session to open.
     * @param {string} content Content of the document or update.
     */

  }, {
    key: "openReadOnly",
    value: function openReadOnly(path, content) {
      if (!this.sessions[path]) {
        var session = this._createSession(content, this._getMode(path));

        this.sessions[path] = session;
        this.readOnlySessions[path] = true;
      }

      this._switchSession(path);
    }
    /**
     * Content of the current session
     * @return {String} content of the file referenced by @arg path
     */

  }, {
    key: "currentContent",
    value: function currentContent() {
      return this.get(this.current());
    }
    /**
     * Content of the session targeted by @arg path
     * if @arg path is null, the content of the current session is returned
     * @param {string} path Path of the session to get.
     * @return {String} content of the file referenced by @arg path
     */

  }, {
    key: "get",
    value: function get(path) {
      if (!path || this.currentSession === path) {
        return this.editor.getValue();
      } else if (this.sessions[path]) {
        return this.sessions[path].getValue();
      }
    }
    /**
     * Path of the currently editing file
     * returns `undefined` if no session is being editer
     * @return {String} path of the current session
     */

  }, {
    key: "current",
    value: function current() {
      if (this.editor.getSession() === this.emptySession) {
        return;
      }

      return this.currentSession;
    }
    /**
     * The position of the cursor
     */

  }, {
    key: "getCursorPosition",
    value: function getCursorPosition() {
      return this.editor.session.doc.positionToIndex(this.editor.getCursorPosition(), 0);
    }
    /**
     * Remove the current session from the list of sessions.
     */

  }, {
    key: "discardCurrentSession",
    value: function discardCurrentSession() {
      if (this.sessions[this.currentSession]) {
        delete this.sessions[this.currentSession];
        this.currentSession = null;
      }
    }
    /**
     * Remove a session based on its path.
     * @param {string} path
     */

  }, {
    key: "discard",
    value: function discard(path) {
      if (this.sessions[path]) delete this.sessions[path];
      if (this.currentSession === path) this.currentSession = null;
    }
    /**
     * Resize the editor, and sets whether or not line wrapping is enabled.
     * @param {boolean} useWrapMode Enable (or disable) wrap mode
     */

  }, {
    key: "resize",
    value: function resize(useWrapMode) {
      this.editor.resize();
      var session = this.editor.getSession();
      session.setUseWrapMode(useWrapMode);

      if (session.getUseWrapMode()) {
        var characterWidth = this.editor.renderer.characterWidth;
        var contentWidth = this.editor.container.ownerDocument.getElementsByClassName('ace_scroller')[0].clientWidth;

        if (contentWidth > 0) {
          session.setWrapLimit(parseInt(contentWidth / characterWidth, 10));
        }
      }
    }
    /**
     * Adds a new marker to the given `Range`.
     * @param {*} lineColumnPos
     * @param {string} source Path of the session to add the mark on.
     * @param {string} cssClass css to apply to the mark.
     */

  }, {
    key: "addMarker",
    value: function addMarker(lineColumnPos, source, cssClass) {
      var currentRange = new Range(lineColumnPos.start.line, lineColumnPos.start.column, lineColumnPos.end.line, lineColumnPos.end.column);

      if (this.sessions[source]) {
        return this.sessions[source].addMarker(currentRange, cssClass);
      }

      return null;
    }
    /**
     * Scrolls to a line. If center is true, it puts the line in middle of screen (or attempts to).
     * @param {number} line The line to scroll to
     * @param {boolean} center If true
     * @param {boolean} animate If true animates scrolling
     * @param {Function} callback Function to be called when the animation has finished
     */

  }, {
    key: "scrollToLine",
    value: function scrollToLine(line, center, animate, callback) {
      this.editor.scrollToLine(line, center, animate, callback);
    }
    /**
     * Remove a marker from the session
     * @param {string} markerId Id of the marker
     * @param {string} source Path of the session
     */

  }, {
    key: "removeMarker",
    value: function removeMarker(markerId, source) {
      if (this.sessions[source]) {
        this.sessions[source].removeMarker(markerId);
      }
    }
    /**
     * Clears all the annotations for the current session.
     */

  }, {
    key: "clearAnnotations",
    value: function clearAnnotations() {
      this.sourceAnnotations = [];
      this.editor.getSession().clearAnnotations();
    }
    /**
     * Add an annotation to the current session.
     * @param {Object} annotation
     */

  }, {
    key: "addAnnotation",
    value: function addAnnotation(annotation) {
      this.sourceAnnotations[this.sourceAnnotations.length] = annotation;
      this.setAnnotations(this.sourceAnnotations);
    }
    /**
     * Set a list of annotations to the current session.
     * @param {Array<Object>} annotation
     */

  }, {
    key: "setAnnotations",
    value: function setAnnotations(sourceAnnotations) {
      this.editor.getSession().setAnnotations(sourceAnnotations);
    }
    /**
     * Moves the cursor and focus to the specified line and column number
     * @param {number} line
     * @param {number} col
     */

  }, {
    key: "gotoLine",
    value: function gotoLine(line, col) {
      this.editor.focus();
      this.editor.gotoLine(line + 1, col - 1, true);
    }
  }]);

  return Editor;
}(_engine.Plugin);

module.exports = Editor;

/***/ }),

/***/ "./app/editor/examples.js":
/*!********************************!*\
  !*** ./app/editor/examples.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var storage = "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.8.0;\n\n/**\n * @title Storage\n * @dev Store & retrieve value in a variable\n */\ncontract Storage {\n\n    uint256 number;\n\n    /**\n     * @dev Store value in variable\n     * @param num value to store\n     */\n    function store(uint256 num) public {\n        number = num;\n    }\n\n    /**\n     * @dev Return value \n     * @return value of 'number'\n     */\n    function retrieve() public view returns (uint256){\n        return number;\n    }\n}";
var owner = "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.8.0;\n\n/**\n * @title Owner\n * @dev Set & change owner\n */\ncontract Owner {\n\n    address private owner;\n    \n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    // modifier to check if caller is owner\n    modifier isOwner() {\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use 'require' to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    /**\n     * @dev Set contract deployer as owner\n     */\n    constructor() {\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function changeOwner(address newOwner) public isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n}";
var ballot = "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.8.0;\n\n/** \n * @title Ballot\n * @dev Implements voting process along with vote delegation\n */\ncontract Ballot {\n   \n    struct Voter {\n        uint weight; // weight is accumulated by delegation\n        bool voted;  // if true, that person already voted\n        address delegate; // person delegated to\n        uint vote;   // index of the voted proposal\n    }\n\n    struct Proposal {\n        // If you can limit the length to a certain number of bytes, \n        // always use one of bytes1 to bytes32 because they are much cheaper\n        bytes32 name;   // short name (up to 32 bytes)\n        uint voteCount; // number of accumulated votes\n    }\n\n    address public chairperson;\n\n    mapping(address => Voter) public voters;\n\n    Proposal[] public proposals;\n\n    /** \n     * @dev Create a new ballot to choose one of 'proposalNames'.\n     * @param proposalNames names of proposals\n     */\n    constructor(bytes32[] memory proposalNames) {\n        chairperson = msg.sender;\n        voters[chairperson].weight = 1;\n\n        for (uint i = 0; i < proposalNames.length; i++) {\n            // 'Proposal({...})' creates a temporary\n            // Proposal object and 'proposals.push(...)'\n            // appends it to the end of 'proposals'.\n            proposals.push(Proposal({\n                name: proposalNames[i],\n                voteCount: 0\n            }));\n        }\n    }\n    \n    /** \n     * @dev Give 'voter' the right to vote on this ballot. May only be called by 'chairperson'.\n     * @param voter address of voter\n     */\n    function giveRightToVote(address voter) public {\n        require(\n            msg.sender == chairperson,\n            \"Only chairperson can give right to vote.\"\n        );\n        require(\n            !voters[voter].voted,\n            \"The voter already voted.\"\n        );\n        require(voters[voter].weight == 0);\n        voters[voter].weight = 1;\n    }\n\n    /**\n     * @dev Delegate your vote to the voter 'to'.\n     * @param to address to which vote is delegated\n     */\n    function delegate(address to) public {\n        Voter storage sender = voters[msg.sender];\n        require(!sender.voted, \"You already voted.\");\n        require(to != msg.sender, \"Self-delegation is disallowed.\");\n\n        while (voters[to].delegate != address(0)) {\n            to = voters[to].delegate;\n\n            // We found a loop in the delegation, not allowed.\n            require(to != msg.sender, \"Found loop in delegation.\");\n        }\n        sender.voted = true;\n        sender.delegate = to;\n        Voter storage delegate_ = voters[to];\n        if (delegate_.voted) {\n            // If the delegate already voted,\n            // directly add to the number of votes\n            proposals[delegate_.vote].voteCount += sender.weight;\n        } else {\n            // If the delegate did not vote yet,\n            // add to her weight.\n            delegate_.weight += sender.weight;\n        }\n    }\n\n    /**\n     * @dev Give your vote (including votes delegated to you) to proposal 'proposals[proposal].name'.\n     * @param proposal index of proposal in the proposals array\n     */\n    function vote(uint proposal) public {\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"Has no right to vote\");\n        require(!sender.voted, \"Already voted.\");\n        sender.voted = true;\n        sender.vote = proposal;\n\n        // If 'proposal' is out of the range of the array,\n        // this will throw automatically and revert all\n        // changes.\n        proposals[proposal].voteCount += sender.weight;\n    }\n\n    /** \n     * @dev Computes the winning proposal taking all previous votes into account.\n     * @return winningProposal_ index of winning proposal in the proposals array\n     */\n    function winningProposal() public view\n            returns (uint winningProposal_)\n    {\n        uint winningVoteCount = 0;\n        for (uint p = 0; p < proposals.length; p++) {\n            if (proposals[p].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }\n    }\n\n    /** \n     * @dev Calls winningProposal() function to get the index of the winner contained in the proposals array and then\n     * @return winnerName_ the name of the winner\n     */\n    function winnerName() public view\n            returns (bytes32 winnerName_)\n    {\n        winnerName_ = proposals[winningProposal()].name;\n    }\n}\n";
var ballotTest = "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.8.0;\nimport \"remix_tests.sol\"; // this import is automatically injected by Remix.\nimport \"../contracts/3_Ballot.sol\";\n\ncontract BallotTest {\n   \n    bytes32[] proposalNames;\n   \n    Ballot ballotToTest;\n    function beforeAll () public {\n        proposalNames.push(bytes32(\"candidate1\"));\n        ballotToTest = new Ballot(proposalNames);\n    }\n    \n    function checkWinningProposal () public {\n        ballotToTest.vote(0);\n        Assert.equal(ballotToTest.winningProposal(), uint(0), \"proposal at index 0 should be the winning proposal\");\n        Assert.equal(ballotToTest.winnerName(), bytes32(\"candidate1\"), \"candidate1 should be the winner name\");\n    }\n    \n    function checkWinninProposalWithReturnValue () public view returns (bool) {\n        return ballotToTest.winningProposal() == 0;\n    }\n}\n";
var deployWithWeb3 = "// Right click on the script name and hit \"Run\" to execute\n(async () => {\n    try {\n        console.log('Running deployWithWeb3 script...')\n        \n        const contractName = 'Storage' // Change this for other contract\n        const constructorArgs = []    // Put constructor args (if any) here for your contract\n    \n        // Note that the script needs the ABI which is generated from the compilation artifact.\n        // Make sure contract is compiled and artifacts are generated\n        const artifactsPath = `browser/contracts/artifacts/${contractName}.json` // Change this for different path\n\n        const metadata = JSON.parse(await remix.call('fileManager', 'getFile', artifactsPath))\n        const accounts = await web3.eth.getAccounts()\n    \n        let contract = new web3.eth.Contract(metadata.abi)\n    \n        contract = contract.deploy({\n            data: metadata.data.bytecode.object,\n            arguments: constructorArgs\n        })\n    \n        const newContractInstance = await contract.send({\n            from: accounts[0],\n            gas: 1500000,\n            gasPrice: '30000000000'\n        })\n        console.log('Contract deployed at address: ', newContractInstance.options.address)\n    } catch (e) {\n        console.log(e.message)\n    }\n  })()";
var deployWithEthers = "// Right click on the script name and hit \"Run\" to execute\n(async () => {\n    try {\n        console.log('Running deployWithEthers script...')\n    \n        const contractName = 'Storage' // Change this for other contract\n        const constructorArgs = []    // Put constructor args (if any) here for your contract\n\n        // Note that the script needs the ABI which is generated from the compilation artifact.\n        // Make sure contract is compiled and artifacts are generated\n        const artifactsPath = `browser/contracts/artifacts/${contractName}.json` // Change this for different path\n    \n        const metadata = JSON.parse(await remix.call('fileManager', 'getFile', artifactsPath))\n        // 'web3Provider' is a remix global variable object\n        const signer = (new ethers.providers.Web3Provider(web3Provider)).getSigner()\n    \n        let factory = new ethers.ContractFactory(metadata.abi, metadata.data.bytecode.object, signer);\n    \n        let contract = await factory.deploy(...constructorArgs);\n    \n        console.log('Contract Address: ', contract.address);\n    \n        // The contract is NOT deployed yet; we must wait until it is mined\n        await contract.deployed()\n        console.log('Deployment successful.')\n    } catch (e) {\n        console.log(e.message)\n    }\n})()";
var readme = "REMIX EXAMPLE PROJECT\n\nRemix example project is present when Remix loads very first time or there are no files existing in the File Explorer. \nIt contains 3 directories:\n\n1. 'contracts': Holds three contracts with different complexity level, denoted with number prefix in file name.\n2. 'scripts': Holds two scripts to deploy a contract. It is explained below.\n3. 'tests': Contains one test file for 'Ballot' contract with unit tests in Solidity.\n\nSCRIPTS\n\nThe 'scripts' folder contains example async/await scripts for deploying the 'Storage' contract.\nFor the deployment of any other contract, 'contractName' and 'constructorArgs' should be updated (along with other code if required). \nScripts have full access to the web3.js and ethers.js libraries.\n\nTo run a script, right click on file name in the file explorer and click 'Run'. Remember, Solidity file must already be compiled.\n\nOutput from script will appear in remix terminal.\n";
module.exports = {
  storage: {
    name: 'contracts/1_Storage.sol',
    content: storage
  },
  owner: {
    name: 'contracts/2_Owner.sol',
    content: owner
  },
  ballot: {
    name: 'contracts/3_Ballot.sol',
    content: ballot
  },
  deployWithWeb3: {
    name: 'scripts/deploy_web3.js',
    content: deployWithWeb3
  },
  deployWithEthers: {
    name: 'scripts/deploy_ethers.js',
    content: deployWithEthers
  },
  ballot_test: {
    name: 'tests/4_Ballot_test.sol',
    content: ballotTest
  },
  readme: {
    name: 'README.txt',
    content: readme
  }
};

/***/ }),

/***/ "./app/editor/sourceHighlighter.js":
/*!*****************************************!*\
  !*** ./app/editor/sourceHighlighter.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n        .highlightcode {\n          position:absolute;\n          z-index:20;\n          opacity: 0.3;\n          background-color: ", ";\n        }\n        .highlightcode_fullLine {\n          position:absolute;\n          z-index:20;\n          opacity: 0.5;\n          background-color: ", ";\n        }\n        .customBackgroundColor {\n          background-color: ", ";\n        }\n        "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var globlalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var SourceHighlighter = /*#__PURE__*/function () {
  function SourceHighlighter(localRegistry) {
    _classCallCheck(this, SourceHighlighter);

    this._components = {};
    this._components.registry = localRegistry || globlalRegistry; // dependencies

    this._deps = {
      editor: this._components.registry.get('editor').api,
      config: this._components.registry.get('config').api,
      fileManager: this._components.registry.get('filemanager').api,
      compilerArtefacts: this._components.registry.get('compilersartefacts').api
    };
    this.position = null;
    this.statementMarker = null;
    this.fullLineMarker = null;
    this.source = null;
  }

  _createClass(SourceHighlighter, [{
    key: "currentSourceLocation",
    value: function currentSourceLocation(lineColumnPos, location) {
      if (this.statementMarker) this._deps.editor.removeMarker(this.statementMarker, this.source);
      if (this.fullLineMarker) this._deps.editor.removeMarker(this.fullLineMarker, this.source);
      var lastCompilationResult = this._deps.compilerArtefacts.__last;

      if (location && location.file !== undefined && lastCompilationResult) {
        var path = lastCompilationResult.getSourceName(location.file);

        if (path) {
          this.currentSourceLocationFromfileName(lineColumnPos, path);
        }
      }
    }
  }, {
    key: "currentSourceLocationFromfileName",
    value: function () {
      var _currentSourceLocationFromfileName = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(lineColumnPos, filePath, style) {
        var css;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.statementMarker) this._deps.editor.removeMarker(this.statementMarker, this.source);
                if (this.fullLineMarker) this._deps.editor.removeMarker(this.fullLineMarker, this.source);
                this.statementMarker = null;
                this.fullLineMarker = null;
                this.source = null;

                if (!lineColumnPos) {
                  _context.next = 17;
                  break;
                }

                this.source = filePath;
                this.style = style || 'var(--info)'; // if (!this.source) this.source = this._deps.fileManager.currentFile()

                if (!(this._deps.fileManager.currentFile() !== this.source)) {
                  _context.next = 12;
                  break;
                }

                _context.next = 11;
                return this._deps.fileManager.open(this.source);

              case 11:
                this.source = this._deps.fileManager.currentFile();

              case 12:
                css = csjs(_templateObject(), this.style, this.style, this.style);
                this.statementMarker = this._deps.editor.addMarker(lineColumnPos, this.source, css.highlightcode.className + ' ' + css.customBackgroundColor.className + ' ' + "highlightLine".concat(lineColumnPos.start.line));

                this._deps.editor.scrollToLine(lineColumnPos.start.line, true, true, function () {});

                this.position = lineColumnPos;

                if (lineColumnPos.start.line === lineColumnPos.end.line) {
                  this.fullLineMarker = this._deps.editor.addMarker({
                    start: {
                      line: lineColumnPos.start.line,
                      column: 0
                    },
                    end: {
                      line: lineColumnPos.start.line + 1,
                      column: 0
                    }
                  }, this.source, css.highlightcode_fullLine.className);
                }

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function currentSourceLocationFromfileName(_x, _x2, _x3) {
        return _currentSourceLocationFromfileName.apply(this, arguments);
      }

      return currentSourceLocationFromfileName;
    }()
  }]);

  return SourceHighlighter;
}();

module.exports = SourceHighlighter;

/***/ }),

/***/ "./app/editor/styles/contextView-styles.js":
/*!*************************************************!*\
  !*** ./app/editor/styles/contextView-styles.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .contextview {\n    opacity             : 1;\n    position            : relative;\n    height              : 25px;\n  }\n  .container {\n    padding             : 1px 15px;\n  }\n  .line {\n    display             : flex;\n    justify-content     : flex-end;\n    align-items         : center;\n    text-overflow       : ellipsis;\n    overflow            : hidden;\n    white-space         : nowrap;\n    font-size           : 13px;\n  }\n  .type {\n    font-style        : italic;\n    margin-right      : 5px;\n  }\n  .name  {\n    font-weight       : bold;\n  }\n  .jump {\n    cursor            : pointer;\n    margin            : 0 5px;\n  }\n  .jump:hover              {\n    color             : var(--secondary);\n  }\n  .referencesnb {\n    float             : right;\n    margin-left       : 15px;\n  }\n  .gasEstimation {\n    margin-right      : 15px;\n    display           : flex;\n    align-items       : center;\n  }\n  .gasStationIcon {\n    margin-right      : 5px;\n  }\n  .contextviewcontainer {\n    z-index           : 50;\n    border-radius     : 1px;\n    border            : 2px solid var(--secondary);\n  }\n  .contextviewcontainer{\n    z-index           : 50;\n    border-radius     : 1px;\n    border            : 2px solid var(--secondary);\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());
module.exports = css;

/***/ }),

/***/ "./app/files/compiler-metadata.js":
/*!****************************************!*\
  !*** ./app/files/compiler-metadata.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var CompilerAbstract = __webpack_require__(/*! ../compiler/compiler-abstract */ "./app/compiler/compiler-abstract.js");

var profile = {
  name: 'compilerMetadata',
  methods: ['deployMetadataOf'],
  events: [],
  version: packageJson.version
};

var CompilerMetadata = /*#__PURE__*/function (_Plugin) {
  _inherits(CompilerMetadata, _Plugin);

  var _super = _createSuper(CompilerMetadata);

  function CompilerMetadata(blockchain, fileManager, config) {
    var _this;

    _classCallCheck(this, CompilerMetadata);

    _this = _super.call(this, profile);
    _this.blockchain = blockchain;
    _this.fileManager = fileManager;
    _this.config = config;
    _this.networks = ['VM:-', 'main:1', 'ropsten:3', 'rinkeby:4', 'kovan:42', 'grli:5', 'Custom'];
    _this.innerPath = 'artifacts';
    return _this;
  }

  _createClass(CompilerMetadata, [{
    key: "_JSONFileName",
    value: function _JSONFileName(path, contractName) {
      return path + '/' + this.innerPath + '/' + contractName + '.json';
    }
  }, {
    key: "_MetadataFileName",
    value: function _MetadataFileName(path, contractName) {
      return path + '/' + this.innerPath + '/' + contractName + '_metadata' + '.json';
    }
  }, {
    key: "onActivation",
    value: function onActivation() {
      var self = this;
      this.on('solidity', 'compilationFinished', function (file, source, languageVersion, data) {
        if (!self.config.get('settings/generate-contract-metadata')) return;
        var compiler = new CompilerAbstract(languageVersion, data, source);
        var provider = self.fileManager.currentFileProvider();
        var path = self.fileManager.currentPath();

        if (provider && path) {
          compiler.visitContracts(function (contract) {
            if (contract.file !== source.target) return;

            var fileName = self._JSONFileName(path, contract.name);

            var metadataFileName = self._MetadataFileName(path, contract.name);

            provider.get(fileName, function (error, content) {
              if (!error) {
                content = content || '{}';
                var metadata;

                try {
                  metadata = JSON.parse(content);
                } catch (e) {
                  console.log(e);
                }

                var deploy = metadata.deploy || {};
                self.networks.forEach(function (network) {
                  deploy[network] = self._syncContext(contract, deploy[network] || {});
                });
                var parsedMetadata;

                try {
                  parsedMetadata = JSON.parse(contract.object.metadata);
                } catch (e) {
                  console.log(e);
                }

                if (parsedMetadata) provider.set(metadataFileName, JSON.stringify(parsedMetadata, null, '\t'));
                var data = {
                  deploy: deploy,
                  data: {
                    bytecode: contract.object.evm.bytecode,
                    deployedBytecode: contract.object.evm.deployedBytecode,
                    gasEstimates: contract.object.evm.gasEstimates,
                    methodIdentifiers: contract.object.evm.methodIdentifiers
                  },
                  abi: contract.object.abi
                };
                provider.set(fileName, JSON.stringify(data, null, '\t'));
              }
            });
          });
        }
      });
    }
  }, {
    key: "_syncContext",
    value: function _syncContext(contract, metadata) {
      var linkReferences = metadata.linkReferences;
      var autoDeployLib = metadata.autoDeployLib;
      if (!linkReferences) linkReferences = {};
      if (autoDeployLib === undefined) autoDeployLib = true;

      for (var libFile in contract.object.evm.bytecode.linkReferences) {
        if (!linkReferences[libFile]) linkReferences[libFile] = {};

        for (var lib in contract.object.evm.bytecode.linkReferences[libFile]) {
          if (!linkReferences[libFile][lib]) {
            linkReferences[libFile][lib] = '<address>';
          }
        }
      }

      metadata.linkReferences = linkReferences;
      metadata.autoDeployLib = autoDeployLib;
      return metadata;
    } // TODO: is only called by dropdownLogic and can be moved there

  }, {
    key: "deployMetadataOf",
    value: function deployMetadataOf(contractName, fileLocation) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var provider;
        var path;

        if (fileLocation) {
          provider = _this2.fileManager.fileProviderOf(fileLocation);
          path = fileLocation.split('/');
          path.pop();
          path = path.join('/');
        } else {
          provider = _this2.fileManager.currentFileProvider();
          path = _this2.fileManager.currentPath();
        }

        if (provider && path) {
          _this2.blockchain.detectNetwork(function (err) {
            var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                id = _ref.id,
                name = _ref.name;

            if (err) {
              console.log(err);
              reject(err);
            } else {
              var fileName = _this2._JSONFileName(path, contractName);

              provider.get(fileName, function (error, content) {
                if (error) return reject(error);
                if (!content) return resolve();

                try {
                  var metadata = JSON.parse(content);
                  metadata = metadata.deploy || {};
                  return resolve(metadata[name + ':' + id] || metadata[name] || metadata[id] || metadata[name.toLowerCase() + ':' + id] || metadata[name.toLowerCase()]);
                } catch (e) {
                  reject(e.message);
                }
              });
            }
          });
        } else {
          reject(new Error("Please select the folder in the file explorer where the metadata of ".concat(contractName, " can be found")));
        }
      });
    }
  }]);

  return CompilerMetadata;
}(_engine.Plugin);

module.exports = CompilerMetadata;

/***/ }),

/***/ "./app/files/fileManager.js":
/*!**********************************!*\
  !*** ./app/files/fileManager.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _yoYo = _interopRequireDefault(__webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js"));

var _async = _interopRequireDefault(__webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js"));

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n          <div>\n            <i class=\"fas fa-exclamation-triangle text-danger mr-1\"></i>\n            <span>\n              ", "\n              <span class=\"font-weight-bold text-warning\">\n                is modifying \n              </span>", "\n            </span>\n          </div>\n        "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var EventEmitter = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

var globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var toaster = __webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js");

var modalDialogCustom = __webpack_require__(/*! ../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var helper = __webpack_require__(/*! ../../lib/helper.js */ "./lib/helper.js");
/*
  attach to files event (removed renamed)
  trigger: currentFileChanged
*/


var profile = {
  name: 'fileManager',
  displayName: 'File manager',
  description: 'Service - read/write to any files or folders, require giving permissions',
  icon: 'assets/img/fileManager.webp',
  permission: true,
  version: packageJson.version,
  methods: ['file', 'exists', 'open', 'writeFile', 'readFile', 'copyFile', 'rename', 'mkdir', 'readdir', 'remove', 'getCurrentFile', 'getFile', 'getFolder', 'setFile', 'switchFile'],
  kind: 'file-system'
};
var errorMsg = {
  ENOENT: 'No such file or directory',
  EISDIR: 'Path is a directory',
  ENOTDIR: 'Path is not on a directory',
  EEXIST: 'File already exists',
  EPERM: 'Permission denied'
};

var createError = function createError(err) {
  return new Error("".concat(errorMsg[err.code], " ").concat(err.message || ''));
};

var FileManager = /*#__PURE__*/function (_Plugin) {
  _inherits(FileManager, _Plugin);

  var _super = _createSuper(FileManager);

  function FileManager(editor, appManager) {
    var _this;

    _classCallCheck(this, FileManager);

    _this = _super.call(this, profile);
    _this.openedFiles = {}; // list all opened files

    _this.events = new EventEmitter();
    _this.editor = editor;
    _this._components = {};
    _this._components.registry = globalRegistry;
    _this.appManager = appManager;

    _this.init();

    return _this;
  }
  /**
   * Emit error if path doesn't exist
   * @param {string} path path of the file/directory
   * @param {string} message message to display if path doesn't exist.
   */


  _createClass(FileManager, [{
    key: "_handleExists",
    value: function () {
      var _handleExists2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(path, message) {
        var exists;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.exists(path);

              case 2:
                exists = _context.sent;

                if (exists) {
                  _context.next = 5;
                  break;
                }

                throw createError({
                  code: 'ENOENT',
                  message: message
                });

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _handleExists(_x, _x2) {
        return _handleExists2.apply(this, arguments);
      }

      return _handleExists;
    }()
    /**
     * Emit error if path is not a file
     * @param {string} path path of the file/directory
     * @param {string} message message to display if path is not a file.
     */

  }, {
    key: "_handleIsFile",
    value: function () {
      var _handleIsFile2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(path, message) {
        var isFile;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.isFile(path);

              case 2:
                isFile = _context2.sent;

                if (isFile) {
                  _context2.next = 5;
                  break;
                }

                throw createError({
                  code: 'EISDIR',
                  message: message
                });

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _handleIsFile(_x3, _x4) {
        return _handleIsFile2.apply(this, arguments);
      }

      return _handleIsFile;
    }()
    /**
     * Emit error if path is not a directory
     * @param {string} path path of the file/directory
     * @param {string} message message to display if path is not a directory.
     */

  }, {
    key: "_handleIsDir",
    value: function () {
      var _handleIsDir2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(path, message) {
        var isDir;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.isDirectory(path);

              case 2:
                isDir = _context3.sent;

                if (isDir) {
                  _context3.next = 5;
                  break;
                }

                throw createError({
                  code: 'ENOTDIR',
                  message: message
                });

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _handleIsDir(_x5, _x6) {
        return _handleIsDir2.apply(this, arguments);
      }

      return _handleIsDir;
    }()
    /** The current opened file */

  }, {
    key: "file",
    value: function file() {
      var file = this.currentFile();
      if (!file) throw createError({
        code: 'ENOENT',
        message: 'No file selected'
      });
      return file;
    }
    /**
     * Verify if the path exists (directory or file)
     * @param {string} path path of the directory or file
     * @returns {boolean} true if the path exists
     */

  }, {
    key: "exists",
    value: function exists(path) {
      var provider = this.fileProviderOf(path);
      var result = provider.exists(path, function (err, result) {
        if (err) return false;
        return result;
      });
      return result;
    }
    /**
     * Verify if the path provided is a file
     * @param {string} path path of the directory or file
     * @returns {boolean} true if path is a file.
     */

  }, {
    key: "isFile",
    value: function isFile(path) {
      var provider = this.fileProviderOf(path);
      var result = provider.isFile(path);
      return result;
    }
    /**
     * Verify if the path provided is a directory
     * @param {string} path path of the directory
     * @returns {boolean} true if path is a directory.
     */

  }, {
    key: "isDirectory",
    value: function isDirectory(path) {
      var provider = this.fileProviderOf(path);
      var result = provider.isDirectory(path);
      return result;
    }
    /**
     * Open the content of the file in the context (eg: Editor)
     * @param {string} path path of the file
     * @returns {void}
     */

  }, {
    key: "open",
    value: function () {
      var _open = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(path) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._handleExists(path, "Cannot open file ".concat(path));

              case 2:
                _context4.next = 4;
                return this._handleIsFile(path, "Cannot open file ".concat(path));

              case 4:
                return _context4.abrupt("return", this.openFile(path));

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function open(_x7) {
        return _open.apply(this, arguments);
      }

      return open;
    }()
    /**
     * Set the content of a specific file
     * @param {string} path path of the file
     * @param {string} data content to write on the file
     * @returns {void}
     */

  }, {
    key: "writeFile",
    value: function () {
      var _writeFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(path, data) {
        var ret;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.exists(path);

              case 2:
                if (!_context5.sent) {
                  _context5.next = 10;
                  break;
                }

                _context5.next = 5;
                return this._handleIsFile(path, "Cannot write file ".concat(path));

              case 5:
                _context5.next = 7;
                return this.setFileContent(path, data);

              case 7:
                return _context5.abrupt("return", _context5.sent);

              case 10:
                _context5.next = 12;
                return this.setFileContent(path, data);

              case 12:
                ret = _context5.sent;
                this.emit('fileAdded', path);
                return _context5.abrupt("return", ret);

              case 15:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function writeFile(_x8, _x9) {
        return _writeFile.apply(this, arguments);
      }

      return writeFile;
    }()
    /**
     * Return the content of a specific file
     * @param {string} path path of the file
     * @returns {string} content of the file
     */

  }, {
    key: "readFile",
    value: function () {
      var _readFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(path) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this._handleExists(path, "Cannot read file ".concat(path));

              case 2:
                _context6.next = 4;
                return this._handleIsFile(path, "Cannot read file ".concat(path));

              case 4:
                return _context6.abrupt("return", this.getFileContent(path));

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function readFile(_x10) {
        return _readFile.apply(this, arguments);
      }

      return readFile;
    }()
    /**
     * Upsert a file with the content of the source file
     * @param {string} src path of the source file
     * @param {string} dest path of the destrination file
     * @returns {void}
     */

  }, {
    key: "copyFile",
    value: function () {
      var _copyFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(src, dest) {
        var content;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._handleExists(src, "Cannot copy from ".concat(src));

              case 2:
                _context7.next = 4;
                return this._handleIsFile(src, "Cannot copy from ".concat(src));

              case 4:
                _context7.next = 6;
                return this._handleIsFile(dest, "Cannot paste content into ".concat(dest));

              case 6:
                _context7.next = 8;
                return this.readFile(src);

              case 8:
                content = _context7.sent;
                _context7.next = 11;
                return this.writeFile(dest, content);

              case 11:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function copyFile(_x11, _x12) {
        return _copyFile.apply(this, arguments);
      }

      return copyFile;
    }()
    /**
     * Change the path of a file/directory
     * @param {string} oldPath current path of the file/directory
     * @param {string} newPath new path of the file/directory
     * @returns {void}
     */

  }, {
    key: "rename",
    value: function () {
      var _rename = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(oldPath, newPath) {
        var isFile, newPathExists, provider;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this._handleExists(oldPath, "Cannot rename ".concat(oldPath));

              case 2:
                _context8.next = 4;
                return this.isFile(oldPath);

              case 4:
                isFile = _context8.sent;
                _context8.next = 7;
                return this.exists(newPath);

              case 7:
                newPathExists = _context8.sent;
                provider = this.fileProviderOf(oldPath);

                if (!isFile) {
                  _context8.next = 16;
                  break;
                }

                if (!newPathExists) {
                  _context8.next = 13;
                  break;
                }

                modalDialogCustom.alert('File already exists.');
                return _context8.abrupt("return");

              case 13:
                return _context8.abrupt("return", provider.rename(oldPath, newPath, false));

              case 16:
                if (!newPathExists) {
                  _context8.next = 19;
                  break;
                }

                modalDialogCustom.alert('Folder already exists.');
                return _context8.abrupt("return");

              case 19:
                return _context8.abrupt("return", provider.rename(oldPath, newPath, true));

              case 20:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function rename(_x13, _x14) {
        return _rename.apply(this, arguments);
      }

      return rename;
    }()
    /**
     * Create a directory
     * @param {string} path path of the new directory
     * @returns {void}
     */

  }, {
    key: "mkdir",
    value: function () {
      var _mkdir = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(path) {
        var provider;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.exists(path);

              case 2:
                if (!_context9.sent) {
                  _context9.next = 4;
                  break;
                }

                throw createError({
                  code: 'EEXIST',
                  message: "Cannot create directory ".concat(path)
                });

              case 4:
                provider = this.fileProviderOf(path);
                provider.createDir(path);

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function mkdir(_x15) {
        return _mkdir.apply(this, arguments);
      }

      return mkdir;
    }()
    /**
     * Get the list of files in the directory
     * @param {string} path path of the directory
     * @returns {string[]} list of the file/directory name in this directory
     */

  }, {
    key: "readdir",
    value: function () {
      var _readdir = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(path) {
        var _this2 = this;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this._handleExists(path);

              case 2:
                _context10.next = 4;
                return this._handleIsDir(path);

              case 4:
                return _context10.abrupt("return", new Promise(function (resolve, reject) {
                  var provider = _this2.fileProviderOf(path);

                  provider.resolveDirectory(path, function (error, filesProvider) {
                    if (error) reject(error);
                    resolve(filesProvider);
                  });
                }));

              case 5:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function readdir(_x16) {
        return _readdir.apply(this, arguments);
      }

      return readdir;
    }()
    /**
     * Removes a file or directory recursively
     * @param {string} path path of the directory/file to remove
     * @returns {void}
     */

  }, {
    key: "remove",
    value: function () {
      var _remove = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(path) {
        var provider;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this._handleExists(path, "Cannot remove file or directory ".concat(path));

              case 2:
                provider = this.fileProviderOf(path);
                _context11.next = 5;
                return provider.remove(path);

              case 5:
                return _context11.abrupt("return", _context11.sent);

              case 6:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function remove(_x17) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
  }, {
    key: "init",
    value: function init() {
      var _this3 = this;

      this._deps = {
        config: this._components.registry.get('config').api,
        browserExplorer: this._components.registry.get('fileproviders/browser').api,
        localhostExplorer: this._components.registry.get('fileproviders/localhost').api,
        filesProviders: this._components.registry.get('fileproviders').api
      };

      this._deps.browserExplorer.event.register('fileChanged', function (path) {
        _this3.fileChangedEvent(path);
      });

      this._deps.browserExplorer.event.register('fileRenamed', function (oldName, newName, isFolder) {
        _this3.fileRenamedEvent(oldName, newName, isFolder);
      });

      this._deps.localhostExplorer.event.register('fileRenamed', function (oldName, newName, isFolder) {
        _this3.fileRenamedEvent(oldName, newName, isFolder);
      });

      this._deps.browserExplorer.event.register('fileRemoved', function (path) {
        _this3.fileRemovedEvent(path);
      });

      this._deps.browserExplorer.event.register('fileAdded', function (path) {
        _this3.fileAddedEvent(path);
      });

      this._deps.localhostExplorer.event.register('fileRemoved', function (path) {
        _this3.fileRemovedEvent(path);
      });

      this._deps.localhostExplorer.event.register('errored', function (event) {
        _this3.removeTabsOf(_this3._deps.localhostExplorer);
      });

      this._deps.localhostExplorer.event.register('closed', function (event) {
        _this3.removeTabsOf(_this3._deps.localhostExplorer);
      });

      this.getCurrentFile = this.file;
      this.getFile = this.readFile;
      this.getFolder = this.readdir;
      this.setFile = this.writeFile;
      this.switchFile = this.open;
    }
  }, {
    key: "fileAddedEvent",
    value: function fileAddedEvent(path) {
      this.emit('fileAdded', path);
    }
  }, {
    key: "fileChangedEvent",
    value: function fileChangedEvent(path) {
      this.emit('currentFileChanged', path);
    }
  }, {
    key: "fileRenamedEvent",
    value: function fileRenamedEvent(oldName, newName, isFolder) {
      if (!isFolder) {
        this._deps.config.set('currentFile', '');

        this.editor.discard(oldName);

        if (this.openedFiles[oldName]) {
          delete this.openedFiles[oldName];
          this.openedFiles[newName] = newName;
        }

        this.openFile(newName);
      } else {
        var newFocus;

        for (var k in this.openedFiles) {
          if (k.indexOf(oldName + '/') === 0) {
            var newAbsolutePath = k.replace(oldName, newName);
            this.openedFiles[newAbsolutePath] = newAbsolutePath;
            delete this.openedFiles[k];

            if (this._deps.config.get('currentFile') === k) {
              newFocus = newAbsolutePath;
            }
          }
        }

        if (newFocus) {
          this.openFile(newFocus);
        }
      } // TODO: Only keep `this.emit` (issue#2210)


      this.emit('fileRenamed', oldName, newName, isFolder);
      this.events.emit('fileRenamed', oldName, newName, isFolder);
    }
  }, {
    key: "currentFileProvider",
    value: function currentFileProvider() {
      var path = this.currentPath();

      if (path) {
        return this.fileProviderOf(path);
      }

      return null;
    }
  }, {
    key: "currentFile",
    value: function currentFile() {
      return this._deps.config.get('currentFile');
    }
  }, {
    key: "closeFile",
    value: function closeFile(name) {
      delete this.openedFiles[name];

      if (!Object.keys(this.openedFiles).length) {
        this._deps.config.set('currentFile', ''); // TODO: Only keep `this.emit` (issue#2210)


        this.emit('noFileSelected');
        this.events.emit('noFileSelected');
      } // TODO: Only keep `this.emit` (issue#2210)


      this.emit('fileClosed', name);
      this.events.emit('fileClosed', name);
    }
  }, {
    key: "currentPath",
    value: function currentPath() {
      var currentFile = this._deps.config.get('currentFile');

      return this.extractPathOf(currentFile);
    }
  }, {
    key: "extractPathOf",
    value: function extractPathOf(file) {
      var reg = /(.*)(\/).*/;
      var path = reg.exec(file);
      return path ? path[1] : null;
    }
  }, {
    key: "getFileContent",
    value: function getFileContent(path) {
      var _this4 = this;

      var provider = this.fileProviderOf(path);
      if (!provider) throw createError({
        code: 'ENOENT',
        message: "".concat(path, " not available")
      }); // TODO: change provider to Promise

      return new Promise(function (resolve, reject) {
        if (_this4.currentFile() === path) return resolve(_this4.editor.currentContent());
        provider.get(path, function (err, content) {
          if (err) reject(err);
          resolve(content);
        });
      });
    }
  }, {
    key: "setFileContent",
    value: function () {
      var _setFileContent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(path, content) {
        var canCall;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (!this.currentRequest) {
                  _context12.next = 5;
                  break;
                }

                _context12.next = 3;
                return this.askUserPermission('writeFile', '');

              case 3:
                canCall = _context12.sent;

                if (canCall) {
                  // inform the user about modification after permission is granted and even if permission was saved before
                  toaster((0, _yoYo["default"])(_templateObject(), this.currentRequest.from, path), '', {
                    time: 3000
                  });
                }

              case 5:
                _context12.next = 7;
                return this._setFileInternal(path, content);

              case 7:
                return _context12.abrupt("return", _context12.sent);

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function setFileContent(_x18, _x19) {
        return _setFileContent.apply(this, arguments);
      }

      return setFileContent;
    }()
  }, {
    key: "_setFileInternal",
    value: function _setFileInternal(path, content) {
      var _this5 = this;

      var provider = this.fileProviderOf(path);
      if (!provider) throw createError({
        code: 'ENOENT',
        message: "".concat(path, " not available")
      }); // TODO : Add permission
      // TODO : Change Provider to Promise

      return new Promise(function (resolve, reject) {
        provider.set(path, content, function (error) {
          if (error) reject(error);

          _this5.syncEditor(path);

          _this5.emit('fileSaved', path);

          resolve(true);
        });
      });
    }
  }, {
    key: "_saveAsCopy",
    value: function _saveAsCopy(path, content) {
      var _this6 = this;

      var fileProvider = this.fileProviderOf(path);

      if (fileProvider) {
        helper.createNonClashingNameWithPrefix(path, fileProvider, '', function (error, copyName) {
          if (error) {
            copyName = path + '.' + _this6.currentRequest.from;
          }

          _this6._setFileInternal(copyName, content);

          _this6.openFile(copyName);
        });
      }
    }
  }, {
    key: "removeTabsOf",
    value: function removeTabsOf(provider) {
      for (var tab in this.openedFiles) {
        if (this.fileProviderOf(tab).type === provider.type) {
          this.fileRemovedEvent(tab);
        }
      }
    }
  }, {
    key: "fileRemovedEvent",
    value: function fileRemovedEvent(path) {
      if (path === this._deps.config.get('currentFile')) {
        this._deps.config.set('currentFile', '');
      }

      this.editor.discard(path);
      delete this.openedFiles[path]; // TODO: Only keep `this.emit` (issue#2210)

      this.emit('fileRemoved', path);
      this.events.emit('fileRemoved', path);
      this.openFile();
    }
  }, {
    key: "unselectCurrentFile",
    value: function unselectCurrentFile() {
      this.saveCurrentFile();

      this._deps.config.set('currentFile', ''); // TODO: Only keep `this.emit` (issue#2210)


      this.emit('noFileSelected');
      this.events.emit('noFileSelected');
    }
  }, {
    key: "openFile",
    value: function openFile(file) {
      var _this7 = this;

      var _openFile = function _openFile(file) {
        _this7.saveCurrentFile();

        var provider = _this7.fileProviderOf(file);

        if (!provider) return console.error("no provider for ".concat(file));
        file = provider.getPathFromUrl(file) || file; // in case an external URL is given as input, we resolve it to the right internal path

        _this7._deps.config.set('currentFile', file);

        _this7.openedFiles[file] = file;
        provider.get(file, function (error, content) {
          if (error) {
            console.log(error);
          } else {
            if (provider.isReadOnly(file)) {
              _this7.editor.openReadOnly(file, content);
            } else {
              _this7.editor.open(file, content);
            } // TODO: Only keep `this.emit` (issue#2210)


            _this7.emit('currentFileChanged', file);

            _this7.events.emit('currentFileChanged', file);
          }
        });
      };

      if (file) return _openFile(file);else {
        var browserProvider = this._deps.filesProviders.browser;
        browserProvider.resolveDirectory('browser', function (error, filesProvider) {
          if (error) console.error(error);
          var fileList = Object.keys(filesProvider);

          if (fileList.length) {
            _openFile(browserProvider.type + '/' + fileList[0]);
          } else {
            // TODO: Only keep `this.emit` (issue#2210)
            _this7.emit('noFileSelected');

            _this7.events.emit('noFileSelected');
          }
        });
      }
    }
  }, {
    key: "getProvider",
    value: function getProvider(name) {
      return this._deps.filesProviders[name];
    }
  }, {
    key: "fileProviderOf",
    value: function fileProviderOf(file) {
      if (file.indexOf('localhost') === 0) {
        return this._deps.filesProviders.localhost;
      }

      return this._deps.filesProviders.browser;
    } // returns the list of directories inside path

  }, {
    key: "dirList",
    value: function dirList(path) {
      var _this8 = this;

      var dirPaths = [];

      var collectList = function collectList(path) {
        return new Promise(function (resolve, reject) {
          _this8.readdir(path).then(function (ls) {
            var promises = Object.keys(ls).map(function (item, index) {
              var root = path.indexOf('/') === -1 ? path : path.substr(0, path.indexOf('/'));
              var curPath = "".concat(root, "/").concat(item); // adding 'browser' or 'localhost'

              if (ls[item].isDirectory && !dirPaths.includes(curPath)) {
                dirPaths.push(curPath);
                resolve(dirPaths);
              }

              return new Promise(function (resolve, reject) {
                resolve();
              });
            });
            Promise.all(promises).then(function () {
              resolve(dirPaths);
            });
          });
        });
      };

      return collectList(path);
    }
  }, {
    key: "isRemixDActive",
    value: function isRemixDActive() {
      return this.appManager.isActive('remixd');
    }
  }, {
    key: "saveCurrentFile",
    value: function saveCurrentFile() {
      var currentFile = this._deps.config.get('currentFile');

      if (currentFile && this.editor.current()) {
        var input = this.editor.get(currentFile);

        if (input) {
          var provider = this.fileProviderOf(currentFile);

          if (provider) {
            provider.set(currentFile, input);
            this.emit('fileSaved', currentFile);
          } else {
            console.log('cannot save ' + currentFile + '. Does not belong to any explorer');
          }
        }
      }
    }
  }, {
    key: "syncEditor",
    value: function syncEditor(path) {
      var _this9 = this;

      var currentFile = this._deps.config.get('currentFile');

      if (path !== currentFile) return;
      var provider = this.fileProviderOf(currentFile);

      if (provider) {
        provider.get(currentFile, function (error, content) {
          if (error) console.log(error);

          _this9.editor.setText(content);
        });
      } else {
        console.log('cannot save ' + currentFile + '. Does not belong to any explorer');
      }
    }
  }, {
    key: "setBatchFiles",
    value: function setBatchFiles(filesSet, fileProvider, override, callback) {
      var self = this;
      if (!fileProvider) fileProvider = 'browser';
      if (override === undefined) override = false;

      _async["default"].each(Object.keys(filesSet), function (file, callback) {
        if (override) {
          self._deps.filesProviders[fileProvider].set(file, filesSet[file].content);

          self.syncEditor(fileProvider + file);
          return callback();
        }

        helper.createNonClashingName(file, self._deps.filesProviders[fileProvider], function (error, name) {
          if (error) {
            modalDialogCustom.alert('Unexpected error loading the file ' + error);
          } else if (helper.checkSpecialChars(name)) {
            modalDialogCustom.alert('Special characters are not allowed');
          } else {
            self._deps.filesProviders[fileProvider].set(name, filesSet[file].content);

            self.syncEditor(fileProvider + name);
          }

          callback();
        });
      }, function (error) {
        if (callback) callback(error);
      });
    }
  }]);

  return FileManager;
}(_engine.Plugin);

module.exports = FileManager;

/***/ }),

/***/ "./app/files/fileProvider.js":
/*!***********************************!*\
  !*** ./app/files/fileProvider.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var CompilerImport = __webpack_require__(/*! ../compiler/compiler-imports */ "./app/compiler/compiler-imports.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

var modalDialogCustom = __webpack_require__(/*! ../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var tooltip = __webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var Storage = remixLib.Storage;

var FileProvider = /*#__PURE__*/function () {
  function FileProvider(name) {
    _classCallCheck(this, FileProvider);

    this.event = new EventManager();
    this.type = name;
    this.providerExternalsStorage = new Storage('providerExternals:');
    this.externalFolders = [this.type + '/swarm', this.type + '/ipfs', this.type + '/github', this.type + '/gists', this.type + '/https'];
  }

  _createClass(FileProvider, [{
    key: "addNormalizedName",
    value: function addNormalizedName(path, url) {
      this.providerExternalsStorage.set(this.type + '/' + path, url);
      this.providerExternalsStorage.set('reverse-' + url, this.type + '/' + path);
    }
  }, {
    key: "removeNormalizedName",
    value: function removeNormalizedName(path) {
      var value = this.providerExternalsStorage.get(path);
      this.providerExternalsStorage.remove(path);
      this.providerExternalsStorage.remove('reverse-' + value);
    }
  }, {
    key: "normalizedNameExists",
    value: function normalizedNameExists(path) {
      return this.providerExternalsStorage.exists(path);
    }
  }, {
    key: "getNormalizedName",
    value: function getNormalizedName(path) {
      return this.providerExternalsStorage.get(path);
    }
  }, {
    key: "getPathFromUrl",
    value: function getPathFromUrl(url) {
      return this.providerExternalsStorage.get('reverse-' + url);
    }
  }, {
    key: "isExternalFolder",
    value: function isExternalFolder(path) {
      return this.externalFolders.includes(path);
    }
  }, {
    key: "discardChanges",
    value: function discardChanges(path) {
      var _this = this;

      this.remove(path);
      var compilerImport = new CompilerImport();
      this.providerExternalsStorage.keys().map(function (value) {
        if (value.indexOf(path) === 0) {
          compilerImport["import"](_this.getNormalizedName(value), true, function (loadingMsg) {
            tooltip(loadingMsg);
          }, function (error, content, cleanUrl, type, url) {
            if (error) {
              modalDialogCustom.alert(error);
            } else {
              _this.addExternal(type + '/' + cleanUrl, content, url);
            }
          });
        }
      });
    }
  }, {
    key: "exists",
    value: function exists(path, cb) {
      // todo check the type (directory/file) as well #2386
      // currently it is not possible to have a file and folder with same path
      return cb(null, this._exists(path));
    }
  }, {
    key: "_exists",
    value: function _exists(path) {
      path = this.getPathFromUrl(path) || path; // ensure we actually use the normalized path from here

      var unprefixedpath = this.removePrefix(path);
      return path === this.type ? true : window.remixFileSystem.existsSync(unprefixedpath);
    }
  }, {
    key: "init",
    value: function init(cb) {
      cb();
    }
  }, {
    key: "get",
    value: function get(path, cb) {
      cb = cb || function () {};

      path = this.getPathFromUrl(path) || path; // ensure we actually use the normalized path from here

      var unprefixedpath = this.removePrefix(path);
      var exists = window.remixFileSystem.existsSync(unprefixedpath);
      if (!exists) return cb(null, null);
      window.remixFileSystem.readFile(unprefixedpath, 'utf8', function (err, content) {
        cb(err, content);
      });
    }
  }, {
    key: "set",
    value: function set(path, content, cb) {
      cb = cb || function () {};

      var unprefixedpath = this.removePrefix(path);
      var exists = window.remixFileSystem.existsSync(unprefixedpath);

      if (exists && window.remixFileSystem.readFileSync(unprefixedpath, 'utf8') === content) {
        cb();
        return true;
      }

      if (!exists && unprefixedpath.indexOf('/') !== -1) {
        // the last element is the filename and we should remove it
        this.createDir(path.substr(0, path.lastIndexOf('/')));
      }

      try {
        window.remixFileSystem.writeFileSync(unprefixedpath, content);
      } catch (e) {
        cb(e);
        return false;
      }

      if (!exists) {
        this.event.trigger('fileAdded', [this._normalizePath(unprefixedpath), false]);
      } else {
        this.event.trigger('fileChanged', [this._normalizePath(unprefixedpath)]);
      }

      cb();
      return true;
    }
  }, {
    key: "createDir",
    value: function createDir(path, cb) {
      var _this2 = this;

      var unprefixedpath = this.removePrefix(path);
      var paths = unprefixedpath.split('/');
      if (paths.length && paths[0] === '') paths.shift();
      var currentCheck = '';
      paths.forEach(function (value) {
        currentCheck = currentCheck + '/' + value;

        if (!window.remixFileSystem.existsSync(currentCheck)) {
          window.remixFileSystem.mkdirSync(currentCheck);

          _this2.event.trigger('folderAdded', [_this2._normalizePath(currentCheck)]);
        }
      });
      if (cb) cb();
    } // this will not add a folder as readonly but keep the original url to be able to restore it later

  }, {
    key: "addExternal",
    value: function addExternal(path, content, url) {
      if (url) this.addNormalizedName(path, url);
      return this.set(path, content);
    }
  }, {
    key: "isReadOnly",
    value: function isReadOnly(path) {
      return false;
    }
  }, {
    key: "isDirectory",
    value: function isDirectory(path) {
      var unprefixedpath = this.removePrefix(path);
      return path === this.type ? true : window.remixFileSystem.statSync(unprefixedpath).isDirectory();
    }
  }, {
    key: "isFile",
    value: function isFile(path) {
      path = this.getPathFromUrl(path) || path; // ensure we actually use the normalized path from here

      path = this.removePrefix(path);
      return window.remixFileSystem.statSync(path).isFile();
    }
    /**
     * Removes the folder recursively
     * @param {*} path is the folder to be removed
     */

  }, {
    key: "remove",
    value: function remove(path) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        path = _this3.removePrefix(path);

        if (window.remixFileSystem.existsSync(path)) {
          var stat = window.remixFileSystem.statSync(path);

          try {
            if (!stat.isDirectory()) {
              resolve(_this3.removeFile(path));
            } else {
              var items = window.remixFileSystem.readdirSync(path);

              if (items.length !== 0) {
                items.forEach(function (item, index) {
                  var curPath = "".concat(path).concat(path.endsWith('/') ? '' : '/').concat(item);

                  if (window.remixFileSystem.statSync(curPath).isDirectory()) {
                    // delete folder
                    _this3.remove(curPath);
                  } else {
                    // delete file
                    _this3.removeFile(curPath);
                  }
                });
                if (window.remixFileSystem.readdirSync(path).length === 0) window.remixFileSystem.rmdirSync(path, console.log);
              } else {
                // folder is empty
                window.remixFileSystem.rmdirSync(path, console.log);
              }

              _this3.event.trigger('fileRemoved', [_this3._normalizePath(path)]);
            }
          } catch (e) {
            console.log(e);
            return resolve(false);
          }
        }

        return resolve(true);
      });
    }
  }, {
    key: "removeFile",
    value: function removeFile(path) {
      path = this.removePrefix(path);

      if (window.remixFileSystem.existsSync(path) && !window.remixFileSystem.statSync(path).isDirectory()) {
        window.remixFileSystem.unlinkSync(path, console.log);
        this.event.trigger('fileRemoved', [this._normalizePath(path)]);
        return true;
      } else return false;
    }
  }, {
    key: "rename",
    value: function rename(oldPath, newPath, isFolder) {
      var unprefixedoldPath = this.removePrefix(oldPath);
      var unprefixednewPath = this.removePrefix(newPath);

      if (this._exists(unprefixedoldPath)) {
        window.remixFileSystem.renameSync(unprefixedoldPath, unprefixednewPath);
        this.event.trigger('fileRenamed', [this._normalizePath(unprefixedoldPath), this._normalizePath(unprefixednewPath), isFolder]);
        return true;
      }

      return false;
    }
  }, {
    key: "resolveDirectory",
    value: function resolveDirectory(path, callback) {
      if (!path) return callback(null, _defineProperty({}, this.type, {}));
      path = this.removePrefix(path);
      if (path.indexOf('/') !== 0) path = '/' + path;
      window.remixFileSystem.readdir(path, function (error, files) {
        var ret = {};

        if (files) {
          files.forEach(function (element) {
            var absPath = (path === '/' ? '' : path) + '/' + element;
            ret[absPath.indexOf('/') === 0 ? absPath.substr(1, absPath.length) : absPath] = {
              isDirectory: window.remixFileSystem.statSync(absPath).isDirectory()
            }; // ^ ret does not accept path starting with '/'
          });
        }

        callback(error, ret);
      });
    }
  }, {
    key: "removePrefix",
    value: function removePrefix(path) {
      path = path.indexOf(this.type) === 0 ? path.replace(this.type, '') : path;
      if (path === '') return '/';
      return path;
    }
  }, {
    key: "_normalizePath",
    value: function _normalizePath(path) {
      if (path.indexOf('/') !== 0) path = '/' + path;
      return this.type + path;
    }
  }]);

  return FileProvider;
}();

module.exports = FileProvider;

/***/ }),

/***/ "./app/files/git-handle.js":
/*!*********************************!*\
  !*** ./app/files/git-handle.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GitHandle = void 0;

var _engineWeb = __webpack_require__(/*! @remixproject/engine-web */ "../../../node_modules/@remixproject/engine-web/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var profile = {
  name: 'git',
  displayName: 'Git',
  url: 'ws://127.0.0.1:65521',
  methods: ['execute'],
  description: 'Using Remixd daemon, allow to access git API',
  kind: 'other',
  version: packageJson.version
};

var GitHandle = /*#__PURE__*/function (_WebsocketPlugin) {
  _inherits(GitHandle, _WebsocketPlugin);

  var _super = _createSuper(GitHandle);

  function GitHandle() {
    _classCallCheck(this, GitHandle);

    return _super.call(this, profile);
  }

  return GitHandle;
}(_engineWeb.WebsocketPlugin);

exports.GitHandle = GitHandle;

/***/ }),

/***/ "./app/files/remixDProvider.js":
/*!*************************************!*\
  !*** ./app/files/remixDProvider.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

module.exports = /*#__PURE__*/function () {
  function RemixDProvider(appManager) {
    _classCallCheck(this, RemixDProvider);

    this.event = new EventManager();
    this._appManager = appManager;
    this.type = 'localhost';
    this.error = {
      EEXIST: 'File already exists'
    };
    this._isReady = false;
    this._readOnlyFiles = {};
    this._readOnlyMode = false;
    this.filesContent = {};
    this.files = {};
  }

  _createClass(RemixDProvider, [{
    key: "_registerEvent",
    value: function _registerEvent() {
      var _this = this;

      var remixdEvents = ['connecting', 'connected', 'errored', 'closed'];
      remixdEvents.forEach(function (value) {
        _this._appManager.on('remixd', value, function (event) {
          _this.event.trigger(value, [event]);
        });
      });

      this._appManager.on('remixd', 'folderAdded', function (path) {
        _this.event.trigger('folderAdded', [_this.addPrefix(path)]);
      });

      this._appManager.on('remixd', 'fileAdded', function (path) {
        _this.event.trigger('fileAdded', [_this.addPrefix(path)]);
      });

      this._appManager.on('remixd', 'fileChanged', function (path) {
        _this.event.trigger('fileChanged', [_this.addPrefix(path)]);
      });

      this._appManager.on('remixd', 'fileRemoved', function (path) {
        _this.event.trigger('fileRemoved', [_this.addPrefix(path)]);
      });

      this._appManager.on('remixd', 'fileRenamed', function (oldPath, newPath) {
        _this.event.trigger('fileRemoved', [_this.addPrefix(oldPath), _this.addPrefix(newPath)]);
      });

      this._appManager.on('remixd', 'rootFolderChanged', function () {
        _this.event.trigger('rootFolderChanged', []);
      });
    }
  }, {
    key: "isConnected",
    value: function isConnected() {
      return this._isReady;
    }
  }, {
    key: "close",
    value: function close(cb) {
      this._isReady = false;
      cb();
    }
  }, {
    key: "init",
    value: function init(cb) {
      var _this2 = this;

      if (this._isReady) return cb && cb();

      this._appManager.call('remixd', 'folderIsReadOnly', {}).then(function (result) {
        _this2._isReady = true;
        _this2._readOnlyMode = result;

        _this2._registerEvent();

        cb && cb();
      })["catch"](function (error) {
        cb && cb(error);
      });
    }
  }, {
    key: "exists",
    value: function exists(path, cb) {
      if (!this._isReady) return cb && cb('provider not ready');
      var unprefixedpath = this.removePrefix(path);
      return this._appManager.call('remixd', 'exists', {
        path: unprefixedpath
      }).then(function (result) {
        if (cb) return cb(null, result);
        return result;
      })["catch"](function (error) {
        if (cb) return cb(error);
        throw new Error(error);
      });
    }
  }, {
    key: "getNormalizedName",
    value: function getNormalizedName(path) {
      return path;
    }
  }, {
    key: "getPathFromUrl",
    value: function getPathFromUrl(path) {
      return path;
    }
  }, {
    key: "get",
    value: function get(path, cb) {
      var _this3 = this;

      if (!this._isReady) return cb && cb('provider not ready');
      var unprefixedpath = this.removePrefix(path);

      this._appManager.call('remixd', 'get', {
        path: unprefixedpath
      }).then(function (file) {
        _this3.filesContent[path] = file.content;

        if (file.readonly) {
          _this3._readOnlyFiles[path] = 1;
        }

        cb(null, file.content);
      })["catch"](function (error) {
        if (error) console.log(error); // display the last known content.
        // TODO should perhaps better warn the user that the file is not synced.

        return cb(null, _this3.filesContent[path]);
      });
    }
  }, {
    key: "set",
    value: function () {
      var _set = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(path, content, cb) {
        var unprefixedpath;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this._isReady) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return", cb && cb('provider not ready'));

              case 2:
                unprefixedpath = this.removePrefix(path);
                return _context2.abrupt("return", this._appManager.call('remixd', 'set', {
                  path: unprefixedpath,
                  content: content
                }).then( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(result) {
                    return regeneratorRuntime.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (!cb) {
                              _context.next = 2;
                              break;
                            }

                            return _context.abrupt("return", cb(null, result));

                          case 2:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function (_x4) {
                    return _ref.apply(this, arguments);
                  };
                }())["catch"](function (error) {
                  if (cb) return cb(error);
                  throw new Error(error);
                }));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function set(_x, _x2, _x3) {
        return _set.apply(this, arguments);
      }

      return set;
    }()
  }, {
    key: "createDir",
    value: function () {
      var _createDir = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(path, cb) {
        var unprefixedpath;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this._isReady) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return", cb && cb('provider not ready'));

              case 2:
                unprefixedpath = this.removePrefix(path);
                return _context3.abrupt("return", this._appManager.call('remixd', 'createDir', {
                  path: unprefixedpath
                }));

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function createDir(_x5, _x6) {
        return _createDir.apply(this, arguments);
      }

      return createDir;
    }()
  }, {
    key: "isReadOnly",
    value: function isReadOnly(path) {
      return this._readOnlyMode || this._readOnlyFiles[path] === 1;
    }
  }, {
    key: "remove",
    value: function remove(path) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        if (!_this4._isReady) return reject(new Error('provider not ready'));

        var unprefixedpath = _this4.removePrefix(path);

        _this4._appManager.call('remixd', 'remove', {
          path: unprefixedpath
        }).then(function (result) {
          var path = _this4.type + '/' + unprefixedpath;
          delete _this4.filesContent[path];
          resolve(true);

          _this4.init();
        })["catch"](function (error) {
          if (error) console.log(error);
          resolve(false);
        });
      });
    }
  }, {
    key: "rename",
    value: function rename(oldPath, newPath, isFolder) {
      var _this5 = this;

      var unprefixedoldPath = this.removePrefix(oldPath);
      var unprefixednewPath = this.removePrefix(newPath);
      if (!this._isReady) return new Promise(function (resolve, reject) {
        return reject(new Error('provider not ready'));
      });
      return this._appManager.call('remixd', 'rename', {
        oldPath: unprefixedoldPath,
        newPath: unprefixednewPath
      }).then(function (result) {
        var newPath = _this5.type + '/' + unprefixednewPath;
        var oldPath = _this5.type + '/' + unprefixedoldPath;
        _this5.filesContent[newPath] = _this5.filesContent[oldPath];
        delete _this5.filesContent[oldPath];

        _this5.init(function () {
          _this5.event.trigger('fileRenamed', [oldPath, newPath, isFolder]);
        });

        return result;
      })["catch"](function (error) {
        console.log(error);
        if (_this5.error[error.code]) error = _this5.error[error.code];

        _this5.event.trigger('fileRenamedError', [_this5.error[error.code]]);
      });
    }
  }, {
    key: "isExternalFolder",
    value: function isExternalFolder(path) {
      return false;
    }
  }, {
    key: "removePrefix",
    value: function removePrefix(path) {
      path = path.indexOf(this.type) === 0 ? path.replace(this.type, '') : path;
      if (path[0] === '/') return path.substring(1);
      if (path === '') return '/';
      return path;
    }
  }, {
    key: "addPrefix",
    value: function addPrefix(path) {
      if (path.indexOf(this.type + '/') === 0) return path;
      if (path[0] === '/') return 'localhost' + path;
      return 'localhost/' + path;
    }
  }, {
    key: "resolveDirectory",
    value: function resolveDirectory(path, callback) {
      var self = this;
      if (path[0] === '/') path = path.substring(1);
      if (!path) return callback(null, _defineProperty({}, self.type, {}));
      var unprefixedpath = this.removePrefix(path);
      if (!this._isReady) return callback && callback('provider not ready');

      this._appManager.call('remixd', 'resolveDirectory', {
        path: unprefixedpath
      }).then(function (result) {
        callback(null, result);
      })["catch"](callback);
    }
  }, {
    key: "isDirectory",
    value: function () {
      var _isDirectory = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(path) {
        var unprefixedpath;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                unprefixedpath = this.removePrefix(path);

                if (this._isReady) {
                  _context4.next = 3;
                  break;
                }

                throw new Error('provider not ready');

              case 3:
                _context4.next = 5;
                return this._appManager.call('remixd', 'isDirectory', {
                  path: unprefixedpath
                });

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function isDirectory(_x7) {
        return _isDirectory.apply(this, arguments);
      }

      return isDirectory;
    }()
  }, {
    key: "isFile",
    value: function () {
      var _isFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(path) {
        var unprefixedpath;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                unprefixedpath = this.removePrefix(path);

                if (this._isReady) {
                  _context5.next = 3;
                  break;
                }

                throw new Error('provider not ready');

              case 3:
                _context5.next = 5;
                return this._appManager.call('remixd', 'isFile', {
                  path: unprefixedpath
                });

              case 5:
                return _context5.abrupt("return", _context5.sent);

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function isFile(_x8) {
        return _isFile.apply(this, arguments);
      }

      return isFile;
    }()
  }]);

  return RemixDProvider;
}();

/***/ }),

/***/ "./app/files/remixd-handle.js":
/*!************************************!*\
  !*** ./app/files/remixd-handle.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemixdHandle = void 0;

var _isElectron = _interopRequireDefault(__webpack_require__(/*! is-electron */ "../../../node_modules/is-electron/index.js"));

var _engineWeb = __webpack_require__(/*! @remixproject/engine-web */ "../../../node_modules/@remixproject/engine-web/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n    <div class=", ">\n      <div class=", ">Interact with your file system from Remix. Click connect and find shared folder in the Remix file explorer (under localhost).\n        Before you get started, check out the <a target=\"_blank\" href=\"https://remix-ide.readthedocs.io/en/latest/remixd.html\">Remixd tutorial</a>.\n        to find out how to run Remixd.\n      </div>\n      <div class=", ">If you have looked at that tutorial and are just looking for the remixd command, <br> here it is:\n        <br><b>remixd -s absolute-path-to-the-shared-folder --remix-ide your-remix-ide-URL-instance</b>\n      </div>\n      <div class=", ">Connection will start a session between <em>", "</em> and your local file system <i>ws://127.0.0.1:65520</i>\n        so please make sure your system is secured enough (port 65520 neither opened nor forwarded).\n        <i class=\"fas fa-link\"></i> will show you current connection status.\n      </div>\n      <div class=", ">This feature is still in Alpha, so we recommend you to keep a copy of the shared folder.</div>\n    </div>\n  "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .dialog {\n    display: flex;\n    flex-direction: column;\n  }\n  .dialogParagraph {\n    margin-bottom: 2em;\n    word-break: break-word;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var modalDialog = __webpack_require__(/*! ../ui/modaldialog */ "./app/ui/modaldialog.js");

var modalDialogCustom = __webpack_require__(/*! ../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());
var profile = {
  name: 'remixd',
  displayName: 'RemixD',
  url: 'ws://127.0.0.1:65520',
  methods: ['folderIsReadOnly', 'resolveDirectory', 'get', 'exists', 'isFile', 'set', 'rename', 'remove', 'isDirectory', 'list', 'createDir'],
  events: [],
  description: 'Using Remixd daemon, allow to access file system',
  kind: 'other',
  version: packageJson.version
};

var RemixdHandle = /*#__PURE__*/function (_WebsocketPlugin) {
  _inherits(RemixdHandle, _WebsocketPlugin);

  var _super = _createSuper(RemixdHandle);

  function RemixdHandle(fileSystemExplorer, locahostProvider, appManager) {
    var _this;

    _classCallCheck(this, RemixdHandle);

    _this = _super.call(this, profile);
    _this.fileSystemExplorer = fileSystemExplorer;
    _this.locahostProvider = locahostProvider;
    _this.appManager = appManager;
    return _this;
  }

  _createClass(RemixdHandle, [{
    key: "deactivate",
    value: function deactivate() {
      this.fileSystemExplorer.hide();
      if (_get(_getPrototypeOf(RemixdHandle.prototype), "socket", this)) _get(_getPrototypeOf(RemixdHandle.prototype), "deactivate", this).call(this);
      this.call('manager', 'deactivatePlugin', 'git');
      this.locahostProvider.close(function (error) {
        if (error) console.log(error);
      });
    }
  }, {
    key: "activate",
    value: function activate() {
      this.connectToLocalhost();
    }
  }, {
    key: "canceled",
    value: function () {
      var _canceled = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.call('manager', 'deactivatePlugin', 'remixd');
                this.call('manager', 'deactivatePlugin', 'git');

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function canceled() {
        return _canceled.apply(this, arguments);
      }

      return canceled;
    }()
    /**
      * connect to localhost if no connection and render the explorer
      * disconnect from localhost if connected and remove the explorer
      *
      * @param {String} txHash - hash of the transaction
      */

  }, {
    key: "connectToLocalhost",
    value: function () {
      var _connectToLocalhost = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _this2 = this;

        var connection;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                connection = function connection(error) {
                  if (error) {
                    console.log(error);
                    modalDialogCustom.alert('Cannot connect to the remixd daemon.' + 'Please make sure you have the remixd running in the background.');

                    _this2.canceled();
                  } else {
                    var intervalId = setInterval(function () {
                      if (!_this2.socket || _this2.socket && _this2.socket.readyState === 3) {
                        // 3 means connection closed
                        clearInterval(intervalId);
                        console.log(error);
                        modalDialogCustom.alert('Connection to remixd terminated' + 'Please make sure remixd is still running in the background.');

                        _this2.canceled();
                      }
                    }, 3000);

                    _this2.locahostProvider.init(function () {
                      _this2.fileSystemExplorer.show();
                    });

                    _this2.call('manager', 'activatePlugin', 'git');
                  }
                };

                if (this.locahostProvider.isConnected()) {
                  this.deactivate();
                } else if (!(0, _isElectron["default"])()) {
                  // warn the user only if he/she is in the browser context
                  modalDialog('Connect to localhost', remixdDialog(), {
                    label: 'Connect',
                    fn: function fn() {
                      try {
                        _get(_getPrototypeOf(RemixdHandle.prototype), "activate", _this2).call(_this2);

                        setTimeout(function () {
                          if (!_this2.socket || _this2.socket && _this2.socket.readyState === 3) {
                            // 3 means connection closed
                            connection(new Error('Connection with daemon failed.'));
                          } else {
                            connection();
                          }
                        }, 3000);
                      } catch (error) {
                        connection(error);
                      }
                    }
                  }, {
                    label: 'Cancel',
                    fn: function fn() {
                      _this2.canceled();
                    }
                  });
                } else {
                  try {
                    _get(_getPrototypeOf(RemixdHandle.prototype), "activate", this).call(this);

                    setTimeout(function () {
                      connection();
                    }, 2000);
                  } catch (error) {
                    connection(error);
                  }
                }

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function connectToLocalhost() {
        return _connectToLocalhost.apply(this, arguments);
      }

      return connectToLocalhost;
    }()
  }]);

  return RemixdHandle;
}(_engineWeb.WebsocketPlugin);

exports.RemixdHandle = RemixdHandle;

function remixdDialog() {
  return yo(_templateObject2(), css.dialog, css.dialogParagraph, css.dialogParagraph, css.dialogParagraph, window.location.href, css.dialogParagraph);
}

/***/ }),

/***/ "./app/panels/file-panel.js":
/*!**********************************!*\
  !*** ./app/panels/file-panel.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engineWeb = __webpack_require__(/*! @remixproject/engine-web */ "../../../node_modules/@remixproject/engine-web/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ "../../../node_modules/react-dom/index.js"));

var _fileExplorer = __webpack_require__(/*! @remix-ui/file-explorer */ "../../../libs/remix-ui/file-explorer/src/index.ts");

__webpack_require__(/*! ./styles/file-panel-styles.css */ "./app/panels/styles/file-panel-styles.css");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n      <div id=\"fileExplorerView\">\n      </div>\n    "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js"); // var FileExplorer = require('../files/file-explorer')


var _require = __webpack_require__(/*! ../files/remixd-handle.js */ "./app/files/remixd-handle.js"),
    RemixdHandle = _require.RemixdHandle;

var _require2 = __webpack_require__(/*! ../files/git-handle.js */ "./app/files/git-handle.js"),
    GitHandle = _require2.GitHandle;

var globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var canUpload = window.File || window.FileReader || window.FileList || window.Blob;
/*
  Overview of APIs:
   * fileManager: @args fileProviders (browser, shared-folder, swarm, github, etc ...) & config & editor
      - listen on browser & localhost file provider (`fileRenamed` & `fileRemoved`)
      - update the tabs, switchFile
      - trigger `currentFileChanged`
      - set the current file in the config
   * fileProvider: currently browser, swarm, localhost, github, gist
      - link to backend
      - provide properties `type`, `readonly`
      - provide API `resolveDirectory`, `remove`, `exists`, `rename`, `get`, `set`
      - trigger `fileExternallyChanged`, `fileRemoved`, `fileRenamed`, `fileRenamedError`, `fileAdded`
   * file-explorer: treeview @args fileProvider
      - listen on events triggered by fileProvider
      - call fileProvider API
*/

var profile = {
  name: 'fileExplorers',
  displayName: 'File explorers',
  methods: ['createNewFile', 'uploadFile'],
  events: [],
  icon: 'assets/img/fileManager.webp',
  description: ' - ',
  kind: 'fileexplorer',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/file_explorer.html',
  version: packageJson.version
};

module.exports = /*#__PURE__*/function (_ViewPlugin) {
  _inherits(Filepanel, _ViewPlugin);

  var _super = _createSuper(Filepanel);

  function Filepanel(appManager) {
    var _this;

    _classCallCheck(this, Filepanel);

    _this = _super.call(this, profile);
    _this._components = {};
    _this._components.registry = globalRegistry;
    _this._deps = {
      fileProviders: _this._components.registry.get('fileproviders').api,
      fileManager: _this._components.registry.get('filemanager').api,
      config: _this._components.registry.get('config').api
    };
    _this.hideRemixdExplorer = true;
    _this.remixdExplorer = {
      hide: function hide() {
        _this.hideRemixdExplorer = true;

        _this.renderComponent();
      },
      show: function show() {
        _this.hideRemixdExplorer = false;

        _this.renderComponent();
      }
    };
    _this.reset = false;
    _this.registeredMenuItems = [];
    _this.displayNewFile = false;
    _this.uploadFileEvent = null;
    _this.el = yo(_templateObject());
    _this.remixdHandle = new RemixdHandle(_this.remixdExplorer, _this._deps.fileProviders.localhost, appManager);
    _this.gitHandle = new GitHandle();
    _this.event = new EventManager();

    _this._deps.fileProviders.localhost.event.register('connecting', function (event) {});

    _this._deps.fileProviders.localhost.event.register('connected', function (event) {
      _this.remixdExplorer.show();
    });

    _this._deps.fileProviders.localhost.event.register('errored', function (event) {
      _this.remixdExplorer.hide();
    });

    _this._deps.fileProviders.localhost.event.register('closed', function (event) {
      _this.remixdExplorer.hide();
    });

    _this.renderComponent();

    return _this;
  }

  _createClass(Filepanel, [{
    key: "resetFocus",
    value: function resetFocus(value) {
      this.reset = value;
      this.renderComponent();
    }
  }, {
    key: "createNewFile",
    value: function createNewFile() {
      this.displayNewFile = true;
      this.renderComponent();
    }
  }, {
    key: "resetNewFile",
    value: function resetNewFile() {
      this.displayNewFile = false;
      this.renderComponent();
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(target) {
      this.uploadFileEvent = target;
      this.renderComponent();
    }
  }, {
    key: "resetUploadFile",
    value: function resetUploadFile() {
      this.uploadFileEvent = null;
      this.renderComponent();
    }
  }, {
    key: "render",
    value: function render() {
      return this.el;
    }
    /**
     *
     * @param item { id: string, name: string, type?: string[], path?: string[], extension?: string[], pattern?: string[] }
     * @param callback (...args) => void
     */

  }, {
    key: "registerContextMenuItem",
    value: function registerContextMenuItem(item) {
      if (!item) throw new Error('Invalid register context menu argument');
      if (!item.name || !item.id) throw new Error('Item name and id is mandatory');
      if (!item.type && !item.path && !item.extension && !item.pattern) throw new Error('Invalid file matching criteria provided');
      this.registeredMenuItems = [].concat(_toConsumableArray(this.registeredMenuItems), [item]);
      this.renderComponent();
    }
  }, {
    key: "renderComponent",
    value: function renderComponent() {
      var _this2 = this;

      _reactDom["default"].render( /*#__PURE__*/_react["default"].createElement("div", {
        className: "remixui_container"
      }, /*#__PURE__*/_react["default"].createElement("div", {
        className: "remixui_fileexplorer",
        onClick: function onClick() {
          return _this2.resetFocus(true);
        }
      }, /*#__PURE__*/_react["default"].createElement("div", {
        className: "remixui_fileExplorerTree"
      }, /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement("div", {
        className: "pl-2 remixui_treeview",
        "data-id": "filePanelFileExplorerTree"
      }, /*#__PURE__*/_react["default"].createElement(_fileExplorer.FileExplorer, {
        name: "browser",
        registry: this._components.registry,
        filesProvider: this._deps.fileProviders.browser,
        menuItems: ['createNewFile', 'createNewFolder', 'publishToGist', canUpload ? 'uploadFile' : ''],
        plugin: this,
        focusRoot: this.reset,
        contextMenuItems: this.registeredMenuItems,
        displayInput: this.displayNewFile,
        externalUploads: this.uploadFileEvent
      })), /*#__PURE__*/_react["default"].createElement("div", {
        className: "pl-2 filesystemexplorer remixui_treeview"
      }, !this.hideRemixdExplorer && /*#__PURE__*/_react["default"].createElement(_fileExplorer.FileExplorer, {
        name: "localhost",
        registry: this._components.registry,
        filesProvider: this._deps.fileProviders.localhost,
        menuItems: ['createNewFile', 'createNewFolder'],
        plugin: this,
        focusRoot: this.reset,
        contextMenuItems: this.registeredMenuItems
      })))))), this.el);
    }
  }]);

  return Filepanel;
}(_engineWeb.ViewPlugin);

/***/ }),

/***/ "./app/panels/main-view.js":
/*!*********************************!*\
  !*** ./app/panels/main-view.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MainView = void 0;

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n      <div class=", ">\n        ", "\n        ", "\n        ", "\n        ", "\n        ", "\n      </div>\n    "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .mainview            {\n    display           : flex;\n    flex-direction    : column;\n    height            : 100%;\n    width             : 100%;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

var globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var _require = __webpack_require__(/*! ./tab-proxy.js */ "./app/panels/tab-proxy.js"),
    TabProxy = _require.TabProxy;

var ContextView = __webpack_require__(/*! ../editor/contextView */ "./app/editor/contextView.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject()); // @todo(#650) Extract this into two classes: MainPanel (TabsProxy + Iframe/Editor) & BottomPanel (Terminal)

var MainView = /*#__PURE__*/function () {
  function MainView(contextualListener, editor, mainPanel, fileManager, appManager, terminal) {
    _classCallCheck(this, MainView);

    var self = this;
    self.event = new EventManager();
    self._view = {};
    self._components = {};
    self._components.registry = globalRegistry;
    self.editor = editor;
    self.fileManager = fileManager;
    self.mainPanel = mainPanel;
    self.txListener = globalRegistry.get('txlistener').api;
    self._components.terminal = terminal;
    self._components.contextualListener = contextualListener;
    this.appManager = appManager;
    this.init();
  }

  _createClass(MainView, [{
    key: "showApp",
    value: function showApp(name) {
      this.fileManager.unselectCurrentFile();
      this.mainPanel.showContent(name);
      this._view.editor.style.display = 'none';

      this._components.contextView.hide();

      this._view.mainPanel.style.display = 'block';
    }
  }, {
    key: "getAppPanel",
    value: function getAppPanel() {
      return this.mainPanel;
    }
  }, {
    key: "init",
    value: function init() {
      var _this = this;

      var self = this;
      self._deps = {
        config: self._components.registry.get('config').api,
        fileManager: self._components.registry.get('filemanager').api
      };
      self.tabProxy = new TabProxy(self.fileManager, self.editor, self.appManager);
      /*
        We listen here on event from the tab component to display / hide the editor and mainpanel
        depending on the content that should be displayed
      */

      self.fileManager.events.on('currentFileChanged', function (file) {
        // we check upstream for "fileChanged"
        self._view.editor.style.display = 'block';
        self._view.mainPanel.style.display = 'none';

        self._components.contextView.show();
      });
      self.tabProxy.event.on('openFile', function (file) {
        self._view.editor.style.display = 'block';
        self._view.mainPanel.style.display = 'none';

        self._components.contextView.show();
      });
      self.tabProxy.event.on('closeFile', function (file) {});
      self.tabProxy.event.on('switchApp', self.showApp.bind(self));
      self.tabProxy.event.on('closeApp', function (name) {
        self._view.editor.style.display = 'block';

        self._components.contextView.show();

        self._view.mainPanel.style.display = 'none';
      });
      self.tabProxy.event.on('tabCountChanged', function (count) {
        if (!count) _this.editor.displayEmptyReadOnlySession();
      });
      self.data = {
        _layout: {
          top: {
            offset: self._terminalTopOffset(),
            show: true
          }
        }
      };
      var contextView = new ContextView({
        contextualListener: self._components.contextualListener,
        editor: self.editor
      });
      self._components.contextView = contextView;

      self._components.terminal.event.register('resize', function (delta) {
        return self._adjustLayout('top', delta);
      });

      if (self.txListener) {
        self._components.terminal.event.register('listenOnNetWork', function (listenOnNetWork) {
          self.txListener.setListenOnNetwork(listenOnNetWork);
        });
      }
    }
  }, {
    key: "_terminalTopOffset",
    value: function _terminalTopOffset() {
      return this._deps.config.get('terminal-top-offset') || 150;
    }
  }, {
    key: "_adjustLayout",
    value: function _adjustLayout(direction, delta) {
      var limitUp = 0;
      var limitDown = 32;
      var containerHeight = window.innerHeight - limitUp; // - menu bar containerHeight

      var self = this;
      var layout = self.data._layout[direction];

      if (layout) {
        if (delta === undefined) {
          layout.show = !layout.show;
          if (layout.show) delta = layout.offset;else delta = 0;
        } else {
          layout.show = true;

          self._deps.config.set("terminal-".concat(direction, "-offset"), delta);

          layout.offset = delta;
        }
      }

      var tmp = delta - limitDown;
      delta = tmp > 0 ? tmp : 0;

      if (direction === 'top') {
        var mainPanelHeight = containerHeight - delta;
        mainPanelHeight = mainPanelHeight < 0 ? 0 : mainPanelHeight;
        self._view.editor.style.height = "".concat(mainPanelHeight, "px");
        self._view.mainPanel.style.height = "".concat(mainPanelHeight, "px");
        self._view.terminal.style.height = "".concat(delta, "px"); // - menu bar height

        self.editor.resize((document.querySelector('#editorWrap') || {}).checked);

        self._components.terminal.scroll2bottom();
      }
    }
  }, {
    key: "minimizeTerminal",
    value: function minimizeTerminal() {
      this._adjustLayout('top');
    }
  }, {
    key: "showTerminal",
    value: function showTerminal(offset) {
      this._adjustLayout('top', offset || this._terminalTopOffset());
    }
  }, {
    key: "getTerminal",
    value: function getTerminal() {
      return this._components.terminal;
    }
  }, {
    key: "getEditor",
    value: function getEditor() {
      var self = this;
      return self.editor;
    }
  }, {
    key: "refresh",
    value: function refresh() {
      var self = this;

      self._view.tabs.onmouseenter();
    }
  }, {
    key: "log",
    value: function log() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var self = this;
      var command = self._components.terminal.commands[data.type];
      if (typeof command === 'function') command(data.value);
    }
  }, {
    key: "logMessage",
    value: function logMessage(msg) {
      var self = this;
      self.log({
        type: 'log',
        value: msg
      });
    }
  }, {
    key: "logHtmlMessage",
    value: function logHtmlMessage(msg) {
      var self = this;
      self.log({
        type: 'html',
        value: msg
      });
    }
  }, {
    key: "render",
    value: function render() {
      var self = this;
      if (self._view.mainview) return self._view.mainview;
      self._view.editor = self.editor.render();
      self._view.editor.style.display = 'none';
      self._view.mainPanel = self.mainPanel.render();
      self._view.terminal = self._components.terminal.render();
      self._view.mainview = yo(_templateObject2(), css.mainview, self.tabProxy.renderTabsbar(), self._view.editor, self._view.mainPanel, self._components.contextView.render(), self._view.terminal); // INIT

      self._adjustLayout('top', self.data._layout.top.offset);

      document.addEventListener('keydown', function (e) {
        if (e.altKey && e.keyCode === 84) self.tabProxy.switchNextTab(); // alt + t
      });
      return self._view.mainview;
    }
  }, {
    key: "registerCommand",
    value: function registerCommand(name, command, opts) {
      var self = this;
      return self._components.terminal.registerCommand(name, command, opts);
    }
  }, {
    key: "updateTerminalFilter",
    value: function updateTerminalFilter(filter) {
      this._components.terminal.updateJournal(filter);
    }
  }]);

  return MainView;
}();

exports.MainView = MainView;

/***/ }),

/***/ "./app/panels/styles/file-panel-styles.css":
/*!*************************************************!*\
  !*** ./app/panels/styles/file-panel-styles.css ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../../../../../node_modules/postcss-loader/src??embedded!./file-panel-styles.css */ "../../../node_modules/postcss-loader/src/index.js?!./app/panels/styles/file-panel-styles.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "./app/panels/styles/terminal-styles.js":
/*!**********************************************!*\
  !*** ./app/panels/styles/terminal-styles.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .panel              {\n    position          : relative;\n    display           : flex;\n    flex-direction    : column;\n    font-size         : 12px;\n    min-height        : 3em;\n  }\n  .bar                {\n    display           : flex;\n    z-index           : 2;\n  }\n  .menu               {\n    position             : relative;\n    display              : flex;\n    align-items          : center;\n    width                : 100%;\n    max-height           : 35px;\n    min-height           : 35px;\n  }\n  .toggleTerminal              {\n    cursor            : pointer;\n  }\n  .toggleTerminal:hover              {\n    color             : var(--secondary);\n  }\n  .terminal_container   {\n    display             : flex;\n    flex-direction      : column;\n    height              : 100%;\n    overflow-y          : auto;\n    font-family         : monospace;\n    margin              : 0px;\n    background-repeat   : no-repeat;\n    background-position : center 15%;\n    background-size     : auto calc(75% -  1.7em);\n  }\n  .terminal    {\n    position          : relative;\n    display           : flex;\n    flex-direction    : column;\n    height            : 100%;\n  }\n  .journal            {\n    margin-top        : auto;\n    font-family       : monospace;\n  }\n  .block              {\n    word-break        : break-word;\n    white-space       : pre-wrap;\n    line-height       : 2ch;\n    padding           : 1ch;\n    margin-top        : 2ch;\n  }\n  .block > pre        {\n    max-height        : 200px;\n  }\n  .cli                {\n    line-height       : 1.7em;\n    font-family       : monospace;\n    padding           : .4em;\n    color             : var(--primary)\n    border-top        : solid 2px var(--secondary);\n  }\n  .prompt             {\n    margin-right      : 0.5em;\n    font-family       : monospace;\n    font-weight       : bold;\n    font-size         : 14px;\n  }\n  .input              {\n    word-break        : break-word;\n    outline           : none;\n    font-family       : monospace;\n  }\n  .search {\n    display           : flex;\n    align-items       : center;\n    width             : 330px;\n    padding-left      : 20px;\n    height            : 100%;\n    padding-top       : 1px;\n    padding-bottom    : 1px;\n  }\n  .filter                       {\n    height                      : 80%;\n    white-space                 : nowrap;\n    overflow                    : hidden;\n    text-overflow               : ellipsis;\n  }\n  .searchIcon                   {\n    height                      : 100%;\n    width                       : 25px;\n    border-top-left-radius      : 3px;\n    border-bottom-left-radius   : 3px;\n    display                     : flex;\n    align-items                 : center;\n    justify-content             : center;\n    margin-right                : 5px;\n  }\n  .listen         {\n    margin-right  : 30px;\n    min-width     : 40px;\n    height        : 13px;\n    display       : flex;\n    align-items   : center;\n  }\n  .listenLabel {\n    min-width: 50px;\n  }\n  .verticalLine {\n    border-left       : 1px solid var(--secondary)\n    height            : 65%;\n  }\n  .dragbarHorizontal  {\n    position          : absolute;\n    top               : 0;\n    height            : 0.5em;\n    right             : 0;\n    left              : 0;\n    cursor            : ns-resize;\n    z-index           : 999;\n  }\n  .listenOnNetwork {\n    min-height: auto;\n  }\n  .ghostbar           {\n    position          : absolute;\n    height            : 6px;\n    opacity           : 0.5;\n    cursor            : row-resize;\n    z-index           : 9999;\n    left              : 0;\n    right             : 0;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());
module.exports = css;

/***/ }),

/***/ "./app/panels/tab-proxy.js":
/*!*********************************!*\
  !*** ./app/panels/tab-proxy.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TabProxy = void 0;

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n      <div  style=\"display: -webkit-box; max-height: 32px\">\n        ", "\n        ", "\n      </div>\n    "]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"d-flex flex-row justify-content-center align-items-center\">\n        <span data-id=\"tabProxyZoomOut\" class=\"btn btn-sm px-1 fas fa-search-minus text-dark\" onclick=", "></span>\n        <span data-id=\"tabProxyZoomIn\" class=\"btn btn-sm px-1 fas fa-search-plus text-dark\" onclick=", "></span>\n      </div>\n    "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<remix-tabs class=", "></remix-tabs>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .remix_tabs div[title]{\n    display: flex;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var $ = __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js");

var EventEmitter = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

var globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

__webpack_require__(/*! remix-tabs */ "../../../node_modules/remix-tabs/dist/bundle.js");

var css = csjs(_templateObject());
var profile = {
  name: 'tabs',
  methods: ['focus'],
  kind: 'other'
}; // @todo(#650) Merge this with MainPanel into one plugin

var TabProxy = /*#__PURE__*/function (_Plugin) {
  _inherits(TabProxy, _Plugin);

  var _super = _createSuper(TabProxy);

  function TabProxy(fileManager, editor, appManager) {
    var _this;

    _classCallCheck(this, TabProxy);

    _this = _super.call(this, profile);
    _this.event = new EventEmitter();
    _this.fileManager = fileManager;
    _this.appManager = appManager;
    _this.editor = editor;
    _this.data = {};
    _this._view = {};
    _this._handlers = {};
    _this.loadedTabs = [];
    globalRegistry.get('themeModule').api.events.on('themeChanged', function (theme) {
      // update invert for all icons
      _this.updateImgStyles();
    });
    fileManager.events.on('fileRemoved', function (name) {
      _this.removeTab(name);
    });
    fileManager.events.on('fileClosed', function (name) {
      _this.removeTab(name);
    });
    fileManager.events.on('currentFileChanged', function (file) {
      if (_this._handlers[file]) {
        _this._view.filetabs.activateTab(file);

        return;
      }

      _this.addTab(file, '', function () {
        _this.fileManager.open(file);

        _this.event.emit('openFile', file);
      }, function () {
        _this.fileManager.closeFile(file);

        _this.event.emit('closeFile', file);
      });
    });
    fileManager.events.on('fileRenamed', function (oldName, newName, isFolder) {
      if (isFolder) return; // should change the tab title too

      _this.addTab(newName, '', function () {
        _this.fileManager.open(newName);

        _this.event.emit('openFile', newName);
      }, function () {
        _this.fileManager.closeFile(newName);

        _this.event.emit('closeFile', newName);
      });

      _this.removeTab(oldName);
    });
    appManager.event.on('activate', function (_ref) {
      var name = _ref.name,
          location = _ref.location,
          displayName = _ref.displayName,
          icon = _ref.icon;

      if (location === 'mainPanel') {
        _this.addTab(name, displayName, function () {
          return _this.event.emit('switchApp', name);
        }, function () {
          _this.event.emit('closeApp', name);

          _this.appManager.deactivatePlugin(name);
        }, icon);

        _this.switchTab(name);
      }
    });
    appManager.event.on('deactivate', function (profile) {
      _this.removeTab(profile.name);
    });
    return _this;
  }

  _createClass(TabProxy, [{
    key: "focus",
    value: function focus(name) {
      this.event.emit('switchApp', name);

      this._view.filetabs.activateTab(name);
    }
  }, {
    key: "updateImgStyles",
    value: function updateImgStyles() {
      var images = this._view.filetabs.getElementsByClassName('iconImage');

      var _iterator = _createForOfIteratorHelper(images),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var element = _step.value;
          globalRegistry.get('themeModule').api.fixInvert(element);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ;
    }
  }, {
    key: "switchTab",
    value: function switchTab(tabName) {
      if (this._handlers[tabName]) {
        this._handlers[tabName].switchTo();

        this._view.filetabs.activateTab(tabName);
      }
    }
  }, {
    key: "switchNextTab",
    value: function switchNextTab() {
      var active = this._view.filetabs.active;

      if (active && this._handlers[active]) {
        var handlers = Object.keys(this._handlers);
        var i = handlers.indexOf(active);

        if (i >= 0) {
          i = handlers[i + 1] ? i + 1 : 0;
          this.switchTab(handlers[i]);
        }
      }
    }
  }, {
    key: "switchPreviousTab",
    value: function switchPreviousTab() {
      var active = this._view.filetabs.active;

      if (active && this._handlers[active]) {
        var handlers = Object.keys(this._handlers);
        var i = handlers.indexOf(active);

        if (i >= 0) {
          i = handlers[i - 1] ? i - 1 : handlers.length - 1;
          this.switchTab(handlers[i]);
        }
      }
    }
  }, {
    key: "switchToActiveTab",
    value: function switchToActiveTab() {
      var active = this._view.filetabs.active;

      if (active && this._handlers[active]) {
        this.switchTab(active);
      }
    }
  }, {
    key: "addTab",
    value: function addTab(name, title, switchTo, close, icon) {
      var _this2 = this;

      if (this._handlers[name]) return;
      var slash = name.split('/');
      var tabPath = slash.reverse();
      var tempTitle = [];

      if (!title) {
        var _loop = function _loop(i) {
          tempTitle.push(tabPath[i]);
          var formatPath = [].concat(tempTitle).reverse();

          var index = _this2.loadedTabs.findIndex(function (_ref2) {
            var title = _ref2.title;
            return title === formatPath.join('/');
          });

          if (index === -1) {
            title = formatPath.join('/');
            var titleLength = formatPath.length;

            _this2.loadedTabs.push({
              name: name,
              title: title
            });

            formatPath.shift();

            if (formatPath.length > 0) {
              var duplicateTabName = _this2.loadedTabs.find(function (_ref3) {
                var title = _ref3.title;
                return title === formatPath.join('/');
              }).name;

              var duplicateTabPath = duplicateTabName.split('/');

              var duplicateTabFormatPath = _toConsumableArray(duplicateTabPath).reverse();

              var duplicateTabTitle = duplicateTabFormatPath.slice(0, titleLength).reverse().join('/');

              _this2.loadedTabs.push({
                name: duplicateTabName,
                title: duplicateTabTitle
              });

              _this2._view.filetabs.removeTab(duplicateTabName);

              _this2._view.filetabs.addTab({
                id: duplicateTabName,
                title: duplicateTabTitle,
                icon: icon,
                tooltip: duplicateTabName
              });
            }

            return "break";
          }
        };

        for (var i = 0; i < tabPath.length; i++) {
          var _ret = _loop(i);

          if (_ret === "break") break;
        }
      } else {
        this.loadedTabs.push({
          name: name,
          title: title
        });
      }

      this._view.filetabs.addTab({
        id: name.split(' ').join(''),
        title: title,
        icon: icon,
        tooltip: name
      });

      this.updateImgStyles();
      this._handlers[name] = {
        switchTo: switchTo,
        close: close
      };
    }
  }, {
    key: "removeTab",
    value: function removeTab(name) {
      this._view.filetabs.removeTab(name);

      delete this._handlers[name];
      this.switchToActiveTab();
      this.loadedTabs = this.loadedTabs.filter(function (tab) {
        return tab.name !== name;
      });
      this.updateImgStyles();
    }
  }, {
    key: "addHandler",
    value: function addHandler(type, fn) {
      this.handlers[type] = fn;
    }
  }, {
    key: "onZoomOut",
    value: function onZoomOut() {
      this.editor.editorFontSize(-1);
    }
  }, {
    key: "onZoomIn",
    value: function onZoomIn() {
      this.editor.editorFontSize(1);
    }
  }, {
    key: "renderTabsbar",
    value: function renderTabsbar() {
      var _this3 = this;

      this._view.filetabs = yo(_templateObject2(), css.remix_tabs);

      this._view.filetabs.addEventListener('tabClosed', function (event) {
        if (_this3._handlers[event.detail]) _this3._handlers[event.detail].close();

        _this3.event.emit('tabCountChanged', _this3._view.filetabs.tabs.length);
      });

      this._view.filetabs.addEventListener('tabActivated', function (event) {
        if (_this3._handlers[event.detail]) _this3._handlers[event.detail].switchTo();

        _this3.event.emit('tabCountChanged', _this3._view.filetabs.tabs.length);
      });

      this._view.filetabs.canAdd = false;
      var zoomBtns = yo(_templateObject3(), function () {
        return _this3.onZoomOut();
      }, function () {
        return _this3.onZoomIn();
      }); // @todo(#2492) remove style after the mainPanel layout fix.

      this._view.tabs = yo(_templateObject4(), zoomBtns, this._view.filetabs); // tabs

      var $filesEl = $(this._view.filetabs); // Switch tab

      var self = this;
      $filesEl.on('click', '.file:not(.active)', function (ev) {
        ev.preventDefault();
        var name = $(this).find('.name').text();

        self._handlers[name].switchTo();

        return false;
      }); // Remove current tab

      $filesEl.on('click', '.file .remove', function (ev) {
        ev.preventDefault();
        var name = $(this).parent().find('.name').text();

        self._handlers[name].close();

        return false;
      });
      return this._view.tabs;
    }
  }]);

  return TabProxy;
}(_engine.Plugin);

exports.TabProxy = TabProxy;

/***/ }),

/***/ "./app/panels/terminal.js":
/*!********************************!*\
  !*** ./app/panels/terminal.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _templateObject19() {
  var data = _taggedTemplateLiteral(["<div class=\"px-4 ", "\" data-id=\"block_", "\">", "</div>"]);

  _templateObject19 = function _templateObject19() {
    return data;
  };

  return data;
}

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject18() {
  var data = _taggedTemplateLiteral(["<pre>", "</pre>"]);

  _templateObject18 = function _templateObject18() {
    return data;
  };

  return data;
}

function _templateObject17() {
  var data = _taggedTemplateLiteral(["<span class=\"", "\" >", "</span>"]);

  _templateObject17 = function _templateObject17() {
    return data;
  };

  return data;
}

function _templateObject16() {
  var data = _taggedTemplateLiteral(["\n      <div><div> - Welcome to Remix ", " - </div><br>\n      <div>You can use this terminal to: </div>\n      <ul class=", ">\n        <li>Check transactions details and start debugging.</li>\n        <li>Execute JavaScript scripts:\n          <br />\n          <i> - Input a script directly in the command line interface </i>\n          <br />\n          <i> - Select a Javascript file in the file explorer and then run `remix.execute()` or `remix.exeCurrent()`  in the command line interface  </i>\n          <br />\n          <i> - Right click on a JavaScript file in the file explorer and then click `Run` </i>\n        </li>\n      </ul>\n      <div>The following libraries are accessible:</div>\n      <ul class=", ">\n        <li><a target=\"_blank\" href=\"https://web3js.readthedocs.io/en/1.0/\">web3 version 1.0.0</a></li>\n        <li><a target=\"_blank\" href=\"https://docs.ethers.io\">ethers.js</a> </li>\n        <li><a target=\"_blank\" href=\"https://www.npmjs.com/package/swarmgw\">swarmgw</a> </li>\n        <li>remix (run remix.help() for more info)</li>\n      </ul>\n      </div>\n    "], ["\n      <div><div> - Welcome to Remix ", " - </div><br>\n      <div>You can use this terminal to: </div>\n      <ul class=", ">\n        <li>Check transactions details and start debugging.</li>\n        <li>Execute JavaScript scripts:\n          <br />\n          <i> - Input a script directly in the command line interface </i>\n          <br />\n          <i> - Select a Javascript file in the file explorer and then run \\`remix.execute()\\` or \\`remix.exeCurrent()\\`  in the command line interface  </i>\n          <br />\n          <i> - Right click on a JavaScript file in the file explorer and then click \\`Run\\` </i>\n        </li>\n      </ul>\n      <div>The following libraries are accessible:</div>\n      <ul class=", ">\n        <li><a target=\"_blank\" href=\"https://web3js.readthedocs.io/en/1.0/\">web3 version 1.0.0</a></li>\n        <li><a target=\"_blank\" href=\"https://docs.ethers.io\">ethers.js</a> </li>\n        <li><a target=\"_blank\" href=\"https://www.npmjs.com/package/swarmgw\">swarmgw</a> </li>\n        <li>remix (run remix.help() for more info)</li>\n      </ul>\n      </div>\n    "]);

  _templateObject16 = function _templateObject16() {
    return data;
  };

  return data;
}

function _templateObject15() {
  var data = _taggedTemplateLiteral(["<div class=", ">", "", "</div>"]);

  _templateObject15 = function _templateObject15() {
    return data;
  };

  return data;
}

function _templateObject14() {
  var data = _taggedTemplateLiteral(["<div class=\"", " ", "\"></div>"]);

  _templateObject14 = function _templateObject14() {
    return data;
  };

  return data;
}

function _templateObject13() {
  var data = _taggedTemplateLiteral(["<div class=\"", " ", "\"></div>"]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteral(["\n      .anchor            {\n        position         : static;\n        border-top       : 2px dotted blue;\n        height           : 10px;\n      }\n      .overlay           {\n        position         : absolute;\n        width            : 100%;\n        display          : flex;\n        align-items      : center;\n        justify-content  : center;\n        bottom           : 0;\n        right            : 15px;\n        min-height       : 20px;\n      }\n      .text              {\n        z-index          : 2;\n        color            : black;\n        font-weight      : bold;\n        pointer-events   : none;\n      }\n      .background        {\n        z-index          : 1;\n        opacity          : 0.8;\n        background-color : #a6aeba;\n        cursor           : pointer;\n      }\n      .ul                 {\n        padding-left     : 20px;\n        padding-bottom   : 5px;\n      }\n    "]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _templateObject11() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", "\" style=\"height: 180px;\">\n        ", "\n        ", "\n      </div>\n    "]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", "\" tabindex=\"-1\" data-id=\"terminalContainer\" onscroll=", " onkeydown=", ">\n        ", "\n        <div data-id=\"terminalContainerDisplay\" style=\"\n          position: absolute;\n          height: 100%;\n          width: 100%;\n          opacity: 0.1;\n          z-index: -1;\n        \"></div>\n        <div class=", ">\n            ", "\n            ", "\n        </div>\n      </div>\n    "]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", "\">\n        ", "\n        <div class=\"", " border-top border-dark bg-light\" data-id=\"terminalToggleMenu\">\n          ", "\n          <div class=\"mx-2\" id=\"clearConsole\" data-id=\"terminalClearConsole\" onclick=", ">\n            <i class=\"fas fa-ban\" aria-hidden=\"true\" title=\"Clear console\"\n            onmouseenter=", " onmouseleave=", "></i>\n          </div>\n          ", "\n          <div class=", "></div>\n          <div class=\"pt-1 h-80 mx-3 align-items-center ", " custom-control custom-checkbox\">\n            <input\n              class=\"custom-control-input\"\n              id=\"listenNetworkCheck\"\n              onchange=", "\n              type=\"checkbox\"\n              title=\"If checked Remix will listen on all transactions mined in the current environment and not only transactions created by you\"\n            >\n            <label\n              class=\"pt-1 form-check-label custom-control-label text-nowrap\"\"\n              title=\"If checked Remix will listen on all transactions mined in the current environment and not only transactions created by you\"\n              for=\"listenNetworkCheck\"\n            >\n              listen on network\n            </label>\n          </div>\n          <div class=", ">\n            <i class=\"fas fa-search ", " bg-light\" aria-hidden=\"true\"></i>\n            ", "\n          </div>\n        </div>\n      </div>\n    "]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["<input\n      spellcheck=\"false\"\n      type=\"text\"\n      class=\"border ", " form-control\"\n      id=\"searchInput\"\n      onkeydown=", "\n      placeholder=\"Search with transaction hash or address\"\n      data-id=\"terminalInputSearch\">\n    </input>"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["<div class=\"mx-2\" title='Pending Transactions'>0</div>"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n      <div onmousedown=", " class=", "></div>"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n      <i onmouseenter=", " onmouseleave=", " onmousedown=", "\n      class=\"mx-2 ", " fas fa-angle-double-down\" data-id=\"terminalToggleIcon\"></i>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n      <div id=\"terminalCli\" data-id=\"terminalCli\" class=\"", "\" onclick=", ">\n        <span class=", ">", "</span>\n        ", "\n      </div>\n    "]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n      <span class=", " onload=", " onpaste=", " onkeydown=", "></span>\n    "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<div id=\"journal\" class=", " data-id=\"terminalJournal\"></div>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _templateObject() {
  var data = _taggedTemplateLiteral(["<div class=", " bg-secondary></div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var javascriptserialize = __webpack_require__(/*! javascript-serialize */ "../../../node_modules/javascript-serialize/javascriptserialize.js");

var jsbeautify = __webpack_require__(/*! js-beautify */ "../../../node_modules/js-beautify/js/index.js");

var type = __webpack_require__(/*! component-type */ "../../../node_modules/component-type/index.js");

var vm = __webpack_require__(/*! vm */ "../../../node_modules/node-libs-browser/node_modules/vm-browserify/index.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

var CommandInterpreterAPI = __webpack_require__(/*! ../../lib/cmdInterpreterAPI */ "./lib/cmdInterpreterAPI.js");

var AutoCompletePopup = __webpack_require__(/*! ../ui/auto-complete-popup */ "./app/ui/auto-complete-popup.js");

var TxLogger = __webpack_require__(/*! ../../app/ui/txLogger */ "./app/ui/txLogger.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = __webpack_require__(/*! ./styles/terminal-styles */ "./app/panels/styles/terminal-styles.js");

var KONSOLES = [];

function register(api) {
  KONSOLES.push(api);
}

var ghostbar = yo(_templateObject(), css.ghostbar);
var profile = {
  displayName: 'Terminal',
  name: 'terminal',
  methods: [],
  events: [],
  description: ' - ',
  version: packageJson.version
};

var Terminal = /*#__PURE__*/function (_Plugin) {
  _inherits(Terminal, _Plugin);

  var _super = _createSuper(Terminal);

  function Terminal(opts, api) {
    var _this;

    _classCallCheck(this, Terminal);

    _this = _super.call(this, profile);

    var self = _assertThisInitialized(_this);

    self.event = new EventManager();
    self.blockchain = opts.blockchain;
    self._api = api;
    self._opts = opts;
    self.data = {
      lineLength: opts.lineLength || 80,
      // ????
      session: [],
      activeFilters: {
        commands: {},
        input: ''
      },
      filterFns: {}
    };
    self._view = {
      el: null,
      bar: null,
      input: null,
      term: null,
      journal: null,
      cli: null
    };
    self._components = {};
    self._components.cmdInterpreter = new CommandInterpreterAPI(_assertThisInitialized(_this), null, self.blockchain);
    self._components.autoCompletePopup = new AutoCompletePopup(self._opts);

    self._components.autoCompletePopup.event.register('handleSelect', function (input) {
      var textList = self._view.input.innerText.split(' ');

      textList.pop();
      textList.push(input);
      self._view.input.innerText = textList;

      self._view.input.focus();

      self.putCursor2End(self._view.input);
    });

    self._commands = {};
    self.commands = {};
    self._JOURNAL = [];
    self._jobs = [];
    self._INDEX = {};
    self._INDEX.all = [];
    self._INDEX.allMain = [];
    self._INDEX.commands = {};
    self._INDEX.commandsMain = {};
    self.registerCommand('html', self._blocksRenderer('html'), {
      activate: true
    });
    self.registerCommand('log', self._blocksRenderer('log'), {
      activate: true
    });
    self.registerCommand('info', self._blocksRenderer('info'), {
      activate: true
    });
    self.registerCommand('warn', self._blocksRenderer('warn'), {
      activate: true
    });
    self.registerCommand('error', self._blocksRenderer('error'), {
      activate: true
    });
    self.registerCommand('script', function execute(args, scopedCommands, append) {
      var script = String(args[0]);

      self._shell(script, scopedCommands, function (error, output) {
        if (error) scopedCommands.error(error);else if (output) scopedCommands.log(output);
      });
    }, {
      activate: true
    });

    function basicFilter(value, query) {
      try {
        return value.indexOf(query) !== -1;
      } catch (e) {
        return false;
      }
    }

    self.registerFilter('log', basicFilter);
    self.registerFilter('info', basicFilter);
    self.registerFilter('warn', basicFilter);
    self.registerFilter('error', basicFilter);
    self.registerFilter('script', basicFilter);
    if (opts.shell) self._shell = opts.shell; // ???

    register(self);
    return _this;
  }

  _createClass(Terminal, [{
    key: "onActivation",
    value: function onActivation() {
      var _this2 = this;

      this.on('scriptRunner', 'log', function (msg) {
        _this2.commands.log.apply(_this2.commands, msg.data);
      });
      this.on('scriptRunner', 'info', function (msg) {
        _this2.commands.info.apply(_this2.commands, msg.data);
      });
      this.on('scriptRunner', 'warn', function (msg) {
        _this2.commands.warn.apply(_this2.commands, msg.data);
      });
      this.on('scriptRunner', 'error', function (msg) {
        _this2.commands.error.apply(_this2.commands, msg.data);
      });
    }
  }, {
    key: "onDeactivation",
    value: function onDeactivation() {
      this.off('scriptRunner', 'log');
      this.off('scriptRunner', 'info');
      this.off('scriptRunner', 'warn');
      this.off('scriptRunner', 'error');
    }
  }, {
    key: "logHtml",
    value: function logHtml(html) {
      var command = this.commands.html;
      if (typeof command === 'function') command(html);
    }
  }, {
    key: "focus",
    value: function focus() {
      if (this._view.input) this._view.input.focus();
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var self = this;
      if (self._view.el) return self._view.el;
      self._view.journal = yo(_templateObject2(), css.journal);
      self._view.input = yo(_templateObject3(), css.input, function () {
        _this3.focus();
      }, paste, change);

      self._view.input.setAttribute('spellcheck', 'false');

      self._view.input.setAttribute('contenteditable', 'true');

      self._view.input.setAttribute('id', 'terminalCliInput');

      self._view.input.setAttribute('data-id', 'terminalCliInput');

      self._view.input.innerText = '\n';
      self._view.cli = yo(_templateObject4(), css.cli, focusinput, css.prompt, '>', self._view.input);
      self._view.icon = yo(_templateObject5(), hover, hover, minimize, css.toggleTerminal);
      self._view.dragbar = yo(_templateObject6(), mousedown, css.dragbarHorizontal);
      self._view.pendingTxCount = yo(_templateObject7());
      self._view.inputSearch = yo(_templateObject8(), css.filter, filter);
      self._view.bar = yo(_templateObject9(), css.bar, self._view.dragbar, css.menu, self._view.icon, clear, hover, hover, self._view.pendingTxCount, css.verticalLine, css.listenOnNetwork, listenOnNetwork, css.search, css.searchIcon, self._view.inputSearch);
      self._view.term = yo(_templateObject10(), css.terminal_container, throttle(reattach, 10), focusinput, self._components.autoCompletePopup.render(), css.terminal, self._view.journal, self._view.cli);
      self._view.el = yo(_templateObject11(), css.panel, self._view.bar, self._view.term);
      setInterval( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return self.call('udapp', 'pendingTransactionsCount');

              case 3:
                self._view.pendingTxCount.innerHTML = _context.sent;
                _context.next = 8;
                break;

              case 6:
                _context.prev = 6;
                _context.t0 = _context["catch"](0);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 6]]);
      })), 1000);

      function listenOnNetwork(ev) {
        self.event.trigger('listenOnNetWork', [ev.currentTarget.checked]);
      }

      function paste(event) {
        var selection = window.getSelection();
        if (!selection.rangeCount) return false;
        event.preventDefault();
        event.stopPropagation();
        var clipboard = event.clipboardData || window.clipboardData;
        var text = clipboard.getData('text/plain');
        text = text.replace(/[^\x20-\xFF]/gi, ''); // remove non-UTF-8 characters

        var temp = document.createElement('div');
        temp.innerHTML = text;
        var textnode = document.createTextNode(temp.textContent);
        selection.getRangeAt(0).insertNode(textnode);
        selection.empty();
        self.scroll2bottom();
        placeCaretAtEnd(event.currentTarget);
      }

      function placeCaretAtEnd(el) {
        el.focus();
        var range = document.createRange();
        range.selectNodeContents(el);
        range.collapse(false);
        var sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }

      function throttle(fn, wait) {
        var time = Date.now();
        return function debounce() {
          if (time + wait - Date.now() < 0) {
            fn.apply(this, arguments);
            time = Date.now();
          }
        };
      }

      var css2 = csjs(_templateObject12());
      var text = yo(_templateObject13(), css2.overlay, css2.text);
      var background = yo(_templateObject14(), css2.overlay, css2.background);
      var placeholder = yo(_templateObject15(), css2.anchor, background, text);
      var inserted = false;
      window.addEventListener('resize', function (event) {
        self.event.trigger('resize', []);
        self.event.trigger('resize', []);
      });

      function focusinput(event) {
        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.key === 'Down' || event.key === 'ArrowDown' || event.key === 'Up' || event.key === 'ArrowUp' || event.key === 'Left' || event.key === 'ArrowLeft' || event.key === 'Right' || event.key === 'ArrowRight' || event.key === 'Esc' || event.key === 'Escape') return;
        refocus();
      }

      function refocus() {
        self._view.input.focus();

        reattach({
          currentTarget: self._view.term
        });
        delete self.scroll2bottom;
        self.scroll2bottom();
      }

      function reattach(event) {
        var el = event.currentTarget;
        var isBottomed = el.scrollHeight - el.scrollTop - el.clientHeight < 30;

        if (isBottomed) {
          if (inserted) {
            text.innerText = '';
            background.onclick = undefined;
            if (placeholder.parentElement) self._view.journal.removeChild(placeholder);
          }

          inserted = false;
          delete self.scroll2bottom;
        } else {
          if (!inserted) self._view.journal.appendChild(placeholder);
          inserted = true;
          check();

          if (!placeholder.nextElementSibling) {
            placeholder.style.display = 'none';
          } else {
            placeholder.style = '';
          }

          self.scroll2bottom = function () {
            var next = placeholder.nextElementSibling;

            if (next) {
              placeholder.style = '';
              check();
              var messages = 1;

              while (next = next.nextElementSibling) {
                messages += 1;
              }

              text.innerText = "".concat(messages, " new unread log entries");
            } else {
              placeholder.style.display = 'none';
            }
          };
        }
      }

      function check() {
        var pos1 = self._view.term.offsetHeight + self._view.term.scrollTop - self._view.el.offsetHeight * 0.15;
        var pos2 = placeholder.offsetTop;

        if (pos1 - pos2 > 0) {
          text.style.display = 'none';
          background.style.position = 'relative';
          background.style.opacity = 0.3;
          background.style.right = 0;
          background.style.borderBox = 'content-box';
          background.style.padding = '2px';
          background.style.height = self._view.journal.offsetHeight - (placeholder.offsetTop + placeholder.offsetHeight) + 'px';
          background.onclick = undefined;
          background.style.cursor = 'default';
          background.style.pointerEvents = 'none';
        } else {
          background.style = '';
          text.style = '';

          background.onclick = function (event) {
            placeholder.scrollIntoView();
            check();
          };
        }
      }

      function hover(event) {
        event.currentTarget.classList.toggle(css.hover);
      }

      function minimize(event) {
        event.preventDefault();
        event.stopPropagation();

        if (event.button === 0) {
          var classList = self._view.icon.classList;
          classList.toggle('fa-angle-double-down');
          classList.toggle('fa-angle-double-up');
          self.event.trigger('resize', []);
        }
      }

      var filtertimeout = null;

      function filter(event) {
        if (filtertimeout) {
          clearTimeout(filtertimeout);
        }

        filtertimeout = setTimeout(function () {
          self.updateJournal({
            type: 'search',
            value: self._view.inputSearch.value
          });
          self.scroll2bottom();
        }, 500);
      }

      function clear(event) {
        refocus();
        self._view.journal.innerHTML = '';
      } // ----------------- resizeable ui ---------------


      function mousedown(event) {
        event.preventDefault();

        if (event.which === 1) {
          moveGhostbar(event);
          document.body.appendChild(ghostbar);
          document.addEventListener('mousemove', moveGhostbar);
          document.addEventListener('mouseup', removeGhostbar);
          document.addEventListener('keydown', cancelGhostbar);
        }
      }

      function cancelGhostbar(event) {
        if (event.keyCode === 27) {
          document.body.removeChild(ghostbar);
          document.removeEventListener('mousemove', moveGhostbar);
          document.removeEventListener('mouseup', removeGhostbar);
          document.removeEventListener('keydown', cancelGhostbar);
        }
      }

      function moveGhostbar(event) {
        // @NOTE HORIZONTAL ghostbar
        ghostbar.style.top = self._api.getPosition(event) + 'px';
      }

      function removeGhostbar(event) {
        if (self._view.icon.classList.contains('fa-angle-double-up')) {
          self._view.icon.classList.toggle('fa-angle-double-down');

          self._view.icon.classList.toggle('fa-angle-double-up');
        }

        document.body.removeChild(ghostbar);
        document.removeEventListener('mousemove', moveGhostbar);
        document.removeEventListener('mouseup', removeGhostbar);
        document.removeEventListener('keydown', cancelGhostbar);
        self.event.trigger('resize', [self._api.getPosition(event)]);
      }

      self._cmdHistory = [];
      self._cmdIndex = -1;
      self._cmdTemp = '';
      var intro = yo(_templateObject16(), packageJson.version, css2.ul, css2.ul);

      self._shell('remix.help()', self.commands, function () {});

      self.commands.html(intro);
      self._components.txLogger = new TxLogger(this, self.blockchain);

      self._components.txLogger.event.register('debuggingRequested', /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(hash) {
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return self._opts.appManager.isActive('debugger');

                case 2:
                  if (_context2.sent) {
                    _context2.next = 5;
                    break;
                  }

                  _context2.next = 5;
                  return self._opts.appManager.activatePlugin('debugger');

                case 5:
                  _this3.call('menuicons', 'select', 'debugger');

                  _this3.call('debugger', 'debug', hash);

                case 7:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      }());

      return self._view.el;

      function wrapScript(script) {
        var isKnownScript = ['remix.', 'git'].some(function (prefix) {
          return script.trim().startsWith(prefix);
        });
        if (isKnownScript) return script;
        return "\n        try {\n          const ret = ".concat(script, ";\n          if (ret instanceof Promise) {\n            ret.then((result) => { console.log(result) }).catch((error) => { console.log(error) })\n          } else {\n            console.log(ret)\n          }   \n        } catch (e) {\n          console.log(e.message)\n        }\n        ");
      }

      function change(event) {
        if (self._components.autoCompletePopup.handleAutoComplete(event, self._view.input.innerText)) return;
        if (self._view.input.innerText.length === 0) self._view.input.innerText += '\n';

        if (event.which === 13) {
          if (event.ctrlKey) {
            // <ctrl+enter>
            self._view.input.innerText += '\n';
            self.putCursor2End(self._view.input);
            self.scroll2bottom();

            self._components.autoCompletePopup.removeAutoComplete();
          } else {
            // <enter>
            self._cmdIndex = -1;
            self._cmdTemp = '';
            event.preventDefault();

            var script = self._view.input.innerText.trim();

            self._view.input.innerText = '\n';

            if (script.length) {
              self._cmdHistory.unshift(script);

              self.commands.script(wrapScript(script));
            }

            self._components.autoCompletePopup.removeAutoComplete();
          }
        } else if (event.which === 38) {
          // <arrowUp>
          var len = self._cmdHistory.length;
          if (len === 0) return event.preventDefault();

          if (self._cmdHistory.length - 1 > self._cmdIndex) {
            self._cmdIndex++;
          }

          self._view.input.innerText = self._cmdHistory[self._cmdIndex];
          self.putCursor2End(self._view.input);
          self.scroll2bottom();
        } else if (event.which === 40) {
          // <arrowDown>
          if (self._cmdIndex > -1) {
            self._cmdIndex--;
          }

          self._view.input.innerText = self._cmdIndex >= 0 ? self._cmdHistory[self._cmdIndex] : self._cmdTemp;
          self.putCursor2End(self._view.input);
          self.scroll2bottom();
        } else {
          self._cmdTemp = self._view.input.innerText;
        }
      }
    }
  }, {
    key: "putCursor2End",
    value: function putCursor2End(editable) {
      var range = document.createRange();
      range.selectNode(editable);
      var child = editable;
      var chars;

      while (child) {
        if (child.lastChild) child = child.lastChild;else break;

        if (child.nodeType === Node.TEXT_NODE) {
          chars = child.textContent.length;
        } else {
          chars = child.innerHTML.length;
        }
      }

      range.setEnd(child, chars);
      var toStart = true;
      var toEnd = !toStart;
      range.collapse(toEnd);
      var sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
      editable.focus();
    }
  }, {
    key: "updateJournal",
    value: function updateJournal(filterEvent) {
      var self = this;
      var commands = self.data.activeFilters.commands;
      var value = filterEvent.value;

      if (filterEvent.type === 'select') {
        commands[value] = true;
        if (!self._INDEX.commandsMain[value]) return;

        self._INDEX.commandsMain[value].forEach(function (item) {
          item.root.steps.forEach(function (item) {
            self._JOURNAL[item.gidx] = item;
          });
          self._JOURNAL[item.gidx] = item;
        });
      } else if (filterEvent.type === 'deselect') {
        commands[value] = false;
        if (!self._INDEX.commandsMain[value]) return;

        self._INDEX.commandsMain[value].forEach(function (item) {
          item.root.steps.forEach(function (item) {
            self._JOURNAL[item.gidx].hide = true;
          });
          self._JOURNAL[item.gidx].hide = true;
        });
      } else if (filterEvent.type === 'search') {
        if (value !== self.data.activeFilters.input) {
          var query = self.data.activeFilters.input = value;
          var items = self._JOURNAL;

          for (var gidx = 0, len = items.length; gidx < len; gidx++) {
            var item = items[gidx];

            if (item && self.data.filterFns[item.cmd]) {
              var show = query.length ? self.data.filterFns[item.cmd](item.args, query) : true;
              item.hide = !show;
            }
          }
        }
      }

      var df = document.createDocumentFragment();

      self._JOURNAL.forEach(function (item) {
        if (item && item.el && !item.hide) df.appendChild(item.el);
      });

      self._view.journal.innerHTML = '';
      requestAnimationFrame(function updateDOM() {
        self._view.journal.appendChild(df);
      });
    }
  }, {
    key: "_appendItem",
    value: function _appendItem(item) {
      var self = this;
      var el = item.el,
          gidx = item.gidx;
      self._JOURNAL[gidx] = item;

      if (!self._jobs.length) {
        requestAnimationFrame(function updateTerminal() {
          self._jobs.forEach(function (el) {
            return self._view.journal.appendChild(el);
          });

          self.scroll2bottom();
          self._jobs = [];
        });
      }

      if (self.data.activeFilters.commands[item.cmd]) self._jobs.push(el);
    }
  }, {
    key: "scroll2bottom",
    value: function scroll2bottom() {
      var self = this;
      setTimeout(function () {
        self._view.term.scrollTop = self._view.term.scrollHeight;
      }, 0);
    }
  }, {
    key: "_blocksRenderer",
    value: function _blocksRenderer(mode) {
      if (mode === 'html') {
        return function logger(args, scopedCommands, append) {
          if (args.length) append(args[0]);
        };
      }

      mode = {
        log: 'text-info',
        info: 'text-info',
        warn: 'text-warning',
        error: 'text-danger'
      }[mode]; // defaults

      if (mode) {
        var filterUndefined = function filterUndefined(el) {
          return el !== undefined && el !== null;
        };

        return function logger(args, scopedCommands, append) {
          var types = args.filter(filterUndefined).map(type);
          var values = javascriptserialize.apply(null, args.filter(filterUndefined)).map(function (val, idx) {
            if (typeof args[idx] === 'string') val = args[idx];
            if (types[idx] === 'element') val = jsbeautify.html(val);
            return val;
          });

          if (values.length) {
            append(yo(_templateObject17(), mode, values));
          }
        };
      } else {
        throw new Error('mode is not supported');
      }
    }
  }, {
    key: "_scopeCommands",
    value: function _scopeCommands(append) {
      var self = this;
      var scopedCommands = {};
      Object.keys(self.commands).forEach(function makeScopedCommand(cmd) {
        var command = self._commands[cmd];

        scopedCommands[cmd] = function _command() {
          var args = Array.prototype.slice.call(arguments);
          command(args, scopedCommands, function (el) {
            return append(cmd, args, blockify(el));
          });
        };
      });
      return scopedCommands;
    }
  }, {
    key: "registerFilter",
    value: function registerFilter(commandName, filterFn) {
      this.data.filterFns[commandName] = filterFn;
    }
  }, {
    key: "registerCommand",
    value: function registerCommand(name, command, opts) {
      var self = this;
      name = String(name);
      if (self._commands[name]) throw new Error("command \"".concat(name, "\" exists already"));
      if (typeof command !== 'function') throw new Error("invalid command: ".concat(command));
      self._commands[name] = command;
      self._INDEX.commands[name] = [];
      self._INDEX.commandsMain[name] = [];

      self.commands[name] = function _command() {
        var args = Array.prototype.slice.call(arguments);
        var steps = [];
        var root = {
          steps: steps,
          cmd: name
        };
        var ITEM = {
          root: root,
          cmd: name
        };
        root.gidx = self._INDEX.allMain.push(ITEM) - 1;
        root.idx = self._INDEX.commandsMain[name].push(ITEM) - 1;

        function append(cmd, params, el) {
          var item;

          if (cmd) {
            // subcommand
            item = {
              el: el,
              cmd: cmd,
              root: root
            };
          } else {
            // command
            item = ITEM;
            item.el = el;
            cmd = name;
          }

          item.gidx = self._INDEX.all.push(item) - 1;
          item.idx = self._INDEX.commands[cmd].push(item) - 1;
          item.step = steps.push(item) - 1;
          item.args = params;

          self._appendItem(item);
        }

        var scopedCommands = self._scopeCommands(append);

        command(args, scopedCommands, function (el) {
          return append(null, args, blockify(el));
        });
      };

      var help = typeof command.help === 'string' ? command.help : ['// no help available for:', "terminal.commands.".concat(name, "(...)")].join('\n');

      self.commands[name].toString = function (_) {
        return help;
      };

      self.commands[name].help = help;
      self.data.activeFilters.commands[name] = opts && opts.activate;

      if (opts.filterFn) {
        self.registerFilter(name, opts.filterFn);
      }

      return self.commands[name];
    }
  }, {
    key: "_shell",
    value: function () {
      var _shell2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(script, scopedCommands, done) {
        var self, context, cmds, result, _result;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(script.indexOf('remix:') === 0)) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return", done(null, 'This type of command has been deprecated and is not functionning anymore. Please run remix.help() to list available commands.'));

              case 2:
                self = this;

                if (!(script.indexOf('remix.') === 0)) {
                  _context3.next = 14;
                  break;
                }

                // we keep the old feature. This will basically only be called when the command is querying the "remix" object.
                // for all the other case, we use the Code Executor plugin
                context = domTerminalFeatures(self, scopedCommands, self.blockchain);
                _context3.prev = 5;
                cmds = vm.createContext(context);
                result = vm.runInContext(script, cmds);
                return _context3.abrupt("return", done(null, result));

              case 11:
                _context3.prev = 11;
                _context3.t0 = _context3["catch"](5);
                return _context3.abrupt("return", done(_context3.t0.message));

              case 14:
                _context3.prev = 14;

                if (!script.trim().startsWith('git')) {
                  _context3.next = 21;
                  break;
                }

                _context3.next = 18;
                return this.call('git', 'execute', script);

              case 18:
                _result = _context3.sent;
                _context3.next = 24;
                break;

              case 21:
                _context3.next = 23;
                return this.call('scriptRunner', 'execute', script);

              case 23:
                _result = _context3.sent;

              case 24:
                if (_result) self.commands.html(yo(_templateObject18(), _result));
                done();
                _context3.next = 31;
                break;

              case 28:
                _context3.prev = 28;
                _context3.t1 = _context3["catch"](14);
                done(_context3.t1.message || _context3.t1);

              case 31:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[5, 11], [14, 28]]);
      }));

      function _shell(_x2, _x3, _x4) {
        return _shell2.apply(this, arguments);
      }

      return _shell;
    }()
  }]);

  return Terminal;
}(_engine.Plugin);

function domTerminalFeatures(self, scopedCommands, blockchain) {
  return {
    remix: self._components.cmdInterpreter
  };
}

function blockify(el) {
  return yo(_templateObject19(), css.block, el.getAttribute ? el.getAttribute('id') : '', el);
}

module.exports = Terminal;

/***/ }),

/***/ "./app/tabs/analysis-tab.js":
/*!**********************************!*\
  !*** ./app/tabs/analysis-tab.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engineWeb = __webpack_require__(/*! @remixproject/engine-web */ "../../../node_modules/@remixproject/engine-web/index.js");

var _events = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject() {
  var data = _taggedTemplateLiteral(["<div class=\"px-3 pb-1\" id=\"staticanalysisView\">", "</div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var StaticAnalysis = __webpack_require__(/*! ./staticanalysis/staticAnalysisView */ "./app/tabs/staticanalysis/staticAnalysisView.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

var profile = {
  name: 'solidityStaticAnalysis',
  displayName: 'Solidity static analysis',
  methods: [],
  events: [],
  icon: 'assets/img/staticAnalysis.webp',
  description: 'Checks the contract code for security vulnerabilities and bad practices.',
  kind: 'analysis',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/static_analysis.html',
  version: packageJson.version
};

var AnalysisTab = /*#__PURE__*/function (_ViewPlugin) {
  _inherits(AnalysisTab, _ViewPlugin);

  var _super = _createSuper(AnalysisTab);

  function AnalysisTab(registry) {
    var _this;

    _classCallCheck(this, AnalysisTab);

    _this = _super.call(this, profile);
    _this.event = new EventManager();
    _this.events = new _events.EventEmitter();
    _this.registry = registry;
    return _this;
  }

  _createClass(AnalysisTab, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      if (!this.staticanalysis) this.staticanalysis = new StaticAnalysis(this.registry, this);
      this.staticanalysis.event.register('staticAnaysisWarning', function (count) {
        if (count > 0) {
          _this2.emit('statusChanged', {
            key: count,
            title: "".concat(count, " warning").concat(count === 1 ? '' : 's'),
            type: 'warning'
          });
        } else if (count === 0) {
          _this2.emit('statusChanged', {
            key: 'succeed',
            title: 'no warning',
            type: 'success'
          });
        } else {
          // count ==-1 no compilation result
          _this2.emit('statusChanged', {
            key: 'none'
          });
        }
      });
      this.registry.put({
        api: this.staticanalysis,
        name: 'staticanalysis'
      });
      return yo(_templateObject(), this.staticanalysis.render());
    }
  }]);

  return AnalysisTab;
}(_engineWeb.ViewPlugin);

module.exports = AnalysisTab;

/***/ }),

/***/ "./app/tabs/compile-tab.js":
/*!*********************************!*\
  !*** ./app/tabs/compile-tab.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engineWeb = __webpack_require__(/*! @remixproject/engine-web */ "../../../node_modules/@remixproject/engine-web/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

var _publishToStorage = _interopRequireDefault(__webpack_require__(/*! ../../publishToStorage */ "./publishToStorage.js"));

var _compilerHelpers = __webpack_require__(/*! ../compiler/compiler-helpers */ "./app/compiler/compiler-helpers.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _templateObject22() {
  var data = _taggedTemplateLiteral(["\n      <div id=\"compileTabView\">\n        ", "\n        ", "\n        ", "\n      </div>"]);

  _templateObject22 = function _templateObject22() {
    return data;
  };

  return data;
}

function _templateObject21() {
  var data = _taggedTemplateLiteral(["<div class=\"", " p-4\" data-id=\"compiledErrors\" ></div>"]);

  _templateObject21 = function _templateObject21() {
    return data;
  };

  return data;
}

function _templateObject20() {
  var data = _taggedTemplateLiteral(["<pre class=\"", "\">", "</pre>"]);

  _templateObject20 = function _templateObject20() {
    return data;
  };

  return data;
}

function _templateObject19() {
  var data = _taggedTemplateLiteral(["<div>", "</div>"]);

  _templateObject19 = function _templateObject19() {
    return data;
  };

  return data;
}

function _templateObject18() {
  var data = _taggedTemplateLiteral(["<div> - </div>"]);

  _templateObject18 = function _templateObject18() {
    return data;
  };

  return data;
}

function _templateObject17() {
  var data = _taggedTemplateLiteral(["<div>Unable to display \"", "\": ", "</div>"]);

  _templateObject17 = function _templateObject17() {
    return data;
  };

  return data;
}

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject16() {
  var data = _taggedTemplateLiteral(["\n          <div>\n            ", "\n          </div>"]);

  _templateObject16 = function _templateObject16() {
    return data;
  };

  return data;
}

function _templateObject15() {
  var data = _taggedTemplateLiteral(["<pre>", "</pre>"]);

  _templateObject15 = function _templateObject15() {
    return data;
  };

  return data;
}

function _templateObject14() {
  var data = _taggedTemplateLiteral(["<div class=", ">\n        <div class=\"", "\">", " ", " ", "</div>\n        ", "\n      </div>"]);

  _templateObject14 = function _templateObject14() {
    return data;
  };

  return data;
}

function _templateObject13() {
  var data = _taggedTemplateLiteral(["<span class=\"", "\"><i title=\"", "\" class=\"fas fa-question-circle\" aria-hidden=\"true\"></i></span>"]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteral(["<span class=\"", "\">", "</span>"]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function _templateObject11() {
  var data = _taggedTemplateLiteral(["<div class=\"", "\"></div>"]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["<div></div>"]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["<div></div>"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["<section class=\"", " clearfix\"><article class=\"px-2 mt-2 pb-0 d-flex\">\n      <span class=\"mt-2 mx-3 w-100 alert alert-warning\" role=\"alert\">No Contract Compiled Yet</span>\n    </article></section>"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["<section class=\"", " pt-3\">\n      <!-- Select Compiler Version -->\n      <div class=\"mb-3\">\n        <label class=\"", " form-check-label\" for=\"compiledContracts\">Contract</label>\n        ", "\n      </div>\n      <article class=\"mt-2 pb-0\">\n        <button id=\"publishOnSwarm\" class=\"btn btn-secondary btn-block\" title=\"Publish on Swarm\" onclick=\"", "\">\n          <span>Publish on Swarm</span>\n          <img id=\"swarmLogo\" class=\"", " ml-2\" src=\"assets/img/swarm.webp\">\n        </button>\n        <button id=\"publishOnIpfs\" class=\"btn btn-secondary btn-block\" title=\"Publish on Ipfs\" onclick=\"", "\">\n        <span>Publish on Ipfs</span>\n        <img id=\"ipfsLogo\" class=\"", " ml-2\" src=\"assets/img/ipfs.webp\">\n      </button>\n        <button data-id=\"compilation-details\" class=\"btn btn-secondary btn-block\" title=\"Display Contract Details\" onclick=\"", "\">\n          Compilation Details\n        </button>\n        <!-- Copy to Clipboard -->\n        <div class=\"", "\">\n          <div class=\"input-group\">\n            <div class=\"btn-group\" role=\"group\" aria-label=\"Copy to Clipboard\">\n              <button class=\"btn ", "\" title=\"Copy ABI to clipboard\" onclick=\"", "\">\n                <i class=\"", " far fa-copy\" aria-hidden=\"true\"></i>\n                <span>ABI</span>\n              </button>\n              <button class=\"btn ", "\" title=\"Copy Bytecode to clipboard\" onclick=\"", "\">\n                <i class=\"", " far fa-copy\" aria-hidden=\"true\"></i>\n                <span>Bytecode</span>\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    </section>"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["<option value=\"", "\">", " (", ")</option>"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n      <select\n        onchange=\"", "\"\n        data-id=\"compiledContracts\" id=\"compiledContracts\" class=\"custom-select\"\n      >\n        ", "\n      </select>\n    "]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<div><b>", "</b> is updating the <b>Solidity compiler configuration</b>.<pre class=\"text-left\">", "</pre></div>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<div><b>", "</b> is requiring to compile <b>", "</b></div>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n            <div><i class=\"fas fa-exclamation-circle ", "\" aria-hidden=\"true\"></i>\n            The compiler returned with the following internal error: <br> <b>", ".<br>\n            The compiler might be in a non-sane state, please be careful and do not use further compilation data to deploy to mainnet.\n            It is heavily recommended to use another browser not affected by this issue (Firefox is known to not be affected).</b><br>\n            Please join <a href=\"https://gitter.im/ethereum/remix\" target=\"blank\" >remix gitter channel</a> for more information.</div>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["<span data-id=\"compilationFinishedWith_", "\"></span>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var EventEmitter = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

var $ = __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var copy = __webpack_require__(/*! copy-text-to-clipboard */ "../../../node_modules/copy-text-to-clipboard/index.js");

var QueryParams = __webpack_require__(/*! ../../lib/query-params */ "./lib/query-params.js");

var TreeView = __webpack_require__(/*! ../ui/TreeView */ "./app/ui/TreeView.js");

var modalDialog = __webpack_require__(/*! ../ui/modaldialog */ "./app/ui/modaldialog.js");

var copyToClipboard = __webpack_require__(/*! ../ui/copy-to-clipboard */ "./app/ui/copy-to-clipboard.js");

var modalDialogCustom = __webpack_require__(/*! ../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var parseContracts = __webpack_require__(/*! ./compileTab/contractParser */ "./app/tabs/compileTab/contractParser.js");

var addTooltip = __webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js");

var globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var css = __webpack_require__(/*! ./styles/compile-tab-styles */ "./app/tabs/styles/compile-tab-styles.js");

var CompileTabLogic = __webpack_require__(/*! ./compileTab/compileTab.js */ "./app/tabs/compileTab/compileTab.js");

var CompilerContainer = __webpack_require__(/*! ./compileTab/compilerContainer.js */ "./app/tabs/compileTab/compilerContainer.js");

var profile = {
  name: 'solidity',
  displayName: 'Solidity compiler',
  icon: 'assets/img/solidity.webp',
  description: 'Compile solidity contracts',
  kind: 'compiler',
  permission: true,
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/solidity_editor.html',
  version: packageJson.version,
  methods: ['getCompilationResult', 'compile', 'compileWithParameters', 'setCompilerConfig']
}; // EditorApi:
// - events: ['compilationFinished'],
// - methods: ['getCompilationResult']

var CompileTab = /*#__PURE__*/function (_ViewPlugin) {
  _inherits(CompileTab, _ViewPlugin);

  var _super = _createSuper(CompileTab);

  function CompileTab(editor, config, renderer, fileProvider, fileManager, contentImport) {
    var _this;

    _classCallCheck(this, CompileTab);

    _this = _super.call(this, profile);
    _this.events = new EventEmitter();
    _this._view = {
      el: null,
      warnCompilationSlow: null,
      errorContainer: null,
      contractEl: null
    };
    _this.contentImport = contentImport;
    _this.queryParams = new QueryParams();
    _this.fileProvider = fileProvider; // dependencies

    _this.editor = editor;
    _this.config = config;
    _this.renderer = renderer;
    _this.fileManager = fileManager;
    _this.data = {
      contractsDetails: {},
      eventHandlers: {},
      loading: false
    };
    return _this;
  }

  _createClass(CompileTab, [{
    key: "onActivationInternal",
    value: function onActivationInternal() {
      this.compileTabLogic = new CompileTabLogic(this.queryParams, this.fileManager, this.editor, this.config, this.fileProvider, this.contentImport);
      this.compiler = this.compileTabLogic.compiler;
      this.compileTabLogic.init();
      this.compilerContainer = new CompilerContainer(this.compileTabLogic, this.editor, this.config, this.queryParams);
    }
    /************
     * EVENTS
     */

  }, {
    key: "listenToEvents",
    value: function listenToEvents() {
      var _this2 = this;

      this.data.eventHandlers.onContentChanged = function () {
        _this2.emit('statusChanged', {
          key: 'edited',
          title: 'the content has changed, needs recompilation',
          type: 'info'
        });
      };

      this.editor.event.register('contentChanged', this.data.eventHandlers.onContentChanged);

      this.data.eventHandlers.onLoadingCompiler = function () {
        _this2.data.loading = true;

        _this2.emit('statusChanged', {
          key: 'loading',
          title: 'loading compiler...',
          type: 'info'
        });
      };

      this.compiler.event.register('loadingCompiler', this.data.eventHandlers.onLoadingCompiler);

      this.data.eventHandlers.onCompilerLoaded = function () {
        _this2.data.loading = false;

        _this2.emit('statusChanged', {
          key: 'none'
        });
      };

      this.compiler.event.register('compilerLoaded', this.data.eventHandlers.onCompilerLoaded);

      this.data.eventHandlers.onStartingCompilation = function () {
        if (_this2._view.errorContainer) {
          _this2._view.errorContainer.innerHTML = '';
        }

        _this2.emit('statusChanged', {
          key: 'loading',
          title: 'compiling...',
          type: 'info'
        });
      };

      this.compileTabLogic.event.on('startingCompilation', this.data.eventHandlers.onStartingCompilation);

      this.data.eventHandlers.onCurrentFileChanged = function (name) {
        _this2.compilerContainer.currentFile = name;
      };

      this.fileManager.events.on('currentFileChanged', this.data.eventHandlers.onCurrentFileChanged);

      this.data.eventHandlers.onNoFileSelected = function () {
        _this2.compilerContainer.currentFile = '';
      };

      this.fileManager.events.on('noFileSelected', this.data.eventHandlers.onNoFileSelected);

      this.data.eventHandlers.onCompilationFinished = function (success, data, source) {
        _this2._view.errorContainer.appendChild(yo(_templateObject(), _this2.getCurrentVersion()));

        if (success) {
          // forwarding the event to the appManager infra
          _this2.emit('compilationFinished', source.target, source, 'soljson', data);

          if (data.errors && data.errors.length > 0) {
            _this2.emit('statusChanged', {
              key: data.errors.length,
              title: "compilation finished successful with warning".concat(data.errors.length > 1 ? 's' : ''),
              type: 'warning'
            });
          } else _this2.emit('statusChanged', {
            key: 'succeed',
            title: 'compilation successful',
            type: 'success'
          }); // Store the contracts


          _this2.data.contractsDetails = {};

          _this2.compiler.visitContracts(function (contract) {
            _this2.data.contractsDetails[contract.name] = parseContracts(contract.name, contract.object, _this2.compiler.getSource(contract.file));
          });
        } else {
          var count = data.errors ? data.errors.filter(function (error) {
            return error.severity === 'error';
          }).length : 0 + data.error ? 1 : 0;

          _this2.emit('statusChanged', {
            key: count,
            title: "compilation failed with ".concat(count, " error").concat(count.length > 1 ? 's' : ''),
            type: 'error'
          });
        } // Update contract Selection


        var contractMap = {};
        if (success) _this2.compiler.visitContracts(function (contract) {
          contractMap[contract.name] = contract;
        });

        var contractSelection = _this2.contractSelection(contractMap);

        yo.update(_this2._view.contractSelection, contractSelection);

        if (data.error) {
          _this2.renderer.error(data.error.formattedMessage || data.error, _this2._view.errorContainer, {
            type: data.error.severity || 'error',
            errorType: data.error.type
          });

          if (data.error.mode === 'panic') {
            return modalDialogCustom.alert(yo(_templateObject2(), css.panicError, data.error.formattedMessage));
          }
        }

        if (data.errors && data.errors.length) {
          data.errors.forEach(function (err) {
            if (_this2.config.get('hideWarnings')) {
              if (err.severity !== 'warning') {
                _this2.renderer.error(err.formattedMessage, _this2._view.errorContainer, {
                  type: err.severity,
                  errorType: err.type
                });
              }
            } else {
              _this2.renderer.error(err.formattedMessage, _this2._view.errorContainer, {
                type: err.severity,
                errorType: err.type
              });
            }
          });
        }
      };

      this.compiler.event.register('compilationFinished', this.data.eventHandlers.onCompilationFinished);

      this.data.eventHandlers.onThemeChanged = function (theme) {
        var invert = theme.quality === 'dark' ? 1 : 0;
        var img = document.getElementById('swarmLogo');

        if (img) {
          img.style.filter = "invert(".concat(invert, ")");
        }
      };

      globalRegistry.get('themeModule').api.events.on('themeChanged', this.data.eventHandlers.onThemeChanged); // Run the compiler instead of trying to save the website

      $(window).keydown(function (e) {
        // ctrl+s or command+s
        if ((e.metaKey || e.ctrlKey) && e.keyCode === 83) {
          e.preventDefault();

          _this2.compileTabLogic.runCompiler();
        }
      });
    }
  }, {
    key: "getCompilationResult",
    value: function getCompilationResult() {
      return this.compileTabLogic.compiler.state.lastCompilationResult;
    }
    /**
     * compile using @arg fileName.
     * The module UI will be updated accordingly to the new compilation result.
     * This function is used by remix-plugin compiler API.
     * @param {string} fileName to compile
     */

  }, {
    key: "compile",
    value: function compile(fileName) {
      addTooltip(yo(_templateObject3(), this.currentRequest.from, fileName));
      return this.compileTabLogic.compileFile(fileName);
    }
    /**
     * compile using @arg compilationTargets and @arg settings
     * The module UI will *not* be updated, the compilation result is returned
     * This function is used by remix-plugin compiler API.
     * @param {object} map of source files.
     * @param {object} settings {evmVersion, optimize, runs, version, language}
     */

  }, {
    key: "compileWithParameters",
    value: function () {
      var _compileWithParameters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(compilationTargets, settings) {
        var res;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return (0, _compilerHelpers.compile)(compilationTargets, settings);

              case 2:
                res = _context.sent;
                return _context.abrupt("return", res);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function compileWithParameters(_x, _x2) {
        return _compileWithParameters.apply(this, arguments);
      }

      return compileWithParameters;
    }() // This function is used for passing the compiler remix-tests

  }, {
    key: "getCurrentVersion",
    value: function getCurrentVersion() {
      return this.compilerContainer.data.selectedVersion;
    } // This function is used for passing the compiler configuration to 'remix-tests'

  }, {
    key: "getCurrentCompilerConfig",
    value: function getCurrentCompilerConfig() {
      return {
        currentVersion: this.compilerContainer.data.selectedVersion,
        evmVersion: this.compileTabLogic.evmVersion,
        optimize: this.compileTabLogic.optimize,
        runs: this.compileTabLogic.runs
      };
    }
    /**
     * set the compiler configuration
     * This function is used by remix-plugin compiler API.
     * @param {object} settings {evmVersion, optimize, runs, version, language}
     */

  }, {
    key: "setCompilerConfig",
    value: function setCompilerConfig(settings) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        addTooltip(yo(_templateObject4(), _this3.currentRequest.from, JSON.stringify(settings, null, '\t')));

        _this3.compilerContainer.setConfiguration(settings); // @todo(#2875) should use loading compiler return value to check whether the compiler is loaded instead of "setInterval"


        var timeout = 0;
        var id = setInterval(function () {
          timeout++;
          console.log(_this3.data.loading);

          if (!_this3.data.loading || timeout > 10) {
            resolve();
            clearInterval(id);
          }
        }, 200);
      });
    }
    /*********
     * SUB-COMPONENTS
     */

    /**
     * Section to select the compiled contract
     * @param {string[]} contractList Names of the compiled contracts
     */

  }, {
    key: "contractSelection",
    value: function contractSelection(contractMap) {
      var _this4 = this;

      // Return the file name of a path: ex "browser/ballot.sol" -> "ballot.sol"
      var getFileName = function getFileName(path) {
        var part = path.split('/');
        return part[part.length - 1];
      };

      var contractList = contractMap ? Object.keys(contractMap).map(function (key) {
        return {
          name: key,
          file: getFileName(contractMap[key].file)
        };
      }) : [];
      var selectEl = yo(_templateObject5(), function (e) {
        return _this4.selectContract(e.target.value);
      }, contractList.map(function (_ref) {
        var name = _ref.name,
            file = _ref.file;
        return yo(_templateObject6(), name, name, file);
      })); // define swarm logo

      var result = contractList.length ? yo(_templateObject7(), css.compilerSection, css.compilerLabel, selectEl, function () {
        (0, _publishToStorage["default"])('swarm', _this4.fileProvider, _this4.fileManager, _this4.data.contractsDetails[_this4.selectedContract]);
      }, css.storageLogo, function () {
        (0, _publishToStorage["default"])('ipfs', _this4.fileProvider, _this4.fileManager, _this4.data.contractsDetails[_this4.selectedContract]);
      }, css.storageLogo, function () {
        _this4.details();
      }, css.contractHelperButtons, css.copyButton, function () {
        _this4.copyABI();
      }, css.copyIcon, css.copyButton, function () {
        _this4.copyBytecode();
      }, css.copyIcon) : yo(_templateObject8(), css.container);

      if (contractList.length) {
        this.selectedContract = selectEl.value;
      } else {
        delete this.selectedContract;
      }

      return result;
    } // TODO : Add success alert when compilation succeed

  }, {
    key: "contractCompiledSuccess",
    value: function contractCompiledSuccess() {
      return yo(_templateObject9());
    } // TODO : Add error alert when compilation failed

  }, {
    key: "contractCompiledError",
    value: function contractCompiledError() {
      return yo(_templateObject10());
    }
    /************
     * METHODS
     */

  }, {
    key: "selectContract",
    value: function selectContract(contractName) {
      this.selectedContract = contractName;
    }
  }, {
    key: "details",
    value: function details() {
      var _this5 = this;

      var help = {
        Assembly: 'Assembly opcodes describing the contract including corresponding solidity source code',
        Opcodes: 'Assembly opcodes describing the contract',
        'Runtime Bytecode': 'Bytecode storing the state and being executed during normal contract call',
        bytecode: 'Bytecode being executed during contract creation',
        functionHashes: 'List of declared function and their corresponding hash',
        gasEstimates: 'Gas estimation for each function call',
        metadata: 'Contains all informations related to the compilation',
        metadataHash: 'Hash representing all metadata information',
        abi: 'ABI: describing all the functions (input/output params, scope, ...)',
        name: 'Name of the compiled contract',
        swarmLocation: 'Swarm url where all metadata information can be found (contract needs to be published first)',
        web3Deploy: 'Copy/paste this code to any JavaScript/Web3 console to deploy this contract'
      };
      if (!this.selectedContract) throw new Error('No contract compiled yet');
      var contractProperties = this.data.contractsDetails[this.selectedContract];
      var log = yo(_templateObject11(), css.detailsJSON);
      Object.keys(contractProperties).map(function (propertyName) {
        var copyDetails = yo(_templateObject12(), css.copyDetails, copyToClipboard(function () {
          return contractProperties[propertyName];
        }));
        var questionMark = yo(_templateObject13(), css.questionMark, help[propertyName]);
        log.appendChild(yo(_templateObject14(), css.log, css.key, propertyName, copyDetails, questionMark, _this5.insertValue(contractProperties, propertyName)));
      });
      modalDialog(this.selectedContract, log, {
        label: ''
      }, {
        label: 'Close'
      });
    }
  }, {
    key: "insertValue",
    value: function insertValue(details, propertyName) {
      var node;

      if (propertyName === 'web3Deploy' || propertyName === 'name' || propertyName === 'Assembly') {
        node = yo(_templateObject15(), details[propertyName]);
      } else if (propertyName === 'abi' || propertyName === 'metadata') {
        var treeView = new TreeView({
          extractData: function extractData(item, parent, key) {
            var ret = {};

            if (item instanceof Array) {
              ret.children = item.map(function (item, index) {
                return {
                  key: index,
                  value: item
                };
              });
              ret.self = '';
            } else if (item instanceof Object) {
              ret.children = Object.keys(item).map(function (key) {
                return {
                  key: key,
                  value: item[key]
                };
              });
              ret.self = '';
            } else {
              ret.self = item;
              ret.children = [];
            }

            return ret;
          }
        });

        if (details[propertyName] !== '') {
          try {
            node = yo(_templateObject16(), treeView.render(_typeof(details[propertyName]) === 'object' ? details[propertyName] : JSON.parse(details[propertyName]))); // catch in case the parsing fails.
          } catch (e) {
            node = yo(_templateObject17(), propertyName, e.message);
          }
        } else {
          node = yo(_templateObject18());
        }
      } else {
        node = yo(_templateObject19(), JSON.stringify(details[propertyName], null, 4));
      }

      return yo(_templateObject20(), css.value, node || '');
    }
  }, {
    key: "getContractProperty",
    value: function getContractProperty(property) {
      if (!this.selectedContract) throw new Error('No contract compiled yet');
      var contractProperties = this.data.contractsDetails[this.selectedContract];
      return contractProperties[property] || null;
    }
  }, {
    key: "copyContractProperty",
    value: function copyContractProperty(property) {
      var content = this.getContractProperty(property);

      if (!content) {
        addTooltip('No content available for ' + property);
        return;
      }

      try {
        if (typeof content !== 'string') {
          content = JSON.stringify(content, null, '\t');
        }
      } catch (e) {}

      copy(content);
      addTooltip('Copied value to clipboard');
    }
  }, {
    key: "copyABI",
    value: function copyABI() {
      this.copyContractProperty('abi');
    }
  }, {
    key: "copyBytecode",
    value: function copyBytecode() {
      this.copyContractProperty('bytecode');
    }
  }, {
    key: "render",
    value: function render() {
      if (this._view.el) return this._view.el;
      this.onActivationInternal();
      this._view.errorContainer = yo(_templateObject21(), css.errorBlobs);
      this._view.contractSelection = this.contractSelection();
      this._view.compilerContainer = this.compilerContainer.render();
      this.compilerContainer.activate();
      this._view.el = yo(_templateObject22(), this._view.compilerContainer, this._view.contractSelection, this._view.errorContainer);
      return this._view.el;
    }
  }, {
    key: "onActivation",
    value: function onActivation() {
      this.listenToEvents();
    }
  }, {
    key: "onDeactivation",
    value: function onDeactivation() {
      this.compilerContainer.deactivate();
      this.editor.event.unregister('contentChanged', this.data.eventHandlers.onContentChanged);
      this.compiler.event.unregister('loadingCompiler', this.data.eventHandlers.onLoadingCompiler);
      this.compiler.event.unregister('compilerLoaded', this.data.eventHandlers.onCompilerLoaded);
      this.compileTabLogic.event.removeListener('startingCompilation', this.data.eventHandlers.onStartingCompilation);
      this.fileManager.events.removeListener('currentFileChanged', this.data.eventHandlers.onCurrentFileChanged);
      this.fileManager.events.removeListener('noFileSelected', this.data.eventHandlers.onNoFileSelected);
      this.compiler.event.unregister('compilationFinished', this.data.eventHandlers.onCompilationFinished);
      globalRegistry.get('themeModule').api.events.removeListener('themeChanged', this.data.eventHandlers.onThemeChanged);
    }
  }]);

  return CompileTab;
}(_engineWeb.ViewPlugin);

module.exports = CompileTab;

/***/ }),

/***/ "./app/tabs/compileTab/compileTab.js":
/*!*******************************************!*\
  !*** ./app/tabs/compileTab/compileTab.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EventEmitter = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

var Compiler = __webpack_require__(/*! @remix-project/remix-solidity */ "../../../dist/libs/remix-solidity/index.js").Compiler;

var CompileTab = /*#__PURE__*/function () {
  function CompileTab(queryParams, fileManager, editor, config, fileProvider, contentImport) {
    var _this = this;

    _classCallCheck(this, CompileTab);

    this.event = new EventEmitter();
    this.queryParams = queryParams;
    this.compilerImport = contentImport;
    this.compiler = new Compiler(function (url, cb) {
      return _this.compilerImport.resolveAndSave(url).then(function (result) {
        return cb(null, result);
      })["catch"](function (error) {
        return cb(error.message);
      });
    });
    this.fileManager = fileManager;
    this.editor = editor;
    this.config = config;
    this.fileProvider = fileProvider;
  }

  _createClass(CompileTab, [{
    key: "init",
    value: function init() {
      this.optimize = this.queryParams.get().optimize;
      this.optimize = this.optimize === 'true';
      this.queryParams.update({
        optimize: this.optimize
      });
      this.compiler.set('optimize', this.optimize);
      this.runs = this.queryParams.get().runs;
      this.runs = this.runs || 200;
      this.queryParams.update({
        runs: this.runs
      });
      this.compiler.set('runs', this.runs);
      this.evmVersion = this.queryParams.get().evmVersion;

      if (this.evmVersion === 'undefined' || this.evmVersion === 'null' || !this.evmVersion) {
        this.evmVersion = null;
      }

      this.queryParams.update({
        evmVersion: this.evmVersion
      });
      this.compiler.set('evmVersion', this.evmVersion);
    }
  }, {
    key: "setOptimize",
    value: function setOptimize(newOptimizeValue) {
      this.optimize = newOptimizeValue;
      this.queryParams.update({
        optimize: this.optimize
      });
      this.compiler.set('optimize', this.optimize);
    }
  }, {
    key: "setRuns",
    value: function setRuns(runs) {
      this.runs = runs;
      this.queryParams.update({
        runs: this.runs
      });
      this.compiler.set('runs', this.runs);
    }
  }, {
    key: "setEvmVersion",
    value: function setEvmVersion(newEvmVersion) {
      this.evmVersion = newEvmVersion;
      this.queryParams.update({
        evmVersion: this.evmVersion
      });
      this.compiler.set('evmVersion', this.evmVersion);
    }
    /**
     * Set the compiler to using Solidity or Yul (default to Solidity)
     * @params lang {'Solidity' | 'Yul'} ...
     */

  }, {
    key: "setLanguage",
    value: function setLanguage(lang) {
      this.compiler.set('language', lang);
    }
    /**
     * Compile a specific file of the file manager
     * @param {string} target the path to the file to compile
     */

  }, {
    key: "compileFile",
    value: function compileFile(target) {
      var _this2 = this;

      if (!target) throw new Error('No target provided for compiliation');
      var provider = this.fileManager.fileProviderOf(target);
      if (!provider) throw new Error("cannot compile ".concat(target, ". Does not belong to any explorer"));
      return new Promise(function (resolve, reject) {
        provider.get(target, function (error, content) {
          if (error) return reject(error);

          var sources = _defineProperty({}, target, {
            content: content
          });

          _this2.event.emit('startingCompilation'); // setTimeout fix the animation on chrome... (animation triggered by 'staringCompilation')


          setTimeout(function () {
            _this2.compiler.compile(sources, target);

            resolve();
          }, 100);
        });
      });
    }
  }, {
    key: "runCompiler",
    value: function runCompiler() {
      try {
        this.fileManager.saveCurrentFile();
        this.editor.clearAnnotations();
        var currentFile = this.config.get('currentFile');
        return this.compileFile(currentFile);
      } catch (err) {
        console.error(err);
      }
    }
  }]);

  return CompileTab;
}();

module.exports = CompileTab;

/***/ }),

/***/ "./app/tabs/compileTab/compilerContainer.js":
/*!**************************************************!*\
  !*** ./app/tabs/compileTab/compilerContainer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _compilerUtils = __webpack_require__(/*! ../../compiler/compiler-utils */ "./app/compiler/compiler-utils.js");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _templateObject16() {
  var data = _taggedTemplateLiteral(["<option value=\"", "\">", "</option>"]);

  _templateObject16 = function _templateObject16() {
    return data;
  };

  return data;
}

function _templateObject15() {
  var data = _taggedTemplateLiteral(["<option value=\"", "\" selected>", "</option>"]);

  _templateObject15 = function _templateObject15() {
    return data;
  };

  return data;
}

function _templateObject14() {
  var data = _taggedTemplateLiteral(["<option value=\"", "\" selected>custom</option>"]);

  _templateObject14 = function _templateObject14() {
    return data;
  };

  return data;
}

function _templateObject13() {
  var data = _taggedTemplateLiteral(["\n      <section>\n        <!-- Select Compiler Version -->\n        <article>\n          <header class=\"", " border-bottom\">\n            <div class=\"mb-2\">\n              <label class=\"", " form-check-label\" for=\"versionSelector\">\n                Compiler\n                <button class=\"far fa-plus-square border-0 p-0 mx-2 btn-sm\" onclick=\"", "\" title=\"Add a custom compiler with URL\"></button>\n              </label>\n              ", "\n            </div>\n            <div class=\"mb-2 ", " custom-control custom-checkbox\">\n              ", "\n              <label for=\"nightlies\" class=\"form-check-label custom-control-label\">Include nightly builds</label>\n            </div>\n            <div class=\"mb-2\">\n              <label class=\"", " form-check-label\" for=\"compilierLanguageSelector\">Language</label>\n              ", "\n            </div>\n            <div class=\"mb-2\">\n              <label class=\"", " form-check-label\" for=\"evmVersionSelector\">EVM Version</label>\n              ", "\n            </div>\n            <div class=\"mt-3\">\n              <p class=\"mt-2 ", "\">Compiler Configuration</p>\n              <div class=\"mt-2 ", " custom-control custom-checkbox\">\n                ", "\n                <label class=\"form-check-label custom-control-label\" for=\"autoCompile\">Auto compile</label>\n              </div>\n              <div class=\"mt-2 ", " custom-control custom-checkbox\">\n                <div class=\"justify-content-between align-items-center d-flex\">\n                  ", "\n                  <label class=\"form-check-label custom-control-label\" for=\"optimize\">Enable optimization</label>\n                  ", "\n                </div>\n              </div>\n              <div class=\"mt-2 ", " custom-control custom-checkbox\">\n                ", "\n                <label class=\"form-check-label custom-control-label\" for=\"hideWarningsBox\">Hide warnings</label>\n              </div>\n            </div>\n            ", "\n          </header>\n        </article>\n        <!-- Config -->\n      </section>"]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteral(["\n      <input class=\"mr-2 custom-control-input\" id=\"nightlies\" type=\"checkbox\" onchange=", ">\n    "]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function _templateObject11() {
  var data = _taggedTemplateLiteral(["\n      <select onchange=\"", "\" class=\"custom-select\" id=\"evmVersionSelector\">\n        <option value=\"default\" selected=\"selected\">compiler default</option>\n        <option>istanbul</option>\n        <option>petersburg</option>\n        <option>constantinople</option>\n        <option>byzantium</option>\n        <option>spuriousDragon</option>\n        <option>tangerineWhistle</option>\n        <option>homestead</option>\n      </select>"]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["<span id=\"version\"></span>"]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["\n      <select onchange=\"", "\" class=\"custom-select\" id=\"compilierLanguageSelector\" title=\"Available since v0.5.7\">\n        <option>Solidity</option>\n        <option>Yul</option>\n      </select>"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["\n      <select onchange=\"", "\" class=\"custom-select\" id=\"versionSelector\" disabled>\n        <option disabled selected>", "</option>\n        <option disabled>builtin</option>\n      </select>"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["<input\n      min=\"1\"\n      class=\"custom-select ml-2 ", "\"\n      id=\"runs\"\n      placeholder=\"200\"\n      value=\"200\"\n      type=\"number\"\n      title=\"Estimated number of times each opcode of the deployed code will be executed across the life-time of the contract.\"\n      onchange=", "\n    >"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["<input onchange=", " class=\"custom-control-input\" id=\"optimize\" type=\"checkbox\">"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["<input class=\"", " custom-control-input\" onchange=", " id=\"hideWarningsBox\" type=\"checkbox\" title=\"Hide warnings\">"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<input class=\"", " custom-control-input\" onchange=", " data-id=\"compilerContainerAutoCompile\" id=\"autoCompile\" type=\"checkbox\" title=\"Auto compile\">"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<i class=\"fas fa-sync ", "\" aria-hidden=\"true\"></i>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<i title=\"Compilation Slow\" style=\"visibility:hidden\" class=\"", " fas fa-exclamation-triangle\" aria-hidden=\"true\"></i>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n      <button id=\"compileBtn\" data-id=\"compilerContainerCompileBtn\" class=\"btn btn-primary btn-block ", " mt-3\" title=\"Compile\" onclick=\"", "\">\n        <span>", " Compile ", "</span>\n      </button>\n    "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var helper = __webpack_require__(/*! ../../../lib/helper */ "./lib/helper.js");

var addTooltip = __webpack_require__(/*! ../../ui/tooltip */ "./app/ui/tooltip.js");

var semver = __webpack_require__(/*! semver */ "../../../node_modules/semver/semver.js");

var modalDialogCustom = __webpack_require__(/*! ../../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var css = __webpack_require__(/*! ../styles/compile-tab-styles */ "./app/tabs/styles/compile-tab-styles.js");

var CompilerContainer = /*#__PURE__*/function () {
  function CompilerContainer(compileTabLogic, editor, config, queryParams) {
    _classCallCheck(this, CompilerContainer);

    this._view = {};
    this.compileTabLogic = compileTabLogic;
    this.editor = editor;
    this.config = config;
    this.queryParams = queryParams;
    this.data = {
      hideWarnings: config.get('hideWarnings') || false,
      autoCompile: config.get('autoCompile'),
      compileTimeout: null,
      timeout: 300,
      allversions: null,
      selectedVersion: null,
      defaultVersion: 'soljson-v0.7.4+commit.3f05b770.js' // this default version is defined: in makeMockCompiler (for browser test)

    };
  }
  /**
   * Update the compilation button with the name of the current file
   */


  _createClass(CompilerContainer, [{
    key: "isSolFileSelected",
    value: function isSolFileSelected() {
      var currentFile = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      if (!currentFile) currentFile = this.config.get('currentFile');
      if (!currentFile) return false;
      var extention = currentFile.substr(currentFile.length - 3, currentFile.length);
      return extention.toLowerCase() === 'sol' || extention.toLowerCase() === 'yul';
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      // deactivate editor listeners
      this.editor.event.unregister('contentChanged');
      this.editor.event.unregister('sessionSwitched');
    }
  }, {
    key: "activate",
    value: function activate() {
      this.currentFile = this.config.get('currentFile');
      this.listenToEvents();
    }
  }, {
    key: "listenToEvents",
    value: function listenToEvents() {
      var _this = this;

      this.editor.event.register('sessionSwitched', function () {
        if (!_this._view.compileIcon) return;

        _this.scheduleCompilation();
      });
      this.compileTabLogic.event.on('startingCompilation', function () {
        if (!_this._view.compileIcon) return;

        _this._view.compileIcon.setAttribute('title', 'compiling...');

        _this._view.compileIcon.classList.remove("".concat(css.bouncingIcon));

        _this._view.compileIcon.classList.add("".concat(css.spinningIcon));
      });
      this.compileTabLogic.compiler.event.register('compilationDuration', function (speed) {
        if (!_this._view.warnCompilationSlow) return;

        if (speed > 1000) {
          var msg = "Last compilation took ".concat(speed, "ms. We suggest to turn off autocompilation.");

          _this._view.warnCompilationSlow.setAttribute('title', msg);

          _this._view.warnCompilationSlow.style.visibility = 'visible';
        } else {
          _this._view.warnCompilationSlow.style.visibility = 'hidden';
        }
      });
      this.editor.event.register('contentChanged', function () {
        if (!_this._view.compileIcon) return;

        _this.scheduleCompilation();

        _this._view.compileIcon.classList.add("".concat(css.bouncingIcon)); // @TODO: compileView tab

      });
      this.compileTabLogic.compiler.event.register('loadingCompiler', function () {
        if (!_this._view.compileIcon) return;

        _this._disableCompileBtn(true);

        _this._view.compileIcon.setAttribute('title', 'compiler is loading, please wait a few moments.');

        _this._view.compileIcon.classList.add("".concat(css.spinningIcon));

        _this._view.warnCompilationSlow.style.visibility = 'hidden';

        _this._updateLanguageSelector();
      });
      this.compileTabLogic.compiler.event.register('compilerLoaded', function () {
        if (!_this._view.compileIcon) return;

        _this._disableCompileBtn(false);

        _this._view.compileIcon.setAttribute('title', '');

        _this._view.compileIcon.classList.remove("".concat(css.spinningIcon));

        if (_this.data.autoCompile) _this.compileIfAutoCompileOn();
      });
      this.compileTabLogic.compiler.event.register('compilationFinished', function (success, data, source) {
        if (!_this._view.compileIcon) return;

        _this._view.compileIcon.setAttribute('title', 'idle');

        _this._view.compileIcon.classList.remove("".concat(css.spinningIcon));

        _this._view.compileIcon.classList.remove("".concat(css.bouncingIcon));
      });
    }
    /**************
     * SUBCOMPONENT
     */

  }, {
    key: "compilationButton",
    value: function compilationButton() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var displayed = name || '<no file selected>';
      var disabled = name && this.isSolFileSelected() ? '' : 'disabled';
      return yo(_templateObject(), disabled, this.compile.bind(this), this._view.compileIcon, displayed);
    }
  }, {
    key: "_disableCompileBtn",
    value: function _disableCompileBtn(shouldDisable) {
      var btn = document.getElementById('compileBtn');
      if (!btn) return;

      if (shouldDisable) {
        btn.classList.add('disabled');
      } else if (this.isSolFileSelected()) {
        btn.classList.remove('disabled');
      }
    } // Load solc compiler version according to pragma in contract file

  }, {
    key: "_setCompilerVersionFromPragma",
    value: function _setCompilerVersionFromPragma(filename) {
      var _this2 = this;

      if (!this.data.allversions) return;
      this.compileTabLogic.fileManager.readFile(filename).then(function (data) {
        var pragmaArr = data.match(/(pragma solidity (.+?);)/g);

        if (pragmaArr && pragmaArr.length === 1) {
          var pragmaStr = pragmaArr[0].replace('pragma solidity', '').trim();
          var pragma = pragmaStr.substring(0, pragmaStr.length - 1);

          var releasedVersions = _this2.data.allversions.filter(function (obj) {
            return !obj.prerelease;
          }).map(function (obj) {
            return obj.version;
          });

          var allVersions = _this2.data.allversions.map(function (obj) {
            return _this2._retrieveVersion(obj.version);
          });

          var currentCompilerName = _this2._retrieveVersion(_this2._view.versionSelector.selectedOptions[0].label); // contains only numbers part, for example '0.4.22'


          var pureVersion = _this2._retrieveVersion(); // is nightly build newer than the last release


          var isNewestNightly = currentCompilerName.includes('nightly') && semver.gt(pureVersion, releasedVersions[0]); // checking if the selected version is in the pragma range

          var isInRange = semver.satisfies(pureVersion, pragma); // checking if the selected version is from official compilers list(excluding custom versions) and in range or greater

          var isOfficial = allVersions.includes(currentCompilerName);

          if (isOfficial && !isInRange && !isNewestNightly) {
            var compilerToLoad = semver.maxSatisfying(releasedVersions, pragma);

            var compilerPath = _this2.data.allversions.filter(function (obj) {
              return !obj.prerelease && obj.version === compilerToLoad;
            })[0].path;

            if (_this2.data.selectedVersion !== compilerPath) {
              _this2.data.selectedVersion = compilerPath;

              _this2._updateVersionSelector();
            }
          }
        }
      });
    }
  }, {
    key: "_retrieveVersion",
    value: function _retrieveVersion(version) {
      if (!version) version = this._view.versionSelector.value;
      return semver.coerce(version) ? semver.coerce(version).version : '';
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      this.compileTabLogic.compiler.event.register('compilerLoaded', function (version) {
        return _this3.setVersionText(version);
      });
      this.fetchAllVersion(function (allversions, selectedVersion, isURL) {
        _this3.data.allversions = allversions;
        if (isURL) _this3._updateVersionSelector(selectedVersion);else {
          _this3.data.selectedVersion = selectedVersion;
          if (_this3._view.versionSelector) _this3._updateVersionSelector();
        }
      });
      this._view.warnCompilationSlow = yo(_templateObject2(), css.warnCompilationSlow);
      this._view.compileIcon = yo(_templateObject3(), css.icon);
      this._view.autoCompile = yo(_templateObject4(), css.autocompile, function () {
        return _this3.updateAutoCompile();
      });
      this._view.hideWarningsBox = yo(_templateObject5(), css.autocompile, function () {
        return _this3.hideWarnings();
      });
      if (this.data.autoCompile) this._view.autoCompile.setAttribute('checked', '');
      if (this.data.hideWarnings) this._view.hideWarningsBox.setAttribute('checked', '');
      this._view.optimize = yo(_templateObject6(), function () {
        return _this3.onchangeOptimize();
      });
      if (this.compileTabLogic.optimize) this._view.optimize.setAttribute('checked', '');
      this._view.runs = yo(_templateObject7(), css.runs, function () {
        return _this3.onchangeRuns();
      });

      if (this.compileTabLogic.optimize) {
        this._view.runs.removeAttribute('disabled');

        this._view.runs.value = this.compileTabLogic.runs;
      } else {
        this._view.runs.setAttribute('disabled', '');
      }

      this._view.versionSelector = yo(_templateObject8(), this.onchangeLoadVersion.bind(this), this.data.defaultVersion);
      this._view.languageSelector = yo(_templateObject9(), this.onchangeLanguage.bind(this));
      this._view.version = yo(_templateObject10());
      this._view.evmVersionSelector = yo(_templateObject11(), this.onchangeEvmVersion.bind(this));

      if (this.compileTabLogic.evmVersion) {
        var s = this._view.evmVersionSelector;
        var i;

        for (i = 0; i < s.options.length; i++) {
          if (s.options[i].value === this.compileTabLogic.evmVersion) {
            break;
          }
        }

        if (i === s.options.length) {
          // invalid evmVersion from queryParams
          s.selectedIndex = 0; // compiler default

          this.onchangeEvmVersion();
        } else {
          s.selectedIndex = i;
          this.onchangeEvmVersion();
        }
      }

      this._view.compilationButton = this.compilationButton();
      this._view.includeNightlies = yo(_templateObject12(), function () {
        return _this3._updateVersionSelector();
      });
      this._view.compileContainer = yo(_templateObject13(), css.compilerSection, css.compilerLabel, function (e) {
        return _this3.promtCompiler(e);
      }, this._view.versionSelector, css.nightlyBuilds, this._view.includeNightlies, css.compilerLabel, this._view.languageSelector, css.compilerLabel, this._view.evmVersionSelector, css.compilerLabel, css.compilerConfig, this._view.autoCompile, css.compilerConfig, this._view.optimize, this._view.runs, css.compilerConfig, this._view.hideWarningsBox, this._view.compilationButton);
      return this._view.compileContainer;
    }
  }, {
    key: "promtCompiler",
    value: function promtCompiler() {
      var _this4 = this;

      modalDialogCustom.prompt('Add a custom compiler', 'URL', '', function (url) {
        return _this4.addCustomCompiler(url);
      });
    }
  }, {
    key: "addCustomCompiler",
    value: function addCustomCompiler(url) {
      this.data.selectedVersion = this._view.versionSelector.value;

      this._updateVersionSelector(url);
    }
  }, {
    key: "updateAutoCompile",
    value: function updateAutoCompile(event) {
      this.config.set('autoCompile', this._view.autoCompile.checked);
    }
  }, {
    key: "compile",
    value: function compile(event) {
      var currentFile = this.config.get('currentFile');
      if (!this.isSolFileSelected()) return;

      this._setCompilerVersionFromPragma(currentFile);

      this.compileTabLogic.runCompiler();
    }
  }, {
    key: "compileIfAutoCompileOn",
    value: function compileIfAutoCompileOn() {
      if (this.config.get('autoCompile')) {
        this.compile();
      }
    }
  }, {
    key: "hideWarnings",
    value: function hideWarnings(event) {
      this.config.set('hideWarnings', this._view.hideWarningsBox.checked);
      this.compileIfAutoCompileOn();
    }
    /*
      The following functions are handlers for internal events.
    */

  }, {
    key: "onchangeOptimize",
    value: function onchangeOptimize() {
      this.compileTabLogic.setOptimize(!!this._view.optimize.checked);

      if (this.compileTabLogic.optimize) {
        this._view.runs.removeAttribute('disabled');

        this.compileTabLogic.setRuns(parseInt(this._view.runs.value));
      } else {
        this.compileTabLogic.setRuns(200);

        this._view.runs.setAttribute('disabled', '');
      }

      this.compileIfAutoCompileOn();
    }
  }, {
    key: "onchangeRuns",
    value: function onchangeRuns() {
      this.compileTabLogic.setRuns(parseInt(this._view.runs.value));
      this.compileIfAutoCompileOn();
    }
  }, {
    key: "onchangeLanguage",
    value: function onchangeLanguage() {
      this.compileTabLogic.setLanguage(this._view.languageSelector.value);
      this.compileIfAutoCompileOn();
    }
  }, {
    key: "onchangeEvmVersion",
    value: function onchangeEvmVersion() {
      var s = this._view.evmVersionSelector;
      var v = s.value;

      if (v === 'default') {
        v = null;
      }

      this.compileTabLogic.setEvmVersion(v);

      for (var i = 0; i < s.options.length; i++) {
        if (i === s.selectedIndex) {
          s.options[s.selectedIndex].setAttribute('selected', 'selected');
        } else {
          s.options[i].removeAttribute('selected');
        }
      }

      this.compileIfAutoCompileOn();
    }
  }, {
    key: "onchangeLoadVersion",
    value: function onchangeLoadVersion() {
      this.data.selectedVersion = this._view.versionSelector.value;

      this._updateVersionSelector();

      this._updateLanguageSelector();
    }
    /*
      The following functions map with the above event handlers.
      They are an external API for modifying the compiler configuration.
    */

  }, {
    key: "setConfiguration",
    value: function setConfiguration(settings) {
      this.setLanguage(settings.language);
      this.setEvmVersion(settings.evmVersion);
      this.setOptimize(settings.optimize);
      this.setRuns(settings.runs);
      this.setVersion(settings.version);
    }
  }, {
    key: "setOptimize",
    value: function setOptimize(enabled) {
      this._view.optimize.checked = enabled;
      this.onchangeOptimize();
    }
  }, {
    key: "setRuns",
    value: function setRuns(value) {
      if (value) {
        this._view.runs.value = value;
        this.onchangeRuns();
      }
    }
  }, {
    key: "setLanguage",
    value: function setLanguage(lang) {
      this._view.languageSelector.value = lang;
      this.onchangeLanguage();
    }
  }, {
    key: "setEvmVersion",
    value: function setEvmVersion(version) {
      this._view.evmVersionSelector.value = version || 'default';
      this.onchangeEvmVersion();
    }
  }, {
    key: "setVersion",
    value: function setVersion(version) {
      this._view.versionSelector.value = "soljson-v".concat(version, ".js");
      this.onchangeLoadVersion();
    }
  }, {
    key: "_shouldBeAdded",
    value: function _shouldBeAdded(version) {
      return !version.includes('nightly') || version.includes('nightly') && this._view.includeNightlies.checked;
    }
  }, {
    key: "_updateVersionSelector",
    value: function _updateVersionSelector() {
      var _this5 = this;

      var customUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

      // update selectedversion of previous one got filtered out
      if (!this.data.selectedVersion || !this._shouldBeAdded(this.data.selectedVersion)) {
        this.data.selectedVersion = this.data.defaultVersion;
      }

      this._view.versionSelector.innerHTML = '';

      this._view.versionSelector.removeAttribute('disabled');

      this.queryParams.update({
        version: this.data.selectedVersion
      });
      var url;

      if (customUrl !== '') {
        this.data.selectedVersion = customUrl;

        this._view.versionSelector.appendChild(yo(_templateObject14(), customUrl));

        url = customUrl;
        this.queryParams.update({
          version: this.data.selectedVersion
        });
      } else if (this.data.selectedVersion === 'builtin') {
        var location = window.document.location;
        var path = location.pathname;
        if (!path.startsWith('/')) path = '/' + path;
        location = "".concat(location.protocol, "//").concat(location.host).concat(path, "assets/js");
        if (location.endsWith('index.html')) location = location.substring(0, location.length - 10);
        if (!location.endsWith('/')) location += '/';
        url = location + 'soljson.js';
      } else {
        if (this.data.selectedVersion.indexOf('soljson') !== 0 || helper.checkSpecialChars(this.data.selectedVersion)) {
          return console.log('loading ' + this.data.selectedVersion + ' not allowed');
        }

        url = "".concat((0, _compilerUtils.urlFromVersion)(this.data.selectedVersion));
      }

      this.data.allversions.forEach(function (build) {
        var option = build.path === _this5.data.selectedVersion ? yo(_templateObject15(), build.path, build.longVersion) : yo(_templateObject16(), build.path, build.longVersion);

        if (_this5._shouldBeAdded(option.innerText)) {
          _this5._view.versionSelector.appendChild(option);
        }
      }); // Workers cannot load js on "file:"-URLs and we get a
      // "Uncaught RangeError: Maximum call stack size exceeded" error on Chromium,
      // resort to non-worker version in that case.

      if (this.data.selectedVersion !== 'builtin' && (0, _compilerUtils.canUseWorker)(this.data.selectedVersion)) {
        this.compileTabLogic.compiler.loadVersion(true, url);
        this.setVersionText('(loading using worker)');
      } else {
        this.compileTabLogic.compiler.loadVersion(false, url);
        this.setVersionText('(loading)');
      }
    }
  }, {
    key: "_updateLanguageSelector",
    value: function _updateLanguageSelector() {
      // This is the first version when Yul is available
      if (!semver.valid(this._retrieveVersion()) || semver.lt(this._retrieveVersion(), 'v0.5.7+commit.6da8b019.js')) {
        this._view.languageSelector.setAttribute('disabled', '');

        this._view.languageSelector.value = 'Solidity';
        this.compileTabLogic.setLanguage('Solidity');
      } else {
        this._view.languageSelector.removeAttribute('disabled');
      }
    }
  }, {
    key: "setVersionText",
    value: function setVersionText(text) {
      if (this._view.version) this._view.version.innerText = text;
    } // fetching both normal and wasm builds and creating a [version, baseUrl] map

  }, {
    key: "fetchAllVersion",
    value: function () {
      var _fetchAllVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(callback) {
        var selectedVersion, allVersionsWasm, isURL, allVersions, binRes, wasmRes, versions, urlArr;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                allVersions = [{
                  path: 'builtin',
                  longVersion: 'latest local version - 0.7.4'
                }]; // fetch normal builds

                _context.next = 3;
                return (0, _compilerUtils.promisedMiniXhr)("".concat(_compilerUtils.baseURLBin, "/list.json"));

              case 3:
                binRes = _context.sent;
                _context.next = 6;
                return (0, _compilerUtils.promisedMiniXhr)("".concat(_compilerUtils.baseURLWasm, "/list.json"));

              case 6:
                wasmRes = _context.sent;

                if (!(binRes.event.type === 'error' && wasmRes.event.type === 'error')) {
                  _context.next = 10;
                  break;
                }

                selectedVersion = 'builtin';
                return _context.abrupt("return", callback(allVersions, selectedVersion));

              case 10:
                try {
                  versions = JSON.parse(binRes.json).builds.slice().reverse();
                  allVersions = [].concat(_toConsumableArray(allVersions), _toConsumableArray(versions));
                  selectedVersion = this.data.defaultVersion;
                  if (this.queryParams.get().version) selectedVersion = this.queryParams.get().version; // Check if version is a URL and corresponding filename starts with 'soljson'

                  if (selectedVersion.startsWith('https://')) {
                    urlArr = selectedVersion.split('/');
                    if (urlArr[urlArr.length - 1].startsWith('soljson')) isURL = true;
                  }

                  if (wasmRes.event.type !== 'error') {
                    allVersionsWasm = JSON.parse(wasmRes.json).builds.slice().reverse();
                  }
                } catch (e) {
                  addTooltip('Cannot load compiler version list. It might have been blocked by an advertisement blocker. Please try deactivating any of them from this page and reload. Error: ' + e);
                } // replace in allVersions those compiler builds which exist in allVersionsWasm with new once


                if (allVersionsWasm && allVersions) {
                  allVersions.forEach(function (compiler, index) {
                    var wasmIndex = allVersionsWasm.findIndex(function (wasmCompiler) {
                      return wasmCompiler.longVersion === compiler.longVersion;
                    });

                    if (wasmIndex !== -1) {
                      allVersions[index] = allVersionsWasm[wasmIndex];
                      _compilerUtils.pathToURL[compiler.path] = _compilerUtils.baseURLWasm;
                    } else {
                      _compilerUtils.pathToURL[compiler.path] = _compilerUtils.baseURLBin;
                    }
                  });
                }

                callback(allVersions, selectedVersion, isURL);

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function fetchAllVersion(_x) {
        return _fetchAllVersion.apply(this, arguments);
      }

      return fetchAllVersion;
    }()
  }, {
    key: "scheduleCompilation",
    value: function scheduleCompilation() {
      var _this6 = this;

      if (!this.config.get('autoCompile')) return;
      if (this.data.compileTimeout) window.clearTimeout(this.data.compileTimeout);
      this.data.compileTimeout = window.setTimeout(function () {
        return _this6.compileIfAutoCompileOn();
      }, this.data.timeout);
    }
  }, {
    key: "currentFile",
    set: function set() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

      if (name && name !== '') {
        this._setCompilerVersionFromPragma(name);
      }

      if (!this._view.compilationButton) return;
      var button = this.compilationButton(name.split('/').pop());

      this._disableCompileBtn(!name || name && !this.isSolFileSelected(name));

      yo.update(this._view.compilationButton, button);
    }
  }]);

  return CompilerContainer;
}();

module.exports = CompilerContainer;

/***/ }),

/***/ "./app/tabs/compileTab/contractParser.js":
/*!***********************************************!*\
  !*** ./app/tabs/compileTab/contractParser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var solcTranslate = __webpack_require__(/*! solc/translate */ "../../../node_modules/solc/translate.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var txHelper = remixLib.execution.txHelper;

module.exports = function (contractName, contract, compiledSource) {
  return getDetails(contractName, contract, compiledSource);
};

var getDetails = function getDetails(contractName, contract, source) {
  var detail = {};
  detail.name = contractName;
  detail.metadata = contract.metadata;

  if (contract.evm.bytecode.object) {
    detail.bytecode = contract.evm.bytecode.object;
  }

  detail.abi = contract.abi;

  if (contract.evm.bytecode.object) {
    detail.bytecode = contract.evm.bytecode;
    detail.web3Deploy = gethDeploy(contractName.toLowerCase(), contract.abi, contract.evm.bytecode.object);
    detail.metadataHash = retrieveMetadataHash(contract.evm.bytecode.object);

    if (detail.metadataHash) {
      detail.swarmLocation = 'bzzr://' + detail.metadataHash;
    }
  }

  detail.functionHashes = {};

  for (var fun in contract.evm.methodIdentifiers) {
    detail.functionHashes[contract.evm.methodIdentifiers[fun]] = fun;
  }

  detail.gasEstimates = formatGasEstimates(contract.evm.gasEstimates);
  detail.devdoc = contract.devdoc;
  detail.userdoc = contract.userdoc;

  if (contract.evm.deployedBytecode && contract.evm.deployedBytecode.object.length > 0) {
    detail['Runtime Bytecode'] = contract.evm.deployedBytecode;
  }

  if (source && contract.assembly !== null) {
    detail.Assembly = solcTranslate.prettyPrintLegacyAssemblyJSON(contract.evm.legacyAssembly, source.content);
  }

  return detail;
};

var retrieveMetadataHash = function retrieveMetadataHash(bytecode) {
  var match = /a165627a7a72305820([0-9a-f]{64})0029$/.exec(bytecode);

  if (!match) {
    match = /a265627a7a72305820([0-9a-f]{64})6c6578706572696d656e74616cf50037$/.exec(bytecode);
  }

  if (match) {
    return match[1];
  }
};

var gethDeploy = function gethDeploy(contractName, jsonInterface, bytecode) {
  var code = '';
  var funABI = txHelper.getConstructorInterface(jsonInterface);
  funABI.inputs.forEach(function (inp) {
    code += 'var ' + inp.name + ' = /* var of type ' + inp.type + ' here */ ;\n';
  });
  contractName = contractName.replace(/[:./]/g, '_');
  code += 'var ' + contractName + 'Contract = new web3.eth.Contract(' + JSON.stringify(jsonInterface).replace('\n', '') + ');' + '\nvar ' + contractName + ' = ' + contractName + 'Contract.deploy({' + "\n     data: '0x" + bytecode + "', " + '\n     arguments: [';
  funABI.inputs.forEach(function (inp) {
    code += '\n          ' + inp.name + ',';
  });
  code += '\n     ]' + '\n}).send({' + '\n     from: web3.eth.accounts[0], ' + "\n     gas: '4700000'" + '\n   }, function (e, contract){' + '\n    console.log(e, contract);' + "\n    if (typeof contract.address !== 'undefined') {" + "\n         console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash);" + '\n    }' + '\n })';
  return code;
};

var formatGasEstimates = function formatGasEstimates(data) {
  if (!data) return {};
  if (data.creation === undefined && data.external === undefined && data.internal === undefined) return {};

  var gasToText = function gasToText(g) {
    return g === null ? 'unknown' : g;
  };

  var ret = {};
  var fun;

  if ('creation' in data) {
    ret.Creation = data.creation;
  }

  if ('external' in data) {
    ret.External = {};

    for (fun in data.external) {
      ret.External[fun] = gasToText(data.external[fun]);
    }
  }

  if ('internal' in data) {
    ret.Internal = {};

    for (fun in data.internal) {
      ret.Internal[fun] = gasToText(data.internal[fun]);
    }
  }

  return ret;
};

/***/ }),

/***/ "./app/tabs/debugger-tab.js":
/*!**********************************!*\
  !*** ./app/tabs/debugger-tab.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebuggerTab = void 0;

var _tooltip = _interopRequireDefault(__webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js"));

var _debuggerUi = __webpack_require__(/*! @remix-ui/debugger-ui */ "../../../libs/remix-ui/debugger-ui/src/index.ts");

var _debuggerPlugin = __webpack_require__(/*! @remixproject/debugger-plugin */ "../../debugger/src/index.ts");

var _engineWeb = __webpack_require__(/*! @remixproject/engine-web */ "../../../node_modules/@remixproject/engine-web/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "../../../node_modules/react/index.js"));

var _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ "../../../node_modules/react-dom/index.js"));

var _modalDialogCustom = _interopRequireDefault(__webpack_require__(/*! ../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js"));

var remixBleach = _interopRequireWildcard(__webpack_require__(/*! ../../lib/remixBleach */ "./lib/remixBleach.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject6() {
  var data = _taggedTemplateLiteral(["<div><b>Source verification plugin not activated or not available.</b> continuing <i>without</i> source code debugging.</div>"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["<div><b>Using compilation result from Solidity module</b></div>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<div><b>Contract ", " not found in source code repository</b> continuing <i>without</i> source code debugging.</div>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<div><b>Compilation failed...</b> continuing <i>without</i> source code debugging.</div>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<div><b>Recompiling and debugging with params</b><pre class=\"text-left\">", "</pre></div>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", "\" id=\"debugView\">\n        <div id=\"debugger\" class=\"", "\"></div>\n      </div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var css = __webpack_require__(/*! ./styles/debugger-tab-styles */ "./app/tabs/styles/debugger-tab-styles.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var profile = {
  name: 'debugger',
  displayName: 'Debugger',
  methods: ['debug', 'getTrace'],
  events: [],
  icon: 'assets/img/debuggerLogo.webp',
  description: 'Debug transactions',
  kind: 'debugging',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/debugger.html',
  version: packageJson.version
};

var DebuggerTab = /*#__PURE__*/function (_DebuggerApiMixin) {
  _inherits(DebuggerTab, _DebuggerApiMixin);

  var _super = _createSuper(DebuggerTab);

  function DebuggerTab() {
    var _this;

    _classCallCheck(this, DebuggerTab);

    _this = _super.call(this, profile);
    _this.el = null;

    _this.initDebuggerApi();

    return _this;
  }

  _createClass(DebuggerTab, [{
    key: "render",
    value: function render() {
      if (this.el) return this.el;
      this.el = yo(_templateObject(), css.debuggerTabView, css["debugger"]);
      this.on('fetchAndCompile', 'compiling', function (settings) {
        (0, _tooltip["default"])(yo(_templateObject2(), JSON.stringify(settings, null, '\t')));
      });
      this.on('fetchAndCompile', 'compilationFailed', function (data) {
        (0, _tooltip["default"])(yo(_templateObject3()));
      });
      this.on('fetchAndCompile', 'notFound', function (contractAddress) {
        (0, _tooltip["default"])(yo(_templateObject4(), contractAddress));
      });
      this.on('fetchAndCompile', 'usingLocalCompilation', function (contractAddress) {
        (0, _tooltip["default"])(yo(_templateObject5()));
      });
      this.on('fetchAndCompile', 'sourceVerificationNotAvailable', function () {
        (0, _tooltip["default"])(yo(_templateObject6()));
      });
      this.renderComponent();
      return this.el;
    }
  }, {
    key: "showMessage",
    value: function showMessage(title, message) {
      try {
        _modalDialogCustom["default"].alert(title, remixBleach.sanitize(message));
      } catch (e) {
        console.log(e);
      }
    }
  }, {
    key: "renderComponent",
    value: function renderComponent() {
      _reactDom["default"].render( /*#__PURE__*/_react["default"].createElement(_debuggerUi.DebuggerUI, {
        debuggerAPI: this
      }), this.el);
    }
  }]);

  return DebuggerTab;
}((0, _debuggerPlugin.DebuggerApiMixin)(_engineWeb.ViewPlugin));

exports.DebuggerTab = DebuggerTab;

/***/ }),

/***/ "./app/tabs/network-module.js":
/*!************************************!*\
  !*** ./app/tabs/network-module.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NetworkModule = exports.profile = void 0;

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

var _web = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var profile = {
  name: 'network',
  description: 'Manage the network (mainnet, ropsten, goerli...) and the provider (web3, vm, injected)',
  methods: ['getNetworkProvider', 'getEndpoint', 'detectNetwork', 'addNetwork', 'removeNetwork'],
  version: packageJson.version,
  kind: 'network'
}; // Network API has :
// - events: ['providerChanged']
// - methods: ['getNetworkProvider', 'getEndpoint', 'detectNetwork', 'addNetwork', 'removeNetwork']

exports.profile = profile;

var NetworkModule = /*#__PURE__*/function (_Plugin) {
  _inherits(NetworkModule, _Plugin);

  var _super = _createSuper(NetworkModule);

  function NetworkModule(blockchain) {
    var _this;

    _classCallCheck(this, NetworkModule);

    _this = _super.call(this, profile);
    _this.blockchain = blockchain; // TODO: See with remix-lib to make sementic coherent

    _this.blockchain.event.register('contextChanged', function (provider) {
      _this.emit('providerChanged', provider);
    });
    /*
    // Events that could be implemented later
    executionContext.event.register('removeProvider', (provider) => {
      this.events.emit('networkRemoved', provider)
    })
    executionContext.event.register('addProvider', (provider) => {
      this.events.emit('networkAdded', provider)
    })
    executionContext.event.register('web3EndpointChanged', (provider) => {
      this.events.emit('web3EndpointChanged', provider)
    })
    */


    return _this;
  }
  /** Return the current network provider (web3, vm, injected) */


  _createClass(NetworkModule, [{
    key: "getNetworkProvider",
    value: function getNetworkProvider() {
      return this.blockchain.getProvider();
    }
    /** Return the current network */

  }, {
    key: "detectNetwork",
    value: function detectNetwork() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2.blockchain.detectNetwork(function (error, network) {
          error ? reject(error) : resolve(network);
        });
      });
    }
    /** Return the url only if network provider is 'web3' */

  }, {
    key: "getEndpoint",
    value: function getEndpoint() {
      var provider = this.blockchain.getProvider();

      if (provider !== 'web3') {
        throw new Error('no endpoint: current provider is either injected or vm');
      }

      return this.blockchain.web3().currentProvider.host;
    }
    /** Add a custom network to the list of available networks */

  }, {
    key: "addNetwork",
    value: function addNetwork(network) {
      // { name, url }
      var provider = network.url === 'ipc' ? new _web.Web3.providers.IpcProvider() : new _web.Web3.providers.HttpProvider(network.url);
      this.blockchain.addProvider({
        name: network.name,
        provider: provider
      });
    }
    /** Remove a network to the list of availble networks */

  }, {
    key: "removeNetwork",
    value: function removeNetwork(name) {
      this.blockchain.removeProvider(name);
    }
  }]);

  return NetworkModule;
}(_engine.Plugin);

exports.NetworkModule = NetworkModule;

/***/ }),

/***/ "./app/tabs/runTab/contractDropdown.js":
/*!*********************************************!*\
  !*** ./app/tabs/runTab/contractDropdown.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _publishToStorage = _interopRequireDefault(__webpack_require__(/*! ../../../publishToStorage */ "./publishToStorage.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _templateObject13() {
  var data = _taggedTemplateLiteral(["<div>Contract creation initialization returns data with length of more than 24576 bytes. The deployment will likely fails. <br>\n      More info: <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-170.md\" target=\"_blank\">eip-170</a>\n      </div>"]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteral(["<div>Gas estimation errored with the following message (see below).\n        The transaction execution will likely fail. Do you want to force sending? <br>\n        ", "\n        </div>"]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _templateObject11() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", "\" data-id=\"contractDropdownContainer\">\n        <label class=\"", "\">Contract</label>\n        <div class=\"", "\">\n          ", " ", "\n          ", "\n        </div>\n        <div>\n          ", "\n          ", "\n          <div class=\"", " ", "\">\n            ", "\n            ", "\n          </div>\n        </div>\n      </div>\n    "]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["<div class=\"", " mt-2\">or</div>"]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["<div class=\"", "\"></div>"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"d-flex py-1 align-items-center custom-control custom-checkbox\">\n        ", "\n        <label\n          for=\"deployAndRunPublishToIPFS\"\n          data-id=\"contractDropdownIpfsCheckboxLabel\"\n          class=\"m-0 form-check-label custom-control-label ", "\"\n          title=\"Publishing the source code and ABI to IPFS facilitates source code verification and will greatly foster contract adoption (auditing, debugging, calling it, etc...)\"\n        >\n          Publish to IPFS\n        </label>\n      </div>\n      "]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n      <input\n        id=\"deployAndRunPublishToIPFS\"\n        data-id=\"contractDropdownIpfsCheckbox\"\n        class=\"form-check-input custom-control-input\"\n        type=\"checkbox\"\n        onchange=", "\n      >\n    "]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["<span class=\"py-1\">ABI file selected</span>"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["<select class=\"", " custom-select\" disabled title=\"Please compile *.sol file to deploy or access a contract\"></select>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<input class=\"", " ", " ataddressinput form-control\" placeholder=\"Load contract from Address\" title=\"address of contract\" oninput=", " />"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<button class=\"", " btn btn-sm btn-info\" id=\"runAndDeployAtAdressButton\" onclick=", ">At Address</button>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<i title=\"No contract compiled yet or compilation failed. Please check the compile tab for more information.\" class=\"m-2 ml-3 fas fa-times-circle ", "\" ></i>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["<option value=\"", "\" compiler=\"", "\">", " - ", "</option>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = __webpack_require__(/*! ../styles/run-tab-styles */ "./app/tabs/styles/run-tab-styles.js");

var modalDialogCustom = __webpack_require__(/*! ../../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var EventManager = remixLib.EventManager;

var confirmDialog = __webpack_require__(/*! ../../ui/confirmDialog */ "./app/ui/confirmDialog.js");

var modalDialog = __webpack_require__(/*! ../../ui/modaldialog */ "./app/ui/modaldialog.js");

var MultiParamManager = __webpack_require__(/*! ../../ui/multiParamManager */ "./app/ui/multiParamManager.js");

var helper = __webpack_require__(/*! ../../../lib/helper */ "./lib/helper.js");

var ContractDropdownUI = /*#__PURE__*/function () {
  function ContractDropdownUI(blockchain, dropdownLogic, logCallback, runView) {
    _classCallCheck(this, ContractDropdownUI);

    this.blockchain = blockchain;
    this.dropdownLogic = dropdownLogic;
    this.logCallback = logCallback;
    this.runView = runView;
    this.event = new EventManager();
    this.listenToEvents();
    this.ipfsCheckedState = false;
    this.exEnvironment = blockchain.getProvider();
    this.listenToContextChange();
    this.loadType = 'other';
  }

  _createClass(ContractDropdownUI, [{
    key: "listenToEvents",
    value: function listenToEvents() {
      var _this = this;

      this.dropdownLogic.event.register('newlyCompiled', function (success, data, source, compiler, compilerFullName, file) {
        if (!_this.selectContractNames) return;
        _this.selectContractNames.innerHTML = '';

        if (success) {
          _this.dropdownLogic.getCompiledContracts(compiler, compilerFullName).forEach(function (contract) {
            _this.selectContractNames.appendChild(yo(_templateObject(), contract.name, compilerFullName, contract.name, contract.file));
          });
        }

        _this.enableAtAddress(success);

        _this.enableContractNames(success);

        _this.setInputParamsPlaceHolder();

        if (success) {
          _this.compFails.style.display = 'none';
        } else {
          _this.compFails.style.display = 'block';
        }
      });
    }
  }, {
    key: "listenToContextChange",
    value: function listenToContextChange() {
      var _this2 = this;

      this.blockchain.event.register('contextChanged', function () {
        _this2.blockchain.updateNetwork(function (err) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              name = _ref.name;

          if (err) {
            console.log('can\'t detect network');
            return;
          }

          _this2.exEnvironment = _this2.blockchain.getProvider();
          _this2.networkName = name;
          var savedConfig = window.localStorage.getItem("ipfs/".concat(_this2.exEnvironment, "/").concat(_this2.networkName)); // check if an already selected option exist else use default workflow

          if (savedConfig !== null) {
            _this2.setCheckedState(savedConfig);
          } else {
            _this2.setCheckedState(_this2.networkName === 'Main');
          }
        });
      });
    }
  }, {
    key: "setCheckedState",
    value: function setCheckedState(value) {
      value = value === 'true' ? true : value === 'false' ? false : value;
      this.ipfsCheckedState = value;
      if (this.ipfsCheckbox) this.ipfsCheckbox.checked = value;
    }
  }, {
    key: "toggleCheckedState",
    value: function toggleCheckedState() {
      if (this.exEnvironment === 'vm') this.networkName = 'VM';
      this.ipfsCheckedState = !this.ipfsCheckedState;
      window.localStorage.setItem("ipfs/".concat(this.exEnvironment, "/").concat(this.networkName), this.ipfsCheckedState);
    }
  }, {
    key: "enableContractNames",
    value: function enableContractNames(enable) {
      if (enable) {
        if (this.selectContractNames.value === '') return;
        this.selectContractNames.removeAttribute('disabled');
        this.selectContractNames.setAttribute('title', 'Select contract for Deploy or At Address.');
      } else {
        this.selectContractNames.setAttribute('disabled', true);

        if (this.loadType === 'sol') {
          this.selectContractNames.setAttribute('title', ' Select and compile *.sol file to deploy or access a contract.');
        } else {
          this.selectContractNames.setAttribute('title', ' Selected *.abi file allows accessing contracts, select and compile *.sol file to deploy and access one.');
        }
      }
    }
  }, {
    key: "enableAtAddress",
    value: function enableAtAddress(enable) {
      if (enable) {
        if (this.atAddressButtonInput.value === '') return;
        this.atAddress.removeAttribute('disabled');
        this.atAddress.setAttribute('title', 'Interact with the given contract.');
      } else {
        this.atAddress.setAttribute('disabled', true);

        if (this.atAddressButtonInput.value === '') {
          this.atAddress.setAttribute('title', ' Compile *.sol file or select *.abi file & then enter the address of deployed contract.');
        } else {
          this.atAddress.setAttribute('title', ' Compile *.sol file or select *.abi file.');
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      this.compFails = yo(_templateObject2(), css.errorIcon);
      this.atAddress = yo(_templateObject3(), css.atAddress, this.loadFromAddress.bind(this));
      this.atAddressButtonInput = yo(_templateObject4(), css.input, css.ataddressinput, this.atAddressChanged.bind(this));
      this.selectContractNames = yo(_templateObject5(), css.contractNames);
      this.abiLabel = yo(_templateObject6());
      if (this.exEnvironment === 'vm') this.networkName = 'VM';
      this.enableAtAddress(false);
      this.abiLabel.style.display = 'none';
      var savedConfig = window.localStorage.getItem("ipfs/".concat(this.exEnvironment, "/").concat(this.networkName));
      this.ipfsCheckedState = savedConfig === 'true' ? true : false; // eslint-disable-line

      this.ipfsCheckbox = yo(_templateObject7(), function () {
        return _this3.toggleCheckedState();
      });
      if (this.ipfsCheckedState) this.ipfsCheckbox.checked = true;
      this.deployCheckBox = yo(_templateObject8(), this.ipfsCheckbox, css.checkboxAlign);
      this.createPanel = yo(_templateObject9(), css.deployDropdown);
      this.orLabel = yo(_templateObject10(), css.orLabel);
      var contractNamesContainer = yo(_templateObject11(), css.container, css.settingsLabel, css.subcontainer, this.selectContractNames, this.compFails, this.abiLabel, this.createPanel, this.orLabel, css.button, css.atAddressSect, this.atAddress, this.atAddressButtonInput);
      this.selectContractNames.addEventListener('change', this.setInputParamsPlaceHolder.bind(this));
      this.setInputParamsPlaceHolder();

      if (!this.contractNamesContainer) {
        this.contractNamesContainer = contractNamesContainer;
      }

      return contractNamesContainer;
    }
  }, {
    key: "atAddressChanged",
    value: function atAddressChanged(event) {
      if (!this.atAddressButtonInput.value) {
        this.enableAtAddress(false);
      } else {
        if (this.selectContractNames && !this.selectContractNames.getAttribute('disabled') && this.loadType === 'sol' || this.loadType === 'abi') {
          this.enableAtAddress(true);
        } else {
          this.enableAtAddress(false);
        }
      }
    }
  }, {
    key: "changeCurrentFile",
    value: function changeCurrentFile(currentFile) {
      if (!this.selectContractNames) return;

      if (/.(.abi)$/.exec(currentFile)) {
        this.createPanel.style.display = 'none';
        this.orLabel.style.display = 'none';
        this.compFails.style.display = 'none';
        this.loadType = 'abi';
        this.contractNamesContainer.style.display = 'block';
        this.abiLabel.style.display = 'block';
        this.abiLabel.innerHTML = currentFile;
        this.selectContractNames.style.display = 'none';
        this.enableContractNames(true);
        this.enableAtAddress(true);
      } else if (/.(.sol)$/.exec(currentFile)) {
        this.createPanel.style.display = 'block';
        this.orLabel.style.display = 'block';
        this.contractNamesContainer.style.display = 'block';
        this.loadType = 'sol';
        this.selectContractNames.style.display = 'block';
        this.abiLabel.style.display = 'none';
        if (this.selectContractNames.value === '') this.enableAtAddress(false);
      } else {
        this.loadType = 'other';
        this.createPanel.style.display = 'none';
        this.orLabel.style.display = 'none';
        this.compFails.style.display = 'none';
        this.contractNamesContainer.style.display = 'none';
        this.abiLabel.style.display = 'none';
      }
    }
  }, {
    key: "setInputParamsPlaceHolder",
    value: function setInputParamsPlaceHolder() {
      var _this4 = this;

      this.createPanel.innerHTML = '';

      if (this.selectContractNames.selectedIndex < 0 || this.selectContractNames.children.length <= 0) {
        this.createPanel.innerHTML = 'No compiled contracts';
        return;
      }

      var selectedContract = this.getSelectedContract();

      var clickCallback = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(valArray, inputsValues) {
          var selectedContract;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  selectedContract = _this4.getSelectedContract();

                  _this4.createInstance(selectedContract, inputsValues);

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function clickCallback(_x, _x2) {
          return _ref2.apply(this, arguments);
        };
      }();

      var createConstructorInstance = new MultiParamManager(0, selectedContract.getConstructorInterface(), clickCallback, selectedContract.getConstructorInputs(), 'Deploy', selectedContract.bytecodeObject, true);
      this.createPanel.appendChild(createConstructorInstance.render());
      this.createPanel.appendChild(this.deployCheckBox);
    }
  }, {
    key: "getSelectedContract",
    value: function getSelectedContract() {
      var contract = this.selectContractNames.children[this.selectContractNames.selectedIndex];
      var contractName = contract.getAttribute('value');
      var compilerAtributeName = contract.getAttribute('compiler');
      return this.dropdownLogic.getSelectedContract(contractName, compilerAtributeName);
    }
  }, {
    key: "createInstance",
    value: function () {
      var _createInstance = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(selectedContract, args) {
        var _this5 = this;

        var continueCb, self, promptCb, statusCb, finalCb, contractMetadata, compilerContracts, confirmationCb;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(selectedContract.bytecodeObject.length === 0)) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return", modalDialogCustom.alert('This contract may be abstract, not implement an abstract parent\'s methods completely or not invoke an inherited contract\'s constructor correctly.'));

              case 2:
                continueCb = function continueCb(error, continueTxExecution, cancelCb) {
                  if (error) {
                    var msg = typeof error !== 'string' ? error.message : error;
                    modalDialog('Gas estimation failed', yo(_templateObject12(), msg), {
                      label: 'Send Transaction',
                      fn: function fn() {
                        continueTxExecution();
                      }
                    }, {
                      label: 'Cancel Transaction',
                      fn: function fn() {
                        cancelCb();
                      }
                    });
                  } else {
                    continueTxExecution();
                  }
                };

                self = this;

                promptCb = function promptCb(okCb, cancelCb) {
                  modalDialogCustom.promptPassphrase('Passphrase requested', 'Personal mode is enabled. Please provide passphrase of account', '', okCb, cancelCb);
                };

                statusCb = function statusCb(msg) {
                  return _this5.logCallback(msg);
                };

                finalCb = function finalCb(error, contractObject, address) {
                  self.event.trigger('clearInstance');

                  if (error) {
                    return _this5.logCallback(error);
                  }

                  self.event.trigger('newContractInstanceAdded', [contractObject, address, contractObject.name]);
                  var data = self.runView.compilersArtefacts.getCompilerAbstract(contractObject.contract.file);
                  self.runView.compilersArtefacts.addResolvedContract(helper.addressToString(address), data);

                  if (self.ipfsCheckedState) {
                    (0, _publishToStorage["default"])('ipfs', self.runView.fileProvider, self.runView.fileManager, selectedContract);
                  }
                };

                _context2.prev = 7;
                _context2.next = 10;
                return this.runView.call('compilerMetadata', 'deployMetadataOf', selectedContract.name, selectedContract.contract.file);

              case 10:
                contractMetadata = _context2.sent;
                _context2.next = 16;
                break;

              case 13:
                _context2.prev = 13;
                _context2.t0 = _context2["catch"](7);
                return _context2.abrupt("return", statusCb("creation of ".concat(selectedContract.name, " errored: ") + (_context2.t0.message ? _context2.t0.message : _context2.t0)));

              case 16:
                compilerContracts = this.dropdownLogic.getCompilerContracts();
                confirmationCb = this.getConfirmationCb(modalDialog, confirmDialog);

                if (!selectedContract.isOverSizeLimit()) {
                  _context2.next = 20;
                  break;
                }

                return _context2.abrupt("return", modalDialog('Contract code size over limit', yo(_templateObject13()), {
                  label: 'Force Send',
                  fn: function fn() {
                    _this5.deployContract(selectedContract, args, contractMetadata, compilerContracts, {
                      continueCb: continueCb,
                      promptCb: promptCb,
                      statusCb: statusCb,
                      finalCb: finalCb
                    }, confirmationCb);
                  }
                }, {
                  label: 'Cancel',
                  fn: function fn() {
                    _this5.logCallback("creation of ".concat(selectedContract.name, " canceled by user."));
                  }
                }));

              case 20:
                this.deployContract(selectedContract, args, contractMetadata, compilerContracts, {
                  continueCb: continueCb,
                  promptCb: promptCb,
                  statusCb: statusCb,
                  finalCb: finalCb
                }, confirmationCb);

              case 21:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[7, 13]]);
      }));

      function createInstance(_x3, _x4) {
        return _createInstance.apply(this, arguments);
      }

      return createInstance;
    }()
  }, {
    key: "deployContract",
    value: function deployContract(selectedContract, args, contractMetadata, compilerContracts, callbacks, confirmationCb) {
      var statusCb = callbacks.statusCb;

      if (!contractMetadata || contractMetadata && contractMetadata.autoDeployLib) {
        return this.blockchain.deployContractAndLibraries(selectedContract, args, contractMetadata, compilerContracts, callbacks, confirmationCb);
      }

      if (Object.keys(selectedContract.bytecodeLinkReferences).length) statusCb("linking ".concat(JSON.stringify(selectedContract.bytecodeLinkReferences, null, '\t'), " using ").concat(JSON.stringify(contractMetadata.linkReferences, null, '\t')));
      this.blockchain.deployContractWithLibrary(selectedContract, args, contractMetadata, compilerContracts, callbacks, confirmationCb);
    }
  }, {
    key: "getConfirmationCb",
    value: function getConfirmationCb(modalDialog, confirmDialog) {
      var _this6 = this;

      // this code is the same as in recorder.js. TODO need to be refactored out
      var confirmationCb = function confirmationCb(network, tx, gasEstimation, continueTxExecution, cancelCb) {
        if (network.name !== 'Main') {
          return continueTxExecution(null);
        }

        var amount = _this6.blockchain.fromWei(tx.value, true, 'ether');

        var content = confirmDialog(tx, amount, gasEstimation, null, _this6.blockchain.determineGasFees(tx), _this6.blockchain.determineGasPrice.bind(_this6.blockchain));
        modalDialog('Confirm transaction', content, {
          label: 'Confirm',
          fn: function fn() {
            _this6.blockchain.config.setUnpersistedProperty('doNotShowTransactionConfirmationAgain', content.querySelector('input#confirmsetting').checked); // TODO: check if this is check is still valid given the refactor


            if (!content.gasPriceStatus) {
              cancelCb('Given gas price is not correct');
            } else {
              var gasPrice = _this6.blockchain.toWei(content.querySelector('#gasprice').value, 'gwei');

              continueTxExecution(gasPrice);
            }
          }
        }, {
          label: 'Cancel',
          fn: function fn() {
            return cancelCb('Transaction canceled by user.');
          }
        });
      };

      return confirmationCb;
    }
  }, {
    key: "loadFromAddress",
    value: function loadFromAddress() {
      var _this7 = this;

      this.event.trigger('clearInstance');
      var address = this.atAddressButtonInput.value;
      this.dropdownLogic.loadContractFromAddress(address, function (cb) {
        modalDialogCustom.confirm(null, 'Do you really want to interact with ' + address + ' using the current ABI definition?', cb);
      }, function (error, loadType, abi) {
        if (error) {
          return modalDialogCustom.alert(error);
        }

        if (loadType === 'abi') {
          return _this7.event.trigger('newContractABIAdded', [abi, address]);
        }

        var selectedContract = _this7.getSelectedContract();

        _this7.event.trigger('newContractInstanceAdded', [selectedContract.object, address, _this7.selectContractNames.value]);
      });
    }
  }]);

  return ContractDropdownUI;
}();

module.exports = ContractDropdownUI;

/***/ }),

/***/ "./app/tabs/runTab/model/dropdownlogic.js":
/*!************************************************!*\
  !*** ./app/tabs/runTab/model/dropdownlogic.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ethJSUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var txHelper = remixLib.execution.txHelper;

var CompilerAbstract = __webpack_require__(/*! ../../../compiler/compiler-abstract */ "./app/compiler/compiler-abstract.js");

var EventManager = remixLib.EventManager;

var DropdownLogic = /*#__PURE__*/function () {
  function DropdownLogic(compilersArtefacts, config, editor, runView) {
    _classCallCheck(this, DropdownLogic);

    this.compilersArtefacts = compilersArtefacts;
    this.config = config;
    this.editor = editor;
    this.runView = runView;
    this.event = new EventManager();
    this.listenToCompilationEvents();
  } // TODO: can be moved up; the event in contractDropdown will have to refactored a method instead


  _createClass(DropdownLogic, [{
    key: "listenToCompilationEvents",
    value: function listenToCompilationEvents() {
      var _this = this;

      var broadcastCompilationResult = function broadcastCompilationResult(file, source, languageVersion, data) {
        // TODO check whether the tab is configured
        var compiler = new CompilerAbstract(languageVersion, data, source);
        _this.compilersArtefacts[languageVersion] = compiler;
        _this.compilersArtefacts.__last = compiler;

        _this.event.trigger('newlyCompiled', [true, data, source, compiler, languageVersion, file]);
      };

      this.runView.on('solidity', 'compilationFinished', function (file, source, languageVersion, data) {
        return broadcastCompilationResult(file, source, languageVersion, data);
      });
      this.runView.on('vyper', 'compilationFinished', function (file, source, languageVersion, data) {
        return broadcastCompilationResult(file, source, languageVersion, data);
      });
      this.runView.on('lexon', 'compilationFinished', function (file, source, languageVersion, data) {
        return broadcastCompilationResult(file, source, languageVersion, data);
      });
      this.runView.on('yulp', 'compilationFinished', function (file, source, languageVersion, data) {
        return broadcastCompilationResult(file, source, languageVersion, data);
      });
      this.runView.on('optimism-compiler', 'compilationFinished', function (file, source, languageVersion, data) {
        return broadcastCompilationResult(file, source, languageVersion, data);
      });
    }
  }, {
    key: "loadContractFromAddress",
    value: function loadContractFromAddress(address, confirmCb, cb) {
      var _this2 = this;

      if (!ethJSUtil.isValidAddress(address)) {
        return cb('Invalid address.');
      }

      if (/[a-f]/.test(address) && /[A-F]/.test(address) && !ethJSUtil.isValidChecksumAddress(address)) {
        return cb('Invalid checksum address.');
      }

      if (/.(.abi)$/.exec(this.config.get('currentFile'))) {
        confirmCb(function () {
          var abi;

          try {
            abi = JSON.parse(_this2.editor.currentContent());
          } catch (e) {
            return cb('Failed to parse the current file as JSON ABI.');
          }

          cb(null, 'abi', abi);
        });
      } else {
        cb(null, 'instance');
      }
    }
  }, {
    key: "getCompiledContracts",
    value: function getCompiledContracts(compiler, compilerFullName) {
      var contracts = [];
      compiler.visitContracts(function (contract) {
        contracts.push(contract);
      });
      return contracts;
    }
  }, {
    key: "getSelectedContract",
    value: function getSelectedContract(contractName, compilerAtributeName) {
      if (!contractName) return null;
      var compiler = this.compilersArtefacts[compilerAtributeName];
      if (!compiler) return null;
      var contract = compiler.getContract(contractName);
      return {
        name: contractName,
        contract: contract,
        compiler: compiler,
        abi: contract.object.abi,
        bytecodeObject: contract.object.evm.bytecode.object,
        bytecodeLinkReferences: contract.object.evm.bytecode.linkReferences,
        object: contract.object,
        deployedBytecode: contract.object.evm.deployedBytecode,
        getConstructorInterface: function getConstructorInterface() {
          return txHelper.getConstructorInterface(contract.object.abi);
        },
        getConstructorInputs: function getConstructorInputs() {
          var constructorInteface = txHelper.getConstructorInterface(contract.object.abi);
          return txHelper.inputParametersDeclarationToString(constructorInteface.inputs);
        },
        isOverSizeLimit: function isOverSizeLimit() {
          var deployedBytecode = contract.object.evm.deployedBytecode;
          return deployedBytecode && deployedBytecode.object.length / 2 > 24576;
        },
        metadata: contract.object.metadata
      };
    }
  }, {
    key: "getCompilerContracts",
    value: function getCompilerContracts() {
      return this.compilersArtefacts.__last.getData().contracts;
    }
  }]);

  return DropdownLogic;
}();

module.exports = DropdownLogic;

/***/ }),

/***/ "./app/tabs/runTab/model/recorder.js":
/*!*******************************************!*\
  !*** ./app/tabs/runTab/model/recorder.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

var ethutil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var EventManager = remixLib.EventManager;
var format = remixLib.execution.txFormat;
var txHelper = remixLib.execution.txHelper;

var helper = __webpack_require__(/*! ../../../../lib/helper */ "./lib/helper.js");
/**
  * Record transaction as long as the user create them.
  */


var Recorder = /*#__PURE__*/function () {
  function Recorder(blockchain) {
    var _this = this;

    _classCallCheck(this, Recorder);

    var self = this;
    self.event = new EventManager();
    self.blockchain = blockchain;
    self.data = {
      _listen: true,
      _replay: false,
      journal: [],
      _createdContracts: {},
      _createdContractsReverse: {},
      _usedAccounts: {},
      _abis: {},
      _contractABIReferences: {},
      _linkReferences: {}
    };
    this.blockchain.event.register('initiatingTransaction', function (timestamp, tx, payLoad) {
      if (tx.useCall) return;
      var from = tx.from,
          to = tx.to,
          value = tx.value; // convert to and from to tokens

      if (_this.data._listen) {
        var record = {
          value: value,
          parameters: payLoad.funArgs
        };

        if (!to) {
          var abi = payLoad.contractABI;
          var keccak = ethutil.bufferToHex(ethutil.keccak(JSON.stringify(abi)));
          record.abi = keccak;
          record.contractName = payLoad.contractName;
          record.bytecode = payLoad.contractBytecode;
          record.linkReferences = payLoad.linkReferences;

          if (record.linkReferences && Object.keys(record.linkReferences).length) {
            for (var file in record.linkReferences) {
              for (var lib in record.linkReferences[file]) {
                self.data._linkReferences[lib] = '<address>';
              }
            }
          }

          self.data._abis[keccak] = abi;
          _this.data._contractABIReferences[timestamp] = keccak;
        } else {
          var creationTimestamp = _this.data._createdContracts[to];
          record.to = "created{".concat(creationTimestamp, "}");
          record.abi = _this.data._contractABIReferences[creationTimestamp];
        }

        record.name = payLoad.funAbi.name;
        record.inputs = txHelper.serializeInputs(payLoad.funAbi);
        record.type = payLoad.funAbi.type;

        for (var p in record.parameters) {
          var thisarg = record.parameters[p];
          var thistimestamp = _this.data._createdContracts[thisarg];
          if (thistimestamp) record.parameters[p] = "created{".concat(thistimestamp, "}");
        }

        _this.blockchain.getAccounts(function (error, accounts) {
          if (error) return console.log(error);
          record.from = "account{".concat(accounts.indexOf(from), "}");
          self.data._usedAccounts[record.from] = from;
          self.append(timestamp, record);
        });
      }
    });
    this.blockchain.event.register('transactionExecuted', function (error, from, to, data, call, txResult, timestamp, _payload, rawAddress) {
      if (error) return console.log(error);
      if (call) return;
      if (!rawAddress) return; // not a contract creation

      var address = helper.addressToString(rawAddress); // save back created addresses for the convertion from tokens to real adresses

      _this.data._createdContracts[address] = timestamp;
      _this.data._createdContractsReverse[timestamp] = address;
    });
    this.blockchain.event.register('contextChanged', this.clearAll.bind(this));
    this.event.register('newTxRecorded', function (count) {
      _this.event.trigger('recorderCountChange', [count]);
    });
    this.event.register('cleared', function () {
      _this.event.trigger('recorderCountChange', [0]);
    });
  }
  /**
    * stop/start saving txs. If not listenning, is basically in replay mode
    *
    * @param {Bool} listen
    */


  _createClass(Recorder, [{
    key: "setListen",
    value: function setListen(listen) {
      this.data._listen = listen;
      this.data._replay = !listen;
    }
  }, {
    key: "extractTimestamp",
    value: function extractTimestamp(value) {
      var stamp = /created{(.*)}/g.exec(value);

      if (stamp) {
        return stamp[1];
      }

      return null;
    }
    /**
      * convert back from/to from tokens to real addresses
      *
      * @param {Object} record
      * @param {Object} accounts
      * @param {Object} options
      *
      */

  }, {
    key: "resolveAddress",
    value: function resolveAddress(record, accounts, options) {
      if (record.to) {
        var stamp = this.extractTimestamp(record.to);

        if (stamp) {
          record.to = this.data._createdContractsReverse[stamp];
        }
      }

      record.from = accounts[record.from]; // @TODO: writing browser test

      return record;
    }
    /**
      * save the given @arg record
      *
      * @param {Number/String} timestamp
      * @param {Object} record
      *
      */

  }, {
    key: "append",
    value: function append(timestamp, record) {
      var self = this;
      self.data.journal.push({
        timestamp: timestamp,
        record: record
      });
      self.event.trigger('newTxRecorded', [self.data.journal.length]);
    }
    /**
      * basically return the records + associate values (like abis / accounts)
      *
      */

  }, {
    key: "getAll",
    value: function getAll() {
      var self = this;
      var records = [].concat(self.data.journal);
      return {
        accounts: self.data._usedAccounts,
        linkReferences: self.data._linkReferences,
        transactions: records.sort(function (A, B) {
          var stampA = A.timestamp;
          var stampB = B.timestamp;
          return stampA - stampB;
        }),
        abis: self.data._abis
      };
    }
    /**
      * delete the seen transactions
      *
      */

  }, {
    key: "clearAll",
    value: function clearAll() {
      var self = this;
      self.data._listen = true;
      self.data._replay = false;
      self.data.journal = [];
      self.data._createdContracts = {};
      self.data._createdContractsReverse = {};
      self.data._usedAccounts = {};
      self.data._abis = {};
      self.data._contractABIReferences = {};
      self.data._linkReferences = {};
      self.event.trigger('cleared', []);
    }
    /**
      * run the list of records
      *
      * @param {Object} accounts
      * @param {Object} options
      * @param {Object} abis
      * @param {Function} newContractFn
      *
      */

  }, {
    key: "run",
    value: function run(records, accounts, options, abis, linkReferences, confirmationCb, continueCb, promptCb, alertCb, logCallBack, newContractFn) {
      var self = this;
      self.setListen(false);
      logCallBack("Running ".concat(records.length, " transaction(s) ..."));
      async.eachOfSeries(records, function (tx, index, cb) {
        var record = self.resolveAddress(tx.record, accounts, options);
        var abi = abis[tx.record.abi];

        if (!abi) {
          return alertCb('cannot find ABI for ' + tx.record.abi + '.  Execution stopped at ' + index);
        }
        /* Resolve Library */


        if (record.linkReferences && Object.keys(record.linkReferences).length) {
          for (var k in linkReferences) {
            var link = linkReferences[k];
            var timestamp = self.extractTimestamp(link);

            if (timestamp && self.data._createdContractsReverse[timestamp]) {
              link = self.data._createdContractsReverse[timestamp];
            }

            tx.record.bytecode = format.linkLibraryStandardFromlinkReferences(k, link.replace('0x', ''), tx.record.bytecode, tx.record.linkReferences);
          }
        }
        /* Encode params */


        var fnABI;

        if (tx.record.type === 'constructor') {
          fnABI = txHelper.getConstructorInterface(abi);
        } else if (tx.record.type === 'fallback') {
          fnABI = txHelper.getFallbackInterface(abi);
        } else if (tx.record.type === 'receive') {
          fnABI = txHelper.getReceiveInterface(abi);
        } else {
          fnABI = txHelper.getFunction(abi, record.name + record.inputs);
        }

        if (!fnABI) {
          alertCb('cannot resolve abi of ' + JSON.stringify(record, null, '\t') + '. Execution stopped at ' + index);
          return cb('cannot resolve abi');
        }

        if (tx.record.parameters) {
          /* check if we have some params to resolve */
          try {
            tx.record.parameters.forEach(function (value, index) {
              var isString = true;

              if (typeof value !== 'string') {
                isString = false;
                value = JSON.stringify(value);
              }

              for (var timestamp in self.data._createdContractsReverse) {
                value = value.replace(new RegExp('created\\{' + timestamp + '\\}', 'g'), self.data._createdContractsReverse[timestamp]);
              }

              if (!isString) value = JSON.parse(value);
              tx.record.parameters[index] = value;
            });
          } catch (e) {
            return alertCb('cannot resolve input parameters ' + JSON.stringify(tx.record.parameters) + '. Execution stopped at ' + index);
          }
        }

        var data = format.encodeData(fnABI, tx.record.parameters, tx.record.bytecode);

        if (data.error) {
          alertCb(data.error + '. Record:' + JSON.stringify(record, null, '\t') + '. Execution stopped at ' + index);
          return cb(data.error);
        }

        logCallBack("(".concat(index, ") ").concat(JSON.stringify(record, null, '\t')));
        logCallBack("(".concat(index, ") data: ").concat(data.data));
        record.data = {
          dataHex: data.data,
          funArgs: tx.record.parameters,
          funAbi: fnABI,
          contractBytecode: tx.record.bytecode,
          contractName: tx.record.contractName,
          timestamp: tx.timestamp
        };
        self.blockchain.runTx(record, confirmationCb, continueCb, promptCb, function (err, txResult, rawAddress) {
          if (err) {
            console.error(err);
            return logCallBack(err + '. Execution failed at ' + index);
          }

          if (rawAddress) {
            var address = helper.addressToString(rawAddress); // save back created addresses for the convertion from tokens to real adresses

            self.data._createdContracts[address] = tx.timestamp;
            self.data._createdContractsReverse[tx.timestamp] = address;
            newContractFn(abi, address, record.contractName);
          }

          cb(err);
        });
      }, function () {
        self.setListen(true);
        self.clearAll();
      });
    }
  }, {
    key: "runScenario",
    value: function runScenario(json, continueCb, promptCb, alertCb, confirmationCb, logCallBack, cb) {
      if (!json) {
        return cb('a json content must be provided');
      }

      if (typeof json === 'string') {
        try {
          json = JSON.parse(json);
        } catch (e) {
          return cb('A scenario file is required. It must be json formatted');
        }
      }

      try {
        var txArray = json.transactions || [];
        var accounts = json.accounts || [];
        var options = json.options || {};
        var abis = json.abis || {};
        var linkReferences = json.linkReferences || {};
      } catch (e) {
        return cb('Invalid Scenario File. Please try again');
      }

      if (!txArray.length) {
        return;
      }

      this.run(txArray, accounts, options, abis, linkReferences, confirmationCb, continueCb, promptCb, alertCb, logCallBack, function (abi, address, contractName) {
        cb(null, abi, address, contractName);
      });
    }
  }]);

  return Recorder;
}();

module.exports = Recorder;

/***/ }),

/***/ "./app/tabs/runTab/recorder.js":
/*!*************************************!*\
  !*** ./app/tabs/runTab/recorder.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<div>Gas estimation errored with the following message (see below).\n        The transaction execution will likely fail. Do you want to force sending? <br>\n        ", "\n        </div>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n      <i class=\"fas fa-save savetransaction ", " ", "\"\n        onclick=", " title=\"Save Transactions\" aria-hidden=\"true\">\n      </i>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<i class=\"fas fa-play runtransaction ", " ", "\"  title=\"Run Transactions\" aria-hidden=\"true\"></i>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n      .container {}\n      .runTxs {}\n      .recorder {}\n    "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var EventManager = remixLib.EventManager;

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = __webpack_require__(/*! ../styles/run-tab-styles */ "./app/tabs/styles/run-tab-styles.js");

var modalDialogCustom = __webpack_require__(/*! ../../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var modalDialog = __webpack_require__(/*! ../../ui/modaldialog */ "./app/ui/modaldialog.js");

var confirmDialog = __webpack_require__(/*! ../../ui/confirmDialog */ "./app/ui/confirmDialog.js");

var helper = __webpack_require__(/*! ../../../lib/helper.js */ "./lib/helper.js");

var profile = {
  name: 'recorder',
  methods: ['runScenario'],
  version: packageJson.version
};

var RecorderUI = /*#__PURE__*/function (_Plugin) {
  _inherits(RecorderUI, _Plugin);

  var _super = _createSuper(RecorderUI);

  function RecorderUI(blockchain, fileManager, recorder, logCallBack, config) {
    var _this;

    _classCallCheck(this, RecorderUI);

    _this = _super.call(this, profile);
    _this.fileManager = fileManager;
    _this.blockchain = blockchain;
    _this.recorder = recorder;
    _this.logCallBack = logCallBack;
    _this.config = config;
    _this.event = new EventManager();
    return _this;
  }

  _createClass(RecorderUI, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var css2 = csjs(_templateObject());
      this.runButton = yo(_templateObject2(), css2.runTxs, css.icon);
      this.recordButton = yo(_templateObject3(), css2.recorder, css.icon, this.triggerRecordButton.bind(this));

      this.runButton.onclick = function () {
        var file = _this2.config.get('currentFile');

        if (!file) return modalDialogCustom.alert('A scenario file has to be selected');

        _this2.runScenario(file);
      };
    }
  }, {
    key: "runScenario",
    value: function runScenario(file) {
      var _this3 = this;

      if (!file) return modalDialogCustom.alert('Unable to run scenerio, no specified scenario file');

      var continueCb = function continueCb(error, continueTxExecution, cancelCb) {
        if (error) {
          var msg = typeof error !== 'string' ? error.message : error;
          modalDialog('Gas estimation failed', yo(_templateObject4(), msg), {
            label: 'Send Transaction',
            fn: function fn() {
              continueTxExecution();
            }
          }, {
            label: 'Cancel Transaction',
            fn: function fn() {
              cancelCb();
            }
          });
        } else {
          continueTxExecution();
        }
      };

      var promptCb = function promptCb(okCb, cancelCb) {
        modalDialogCustom.promptPassphrase('Passphrase requested', 'Personal mode is enabled. Please provide passphrase of account', '', okCb, cancelCb);
      };

      var alertCb = function alertCb(msg) {
        modalDialogCustom.alert(msg);
      };

      var confirmationCb = this.getConfirmationCb(modalDialog, confirmDialog);
      this.fileManager.readFile(file).then(function (json) {
        // TODO: there is still a UI dependency to remove here, it's still too coupled at this point to remove easily
        _this3.recorder.runScenario(json, continueCb, promptCb, alertCb, confirmationCb, _this3.logCallBack, function (error, abi, address, contractName) {
          if (error) {
            return modalDialogCustom.alert(error);
          }

          _this3.event.trigger('newScenario', [abi, address, contractName]);
        });
      })["catch"](function (error) {
        return modalDialogCustom.alert(error);
      });
    }
  }, {
    key: "getConfirmationCb",
    value: function getConfirmationCb(modalDialog, confirmDialog) {
      var _this4 = this;

      // this code is the same as in contractDropdown.js. TODO need to be refactored out
      var confirmationCb = function confirmationCb(network, tx, gasEstimation, continueTxExecution, cancelCb) {
        if (network.name !== 'Main') {
          return continueTxExecution(null);
        }

        var amount = _this4.blockchain.fromWei(tx.value, true, 'ether');

        var content = confirmDialog(tx, amount, gasEstimation, null, _this4.blockchain.determineGasFees(tx), _this4.blockchain.determineGasPrice.bind(_this4.blockchain));
        modalDialog('Confirm transaction', content, {
          label: 'Confirm',
          fn: function fn() {
            _this4.config.setUnpersistedProperty('doNotShowTransactionConfirmationAgain', content.querySelector('input#confirmsetting').checked); // TODO: check if this is check is still valid given the refactor


            if (!content.gasPriceStatus) {
              cancelCb('Given gas price is not correct');
            } else {
              var gasPrice = _this4.blockchain.toWei(content.querySelector('#gasprice').value, 'gwei');

              continueTxExecution(gasPrice);
            }
          }
        }, {
          label: 'Cancel',
          fn: function fn() {
            return cancelCb('Transaction canceled by user.');
          }
        });
      };

      return confirmationCb;
    }
  }, {
    key: "triggerRecordButton",
    value: function triggerRecordButton() {
      this.saveScenario(function (path, cb) {
        modalDialogCustom.prompt('Save transactions as scenario', 'Transactions will be saved in a file under ' + path, 'scenario.json', cb);
      }, function (error) {
        if (error) return modalDialogCustom.alert(error);
      });
    }
  }, {
    key: "saveScenario",
    value: function saveScenario(promptCb, cb) {
      var _this5 = this;

      var txJSON = JSON.stringify(this.recorder.getAll(), null, 2);
      var path = this.fileManager.currentPath();
      promptCb(path, function (input) {
        var fileProvider = _this5.fileManager.fileProviderOf(path);

        if (!fileProvider) return;
        var newFile = path + '/' + input;
        helper.createNonClashingName(newFile, fileProvider, function (error, newFile) {
          if (error) return cb('Failed to create file. ' + newFile + ' ' + error);
          if (!fileProvider.set(newFile, txJSON)) return cb('Failed to create file ' + newFile);

          _this5.fileManager.open(newFile);
        });
      });
    }
  }]);

  return RecorderUI;
}(_engine.Plugin);

module.exports = RecorderUI;

/***/ }),

/***/ "./app/tabs/runTab/settings.js":
/*!*************************************!*\
  !*** ./app/tabs/runTab/settings.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject13() {
  var data = _taggedTemplateLiteral(["<option value=\"", "\" >", "</option>"]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteral(["\n              <div>\n                <b>hash:</b><br>\n                <span id=\"remixRunSignMsgHash\" data-id=\"settingsRemixRunSignMsgHash\">", "</span>\n                <br><b>signature:</b><br>\n                <span id=\"remixRunSignMsgSignature\" data-id=\"settingsRemixRunSignMsgSignature\">", "</span>\n              </div>\n            "]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function _templateObject11() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"\">\n        Note: To use Geth & https://remix.ethereum.org, configure it to allow requests from Remix:(see <a href=\"https://geth.ethereum.org/docs/rpc/server\" target=\"_blank\">Geth Docs on rpc server</a>)\n        <div class=\"border p-1\">geth --rpc --rpccorsdomain https://remix.ethereum.org</div>\n        <br>\n        To run Remix & a local Geth test node, use this command: (see <a href=\"https://geth.ethereum.org/getting-started/dev-mode\" target=\"_blank\">Geth Docs on Dev mode</a>)\n        <div class=\"border p-1\">geth --rpc --rpccorsdomain=\"", "\" --rpcapi web3,eth,debug,personal,net --vmdebug --datadir ", " --dev console</div>\n        <br>\n        <br> \n        <b>WARNING:</b> It is not safe to use the --rpccorsdomain flag with a wildcard: <b>--rpccorsdomain *</b>\n        <br>\n        <br>For more info: <a href=\"https://remix-ide.readthedocs.io/en/latest/run.html#more-about-web3-provider\" target=\"_blank\">Remix Docs on Web3 Provider</a>\n        <br>\n        <br> \n        Web3 Provider Endpoint\n      </div>\n    "]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["<span><b>", "</b> provider removed</span>"]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["<span><b>", "</b> provider added</span>"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["<option\n        title=\"provider name: ", "\"\n        value=\"", "\"\n        name=\"executionContext\"\n      >\n        ", "\n      </option>"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", "\">\n        ", "\n        ", "\n        ", "\n        ", "\n        ", "\n      </div>\n    "]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", "\">\n        <label class=\"", "\" data-id=\"remixDRValueLabel\">Value</label>\n        <div class=\"", "\">\n          <input\n            type=\"number\"\n            min=\"0\"\n            pattern=\"^[0-9]\"\n            step=\"1\"\n            class=\"form-control ", " ", "\"\n            id=\"value\"\n            data-id=\"dandrValue\"\n            value=\"0\"\n            title=\"Enter the value and choose the unit\"\n            onkeypress=", "\n            onchange=", "\n          >\n          <select name=\"unit\" class=\"form-control p-1 ", " ", " custom-select\" id=\"unit\">\n            <option data-unit=\"wei\">wei</option>\n            <option data-unit=\"gwei\">gwei</option>\n            <option data-unit=\"finney\">finney</option>\n            <option data-unit=\"ether\">ether</option>\n          </select>\n        </div>\n      </div>\n    "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", "\">\n        <label class=\"", "\">Gas limit</label>\n        <input type=\"number\" class=\"form-control ", " ", "\" id=\"gasLimit\" value=\"3000000\">\n      </div>\n    "]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", "\">\n        <label class=\"", "\">\n          Account\n          <span id=\"remixRunPlusWraper\" title=\"Create a new account\" onload=", ">\n            <i id=\"remixRunPlus\" class=\"fas fa-plus-circle ", "\" aria-hidden=\"true\" onclick=", "\"></i>\n          </span>\n        </label>\n        <div class=\"", "\">\n          <select data-id=\"runTabSelectAccount\" name=\"txorigin\" class=\"form-control ", " custom-select pr-4\" id=\"txorigin\"></select>\n          <div style=\"margin-left: -5px;\">", "</div>\n          <i id=\"remixRunSignMsg\" data-id=\"settingsRemixRunSignMsg\" class=\"mx-1 fas fa-edit ", "\" aria-hidden=\"true\" onclick=", " title=\"Sign a message using this account key\"></i>\n        </div>\n      </div>\n    "]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n    <div class=\"", "\">\n        <div class=\"", "\">\n        </div>\n        <div class=\"", "\" data-id=\"settingsNetworkEnv\">\n          ", "\n        </div>\n      </div>\n    "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", "\">\n        <label id=\"selectExEnv\" class=\"", "\">\n          Environment\n        </label>\n        <div class=\"", "\">\n          <select id=\"selectExEnvOptions\" data-id=\"settingsSelectEnvOptions\" onchange=", " class=\"form-control ", " custom-select\">\n            <option id=\"vm-mode\"\n              title=\"Execution environment does not connect to any node, everything is local and in memory only.\"\n              value=\"vm\" name=\"executionContext\"> JavaScript VM\n            </option>\n            <option id=\"injected-mode\"\n              title=\"Execution environment has been provided by Metamask or similar provider.\"\n              value=\"injected\" name=\"executionContext\"> Injected Web3\n            </option>\n            <option id=\"web3-mode\" data-id=\"settingsWeb3Mode\"\n              title=\"Execution environment connects to node at localhost (or via IPC if available), transactions will be sent to the network and can cause loss of money or worse!\n              If this page is served via https and you access your node via http, it might not work. In this case, try cloning the repository and serving it via http.\"\n              value=\"web3\" name=\"executionContext\"> Web3 Provider\n            </option>\n          </select>\n          <a href=\"https://remix-ide.readthedocs.io/en/latest/run.html#run-setup\" target=\"_blank\"><i class=\"", " ml-2 fas fa-info\" title=\"check out docs to setup Environment\"></i></a>\n        </div>\n      </div>\n    "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["<span class=\"", " badge badge-secondary\"></span>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var $ = __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var EventManager = remixLib.EventManager;

var css = __webpack_require__(/*! ../styles/run-tab-styles */ "./app/tabs/styles/run-tab-styles.js");

var copyToClipboard = __webpack_require__(/*! ../../ui/copy-to-clipboard */ "./app/ui/copy-to-clipboard.js");

var modalDialogCustom = __webpack_require__(/*! ../../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var addTooltip = __webpack_require__(/*! ../../ui/tooltip */ "./app/ui/tooltip.js");

var helper = __webpack_require__(/*! ../../../lib/helper.js */ "./lib/helper.js");

var globalRegistry = __webpack_require__(/*! ../../../global/registry */ "./global/registry.js");

var SettingsUI = /*#__PURE__*/function () {
  function SettingsUI(blockchain, networkModule) {
    var _this = this;

    _classCallCheck(this, SettingsUI);

    this.blockchain = blockchain;
    this.event = new EventManager();
    this._components = {};
    this.blockchain.event.register('transactionExecuted', function (error, from, to, data, lookupOnly, txResult) {
      if (!lookupOnly) _this.el.querySelector('#value').value = 0;
      if (error) return;

      _this.updateAccountBalances();
    });
    this._components = {
      registry: globalRegistry,
      networkModule: networkModule
    };
    this._components.registry = globalRegistry;
    this._deps = {
      config: this._components.registry.get('config').api
    };

    this._deps.config.events.on('settings/personal-mode_changed', this.onPersonalChange.bind(this));

    setInterval(function () {
      _this.updateAccountBalances();
    }, 1000);
    this.accountListCallId = 0;
    this.loadedAccounts = {};
  }

  _createClass(SettingsUI, [{
    key: "updateAccountBalances",
    value: function updateAccountBalances() {
      var _this2 = this;

      if (!this.el) return;
      var accounts = $(this.el.querySelector('#txorigin')).children('option');
      accounts.each(function (index, account) {
        _this2.blockchain.getBalanceInEther(account.value, function (err, balance) {
          if (err) return;
          var updated = helper.shortenAddress(account.value, balance);

          if (updated !== account.innerText) {
            // check if the balance has been updated and update UI accordingly.
            account.innerText = updated;
          }
        });
      });
    }
  }, {
    key: "validateInputKey",
    value: function validateInputKey(e) {
      // preventing not numeric keys
      // preventing 000 case
      if (!helper.isNumeric(e.key) || e.key === '0' && !parseInt(this.el.querySelector('#value').value) && this.el.querySelector('#value').value.length > 0) {
        e.preventDefault();
        e.stopImmediatePropagation();
      }
    }
  }, {
    key: "validateValue",
    value: function validateValue() {
      var valueEl = this.el.querySelector('#value');
      valueEl.value = parseInt(valueEl.value); // assign 0 if given value is
      // - empty
      // - not valid (for ex 4345-54)
      // - contains only '0's (for ex 0000) copy past or edit

      if (!valueEl.value) valueEl.value = 0; // if giveen value is negative(possible with copy-pasting) set to 0

      if (valueEl.value < 0) valueEl.value = 0;
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      this.netUI = yo(_templateObject(), css.network);
      var environmentEl = yo(_templateObject2(), css.crow, css.settingsLabel, css.environment, function () {
        _this3.updateNetwork();
      }, css.select, css.infoDeployAction);
      var networkEl = yo(_templateObject3(), css.crow, css.settingsLabel, css.environment, this.netUI);
      var accountEl = yo(_templateObject4(), css.crow, css.settingsLabel, this.updatePlusButton.bind(this), css.icon, this.newAccount.bind(this), css.account, css.select, copyToClipboard(function () {
        return document.querySelector('#runTabView #txorigin').value;
      }), css.icon, this.signMessage.bind(this));
      var gasPriceEl = yo(_templateObject5(), css.crow, css.settingsLabel, css.gasNval, css.col2);
      var valueEl = yo(_templateObject6(), css.crow, css.settingsLabel, css.gasValueContainer, css.gasNval, css.col2, function (e) {
        return _this3.validateInputKey(e);
      }, function () {
        return _this3.validateValue();
      }, css.gasNvalUnit, css.col2_2);
      var el = yo(_templateObject7(), css.settings, environmentEl, networkEl, accountEl, gasPriceEl, valueEl);
      var selectExEnv = environmentEl.querySelector('#selectExEnvOptions');
      this.setDropdown(selectExEnv);
      this.blockchain.event.register('contextChanged', function (context, silent) {
        _this3.setFinalContext();
      });
      setInterval(function () {
        _this3.updateNetwork();
      }, 1000);
      this.el = el;
      this.fillAccountsList();
      return el;
    }
  }, {
    key: "setDropdown",
    value: function setDropdown(selectExEnv) {
      var _this4 = this;

      this.selectExEnv = selectExEnv;

      var addProvider = function addProvider(network) {
        selectExEnv.appendChild(yo(_templateObject8(), network.name, network.name, network.name));
        addTooltip(yo(_templateObject9(), network.name));
      };

      var removeProvider = function removeProvider(name) {
        var env = selectExEnv.querySelector("option[value=\"".concat(name, "\"]"));

        if (env) {
          selectExEnv.removeChild(env);
          addTooltip(yo(_templateObject10(), name));
        }
      };

      this.blockchain.event.register('addProvider', function (provider) {
        return addProvider(provider);
      });
      this.blockchain.event.register('removeProvider', function (name) {
        return removeProvider(name);
      });
      selectExEnv.addEventListener('change', function (event) {
        var context = selectExEnv.options[selectExEnv.selectedIndex].value;

        _this4.blockchain.changeExecutionContext(context, function () {
          modalDialogCustom.prompt('External node request', _this4.web3ProviderDialogBody(), 'http://127.0.0.1:8545', function (target) {
            _this4.blockchain.setProviderFromEndpoint(target, context, function (alertMsg) {
              if (alertMsg) addTooltip(alertMsg);

              _this4.setFinalContext();
            });
          }, _this4.setFinalContext.bind(_this4));
        }, function (alertMsg) {
          addTooltip(alertMsg);
        }, _this4.setFinalContext.bind(_this4));
      });
      selectExEnv.value = this.blockchain.getProvider();
    }
  }, {
    key: "web3ProviderDialogBody",
    value: function web3ProviderDialogBody() {
      var thePath = '<path/to/local/folder/for/test/chain>';
      return yo(_templateObject11(), window.origin, thePath);
    }
  }, {
    key: "setFinalContext",
    value: function setFinalContext() {
      // set the final context. Cause it is possible that this is not the one we've originaly selected
      this.selectExEnv.value = this.blockchain.getProvider();
      this.event.trigger('clearInstance', []);
      this.updateNetwork();
      this.updatePlusButton();
    }
  }, {
    key: "updatePlusButton",
    value: function updatePlusButton() {
      // enable/disable + button
      var plusBtn = document.getElementById('remixRunPlus');
      var plusTitle = document.getElementById('remixRunPlusWraper');

      switch (this.selectExEnv.value) {
        case 'injected':
          plusBtn.classList.add(css.disableMouseEvents);
          plusTitle.title = "Unfortunately it's not possible to create an account using injected web3. Please create the account directly from your provider (i.e metamask or other of the same type).";
          break;

        case 'vm':
          plusBtn.classList.remove(css.disableMouseEvents);
          plusTitle.title = 'Create a new account';
          break;

        case 'web3':
          this.onPersonalChange();
          break;

        default:
          {
            plusBtn.classList.add(css.disableMouseEvents);
            plusTitle.title = "Unfortunately it's not possible to create an account using an external wallet (".concat(this.selectExEnv.value, ").");
          }
      }
    }
  }, {
    key: "onPersonalChange",
    value: function onPersonalChange() {
      var plusBtn = document.getElementById('remixRunPlus');
      var plusTitle = document.getElementById('remixRunPlusWraper');

      if (!this._deps.config.get('settings/personal-mode')) {
        plusBtn.classList.add(css.disableMouseEvents);
        plusTitle.title = 'Creating an account is possible only in Personal mode. Please go to Settings to enable it.';
      } else {
        plusBtn.classList.remove(css.disableMouseEvents);
        plusTitle.title = 'Create a new account';
      }
    }
  }, {
    key: "newAccount",
    value: function newAccount() {
      this.blockchain.newAccount('', function (cb) {
        modalDialogCustom.promptPassphraseCreation(function (error, passphrase) {
          if (error) {
            return modalDialogCustom.alert(error);
          }

          cb(passphrase);
        }, function () {});
      }, function (error, address) {
        if (error) {
          return addTooltip('Cannot create an account: ' + error);
        }

        addTooltip("account ".concat(address, " created"));
      });
    }
  }, {
    key: "signMessage",
    value: function signMessage() {
      var _this5 = this;

      this.blockchain.getAccounts(function (err, accounts) {
        if (err) {
          return addTooltip("Cannot get account list: ".concat(err));
        }

        var signMessageDialog = {
          title: 'Sign a message',
          text: 'Enter a message to sign',
          inputvalue: 'Message to sign'
        };

        var $txOrigin = _this5.el.querySelector('#txorigin');

        if (!$txOrigin.selectedOptions[0] && (_this5.blockchain.isInjectedWeb3() || _this5.blockchain.isWeb3Provider())) {
          return addTooltip('Account list is empty, please make sure the current provider is properly connected to remix');
        }

        var account = $txOrigin.selectedOptions[0].value;

        var promptCb = function promptCb(passphrase) {
          var modal = modalDialogCustom.promptMulti(signMessageDialog, function (message) {
            _this5.blockchain.signMessage(message, account, passphrase, function (err, msgHash, signedData) {
              if (err) {
                return addTooltip(err);
              }

              modal.hide();
              modalDialogCustom.alert(yo(_templateObject12(), msgHash, signedData));
            });
          }, false);
        };

        if (_this5.blockchain.isWeb3Provider()) {
          return modalDialogCustom.promptPassphrase('Passphrase to sign a message', 'Enter your passphrase for this account to sign the message', '', promptCb, false);
        }

        promptCb();
      });
    }
  }, {
    key: "updateNetwork",
    value: function updateNetwork() {
      var _this6 = this;

      this.blockchain.updateNetwork(function (err) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            id = _ref.id,
            name = _ref.name;

        if (err) {
          _this6.netUI.innerHTML = 'can\'t detect network ';
          return;
        }

        var network = _this6._components.networkModule.getNetworkProvider.bind(_this6._components.networkModule);

        _this6.netUI.innerHTML = network() !== 'vm' ? "".concat(name, " (").concat(id || '-', ") network") : '';
      });
      this.fillAccountsList();
    } // TODO: unclear what's the goal of accountListCallId, feels like it can be simplified

  }, {
    key: "fillAccountsList",
    value: function fillAccountsList() {
      var _this7 = this;

      this.accountListCallId++;
      var callid = this.accountListCallId;
      var txOrigin = this.el.querySelector('#txorigin');
      this.blockchain.getAccounts(function (err, accounts) {
        if (_this7.accountListCallId > callid) return;
        _this7.accountListCallId++;

        if (err) {
          addTooltip("Cannot get account list: ".concat(err));
        }

        for (var loadedaddress in _this7.loadedAccounts) {
          if (accounts.indexOf(loadedaddress) === -1) {
            txOrigin.removeChild(txOrigin.querySelector('option[value="' + loadedaddress + '"]'));
            delete _this7.loadedAccounts[loadedaddress];
          }
        }

        for (var i in accounts) {
          var address = accounts[i];

          if (!_this7.loadedAccounts[address]) {
            txOrigin.appendChild(yo(_templateObject13(), address, address));
            _this7.loadedAccounts[address] = 1;
          }
        }

        txOrigin.setAttribute('value', accounts[0]);
      });
    }
  }]);

  return SettingsUI;
}();

module.exports = SettingsUI;

/***/ }),

/***/ "./app/tabs/settings-tab.js":
/*!**********************************!*\
  !*** ./app/tabs/settings-tab.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engineWeb = __webpack_require__(/*! @remixproject/engine-web */ "../../../node_modules/@remixproject/engine-web/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject20() {
  var data = _taggedTemplateLiteral(["\n      <div id=\"settingsView\" data-id=\"settingsTabSettingsView\">\n        ", "\n        ", "\n        ", "\n      </div>"]);

  _templateObject20 = function _templateObject20() {
    return data;
  };

  return data;
}

function _templateObject19() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", " border-top\">\n        <div class=\"card-body pt-3 pb-2\">\n          <h6 class=\"", " card-title\">Themes</h6>\n            ", "\n        </div>\n      </div>"]);

  _templateObject19 = function _templateObject19() {
    return data;
  };

  return data;
}

function _templateObject18() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", " border-top\">\n        <div class=\"card-body pt-3 pb-2\">\n          <h6 class=\"", " card-title\">Github Access Token</h6>\n          <p class=\"mb-1\">Manage the access token used to publish to Gist and retrieve Github contents.</p>\n          <p class=\"\">Go to github token page (link below) to create a new token and save it in Remix. Make sure this token has only 'create gist' permission.</p>\n          <p class=\"", " mb-1\"><a class=\"text-primary ", "\" target=\"_blank\" href=\"https://github.com/settings/tokens\">https://github.com/settings/tokens</a></p>\n          <div class=\"", "\"><label>TOKEN:</label>", "</div>\n        </div>\n      </div>"]);

  _templateObject18 = function _templateObject18() {
    return data;
  };

  return data;
}

function _templateObject17() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", " border-top\">\n        <div class=\"card-body pt-3 pb-2\">\n          <h6 class=\"", " card-title\">General settings</h6>\n          <div class=\"mt-2 custom-control custom-checkbox mb-1\">\n            ", "\n            ", "\n          </div>\n          <div class=\"fmt-2 custom-control custom-checkbox mb-1\">\n            ", "\n            ", "\n          </div>\n          <div class=\"mt-2 custom-control custom-checkbox mb-1\">\n            ", "\n            ", "\n          </div>\n          <div class=\"custom-control custom-checkbox mb-1\">\n            ", ">\n            ", "\n          </div>\n        </div>\n      </div>\n      "]);

  _templateObject17 = function _templateObject17() {
    return data;
  };

  return data;
}

function _templateObject16() {
  var data = _taggedTemplateLiteral(["<textarea rows=\"4\" cols=\"70\" id=\"plugininput\" type=\"text\" class=\"", "\" ></textarea>"]);

  _templateObject16 = function _templateObject16() {
    return data;
  };

  return data;
}

function _templateObject15() {
  var data = _taggedTemplateLiteral(["<label class=\"form-check-label custom-control-label align-middle\" data-id=\"settingsTabGenerateContractMetadataLabel\" for=\"generatecontractmetadata\">Generate contract metadata. Generate a JSON file in the contract folder. Allows to specify library addresses the contract depends on. If nothing is specified, Remix deploys libraries automatically.</label>"]);

  _templateObject15 = function _templateObject15() {
    return data;
  };

  return data;
}

function _templateObject14() {
  var data = _taggedTemplateLiteral(["<input onchange=", " id=\"generatecontractmetadata\" data-id=\"settingsTabGenerateContractMetadata\" type=\"checkbox\" class=\"custom-control-input\">"]);

  _templateObject14 = function _templateObject14() {
    return data;
  };

  return data;
}

function _templateObject13() {
  var data = _taggedTemplateLiteral(["<label class=\"form-check-label custom-control-label align-middle\" for=\"personal\"> ", " Enable Personal Mode for web3 provider. ", "></label>"]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteral(["<i class=\"", " fas fa-exclamation-triangle text-warning\" aria-hidden=\"true\"></i>"]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function _templateObject11() {
  var data = _taggedTemplateLiteral(["<input onchange=", " id=\"personal\" type=\"checkbox\" class=\"custom-control-input\">"]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["<label class=\"form-check-label custom-control-label align-middle\" for=\"editorWrap\">Text Wrap</label>"]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["<input id=\"editorWrap\" class=\"custom-control-input\" type=\"checkbox\" onchange=", ">"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["<label class=\"form-check-label custom-control-label align-middle\" for=\"alwaysUseVM\">Always use Ethereum VM at Load</label>"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["<input onchange=", " class=\"custom-control-input\" id=\"alwaysUseVM\" data-id=\"settingsTabAlwaysUseVM\" type=\"checkbox\">"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"text-secondary mb-0 h6\">\n        ", "\n        <div class=\"d-flex justify-content-end pt-2\">\n          ", "", "", "\n        </div>\n        <p class=\"pt-1\">\n          <i class=\"", " fas fa-exclamation-triangle text-warning\" aria-hidden=\"true\"></i>\n          <span class=\"text-warning\">Please reload Remix after having saved the token.</span>\n        </p>\n      </div>\n    "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["<button class=\"btn btn-sm btn-secondary ml-2\" id=\"removegisttoken\" data-id=\"settingsTabRemoveGistToken\" title=\"Delete Github access token\" onclick=", ">Remove</button>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<input class=\"btn btn-sm btn-primary ml-2\" id=\"savegisttoken\" data-id=\"settingsTabSaveGistToken\" onclick=", " value=\"Save\" type=\"button\">"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<input id=\"gistaccesstoken\" data-id=\"settingsTabGistAccessToken\" type=\"password\" class=\"form-control\">"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<div class=\"radio custom-control custom-radio mb-1 form-check ", "\">\n          <input type=\"radio\" onchange=", " class=\"align-middle custom-control-input\" name=\"theme\" id=\"", "\" data-id=\"settingsTabTheme", "\">\n          <label class=\"form-check-label custom-control-label\" data-id=\"settingsTabThemeLabel", "\" for=\"", "\">", " (", ")</label>\n        </div>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["<div class=\"card-text themes-container\">\n        ", "\n      </div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var tooltip = __webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js");

var copyToClipboard = __webpack_require__(/*! ../ui/copy-to-clipboard */ "./app/ui/copy-to-clipboard.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

var css = __webpack_require__(/*! ./styles/settings-tab-styles */ "./app/tabs/styles/settings-tab-styles.js");

var profile = {
  name: 'settings',
  displayName: 'Settings',
  methods: ['getGithubAccessToken'],
  events: [],
  icon: 'assets/img/settings.webp',
  description: 'Remix-IDE settings',
  kind: 'settings',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/settings.html',
  version: packageJson.version,
  permission: true
};

module.exports = /*#__PURE__*/function (_ViewPlugin) {
  _inherits(SettingsTab, _ViewPlugin);

  var _super = _createSuper(SettingsTab);

  function SettingsTab(config, editor, appManager) {
    var _this;

    _classCallCheck(this, SettingsTab);

    _this = _super.call(this, profile);
    _this.config = config;
    _this.editor = editor;
    _this.appManager = appManager;
    _this._components = {};
    _this._deps = {
      themeModule: globalRegistry.get('themeModule').api
    };
    _this._view = {
      /* eslint-disable */
      el: null,
      optionVM: null,
      optionVMLabel: null,
      personal: null,
      personalLabel: null,
      warnPersonalMode: null,
      generateContractMetadata: null,
      generateContractMetadataLabel: null,
      config: {
        general: null,
        themes: null
      },
      textWrap: null,
      textWrapLabel: null
    };
    /* eslint-enable */

    _this.event = new EventManager();
    return _this;
  }

  _createClass(SettingsTab, [{
    key: "createThemeCheckies",
    value: function createThemeCheckies() {
      var _this2 = this;

      var themes = this._deps.themeModule.getThemes();

      var onswitchTheme = function onswitchTheme(event, name) {
        _this2._deps.themeModule.switchTheme(name);
      };

      if (themes) {
        return yo(_templateObject(), themes.map(function (aTheme) {
          var el = yo(_templateObject2(), css.crow, function (event) {
            onswitchTheme(event, aTheme.name);
          }, aTheme.name, aTheme.name, aTheme.name, aTheme.name, aTheme.name, aTheme.quality);
          if (_this2._deps.themeModule.active === aTheme.name) el.querySelector('input').setAttribute('checked', 'checked');
          return el;
        }));
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var self = this;
      if (self._view.el) return self._view.el; // Gist settings

      var token = this.config.get('settings/gist-access-token');
      var gistAccessToken = yo(_templateObject3());
      if (token) gistAccessToken.value = token;

      var removeToken = function removeToken() {
        self.config.set('settings/gist-access-token', '');
        gistAccessToken.value = '';
        tooltip('Access token removed');
      };

      var saveToken = function saveToken() {
        _this3.config.set('settings/gist-access-token', gistAccessToken.value);

        tooltip('Access token has been saved. RELOAD the page to apply it.');
      };

      var gistAddToken = yo(_templateObject4(), function () {
        return saveToken();
      });
      var gistRemoveToken = yo(_templateObject5(), function () {
        return removeToken();
      });
      this._view.gistToken = yo(_templateObject6(), gistAccessToken, copyToClipboard(function () {
        return gistAccessToken.value;
      }), gistAddToken, gistRemoveToken, css.icon);
      this._view.optionVM = yo(_templateObject7(), onchangeOption);
      this._view.optionVMLabel = yo(_templateObject8());
      if (this.config.get('settings/always-use-vm') === undefined) this.config.set('settings/always-use-vm', true);
      if (this.config.get('settings/always-use-vm')) this._view.optionVM.setAttribute('checked', '');
      elementStateChanged(self._view.optionVMLabel, !this.config.get('settings/always-use-vm'));
      this._view.textWrap = yo(_templateObject9(), textWrapEvent);
      this._view.textWrapLabel = yo(_templateObject10());
      if (this.config.get('settings/text-wrap')) this._view.textWrap.setAttribute('checked', '');
      elementStateChanged(self._view.textWrapLabel, !this.config.get('settings/text-wrap'));
      var warnText = "Transaction sent over Web3 will use the web3.personal API - be sure the endpoint is opened before enabling it.\n    This mode allows to provide the passphrase in the Remix interface without having to unlock the account.\n    Although this is very convenient, you should completely trust the backend you are connected to (Geth, Parity, ...).\n    Remix never persist any passphrase.".split('\n').map(function (s) {
        return s.trim();
      }).join(' ');
      this._view.personal = yo(_templateObject11(), onchangePersonal);
      this._view.warnPersonalMode = yo(_templateObject12(), css.icon);
      this._view.personalLabel = yo(_templateObject13(), this._view.warnPersonalMode, warnText);
      if (this.config.get('settings/personal-mode')) this._view.personal.setAttribute('checked', '');
      elementStateChanged(self._view.personalLabel, !this.config.get('settings/personal-mode'));
      this._view.generateContractMetadata = yo(_templateObject14(), onchangeGenerateContractMetadata);
      this._view.generateContractMetadataLabel = yo(_templateObject15());
      if (this.config.get('settings/generate-contract-metadata') === undefined) this.config.set('settings/generate-contract-metadata', true);
      if (this.config.get('settings/generate-contract-metadata')) this._view.generateContractMetadata.setAttribute('checked', '');
      elementStateChanged(self._view.generateContractMetadataLabel, !this.config.get('settings/generate-contract-metadata'));
      this._view.pluginInput = yo(_templateObject16(), css.pluginTextArea);
      this._view.themes = this._deps.themeModule.getThemes();
      this._view.themesCheckBoxes = this.createThemeCheckies();
      this._view.config.general = yo(_templateObject17(), css.info, css.title, this._view.generateContractMetadata, this._view.generateContractMetadataLabel, this._view.optionVM, this._view.optionVMLabel, this._view.textWrap, this._view.textWrapLabel, this._view.personal, this._view.personalLabel);
      this._view.gistToken = yo(_templateObject18(), css.info, css.title, css.crowNoFlex, css.text, css.crowNoFlex, this._view.gistToken);
      this._view.config.themes = yo(_templateObject19(), css.info, css.title, this._view.themesCheckBoxes);
      this._view.el = yo(_templateObject20(), this._view.config.general, this._view.gistToken, this._view.config.themes);

      function onchangeGenerateContractMetadata(event) {
        var isChecked = self.config.get('settings/generate-contract-metadata');
        self.config.set('settings/generate-contract-metadata', !isChecked);
        elementStateChanged(self._view.generateContractMetadataLabel, isChecked);
      }

      function onchangeOption(event) {
        var isChecked = self.config.get('settings/always-use-vm');
        self.config.set('settings/always-use-vm', !isChecked);
        elementStateChanged(self._view.optionVMLabel, isChecked);
      }

      function textWrapEvent(event) {
        var isChecked = self.config.get('settings/text-wrap');
        self.config.set('settings/text-wrap', !isChecked);
        elementStateChanged(self._view.textWrapLabel, isChecked);
        self.editor.resize(!isChecked);
      }

      function onchangePersonal(event) {
        var isChecked = self.config.get('settings/personal-mode');
        self.config.set('settings/personal-mode', !isChecked);
        elementStateChanged(self._view.personalLabel, isChecked);
      }

      function elementStateChanged(el, isChanged) {
        if (isChanged) {
          el.classList.remove('text-dark');
          el.classList.add('text-secondary');
        } else {
          el.classList.add('text-dark');
          el.classList.remove('text-secondary');
        }
      }

      this._deps.themeModule.switchTheme();

      return this._view.el;
    }
  }, {
    key: "getGithubAccessToken",
    value: function getGithubAccessToken() {
      return this.config.get('settings/gist-access-token');
    }
  }]);

  return SettingsTab;
}(_engineWeb.ViewPlugin);

/***/ }),

/***/ "./app/tabs/staticanalysis/staticAnalysisView.js":
/*!*******************************************************!*\
  !*** ./app/tabs/staticanalysis/staticAnalysisView.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject8() {
  var data = _taggedTemplateLiteral(["\n    <div class=\"accordion\" id=\"accordionModules\">\n      ", "\n    </div>"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", "\">\n        <input type=\"radio\" name=\"accordion\" class=\"w-100 d-none card\" id=\"heading", "\" onclick=", "\"/>\n        <label for=\"heading", "\" style=\"cursor: pointer;\" class=\"pl-3 card-header h6 d-flex justify-content-between font-weight-bold border-left px-1 py-2 w-100\">\n          ", "\n          <div>\n            <i class=\"fas fa-angle-double-right\"></i>\n          </div>\n        </label>\n        <div class=\"w-100 d-block px-2 my-1 ", "\">\n          ", "\n        </div>\n      </div>\n    "]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n        <div class=\"form-check\">\n          <input id=\"staticanalysismodule_", "_", "\"\n            type=\"checkbox\"\n            class=\"form-check-input staticAnalysisItem\"\n            name=\"staticanalysismodule\"\n            index=", "\n            checked=\"true\"\n            style=\"vertical-align:bottom\"\n            onclick=\"", "\"\n          >\n          <label for=\"staticanalysismodule_", "_", "\" class=\"form-check-label mb-1\">\n            <p class=\"mb-0 font-weight-bold text-capitalize\">", "</p>\n            ", "\n          </label>\n        </div>\n      "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["<span></span>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<span><a href=\"", "\" target=\"_blank\">more</a></span>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n            <span class=\"d-flex flex-column\">\n              <span class=\"h6 font-weight-bold\">", "</span>\n              ", "\n              ", "\n              <span class=\"\" title=\"Position in ", "\">Pos: ", "</span>\n            </span>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n    <div class=\"", "\">\n      <div class=\"my-2 d-flex flex-column align-items-left\">\n        <div class=\"", " d-flex justify-content-between\">\n          <div class=\"pl-2 ", "\" for=\"checkAllEntries\">\n            <input id=\"checkAllEntries\"\n              type=\"checkbox\"\n              onclick=\"", "\"\n              style=\"vertical-align:bottom\"\n              checked=\"true\"\n            >\n            <label class=\"text-nowrap pl-2 mb-0\" for=\"checkAllEntries\">\n              Select all\n            </label>\n          </div>\n          <div class=\"", "\" for=\"autorunstaticanalysis\">\n            <input id=\"autorunstaticanalysis\"\n              type=\"checkbox\"\n              style=\"vertical-align:bottom\"\n              checked=\"true\"\n            >\n            <label class=\"text-nowrap pl-2 mb-0\" for=\"autorunstaticanalysis\">\n              Autorun\n            </label>\n          </div>\n          ", "\n        </div>\n      </div>\n      <div id=\"staticanalysismodules\" class=\"list-group list-group-flush\">\n        ", "\n      </div>\n      <div class=\"mt-2 p-2 d-flex border-top flex-column\">\n        <span>last results for:</span>\n        <span class=\"text-break break-word word-break font-weight-bold\" id=\"staticAnalysisCurrentFile\">", "</span>\n      </div>\n      <div class=\"", " my-1\" id='staticanalysisresult'></div>\n    </div>\n  "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["<button class=\"btn btn-sm w-25 btn-primary\" onclick=\"", "\" >Run</button>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var StaticAnalysisRunner = __webpack_require__(/*! @remix-project/remix-analyzer */ "../../../dist/libs/remix-analyzer/index.js").CodeAnalysis;

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var $ = __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var utils = remixLib.util;

var css = __webpack_require__(/*! ./styles/staticAnalysisView-styles */ "./app/tabs/staticanalysis/styles/staticAnalysisView-styles.js");

var Renderer = __webpack_require__(/*! ../../ui/renderer */ "./app/ui/renderer.js");

var SourceHighlighter = __webpack_require__(/*! ../../editor/sourceHighlighter */ "./app/editor/sourceHighlighter.js");

var EventManager = __webpack_require__(/*! ../../../lib/events */ "./lib/events.js");

function staticAnalysisView(localRegistry, analysisModule) {
  var self = this;
  this.event = new EventManager();
  this.view = null;
  this.runner = new StaticAnalysisRunner();
  this.modulesView = this.renderModules();
  this.lastCompilationResult = null;
  this.lastCompilationSource = null;
  this.currentFile = 'No file compiled';
  this.sourceHighlighter = new SourceHighlighter();
  this.analysisModule = analysisModule;
  self._components = {
    renderer: new Renderer()
  };
  self._components.registry = localRegistry; // dependencies

  self._deps = {
    offsetToLineColumnConverter: self._components.registry.get('offsettolinecolumnconverter').api
  };
  analysisModule.on('solidity', 'compilationFinished', function (file, source, languageVersion, data) {
    self.lastCompilationResult = null;
    self.lastCompilationSource = null;
    if (languageVersion.indexOf('soljson') !== 0) return;
    self.lastCompilationResult = data;
    self.lastCompilationSource = source;
    self.currentFile = file;
    self.correctRunBtnDisabled();

    if (self.view && self.view.querySelector('#autorunstaticanalysis').checked) {
      self.run();
    }
  });
}

staticAnalysisView.prototype.render = function () {
  var _this = this;

  this.runBtn = yo(_templateObject(), function () {
    _this.run();
  });
  var view = yo(_templateObject2(), css.analysis, css.top, css.label, function (event) {
    _this.checkAll(event);
  }, css.label, this.runBtn, this.modulesView, this.currentFile, css.result);

  if (!this.view) {
    this.view = view;
  }

  this.correctRunBtnDisabled();
  return view;
};

staticAnalysisView.prototype.selectedModules = function () {
  if (!this.view) {
    return [];
  }

  var selected = this.view.querySelectorAll('[name="staticanalysismodule"]:checked');
  var toRun = [];

  for (var i = 0; i < selected.length; i++) {
    toRun.push(selected[i].attributes.index.value);
  }

  return toRun;
};

staticAnalysisView.prototype.run = function () {
  var _this2 = this;

  if (!this.view) {
    return;
  }

  var highlightLocation = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(location, fileName) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this2.analysisModule.call('editor', 'discardHighlight');

            case 2:
              _context.next = 4;
              return _this2.analysisModule.call('editor', 'highlight', location, fileName);

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function highlightLocation(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();

  var selected = this.selectedModules();
  var warningContainer = $('#staticanalysisresult');
  warningContainer.empty();
  this.view.querySelector('#staticAnalysisCurrentFile').innerText = this.currentFile;
  var self = this;

  if (this.lastCompilationResult && selected.length) {
    this.runBtn.removeAttribute('disabled');
    var warningCount = 0;
    this.runner.run(this.lastCompilationResult, selected, function (results) {
      var groupedModules = utils.groupBy(preProcessModules(_this2.runner.modules()), 'categoryId');
      results.map(function (result, j) {
        var moduleName;
        Object.keys(groupedModules).map(function (key) {
          groupedModules[key].forEach(function (el) {
            if (el.name === result.name) {
              moduleName = groupedModules[key][0].categoryDisplayName;
            }
          });
        });

        var alreadyExistedEl = _this2.view.querySelector("[id=\"staticAnalysisModule".concat(moduleName, "\"]"));

        if (!alreadyExistedEl) {
          warningContainer.append("\n            <div class=\"mb-4\" name=\"staticAnalysisModules\" id=\"staticAnalysisModule".concat(moduleName, "\">\n              <span class=\"text-dark h6\">").concat(moduleName, "</span>\n            </div>\n          "));
        }

        result.report.map(function (item, i) {
          var location = '';
          var locationString = 'not available';
          var column = 0;
          var row = 0;
          var fileName = _this2.currentFile;

          if (item.location) {
            var split = item.location.split(':');
            var file = split[2];
            location = {
              start: parseInt(split[0]),
              length: parseInt(split[1])
            };
            location = self._deps.offsetToLineColumnConverter.offsetToLineColumn(location, parseInt(file), self.lastCompilationSource.sources, self.lastCompilationResult.sources);
            row = location.start.line;
            column = location.start.column;
            locationString = row + 1 + ':' + column + ':';
            fileName = Object.keys(self.lastCompilationResult.contracts)[file];
          }

          warningCount++;
          var msg = yo(_templateObject3(), result.name, item.warning, item.more ? yo(_templateObject4(), item.more) : yo(_templateObject5()), fileName, locationString);

          self._components.renderer.error(msg, _this2.view.querySelector("[id=\"staticAnalysisModule".concat(moduleName, "\"]")), {
            click: function click() {
              return highlightLocation(location, fileName);
            },
            type: 'warning',
            useSpan: true,
            errFile: fileName,
            errLine: row,
            errCol: column
          });
        });
      }); // hide empty staticAnalysisModules sections

      _this2.view.querySelectorAll('[name="staticAnalysisModules"]').forEach(function (section) {
        if (!section.getElementsByClassName('alert-warning').length) section.hidden = true;
      });

      self.event.trigger('staticAnaysisWarning', [warningCount]);
    });
  } else {
    this.runBtn.setAttribute('disabled', 'disabled');

    if (selected.length) {
      warningContainer.html('No compiled AST available');
    }

    self.event.trigger('staticAnaysisWarning', [-1]);
  }
};

staticAnalysisView.prototype.checkModule = function (event) {
  var selected = this.view.querySelectorAll('[name="staticanalysismodule"]:checked');
  var checkAll = this.view.querySelector('[id="checkAllEntries"]');
  this.correctRunBtnDisabled();

  if (event.target.checked) {
    checkAll.checked = true;
  } else if (!selected.length) {
    checkAll.checked = false;
  }
};

staticAnalysisView.prototype.correctRunBtnDisabled = function () {
  if (!this.view) {
    return;
  }

  var selected = this.view.querySelectorAll('[name="staticanalysismodule"]:checked');

  if (this.lastCompilationResult && selected.length !== 0) {
    this.runBtn.removeAttribute('disabled');
  } else {
    this.runBtn.setAttribute('disabled', 'disabled');
  }
};

staticAnalysisView.prototype.checkAll = function (event) {
  if (!this.view) {
    return;
  } // checks/unchecks all


  var checkBoxes = this.view.querySelectorAll('[name="staticanalysismodule"]');
  checkBoxes.forEach(function (checkbox) {
    checkbox.checked = event.target.checked;
  });
  this.correctRunBtnDisabled();
};

staticAnalysisView.prototype.handleCollapse = function (e) {
  var downs = e.toElement.parentElement.getElementsByClassName('fas fa-angle-double-right');
  var iEls = document.getElementsByTagName('i');

  for (var i = 0; i < iEls.length; i++) {
    iEls[i].hidden = false;
  }

  downs[0].hidden = true;
};

staticAnalysisView.prototype.renderModules = function () {
  var _this3 = this;

  var groupedModules = utils.groupBy(preProcessModules(this.runner.modules()), 'categoryId');
  var moduleEntries = Object.keys(groupedModules).map(function (categoryId, i) {
    var category = groupedModules[categoryId];
    var entriesDom = category.map(function (item, i) {
      return yo(_templateObject6(), categoryId, i, item._index, function (event) {
        return _this3.checkModule(event);
      }, categoryId, i, item.name, item.description);
    });
    return yo(_templateObject7(), css.block, categoryId, function (e) {
      return _this3.handleCollapse(e);
    }, categoryId, category[0].categoryDisplayName, css.entries, entriesDom);
  }); // collaps first module

  moduleEntries[0].getElementsByTagName('input')[0].checked = true;
  moduleEntries[0].getElementsByTagName('i')[0].hidden = true;
  return yo(_templateObject8(), moduleEntries);
};

module.exports = staticAnalysisView;
/**
 * @dev Process & categorize static analysis modules to show them on UI
 * @param arr list of static analysis modules received from remix-analyzer module
 */

function preProcessModules(arr) {
  return arr.map(function (Item, i) {
    var itemObj = new Item();
    itemObj._index = i;
    itemObj.categoryDisplayName = itemObj.category.displayName;
    itemObj.categoryId = itemObj.category.id;
    return itemObj;
  });
}

/***/ }),

/***/ "./app/tabs/staticanalysis/styles/staticAnalysisView-styles.js":
/*!*********************************************************************!*\
  !*** ./app/tabs/staticanalysis/styles/staticAnalysisView-styles.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .analysis {\n    display: flex;\n    flex-direction: column;\n  }\n  .result {\n    margin-top: 1%;\n    max-height: 300px;\n    word-break: break-word;\n  }\n  .buttons  {\n    margin: 1rem 0;\n  }\n  .label {\n    display: flex;\n    align-items: center;\n  }\n  .label {\n    display: flex;\n    align-items: center;\n    user-select: none;\n  }\n  .block input[type='radio']:checked ~ .entries{\n    height: auto;\n    transition: .5s ease-in;\n  }\n  .entries{\n    height: 0;\n    overflow: hidden;\n    transition: .5s ease-out;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());
module.exports = css;

/***/ }),

/***/ "./app/tabs/styles/compile-tab-styles.js":
/*!***********************************************!*\
  !*** ./app/tabs/styles/compile-tab-styles.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .title {\n    font-size: 1.1em;\n    font-weight: bold;\n    margin-bottom: 1em;\n  }\n  .panicError {\n    color: red;\n    font-size: 20px;\n  }\n  .crow {\n    display: flex;\n    overflow: auto;\n    clear: both;\n    padding: .2em;\n  }\n  .checkboxText {\n    font-weight: normal;\n  }\n  .crow label {\n    cursor:pointer;\n  }\n  .crowNoFlex {\n    overflow: auto;\n    clear: both;\n  }\n  .info {\n    padding: 10px;\n    word-break: break-word;\n  }\n  .contract {\n    display: block;\n    margin: 3% 0;\n  }\n  .nightlyBuilds {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n  }\n  .autocompileContainer {\n    display: flex;\n    align-items: center;\n  }\n  .runs {\n    width: 40%;\n  }\n  .hideWarningsContainer {\n    display: flex;\n    align-items: center;\n  }\n  .autocompile {}\n  .autocompileTitle {\n    font-weight: bold;\n    margin: 1% 0;\n  }\n  .autocompileText {\n    margin: 1% 0;\n    font-size: 12px;\n    overflow: hidden;\n    word-break: normal;\n    line-height: initial;\n  }\n  .warnCompilationSlow {\n    margin-left: 1%;\n  }\n  .compilerConfig {\n    display: flex;\n    align-items: center;\n  }\n  .compilerConfig label {\n    margin: 0;\n  }\n  .compilerSection {\n    padding: 12px 24px 16px;\n  }\n  .compilerLabel {\n    margin-bottom: 2px;\n    font-size: 11px;\n    line-height: 12px;\n    text-transform: uppercase;\n  }\n  .copyButton {\n    padding: 6px;\n    font-weight: bold;\n    font-size: 11px;\n    line-height: 15px;\n  }\n  .name {\n    display: flex;\n  }\n  .size {\n    display: flex;\n  }\n  .checkboxes {\n    display: flex;\n    width: 100%;\n    justify-content: space-between;\n    flex-wrap: wrap;\n  }\n  .compileButton {\n    width: 100%;\n    margin: 15px 0 10px 0;\n    font-size: 12px;\n  }\n  .container {\n    margin: 0;\n    margin-bottom: 2%;\n  }\n  .optimizeContainer {\n    display: flex;\n  }\n  .noContractAlert {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  .contractHelperButtons {\n    margin-top: 6px;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    float: right;\n  }\n  .copyToClipboard {\n    font-size: 1rem;\n  }\n  .copyIcon {\n    margin-right: 5px;\n  }\n  .log {\n    display: flex;\n    flex-direction: column;\n    margin-bottom: 5%;\n    overflow: visible;\n  }\n  .key {\n    margin-right: 5px;\n    text-transform: uppercase;\n    width: 100%;\n  }\n  .value {\n    display: flex;\n    width: 100%;\n    margin-top: 1.5%;\n  }\n  .questionMark {\n    margin-left: 2%;\n    cursor: pointer;\n  }\n  .questionMark:hover {\n  }\n  .detailsJSON {\n    padding: 8px 0;\n    border: none;\n  }\n  .icon {\n    margin-right: 0.3em;\n  }\n  .errorBlobs {\n    padding-left: 5px;\n    padding-right: 5px;\n    word-break: break-word;\n  }\n  .storageLogo {\n    width: 20px;\n    height: 20px;\n  }\n  .spinningIcon {\n    display: inline-block;\n    position: relative;\n    animation: spin 2s infinite linear;\n    -moz-animation: spin 2s infinite linear;\n    -o-animation: spin 2s infinite linear;\n    -webkit-animation: spin 2s infinite linear;\n  }\n  @keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n  }\n  @-webkit-keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n  }\n  @-moz-keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n  }\n  @-o-keyframes spin {\n     0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n  }\n  @-ms-keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n  }\n\n  .bouncingIcon {\n    display: inline-block;\n    position: relative;\n    -moz-animation: bounce 2s infinite linear;\n    -o-animation: bounce 2s infinite linear;\n    -webkit-animation: bounce 2s infinite linear;\n    animation: bounce 2s infinite linear;\n  } \n\n  @-webkit-keyframes bounce {\n      0% { top: 0; }\n      50% { top: -0.2em; }\n      70% { top: -0.3em; }\n      100% { top: 0; }\n  }\n  @-moz-keyframes bounce {\n      0% { top: 0; }\n      50% { top: -0.2em; }\n      70% { top: -0.3em; }\n      100% { top: 0; }\n  }\n  @-o-keyframes bounce {\n      0% { top: 0; }\n      50% { top: -0.2em; }\n      70% { top: -0.3em; }\n      100% { top: 0; }\n  }\n  @-ms-keyframes bounce {\n      0% { top: 0; }\n      50% { top: -0.2em; }\n      70% { top: -0.3em; }\n      100% { top: 0; }\n  }\n  @keyframes bounce {\n      0% { top: 0; }\n      50% { top: -0.2em; }\n      70% { top: -0.3em; }\n      100% { top: 0; }\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());
module.exports = css;

/***/ }),

/***/ "./app/tabs/styles/debugger-tab-styles.js":
/*!************************************************!*\
  !*** ./app/tabs/styles/debugger-tab-styles.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .debuggerTabView {\n    padding: 2%;\n  }\n  .debugger {\n    margin-bottom: 1%;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());
module.exports = css;

/***/ }),

/***/ "./app/tabs/styles/run-tab-styles.js":
/*!*******************************************!*\
  !*** ./app/tabs/styles/run-tab-styles.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .runTabView {\n    display: flex;\n    flex-direction: column;\n  }\n  .runTabView::-webkit-scrollbar {\n    display: none;\n  }\n  .settings {\n    padding: 0 24px 16px;\n  }\n  .crow {\n    display: block;\n    margin-top: 8px;\n  }\n  .col1 {\n    width: 30%;\n    float: left;\n    align-self: center;\n  }\n  .settingsLabel {\n    font-size: 11px;\n    margin-bottom: 4px;\n    text-transform: uppercase;\n  }\n  .environment {\n    display: flex;\n    align-items: center;\n    position: relative;\n    width: 100%;\n  }\n  .environment a {\n    margin-left: 7px;\n  }\n  .account {\n    display: flex;\n    align-items: center;\n  }\n  .account i {\n    margin-left: 12px;\n  }\n  .col2 {\n    border-radius: 3px;\n  }\n  .col2_1 {\n    width: 164px;\n    min-width: 164px;\n  }\n  .col2_2 {\n  }\n  .select {\n    font-weight: normal;\n    width: 100%;\n    overflow: hidden;\n  }\n  .instanceContainer {\n    display: flex;\n    flex-direction: column;\n    margin-bottom: 2%;\n    border: none;\n    text-align: center;\n    padding: 0 14px 16px;\n  }\n  .pendingTxsContainer  {\n    display: flex;\n    flex-direction: column;\n    margin-top: 2%;\n    border: none;\n    text-align: center;\n  }\n  .container {\n    padding: 0 24px 16px;\n  }\n  .recorderDescription {\n    margin: 0 15px 15px 0;\n   }\n  .contractNames {\n    width: 100%;\n    border: 1px solid\n  }\n  .subcontainer {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    margin-bottom: 8px;\n  }\n  .subcontainer i {\n    width: 16px;\n    display: flex;\n    justify-content: center;\n    margin-left: 1px;\n  }\n  .button button{\n    flex: none;\n  }\n  .button {\n    display: flex;\n    align-items: center;\n    margin-top: 13px;\n  }\n  .transaction {\n  }\n  .atAddress {\n    margin: 0;\n    min-width: 100px;\n    width: 100px;\n    height: 100%;\n    word-break: inherit;\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n    border-right: 0;\n  }\n  .atAddressSect {\n    margin-top: 8px;\n    height: 32px;\n  }\n  .atAddressSect input {\n    height: 32px;\n    border-top-left-radius: 0 !important;\n    border-bottom-left-radius: 0 !important;\n  }\n  .ataddressinput {\n    padding: .25rem;\n  }\n  .create {\n  }\n  .input {\n    font-size: 10px !important;\n  }\n  .noInstancesText {\n    font-style: italic;\n    text-align: left;\n    padding-left: 15px;\n  }\n  .pendingTxsText {\n    font-style: italic;\n    display: flex;\n    justify-content: space-evenly;\n    align-items: center;\n    flex-wrap: wrap;\n  }\n  .item {\n    margin-right: 1em;\n    display: flex;\n    align-items: center;\n  }\n  .pendingContainer {\n    display: flex;\n    align-items: baseline;\n  }\n  .pending {\n    height: 25px;\n    text-align: center;\n    padding-left: 10px;\n    border-radius: 3px;\n    margin-left: 5px;\n  }\n  .disableMouseEvents {\n    pointer-events: none;\n  }\n  .icon {\n    cursor: pointer;\n    font-size: 12px;\n    cursor: pointer;\n    margin-left: 5px;\n  }\n  .icon:hover {\n    font-size: 12px;\n    color: var(--warning);\n  }\n  .errorIcon {\n    color: var(--warning);\n    margin-left: 15px;\n  }\n  .failDesc {\n    color: var(--warning);\n    padding-left: 10px;\n    display: inline;\n  }\n  .network {\n    margin-left: 8px;\n    pointer-events: none;\n  }\n  .networkItem {\n    margin-right: 5px;\n  }\n  .transactionActions {\n    display: flex;\n    justify-content: space-evenly;\n    width: 145px;\n  }\n  .orLabel {\n    text-align: center;\n    text-transform: uppercase;\n  }\n  .infoDeployAction {\n    margin-left: 1px;\n    font-size: 13px;\n    color: var(--info);\n  }\n  .gasValueContainer {\n    flex-direction: row;\n    display: flex;\n  }\n  .gasNval {\n    width: 55%;\n    font-size: 0.8rem;\n  }\n  .gasNvalUnit {\n    width: 41%;\n    margin-left: 10px;\n    font-size: 0.8rem;\n  }\n  .deployDropdown {\n    text-align: center;\n    text-transform: uppercase;\n  }\n  .checkboxAlign {\n    padding-top: 2px;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());
module.exports = css;

/***/ }),

/***/ "./app/tabs/styles/settings-tab-styles.js":
/*!************************************************!*\
  !*** ./app/tabs/styles/settings-tab-styles.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .settingsTabView {\n    padding: 2%;\n  }\n  .info {\n    word-break: break-word;\n    font-size: .8rem;\n  }\n  .info h7 {\n    margin-bottom: .5rem;\n  }\n  .frow {\n    margin-bottom: .5rem;\n  }\n  .crow label {\n    cursor:pointer;\n  }\n  .crowNoFlex {\n    overflow: auto;\n    clear: both;\n  }\n  .attention {\n    margin-bottom: 1em;\n    padding: .5em;\n    font-weight: bold;\n  }\n  .heading {\n    margin-bottom: 0;\n  }\n  .explaination {\n    margin-top: 3px;\n    margin-bottom: 3px;\n  }\n  input {\n    width: inherit;\n  }\n  input[type=radio] {\n    margin-top: 2px;\n  }\n  .pluginTextArea {\n    font-family: unset;\n  }\n\n  .removePlugin {\n    cursor: pointer;\n  }\n  .icon {\n    margin-right: .5em;\n  }\n  .aPlugin {\n    display: inline-block;\n    padding-left: 10px;\n    padding-top: 4px;\n    padding-bottom: 6px;\n    max-width: 100px;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    vertical-align: middle;\n  }\n  .removePlugin{\n    padding-left: 7px;\n    padding-right: 7px;\n    margin-left: 10px;\n  }\n  .inline {\n    display: inline;\n    width: 32%;\n  }\n  .text, .text:hover {\n    text-decoration: none;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());
module.exports = css;

/***/ }),

/***/ "./app/tabs/styles/test-tab-styles.js":
/*!********************************************!*\
  !*** ./app/tabs/styles/test-tab-styles.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .testTabView {}\n  .infoBox  {\n    margin: 5%;\n  }\n  .tests {}\n  .testList {\n    line-height: 2em;\n    display: flex;\n    flex-direction: column;\n    margin: 5%;\n    max-height: 300px;\n    overflow-y: auto;\n\n  }\n  .container {\n    margin: 2%;\n    padding-bottom: 5%;\n    max-height: 300px;\n    overflow-y: auto;\n  }\n  .summaryTitle {\n    font-weight: bold;\n  }\n  .testPass {\n  }\n  .testLog {\n    margin-bottom: 1%;\n    border-radius: 4px;\n    padding: 1% 1% 1% 5%;\n  }\n  .testFailure {\n  }\n  .testFailureSummary {\n  }\n  .title {\n    font-size: 1.1em;\n    font-weight: bold;\n    margin-bottom: 1em;\n  }\n  .label {\n    display: flex;\n    align-items: center;\n    white-space: nowrap;\n  }\n  .labelOnBtn {\n    border: hidden;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());
module.exports = css;

/***/ }),

/***/ "./app/tabs/test-tab.js":
/*!******************************!*\
  !*** ./app/tabs/test-tab.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engineWeb = __webpack_require__(/*! @remixproject/engine-web */ "../../../node_modules/@remixproject/engine-web/index.js");

var _compilerUtils = __webpack_require__(/*! ../compiler/compiler-utils */ "./app/compiler/compiler-utils.js");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject31() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", " px-2\" id=\"testView\">\n        <div class=\"", "\">\n          <p class=\"text-lg\"> Test your smart contract in Solidity.</p>\n          <p> Select directory to load and generate test files.</p>\n          <label>Test directory:</label>\n          ", "\n        </div>\n        <div class=\"", "\">          \n          <div class=\"d-flex p-2\">\n           ", "\n           ", "\n          </div>\n          <div class=\"d-flex p-2\">\n            ", "\n            ", "\n          </div>\n          ", "\n          ", "\n          <div class=\"align-items-start flex-column mt-2 mx-3 mb-0\">\n            ", "\n            ", "\n            ", "\n          </div>\n          ", "\n        </div>\n      </div>\n    "]);

  _templateObject31 = function _templateObject31() {
    return data;
  };

  return data;
}

function _templateObject30() {
  var data = _taggedTemplateLiteral(["\n      <div>\n          ", "\n          ", "\n      </div>\n    "]);

  _templateObject30 = function _templateObject30() {
    return data;
  };

  return data;
}

function _templateObject29() {
  var data = _taggedTemplateLiteral(["<input\n      placeholder=", "\n      list=\"utPathList\"\n      class=\"custom-select\"\n      id=\"utPath\"\n      data-id=\"uiPathInput\"\n      name=\"utPath\"\n      style=\"background-image: var(--primary);\"\n      onkeydown=", "\n      onchange=", "/>"]);

  _templateObject29 = function _templateObject29() {
    return data;
  };

  return data;
}

function _templateObject28() {
  var data = _taggedTemplateLiteral(["<datalist id=\"utPathList\"></datalist>"]);

  _templateObject28 = function _templateObject28() {
    return data;
  };

  return data;
}

function _templateObject27() {
  var data = _taggedTemplateLiteral(["<label class=\"text-danger h6\" data-id=\"testTabTestsExecutionStoppedError\">The test execution has been stopped because of error(s) in your test file</label>"]);

  _templateObject27 = function _templateObject27() {
    return data;
  };

  return data;
}

function _templateObject26() {
  var data = _taggedTemplateLiteral(["<label class=\"text-warning h6\" data-id=\"testTabTestsExecutionStopped\">The test execution has been stopped</label>"]);

  _templateObject26 = function _templateObject26() {
    return data;
  };

  return data;
}

function _templateObject25() {
  var data = _taggedTemplateLiteral(["<div class=\"mx-3 mb-2 pb-4 border-top border-primary\" hidden='true' id=\"solidityUnittestsOutput\" data-id=\"testTabSolidityUnitTestsOutput\"></a>"]);

  _templateObject25 = function _templateObject25() {
    return data;
  };

  return data;
}

function _templateObject24() {
  var data = _taggedTemplateLiteral(["<option>", "</option>"]);

  _templateObject24 = function _templateObject24() {
    return data;
  };

  return data;
}

function _templateObject23() {
  var data = _taggedTemplateLiteral(["<option>localhost</option>"]);

  _templateObject23 = function _templateObject23() {
    return data;
  };

  return data;
}

function _templateObject22() {
  var data = _taggedTemplateLiteral(["<option>browser</option>"]);

  _templateObject22 = function _templateObject22() {
    return data;
  };

  return data;
}

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _templateObject21() {
  var data = _taggedTemplateLiteral(["<span class='text-info h6'>Progress: ", " finished (of ", ")</span>"]);

  _templateObject21 = function _templateObject21() {
    return data;
  };

  return data;
}

function _templateObject20() {
  var data = _taggedTemplateLiteral(["<span></span>"]);

  _templateObject20 = function _templateObject20() {
    return data;
  };

  return data;
}

function _templateObject19() {
  var data = _taggedTemplateLiteral(["\n      <a class=\"btn border text-decoration-none pr-0 d-flex w-50 ml-2\" title=\"Check out documentation.\" target=\"__blank\" href=\"https://remix-ide.readthedocs.io/en/latest/unittesting.html#generate-test-file\">\n        <label class=\"btn p-1 ml-2 m-0\">How to use...</label>\n      </a>\n    "]);

  _templateObject19 = function _templateObject19() {
    return data;
  };

  return data;
}

function _templateObject18() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"d-flex align-items-center mx-3 pb-2 mt-2 border-bottom\">\n        <input id=\"checkAllTests\"\n          type=\"checkbox\"\n          data-id=\"testTabCheckAllTests\"\n          onclick=\"", "\"\n          checked=\"true\"\n        >\n        <label class=\"text-nowrap pl-2 mb-0\" for=\"checkAllTests\"> Select all </label>\n      </div>\n    "]);

  _templateObject18 = function _templateObject18() {
    return data;
  };

  return data;
}

function _templateObject17() {
  var data = _taggedTemplateLiteral(["<div class=\"", " py-2 mt-0 border-bottom\">", "</div>"]);

  _templateObject17 = function _templateObject17() {
    return data;
  };

  return data;
}

function _templateObject16() {
  var data = _taggedTemplateLiteral(["\n      <button id=\"runTestsTabStopAction\" data-id=\"testTabRunTestsTabStopAction\" class=\"w-50 pl-2 ml-2 btn btn-secondary\" disabled=\"disabled\" title=\"Stop running tests\" onclick=", "\">\n        <span class=\"fas fa-stop ml-2\"></span>\n        <label class=\"", " btn btn-secondary p-1 ml-2 m-0\" id=\"runTestsTabStopActionLabel\">Stop</label>\n      </button>\n    "]);

  _templateObject16 = function _templateObject16() {
    return data;
  };

  return data;
}

function _templateObject15() {
  var data = _taggedTemplateLiteral(["\n      <button id=\"runTestsTabRunAction\" title=\"Run tests\" data-id=\"testTabRunTestsTabRunAction\" class=\"w-50 btn btn-primary\" onclick=\"", "\">\n        <span class=\"fas fa-play ml-2\"></span>\n        <label class=\"", " btn btn-primary p-1 ml-2 m-0\">Run</label>\n      </button>\n    "]);

  _templateObject15 = function _templateObject15() {
    return data;
  };

  return data;
}

function _templateObject14() {
  var data = _taggedTemplateLiteral(["\n      <button\n        class=\"btn border w-50\"\n        data-id=\"testTabGenerateTestFile\"\n        title=\"Generate sample test file.\"\n        onclick=\"", "\"\n      >\n        Generate\n      </button>\n    "]);

  _templateObject14 = function _templateObject14() {
    return data;
  };

  return data;
}

function _templateObject13() {
  var data = _taggedTemplateLiteral(["\n        <div>\n          <p class=\"text-info mb-2 border-top m-0\"></p>\n        </div>\n      "]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteral(["\n          <div class=\"d-flex alert-secondary mb-3 p-3 flex-column\">\n            <span class=\"font-weight-bold\">Result for ", "</span>\n            <span class=\"text-danger\">Failing: ", "</span>\n            <span>Total time: ", "s</span>\n          </div>\n        "]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function _templateObject11() {
  var data = _taggedTemplateLiteral(["\n          <div class=\"d-flex alert-secondary mb-3 p-3 flex-column\">\n            <span class=\"font-weight-bold\">Result for ", "</span>\n            <span class=\"text-success\">Passing: ", "</span>\n            <span>Total time: ", "s</span>\n          </div>\n        "]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["\n          <div class=\"d-flex alert-secondary mb-3 p-3 flex-column\">\n            <span class=\"font-weight-bold\">Result for ", "</span>\n            <span class=\"text-success\">Passing: ", "</span>\n            <span class=\"text-danger\">Failing: ", "</span>\n            <span>Total time: ", "s</span>\n          </div>\n        "]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["\n        <div id=\"", "\"  data-id=\"testTabSolidityUnitTestsOutputheader\" class=\"pt-1\">\n          ", " <span class=\"font-weight-bold\">", " (", ")</span>\n        </div>\n      "]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["\n        <div\n          class=\"alert-danger d-inline-block mb-1 mr-1 p-1 failed_", "\"\n          title=\"At least one contract test failed\"\n        >\n          FAIL\n        </div>\n      "]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n        <div id=\"", "\" data-id=\"testTabSolidityUnitTestsOutputheader\" class=\"pt-1\">\n          ", " <span class=\"font-weight-bold\">", " (", ")</span>\n        </div>\n      "]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n        <div\n          class=\"alert-success d-inline-block mb-1 mr-1 p-1 passed_", "\"\n          title=\"All contract tests passed\"\n        >\n          PASS\n        </div>\n      "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n          <div\n            class=\"bg-light mb-2 ", " ", " d-flex flex-column text-danger border-0\"\n            id=\"UTContext", "\"\n            onclick=", "\n          >\n            <span> \u2718 ", "</span>\n            <span class=\"text-dark\">Error Message:</span>\n            <span class=\"pb-2 text-break\">\"", "\"</span>\n            <span class=\"text-dark\">Assertion:</span>\n            <div class=\"d-flex flex-wrap\">\n              <span>Expected value should be</span>\n              <div class=\"mx-1 font-weight-bold\">", "</div>\n              <div>", " ", "</div>\n            </div>\n            <span class=\"text-dark\">Received value:</span>\n            <span>", "</span>\n            <span class=\"text-dark text-sm pb-2\">Skipping the remaining tests of the function.</span>\n          </div>\n        "]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n        <div\n          class=\"bg-light mb-2 ", " ", " d-flex flex-column text-danger border-0\"\n          id=\"UTContext", "\"\n          onclick=", "\n        >\n          <span> \u2718 ", "</span>\n          <span class=\"text-dark\">Error Message:</span>\n          <span class=\"pb-2 text-break\">\"", "\"</span>\n        </div>\n      "]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n        <div\n          id=\"", "\"\n          data-id=\"testTabSolidityUnitTestsOutputheader\"\n          class=\"", " ", " bg-light mb-2 text-success border-0\"\n          onclick=", "\n        >\n          \u2713 ", "\n        </div>\n      "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n        <div id=\"", "\" data-id=\"testTabSolidityUnitTestsOutputheader\" class=\"pt-1\">\n          <span class=\"font-weight-bold\">", " (", ")</span>\n        </div>\n      "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"d-flex align-items-center py-1\">\n        <input class=\"singleTest\" id=\"singleTest", "\" onchange=", " type=\"checkbox\" checked=\"true\">\n        <label class=\"singleTestLabel text-nowrap pl-2 mb-0\" for=\"singleTest", "\">", "</label>\n      </div>\n    "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

var tooltip = __webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js");

var css = __webpack_require__(/*! ./styles/test-tab-styles */ "./app/tabs/styles/test-tab-styles.js");

var remixTests = __webpack_require__(/*! @remix-project/remix-tests */ "../../../dist/libs/remix-tests/src/index.js");

var TestTabLogic = __webpack_require__(/*! ./testTab/testTab */ "./app/tabs/testTab/testTab.js");

var profile = {
  name: 'solidityUnitTesting',
  displayName: 'Solidity unit testing',
  methods: ['testFromPath', 'testFromSource'],
  events: [],
  icon: 'assets/img/unitTesting.webp',
  description: 'Fast tool to generate unit tests for your contracts',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/unittesting.html'
};

module.exports = /*#__PURE__*/function (_ViewPlugin) {
  _inherits(TestTab, _ViewPlugin);

  var _super = _createSuper(TestTab);

  function TestTab(fileManager, offsetToLineColumnConverter, filePanel, compileTab, appManager, renderer, contentImport) {
    var _this;

    _classCallCheck(this, TestTab);

    _this = _super.call(this, profile);
    _this.compileTab = compileTab;
    _this.contentImport = contentImport;
    _this._view = {
      el: null
    };
    _this.fileManager = fileManager;
    _this.filePanel = filePanel;
    _this.data = {};
    _this.appManager = appManager;
    _this.renderer = renderer;
    _this.hasBeenStopped = false;
    _this.runningTestsNumber = 0;
    _this.readyTestsNumber = 0;
    _this.areTestsRunning = false;
    _this.defaultPath = 'browser/tests';
    _this.offsetToLineColumnConverter = offsetToLineColumnConverter;
    appManager.event.on('activate', function (name) {
      if (name === 'solidity') _this.updateRunAction();
    });
    appManager.event.on('deactivate', function (name) {
      if (name === 'solidity') _this.updateRunAction();
    });
    return _this;
  }

  _createClass(TestTab, [{
    key: "onActivationInternal",
    value: function onActivationInternal() {
      this.testTabLogic = new TestTabLogic(this.fileManager);
      this.listenToEvents();
    }
  }, {
    key: "listenToEvents",
    value: function listenToEvents() {
      var _this2 = this;

      this.filePanel.event.register('newTestFileCreated', function (file) {
        var testList = _this2._view.el.querySelector("[class^='testList']");

        var test = _this2.createSingleTest(file);

        testList.appendChild(test);

        _this2.data.allTests.push(file);

        _this2.data.selectedTests.push(file);
      });
      this.fileManager.events.on('noFileSelected', function () {});
      this.fileManager.events.on('currentFileChanged', function (file, provider) {
        return _this2.updateForNewCurrent(file);
      });
    }
  }, {
    key: "updateForNewCurrent",
    value: function updateForNewCurrent(file) {
      var _this3 = this;

      this.updateGenerateFileAction(file);
      if (!this.areTestsRunning) this.updateRunAction(file);
      this.testTabLogic.getTests(function (error, tests) {
        if (error) return tooltip(error);
        _this3.data.allTests = tests;
        _this3.data.selectedTests = _toConsumableArray(_this3.data.allTests);

        _this3.updateTestFileList(tests);

        if (!_this3.testsOutput) return; // eslint-disable-line
      });
    }
  }, {
    key: "createSingleTest",
    value: function createSingleTest(testFile) {
      var _this4 = this;

      return yo(_templateObject(), testFile, function (e) {
        return _this4.toggleCheckbox(e.target.checked, testFile);
      }, testFile, testFile);
    }
  }, {
    key: "listTests",
    value: function listTests() {
      var _this5 = this;

      if (!this.data.allTests) return [];
      return this.data.allTests.map(function (testFile) {
        return _this5.createSingleTest(testFile);
      });
    }
  }, {
    key: "toggleCheckbox",
    value: function toggleCheckbox(eChecked, test) {
      if (!this.data.selectedTests) {
        this.data.selectedTests = this._view.el.querySelectorAll('.singleTest:checked');
      }

      var selectedTests = this.data.selectedTests;
      selectedTests = eChecked ? [].concat(_toConsumableArray(selectedTests), [test]) : selectedTests.filter(function (el) {
        return el !== test;
      });
      this.data.selectedTests = selectedTests;

      var checkAll = this._view.el.querySelector('[id="checkAllTests"]');

      var runBtn = document.getElementById('runTestsTabRunAction');

      if (eChecked) {
        checkAll.checked = true;
        var stopBtnInnerText = document.getElementById('runTestsTabStopAction').innerText;

        if ((this.readyTestsNumber === this.runningTestsNumber || this.hasBeenStopped) && stopBtnInnerText.trim() === 'Stop') {
          runBtn.removeAttribute('disabled');
          runBtn.setAttribute('title', 'Run tests');
        }
      } else if (!selectedTests.length) {
        checkAll.checked = false;
        runBtn.setAttribute('disabled', 'disabled');
        runBtn.setAttribute('title', 'No test file selected');
      }
    }
  }, {
    key: "checkAll",
    value: function checkAll(event) {
      var checkBoxes = this._view.el.querySelectorAll('.singleTest');

      var checkboxesLabels = this._view.el.querySelectorAll('.singleTestLabel'); // checks/unchecks all


      for (var i = 0; i < checkBoxes.length; i++) {
        checkBoxes[i].checked = event.target.checked;
        this.toggleCheckbox(event.target.checked, checkboxesLabels[i].innerText);
      }
    }
  }, {
    key: "discardHighlight",
    value: function () {
      var _discardHighlight = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.call('editor', 'discardHighlight');

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function discardHighlight() {
        return _discardHighlight.apply(this, arguments);
      }

      return discardHighlight;
    }()
  }, {
    key: "highlightLocation",
    value: function () {
      var _highlightLocation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(location, runningTests, fileName) {
        var split, file;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!location) {
                  _context2.next = 9;
                  break;
                }

                split = location.split(':');
                file = split[2];
                location = {
                  start: parseInt(split[0]),
                  length: parseInt(split[1])
                };
                location = this.offsetToLineColumnConverter.offsetToLineColumnWithContent(location, parseInt(file), runningTests[fileName].content);
                _context2.next = 7;
                return this.call('editor', 'discardHighlight');

              case 7:
                _context2.next = 9;
                return this.call('editor', 'highlight', location, fileName);

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function highlightLocation(_x, _x2, _x3) {
        return _highlightLocation.apply(this, arguments);
      }

      return highlightLocation;
    }()
  }, {
    key: "testCallback",
    value: function testCallback(result, runningTests) {
      var _this6 = this;

      this.testsOutput.hidden = false;

      if (result.type === 'contract') {
        this.testSuite = result.value;

        if (this.testSuites) {
          this.testSuites.push(this.testSuite);
        } else {
          this.testSuites = [this.testSuite];
        }

        this.rawFileName = result.filename;
        this.runningTestFileName = this.cleanFileName(this.rawFileName, this.testSuite);
        this.outputHeader = yo(_templateObject2(), this.runningTestFileName, this.testSuite, this.rawFileName);
        this.testsOutput.appendChild(this.outputHeader);
      } else if (result.type === 'testPass') {
        this.testsOutput.appendChild(yo(_templateObject3(), this.runningTestFileName, css.testPass, css.testLog, function () {
          return _this6.discardHighlight();
        }, result.value));
      } else if (result.type === 'testFailure') {
        if (!result.assertMethod) {
          this.testsOutput.appendChild(yo(_templateObject4(), css.testFailure, css.testLog, result.context, function () {
            return _this6.highlightLocation(result.location, runningTests, result.filename);
          }, result.value, result.errMsg));
        } else {
          var preposition = result.assertMethod === 'equal' || result.assertMethod === 'notEqual' ? 'to' : '';
          var method = result.assertMethod === 'ok' ? '' : result.assertMethod;
          var expected = result.assertMethod === 'ok' ? '\'true\'' : result.expected;
          this.testsOutput.appendChild(yo(_templateObject5(), css.testFailure, css.testLog, result.context, function () {
            return _this6.highlightLocation(result.location, runningTests, result.filename);
          }, result.value, result.errMsg, method, preposition, expected, result.returned));
        }
      }
    }
  }, {
    key: "resultsCallback",
    value: function resultsCallback(_err, result, cb) {
      // total stats for the test
      // result.passingNum
      // result.failureNum
      // result.timePassed
      cb();
    }
  }, {
    key: "cleanFileName",
    value: function cleanFileName(fileName, testSuite) {
      return fileName ? fileName.replace(/\//g, '_').replace(/\./g, '_') + testSuite : fileName;
    }
  }, {
    key: "setHeader",
    value: function setHeader(status) {
      if (status) {
        var label = yo(_templateObject6(), this.runningTestFileName);
        this.outputHeader && yo.update(this.outputHeader, yo(_templateObject7(), this.runningTestFileName, label, this.testSuite, this.rawFileName));
      } else {
        var _label = yo(_templateObject8(), this.runningTestFileName);

        this.outputHeader && yo.update(this.outputHeader, yo(_templateObject9(), this.runningTestFileName, _label, this.testSuite, this.rawFileName));
      }
    }
  }, {
    key: "updateFinalResult",
    value: function updateFinalResult(_errors, result, filename) {
      var _this7 = this;

      ++this.readyTestsNumber;
      this.testsOutput.hidden = false;

      if (!result && _errors && (_errors.errors || Array.isArray(_errors) && (_errors[0].message || _errors[0].formattedMessage))) {
        this.testCallback({
          type: 'contract',
          filename: filename
        });
        this.setHeader(false);
      }

      if (_errors && _errors.errors) {
        _errors.errors.forEach(function (err) {
          return _this7.renderer.error(err.formattedMessage || err.message, _this7.testsOutput, {
            type: err.severity
          });
        });
      } else if (_errors && Array.isArray(_errors) && (_errors[0].message || _errors[0].formattedMessage)) {
        _errors.forEach(function (err) {
          return _this7.renderer.error(err.formattedMessage || err.message, _this7.testsOutput, {
            type: err.severity
          });
        });
      } else if (_errors && !_errors.errors && !Array.isArray(_errors)) {
        // To track error like this: https://github.com/ethereum/remix/pull/1438
        this.renderer.error(_errors.formattedMessage || _errors.message, this.testsOutput, {
          type: 'error'
        });
      }

      yo.update(this.resultStatistics, this.createResultLabel());

      if (result) {
        var totalTime = parseFloat(result.totalTime).toFixed(2);

        if (result.totalPassing > 0 && result.totalFailing > 0) {
          this.testsOutput.appendChild(yo(_templateObject10(), filename, result.totalPassing, result.totalFailing, totalTime));
        } else if (result.totalPassing > 0 && result.totalFailing <= 0) {
          this.testsOutput.appendChild(yo(_templateObject11(), filename, result.totalPassing, totalTime));
        } else if (result.totalPassing <= 0 && result.totalFailing > 0) {
          this.testsOutput.appendChild(yo(_templateObject12(), filename, result.totalFailing, totalTime));
        } // fix for displaying right label for multiple tests (testsuites) in a single file


        this.testSuites.forEach(function (testSuite) {
          _this7.testSuite = testSuite;
          _this7.runningTestFileName = _this7.cleanFileName(filename, _this7.testSuite);
          _this7.outputHeader = document.querySelector("#".concat(_this7.runningTestFileName));

          _this7.setHeader(true);
        });
        result.errors.forEach(function (error, index) {
          _this7.testSuite = error.context;
          _this7.runningTestFileName = _this7.cleanFileName(filename, error.context);
          _this7.outputHeader = document.querySelector("#".concat(_this7.runningTestFileName));
          var isFailingLabel = document.querySelector(".failed_".concat(_this7.runningTestFileName));
          if (!isFailingLabel) _this7.setHeader(false);
        });
        this.testsOutput.appendChild(yo(_templateObject13()));
      }

      if (this.hasBeenStopped && this.readyTestsNumber !== this.runningTestsNumber) {
        // if all tests has been through before stopping no need to print this.
        this.testsExecutionStopped.hidden = false;
      }

      if (_errors) this.testsExecutionStoppedError.hidden = false;

      if (_errors || this.hasBeenStopped || this.readyTestsNumber === this.runningTestsNumber) {
        // All tests are ready or the operation has been canceled or there was a compilation error in one of the test files.
        var stopBtn = document.getElementById('runTestsTabStopAction');
        stopBtn.setAttribute('disabled', 'disabled');
        var stopBtnLabel = document.getElementById('runTestsTabStopActionLabel');
        stopBtnLabel.innerText = 'Stop';

        if (this.data.selectedTests.length !== 0) {
          var runBtn = document.getElementById('runTestsTabRunAction');
          runBtn.removeAttribute('disabled');
        }

        this.areTestsRunning = false;
      }
    }
  }, {
    key: "testFromPath",
    value: function () {
      var _testFromPath = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(path) {
        var fileContent;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.fileManager.readFile(path);

              case 2:
                fileContent = _context3.sent;
                return _context3.abrupt("return", this.testFromSource(fileContent, path));

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function testFromPath(_x4) {
        return _testFromPath.apply(this, arguments);
      }

      return testFromPath;
    }()
    /*
      Test is not associated with the UI
    */

  }, {
    key: "testFromSource",
    value: function testFromSource(content) {
      var _this8 = this;

      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'browser/unit_test.sol';
      return new Promise(function (resolve, reject) {
        var runningTest = {};
        runningTest[path] = {
          content: content
        };

        var _this8$compileTab$get = _this8.compileTab.getCurrentCompilerConfig(),
            currentVersion = _this8$compileTab$get.currentVersion,
            evmVersion = _this8$compileTab$get.evmVersion,
            optimize = _this8$compileTab$get.optimize,
            runs = _this8$compileTab$get.runs;

        var currentCompilerUrl = (0, _compilerUtils.urlFromVersion)(currentVersion);
        var compilerConfig = {
          currentCompilerUrl: currentCompilerUrl,
          evmVersion: evmVersion,
          optimize: optimize,
          usingWorker: (0, _compilerUtils.canUseWorker)(currentVersion),
          runs: runs
        };
        remixTests.runTestSources(runningTest, compilerConfig, function () {}, function () {}, function (error, result) {
          if (error) return reject(error);
          resolve(result);
        }, function (url, cb) {
          return _this8.contentImport.resolveAndSave(url).then(function (result) {
            return cb(null, result);
          })["catch"](function (error) {
            return cb(error.message);
          });
        });
      });
    }
  }, {
    key: "runTest",
    value: function runTest(testFilePath, callback) {
      var _this9 = this;

      if (this.hasBeenStopped) {
        this.updateFinalResult();
        return;
      }

      this.resultStatistics.hidden = false;
      this.fileManager.readFile(testFilePath).then(function (content) {
        var runningTests = {};
        runningTests[testFilePath] = {
          content: content
        };

        var _this9$compileTab$get = _this9.compileTab.getCurrentCompilerConfig(),
            currentVersion = _this9$compileTab$get.currentVersion,
            evmVersion = _this9$compileTab$get.evmVersion,
            optimize = _this9$compileTab$get.optimize,
            runs = _this9$compileTab$get.runs;

        var currentCompilerUrl = (0, _compilerUtils.urlFromVersion)(currentVersion);
        var compilerConfig = {
          currentCompilerUrl: currentCompilerUrl,
          evmVersion: evmVersion,
          optimize: optimize,
          usingWorker: (0, _compilerUtils.canUseWorker)(currentVersion),
          runs: runs
        };
        remixTests.runTestSources(runningTests, compilerConfig, function (result) {
          return _this9.testCallback(result, runningTests);
        }, function (_err, result, cb) {
          return _this9.resultsCallback(_err, result, cb);
        }, function (error, result) {
          _this9.updateFinalResult(error, result, testFilePath);

          callback(error);
        }, function (url, cb) {
          return _this9.contentImport.resolveAndSave(url).then(function (result) {
            return cb(null, result);
          })["catch"](function (error) {
            return cb(error.message);
          });
        });
      })["catch"](function (error) {
        if (error) return; // eslint-disable-line
      });
    }
  }, {
    key: "updateCurrentPath",
    value: function updateCurrentPath(e) {
      var newValue = e.target.value === '' ? this.defaultPath : e.target.value;
      this.testTabLogic.setCurrentPath(newValue);
      this.updateRunAction();
      this.updateForNewCurrent();
    }
  }, {
    key: "runTests",
    value: function runTests() {
      var _this10 = this;

      this.areTestsRunning = true;
      this.hasBeenStopped = false;
      this.readyTestsNumber = 0;
      this.runningTestsNumber = this.data.selectedTests.length;
      yo.update(this.resultStatistics, this.createResultLabel());
      var stopBtn = document.getElementById('runTestsTabStopAction');
      stopBtn.removeAttribute('disabled');
      var runBtn = document.getElementById('runTestsTabRunAction');
      runBtn.setAttribute('disabled', 'disabled');
      this.call('editor', 'clearAnnotations');
      this.testsOutput.innerHTML = '';
      this.testsOutput.hidden = true;
      this.testsExecutionStopped.hidden = true;
      this.testsExecutionStoppedError.hidden = true;
      var tests = this.data.selectedTests;
      if (!tests) return;
      this.resultStatistics.hidden = tests.length === 0;
      async.eachOfSeries(tests, function (value, key, callback) {
        if (_this10.hasBeenStopped) return;

        _this10.runTest(value, callback);
      });
    }
  }, {
    key: "stopTests",
    value: function stopTests() {
      this.hasBeenStopped = true;
      var stopBtnLabel = document.getElementById('runTestsTabStopActionLabel');
      stopBtnLabel.innerText = 'Stopping';
      var stopBtn = document.getElementById('runTestsTabStopAction');
      stopBtn.setAttribute('disabled', 'disabled');
      var runBtn = document.getElementById('runTestsTabRunAction');
      runBtn.setAttribute('disabled', 'disabled');
    }
  }, {
    key: "updateGenerateFileAction",
    value: function updateGenerateFileAction(currentFile) {
      var el = yo(_templateObject14(), this.testTabLogic.generateTestFile.bind(this.testTabLogic));

      if (!this.generateFileActionElement) {
        this.generateFileActionElement = el;
      } else {
        yo.update(this.generateFileActionElement, el);
      }

      return this.generateFileActionElement;
    }
  }, {
    key: "updateRunAction",
    value: function updateRunAction(currentFile) {
      var _this11 = this;

      var el = yo(_templateObject15(), function () {
        return _this11.runTests();
      }, css.labelOnBtn);
      var isSolidityActive = this.appManager.isActive('solidity');

      if (!isSolidityActive || !this.listTests().length) {
        el.setAttribute('disabled', 'disabled');

        if (!currentFile || currentFile && currentFile.split('.').pop().toLowerCase() !== 'sol') {
          el.setAttribute('title', 'No solidity file selected');
        } else {
          el.setAttribute('title', 'The "Solidity Plugin" should be activated'); // @todo(#2747)  we can activate the plugin here
        }
      }

      if (!this.runActionElement) {
        this.runActionElement = el;
      } else {
        yo.update(this.runActionElement, el);
      }

      return this.runActionElement;
    }
  }, {
    key: "updateStopAction",
    value: function updateStopAction() {
      var _this12 = this;

      return yo(_templateObject16(), function () {
        return _this12.stopTests();
      }, css.labelOnBtn);
    }
  }, {
    key: "updateTestFileList",
    value: function updateTestFileList(tests) {
      var testsMessage = tests && tests.length ? this.listTests() : 'No test file available';
      var el = yo(_templateObject17(), css.testList, testsMessage);

      if (!this.testFilesListElement) {
        this.testFilesListElement = el;
      } else {
        yo.update(this.testFilesListElement, el);
      }

      this.updateRunAction();
      return this.testFilesListElement;
    }
  }, {
    key: "selectAll",
    value: function selectAll() {
      var _this13 = this;

      return yo(_templateObject18(), function (event) {
        _this13.checkAll(event);
      });
    }
  }, {
    key: "infoButton",
    value: function infoButton() {
      return yo(_templateObject19());
    }
  }, {
    key: "createResultLabel",
    value: function createResultLabel() {
      if (!this.data.selectedTests) return yo(_templateObject20());
      var ready = this.readyTestsNumber ? "".concat(this.readyTestsNumber) : '0';
      return yo(_templateObject21(), ready, this.runningTestsNumber);
    }
  }, {
    key: "updateDirList",
    value: function updateDirList() {
      var _this14 = this;

      var _iterator = _createForOfIteratorHelper(this.uiPathList.querySelectorAll('option')),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var o = _step.value;
          o.remove();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.uiPathList.appendChild(yo(_templateObject22()));
      if (this.testTabLogic.isRemixDActive()) this.uiPathList.appendChild(yo(_templateObject23()));
      if (!this._view.el) return;
      this.testTabLogic.dirList(this.inputPath.value).then(function (options) {
        options.forEach(function (path) {
          return _this14.uiPathList.appendChild(yo(_templateObject24(), path));
        });
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this15 = this;

      this.onActivationInternal();
      this.testsOutput = yo(_templateObject25());
      this.testsExecutionStopped = yo(_templateObject26());
      this.testsExecutionStoppedError = yo(_templateObject27());
      this.uiPathList = yo(_templateObject28());
      this.inputPath = yo(_templateObject29(), this.defaultPath, function (e) {
        if (e.keyCode === 191) _this15.updateDirList();
      }, function (e) {
        return _this15.updateCurrentPath(e);
      });
      var availablePaths = yo(_templateObject30(), this.inputPath, this.uiPathList);
      this.updateDirList();
      this.testsExecutionStopped.hidden = true;
      this.testsExecutionStoppedError.hidden = true;
      this.resultStatistics = this.createResultLabel();
      this.resultStatistics.hidden = true;
      var el = yo(_templateObject31(), css.testTabView, css.infoBox, availablePaths, css.tests, this.updateGenerateFileAction(), this.infoButton(), this.updateRunAction(), this.updateStopAction(), this.selectAll(), this.updateTestFileList(), this.resultStatistics, this.testsExecutionStopped, this.testsExecutionStoppedError, this.testsOutput);
      this._view.el = el;
      this.testTabLogic.setCurrentPath(this.defaultPath);
      this.updateForNewCurrent(this.fileManager.currentFile());
      return el;
    }
  }]);

  return TestTab;
}(_engineWeb.ViewPlugin);

/***/ }),

/***/ "./app/tabs/testTab/testTab.js":
/*!*************************************!*\
  !*** ./app/tabs/testTab/testTab.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var helper = __webpack_require__(/*! ../../../lib/helper.js */ "./lib/helper.js");

var modalDialogCustom = __webpack_require__(/*! ../../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var remixPath = __webpack_require__(/*! path */ "../../../node_modules/path-browserify/index.js");

var TestTabLogic = /*#__PURE__*/function () {
  function TestTabLogic(fileManager) {
    _classCallCheck(this, TestTabLogic);

    this.fileManager = fileManager;
    this.currentPath = 'browser/tests';
  }

  _createClass(TestTabLogic, [{
    key: "setCurrentPath",
    value: function setCurrentPath(path) {
      if (path.indexOf('/') === 0) return;
      this.currentPath = path;
      var fileProvider = this.fileManager.fileProviderOf(path.split('/')[0]);
      fileProvider.exists(path, function (e, res) {
        if (!res) fileProvider.createDir(path);
      });
    }
  }, {
    key: "generateTestFile",
    value: function generateTestFile() {
      var _this = this;

      var fileName = this.fileManager.currentFile();
      var hasCurrent = !!fileName && this.fileManager.currentFile().split('.').pop().toLowerCase() === 'sol';
      if (!hasCurrent) fileName = this.currentPath + '/newFile.sol';
      var fileProvider = this.fileManager.fileProviderOf(this.currentPath);
      if (!fileProvider) return;
      var splittedFileName = fileName.split('/');
      var fileNameToImport = !hasCurrent ? fileName : this.currentPath + '/' + splittedFileName[splittedFileName.length - 1];
      helper.createNonClashingNameWithPrefix(fileNameToImport, fileProvider, '_test', function (error, newFile) {
        if (error) return modalDialogCustom.alert('Failed to create file. ' + newFile + ' ' + error);
        if (!fileProvider.set(newFile, _this.generateTestContractSample(hasCurrent, fileName))) return modalDialogCustom.alert('Failed to create test file ' + newFile);

        _this.fileManager.open(newFile);

        _this.fileManager.syncEditor(newFile);
      });
    }
  }, {
    key: "dirList",
    value: function dirList(path) {
      return this.fileManager.dirList(path);
    }
  }, {
    key: "isRemixDActive",
    value: function isRemixDActive() {
      return this.fileManager.isRemixDActive();
    }
  }, {
    key: "getTests",
    value: function () {
      var _getTests = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(cb) {
        var provider, tests, files, file;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.currentPath) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", cb(null, []));

              case 2:
                provider = this.fileManager.fileProviderOf(this.currentPath);

                if (provider) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return", cb(null, []));

              case 5:
                tests = [];
                _context.prev = 6;
                _context.next = 9;
                return this.fileManager.readdir(this.currentPath);

              case 9:
                files = _context.sent;
                _context.next = 15;
                break;

              case 12:
                _context.prev = 12;
                _context.t0 = _context["catch"](6);
                cb(_context.t0.message);

              case 15:
                for (file in files) {
                  if (/.(_test.sol)$/.exec(file)) tests.push(provider.type + '/' + file);
                }

                cb(null, tests, this.currentPath);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[6, 12]]);
      }));

      function getTests(_x) {
        return _getTests.apply(this, arguments);
      }

      return getTests;
    }() // @todo(#2758): If currently selected file is compiled and compilation result is available,
    // 'contractName' should be <compiledContractName> + '_testSuite'

  }, {
    key: "generateTestContractSample",
    value: function generateTestContractSample(hasCurrent, fileToImport) {
      var contractName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'testSuite';
      var relative = remixPath.relative(this.currentPath, remixPath.dirname(fileToImport));
      if (relative === '') relative = '.';
      var comment = hasCurrent ? "import \"".concat(relative, "/").concat(remixPath.basename(fileToImport), "\";") : '// Import here the file to test.';
      return "// SPDX-License-Identifier: GPL-3.0\n    \npragma solidity >=0.4.22 <0.8.0;\nimport \"remix_tests.sol\"; // this import is automatically injected by Remix.\nimport \"remix_accounts.sol\";\n".concat(comment, "\n\n// File name has to end with '_test.sol', this file can contain more than one testSuite contracts\ncontract ").concat(contractName, " {\n\n    /// 'beforeAll' runs before all other tests\n    /// More special functions are: 'beforeEach', 'beforeAll', 'afterEach' & 'afterAll'\n    function beforeAll() public {\n        // Here should instantiate tested contract\n        Assert.equal(uint(1), uint(1), \"1 should be equal to 1\");\n    }\n\n    function checkSuccess() public {\n        // Use 'Assert' to test the contract, \n        // See documentation: https://remix-ide.readthedocs.io/en/latest/assert_library.html\n        Assert.equal(uint(2), uint(2), \"2 should be equal to 2\");\n        Assert.notEqual(uint(2), uint(3), \"2 should not be equal to 3\");\n    }\n\n    function checkSuccess2() public pure returns (bool) {\n        // Use the return value (true or false) to test the contract\n        return true;\n    }\n    \n    function checkFailure() public {\n        Assert.equal(uint(1), uint(2), \"1 is not equal to 2\");\n    }\n\n    /// Custom Transaction Context\n    /// See more: https://remix-ide.readthedocs.io/en/latest/unittesting.html#customization\n    /// #sender: account-1\n    /// #value: 100\n    function checkSenderAndValue() public payable {\n        // account index varies 0-9, value is in wei\n        Assert.equal(msg.sender, TestsAccounts.getAccount(1), \"Invalid sender\");\n        Assert.equal(msg.value, 100, \"Invalid value\");\n    }\n}\n");
    }
  }]);

  return TestTabLogic;
}();

module.exports = TestTabLogic;

/***/ }),

/***/ "./app/tabs/theme-module.js":
/*!**********************************!*\
  !*** ./app/tabs/theme-module.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ThemeModule = void 0;

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var _events = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

var _queryParams = _interopRequireDefault(__webpack_require__(/*! ../../lib/query-params */ "./lib/query-params.js"));

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

var _yoYo = _interopRequireDefault(__webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject() {
  var data = _taggedTemplateLiteral(["<link rel=\"stylesheet\" href=\"", "\" id=\"theme-link\"/>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var themes = [{
  name: 'Dark',
  quality: 'dark',
  url: 'assets/css/themes/remix-dark_tvx1s2.css'
}, {
  name: 'Light',
  quality: 'light',
  url: 'assets/css/themes/remix-light_powaqg.css'
}, {
  name: 'Midcentury',
  quality: 'light',
  url: 'assets/css/themes/remix-midcentury_hrzph3.css'
}, {
  name: 'Black',
  quality: 'dark',
  url: 'assets/css/themes/remix-black_undtds.css'
}, {
  name: 'Candy',
  quality: 'light',
  url: 'assets/css/themes/remix-candy_ikhg4m.css'
}, {
  name: 'Cerulean',
  quality: 'light',
  url: 'assets/css/themes/bootstrap-cerulean.min.css'
}, {
  name: 'Flatly',
  quality: 'light',
  url: 'assets/css/themes/bootstrap-flatly.min.css'
}, {
  name: 'Spacelab',
  quality: 'light',
  url: 'assets/css/themes/bootstrap-spacelab.min.css'
}, {
  name: 'Cyborg',
  quality: 'dark',
  url: 'assets/css/themes/bootstrap-cyborg.min.css'
}];
var profile = {
  name: 'theme',
  events: ['themeChanged'],
  methods: ['switchTheme', 'getThemes', 'currentTheme'],
  version: packageJson.version,
  kind: 'theme'
};

var ThemeModule = /*#__PURE__*/function (_Plugin) {
  _inherits(ThemeModule, _Plugin);

  var _super = _createSuper(ThemeModule);

  function ThemeModule(registry) {
    var _this;

    _classCallCheck(this, ThemeModule);

    _this = _super.call(this, profile);
    _this.events = new _events.EventEmitter();
    _this._deps = {
      config: registry.get('config').api
    };
    _this.themes = themes.reduce(function (acc, theme) {
      theme.url = window.location.origin + window.location.pathname + theme.url;
      return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, theme.name, theme));
    }, {});
    var queryTheme = new _queryParams["default"]().get().theme;
    queryTheme = _this.themes[queryTheme] ? queryTheme : null;

    var currentTheme = _this._deps.config.get('settings/theme');

    currentTheme = _this.themes[currentTheme] ? currentTheme : null;
    _this.active = queryTheme || currentTheme || 'Dark';
    _this.forced = !!queryTheme;
    return _this;
  }
  /** Return the active theme */


  _createClass(ThemeModule, [{
    key: "currentTheme",
    value: function currentTheme() {
      return this.themes[this.active];
    }
    /** Returns all themes as an array */

  }, {
    key: "getThemes",
    value: function getThemes() {
      var _this2 = this;

      return Object.keys(this.themes).map(function (key) {
        return _this2.themes[key];
      });
    }
    /**
     * Init the theme
     */

  }, {
    key: "initTheme",
    value: function initTheme(callback) {
      if (this.active) {
        var nextTheme = this.themes[this.active]; // Theme

        document.documentElement.style.setProperty('--theme', nextTheme.quality);
        var theme = (0, _yoYo["default"])(_templateObject(), nextTheme.url);
        theme.addEventListener('load', function () {
          if (callback) callback();
        });
        document.head.insertBefore(theme, document.head.firstChild);
      }
    }
    /**
     * Change the current theme
     * @param {string} [themeName] - The name of the theme
     */

  }, {
    key: "switchTheme",
    value: function switchTheme(themeName) {
      if (themeName && !Object.keys(this.themes).includes(themeName)) {
        throw new Error("Theme ".concat(themeName, " doesn't exist"));
      }

      var next = themeName || this.active; // Name

      var nextTheme = this.themes[next]; // Theme

      if (!this.forced) this._deps.config.set('settings/theme', next);
      document.getElementById('theme-link').setAttribute('href', nextTheme.url);
      document.documentElement.style.setProperty('--theme', nextTheme.quality);
      if (themeName) this.active = themeName; // TODO: Only keep `this.emit` (issue#2210)

      this.emit('themeChanged', nextTheme);
      this.events.emit('themeChanged', nextTheme);
    }
    /**
     * fixes the invertion for images since this should be adjusted when we switch between dark/light qualified themes
     * @param {element} [image] - the dom element which invert should be fixed to increase visibility
     */

  }, {
    key: "fixInvert",
    value: function fixInvert(image) {
      var invert = this.currentTheme().quality === 'dark' ? 1 : 0;

      if (image) {
        image.style.filter = "invert(".concat(invert, ")");
      }
    }
  }]);

  return ThemeModule;
}(_engine.Plugin);

exports.ThemeModule = ThemeModule;

/***/ }),

/***/ "./app/tabs/web3-provider.js":
/*!***********************************!*\
  !*** ./app/tabs/web3-provider.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Web3ProviderModule = exports.profile = void 0;

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var profile = {
  name: 'web3Provider',
  displayName: 'Global Web3 Provider',
  description: 'Represent the current web3 provider used by the app at global scope',
  methods: ['sendAsync'],
  version: packageJson.version,
  kind: 'provider'
};
exports.profile = profile;

var Web3ProviderModule = /*#__PURE__*/function (_Plugin) {
  _inherits(Web3ProviderModule, _Plugin);

  var _super = _createSuper(Web3ProviderModule);

  function Web3ProviderModule(blockchain) {
    var _this;

    _classCallCheck(this, Web3ProviderModule);

    _this = _super.call(this, profile);
    _this.blockchain = blockchain;
    return _this;
  }
  /*
    that is used by plugins to call the current ethereum provider.
    Should be taken carefully and probably not be release as it is now.
  */


  _createClass(Web3ProviderModule, [{
    key: "sendAsync",
    value: function sendAsync(payload) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var provider = _this2.blockchain.web3().currentProvider; // see https://github.com/ethereum/web3.js/pull/1018/files#diff-d25786686c1053b786cc2626dc6e048675050593c0ebaafbf0814e1996f22022R129


        provider[provider.sendAsync ? 'sendAsync' : 'send'](payload, function (error, message) {
          if (error) return reject(error);
          resolve(message);
        });
      });
    }
  }]);

  return Web3ProviderModule;
}(_engine.Plugin);

exports.Web3ProviderModule = Web3ProviderModule;

/***/ }),

/***/ "./app/udapp/index.js":
/*!****************************!*\
  !*** ./app/udapp/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _runTab = __webpack_require__(/*! ./run-tab */ "./app/udapp/run-tab.js");

Object.keys(_runTab).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _runTab[key];
    }
  });
});

var _makeUdapp = __webpack_require__(/*! ./make-udapp */ "./app/udapp/make-udapp.js");

Object.keys(_makeUdapp).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _makeUdapp[key];
    }
  });
});

/***/ }),

/***/ "./app/udapp/make-udapp.js":
/*!*********************************!*\
  !*** ./app/udapp/make-udapp.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeUdapp = makeUdapp;

function _templateObject() {
  var data = _taggedTemplateLiteral(["<a href=\"", "\" target=\"_blank\">", "</a>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var registry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var EventsDecoder = remixLib.execution.EventsDecoder;
var transactionDetailsLinks = {
  Main: 'https://www.etherscan.io/tx/',
  Rinkeby: 'https://rinkeby.etherscan.io/tx/',
  Ropsten: 'https://ropsten.etherscan.io/tx/',
  Kovan: 'https://kovan.etherscan.io/tx/',
  Goerli: 'https://goerli.etherscan.io/tx/'
};

function txDetailsLink(network, hash) {
  if (transactionDetailsLinks[network]) {
    return transactionDetailsLinks[network] + hash;
  }
}

function makeUdapp(blockchain, compilersArtefacts, logHtmlCallback) {
  // ----------------- UniversalDApp -----------------
  // TODO: to remove when possible
  blockchain.event.register('transactionBroadcasted', function (txhash, networkName) {
    var txLink = txDetailsLink(networkName, txhash);
    if (txLink && logHtmlCallback) logHtmlCallback(yo(_templateObject(), txLink, txLink));
  }); // ----------------- Tx listener -----------------

  var _transactionReceipts = {};

  var transactionReceiptResolver = function transactionReceiptResolver(tx, cb) {
    if (_transactionReceipts[tx.hash]) {
      return cb(null, _transactionReceipts[tx.hash]);
    }

    blockchain.web3().eth.getTransactionReceipt(tx.hash, function (error, receipt) {
      if (error) {
        return cb(error);
      }

      _transactionReceipts[tx.hash] = receipt;
      cb(null, receipt);
    });
  };

  var txlistener = blockchain.getTxListener({
    api: {
      contracts: function contracts() {
        if (compilersArtefacts.__last) return compilersArtefacts.getAllContractDatas();
        return null;
      },
      resolveReceipt: transactionReceiptResolver
    }
  });
  registry.put({
    api: txlistener,
    name: 'txlistener'
  });
  blockchain.startListening(txlistener);
  var eventsDecoder = new EventsDecoder({
    resolveReceipt: transactionReceiptResolver
  });
  txlistener.startListening();
  registry.put({
    api: eventsDecoder,
    name: 'eventsDecoder'
  });
}

/***/ }),

/***/ "./app/udapp/run-tab.js":
/*!******************************!*\
  !*** ./app/udapp/run-tab.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RunTab = void 0;

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _templateObject8() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"d-flex flex-column\">\n        <div class=\"", " mt-2\">\n          All transactions (deployed contracts and function executions) in this environment can be saved and replayed in\n          another environment. e.g Transactions created in Javascript VM can be replayed in the Injected Web3.\n        </div>\n        <div class=\"", "\">\n          ", "\n          ", "\n          </div>\n        </div>\n      </div>"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"d-flex flex-column\">\n        <div class=\"ml-2 badge badge-pill badge-primary\" title=\"The number of recorded transactions\">", "</div>\n      </div>"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["<span>0</span>"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n      <span class=\"mx-2 mt-3 alert alert-warning\" data-id=\"deployAndRunNoInstanceText\" role=\"alert\">\n        Currently you have no contract instances to interact with.\n      </span>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"d-flex justify-content-between align-items-center pl-2 ml-1 mb-2\"\n        title=\"Autogenerated generic user interfaces for interaction with deployed contracts\">\n        Deployed Contracts\n        <i class=\"mr-2 ", " far fa-trash-alt\" data-id=\"deployAndRunClearInstances\" onclick=", "\n          title=\"Clear instances list and reset recorder\" aria-hidden=\"true\">\n        </i>\n      </div>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<div class=\"", " border-0 list-group-item\"></div>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n    <div class=\"list-group list-group-flush\">\n      ", "\n      ", "\n      ", "\n      ", "\n    </div>\n    "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["<div class=\"", " run-tab\" id=\"runTabView\" data-id=\"runTabView\"></div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var $ = __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var ethJSUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

var Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

var Card = __webpack_require__(/*! ../ui/card */ "./app/ui/card.js");

var css = __webpack_require__(/*! ../tabs/styles/run-tab-styles */ "./app/tabs/styles/run-tab-styles.js");

var SettingsUI = __webpack_require__(/*! ../tabs/runTab/settings.js */ "./app/tabs/runTab/settings.js");

var Recorder = __webpack_require__(/*! ../tabs/runTab/model/recorder.js */ "./app/tabs/runTab/model/recorder.js");

var RecorderUI = __webpack_require__(/*! ../tabs/runTab/recorder.js */ "./app/tabs/runTab/recorder.js");

var DropdownLogic = __webpack_require__(/*! ../tabs/runTab/model/dropdownlogic.js */ "./app/tabs/runTab/model/dropdownlogic.js");

var ContractDropdownUI = __webpack_require__(/*! ../tabs/runTab/contractDropdown.js */ "./app/tabs/runTab/contractDropdown.js");

var UniversalDAppUI = __webpack_require__(/*! ../ui/universal-dapp-ui */ "./app/ui/universal-dapp-ui.js");

var profile = {
  name: 'udapp',
  displayName: 'Deploy & run transactions',
  icon: 'assets/img/deployAndRun.webp',
  description: 'execute and save transactions',
  kind: 'udapp',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/run.html',
  version: packageJson.version,
  permission: true,
  events: ['newTransaction'],
  methods: ['createVMAccount', 'sendTransaction', 'getAccounts', 'pendingTransactionsCount']
};

var RunTab = /*#__PURE__*/function (_LibraryPlugin) {
  _inherits(RunTab, _LibraryPlugin);

  var _super = _createSuper(RunTab);

  function RunTab(blockchain, pluginUDapp, config, fileManager, editor, filePanel, compilersArtefacts, networkModule, mainView, fileProvider) {
    var _this;

    _classCallCheck(this, RunTab);

    _this = _super.call(this, pluginUDapp, profile);
    _this.event = new EventManager();
    _this.config = config;
    _this.blockchain = blockchain;
    _this.fileManager = fileManager;
    _this.editor = editor;

    _this.logCallback = function (msg) {
      mainView.getTerminal().logHtml(msg);
    };

    _this.filePanel = filePanel;
    _this.compilersArtefacts = compilersArtefacts;
    _this.networkModule = networkModule;
    _this.fileProvider = fileProvider;
    return _this;
  }

  _createClass(RunTab, [{
    key: "renderContainer",
    value: function renderContainer() {
      this.container = yo(_templateObject(), css.runTabView);
      var el = yo(_templateObject2(), this.settingsUI.render(), this.contractDropdownUI.render(), this.recorderCard.render(), this.instanceContainer);
      this.container.appendChild(el);
      return this.container;
    }
  }, {
    key: "renderInstanceContainer",
    value: function renderInstanceContainer() {
      var _this2 = this;

      this.instanceContainer = yo(_templateObject3(), css.instanceContainer);
      var instanceContainerTitle = yo(_templateObject4(), css.icon, function () {
        return _this2.event.trigger('clearInstance', []);
      });
      this.noInstancesText = yo(_templateObject5());
      this.event.register('clearInstance', function () {
        _this2.instanceContainer.innerHTML = ''; // clear the instances list

        _this2.instanceContainer.appendChild(instanceContainerTitle);

        _this2.instanceContainer.appendChild(_this2.noInstancesText);
      });
      this.instanceContainer.appendChild(instanceContainerTitle);
      this.instanceContainer.appendChild(this.noInstancesText);
    }
  }, {
    key: "renderSettings",
    value: function renderSettings() {
      var _this3 = this;

      this.settingsUI = new SettingsUI(this.blockchain, this.networkModule);
      this.settingsUI.event.register('clearInstance', function () {
        _this3.event.trigger('clearInstance', []);
      });
    }
  }, {
    key: "renderDropdown",
    value: function renderDropdown(udappUI, fileManager, compilersArtefacts, config, editor, logCallback) {
      var _this4 = this;

      var dropdownLogic = new DropdownLogic(compilersArtefacts, config, editor, this);
      this.contractDropdownUI = new ContractDropdownUI(this.blockchain, dropdownLogic, logCallback, this);
      fileManager.events.on('currentFileChanged', this.contractDropdownUI.changeCurrentFile.bind(this.contractDropdownUI));
      this.contractDropdownUI.event.register('clearInstance', function () {
        var noInstancesText = _this4.noInstancesText;

        if (noInstancesText.parentNode) {
          noInstancesText.parentNode.removeChild(noInstancesText);
        }
      });
      this.contractDropdownUI.event.register('newContractABIAdded', function (abi, address) {
        _this4.instanceContainer.appendChild(udappUI.renderInstanceFromABI(abi, address, '<at address>'));
      });
      this.contractDropdownUI.event.register('newContractInstanceAdded', function (contractObject, address, value) {
        _this4.instanceContainer.appendChild(udappUI.renderInstance(contractObject, address, value));
      });
    }
  }, {
    key: "renderRecorder",
    value: function renderRecorder(udappUI, fileManager, config, logCallback) {
      var _this5 = this;

      this.recorderCount = yo(_templateObject6());
      var recorder = new Recorder(this.blockchain);
      recorder.event.register('recorderCountChange', function (count) {
        _this5.recorderCount.innerText = count;
      });
      this.event.register('clearInstance', recorder.clearAll.bind(recorder));
      this.recorderInterface = new RecorderUI(this.blockchain, fileManager, recorder, logCallback, config);
      this.recorderInterface.event.register('newScenario', function (abi, address, contractName) {
        var noInstancesText = _this5.noInstancesText;

        if (noInstancesText.parentNode) {
          noInstancesText.parentNode.removeChild(noInstancesText);
        }

        _this5.instanceContainer.appendChild(udappUI.renderInstanceFromABI(abi, address, contractName));
      });
      this.recorderInterface.render();
    }
  }, {
    key: "renderRecorderCard",
    value: function renderRecorderCard() {
      var collapsedView = yo(_templateObject7(), this.recorderCount);
      var expandedView = yo(_templateObject8(), css.recorderDescription, css.transactionActions, this.recorderInterface.recordButton, this.recorderInterface.runButton);
      this.recorderCard = new Card({}, {}, {
        title: 'Transactions recorded',
        collapsedView: collapsedView
      });
      this.recorderCard.event.register('expandCollapseCard', function (arrow, body, status) {
        body.innerHTML = '';
        status.innerHTML = '';

        if (arrow === 'down') {
          status.appendChild(collapsedView);
          body.appendChild(expandedView);
        } else if (arrow === 'up') {
          status.appendChild(collapsedView);
        }
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this6 = this;

      this.udappUI = new UniversalDAppUI(this.blockchain, this.logCallback);
      this.blockchain.resetAndInit(this.config, {
        getAddress: function getAddress(cb) {
          cb(null, $('#txorigin').val());
        },
        getValue: function getValue(cb) {
          try {
            var number = document.querySelector('#value').value;
            var select = document.getElementById('unit');
            var index = select.selectedIndex;
            var selectedUnit = select.querySelectorAll('option')[index].dataset.unit;
            var unit = 'ether'; // default

            if (['ether', 'finney', 'gwei', 'wei'].indexOf(selectedUnit) >= 0) {
              unit = selectedUnit;
            }

            cb(null, Web3.utils.toWei(number, unit));
          } catch (e) {
            cb(e);
          }
        },
        getGasLimit: function getGasLimit(cb) {
          try {
            cb(null, '0x' + new ethJSUtil.BN($('#gasLimit').val(), 10).toString(16));
          } catch (e) {
            cb(e.message);
          }
        }
      });
      this.renderInstanceContainer();
      this.renderSettings();
      this.renderDropdown(this.udappUI, this.fileManager, this.compilersArtefacts, this.config, this.editor, this.logCallback);
      this.renderRecorder(this.udappUI, this.fileManager, this.config, this.logCallback);
      this.renderRecorderCard();

      var addPluginProvider = function addPluginProvider(profile) {
        if (profile.kind === 'provider') {
          (function (profile, app) {
            var web3Provider = {
              sendAsync: function sendAsync(payload, callback) {
                return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                  var result;
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.prev = 0;
                          _context.next = 3;
                          return app.call(profile.name, 'sendAsync', payload);

                        case 3:
                          result = _context.sent;
                          callback(null, result);
                          _context.next = 10;
                          break;

                        case 7:
                          _context.prev = 7;
                          _context.t0 = _context["catch"](0);
                          callback(_context.t0);

                        case 10:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, null, [[0, 7]]);
                }))();
              }
            };
            app.blockchain.addProvider({
              name: profile.displayName,
              provider: web3Provider
            });
          })(profile, _this6);
        }
      };

      var removePluginProvider = function removePluginProvider(profile) {
        if (profile.kind === 'provider') _this6.blockchain.removeProvider(profile.displayName);
      };

      this.on('manager', 'pluginActivated', addPluginProvider.bind(this));
      this.on('manager', 'pluginDeactivated', removePluginProvider.bind(this));
      return this.renderContainer();
    }
  }]);

  return RunTab;
}(_engine.LibraryPlugin);

exports.RunTab = RunTab;

/***/ }),

/***/ "./app/ui/TreeView.js":
/*!****************************!*\
  !*** ./app/ui/TreeView.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject8() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"d-flex mt-2 flex-row ", "\">\n        <label class=\"small font-weight-bold pr-1 ", "\">", ":</label> \n        <label class=\"m-0 ", "\">", "</label>\n      </div>\n    "]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["<li><span class=\"w-100 text-primary ", "\" data-id=\"treeViewLoadMore\" onclick=\"", "\">Load more</span></li>"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["<ul key=", " data-id=\"treeViewUlList", "\" class=\"pl-2 ", "\">", "</ul>"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n      <div key=", " data-id=\"treeViewDiv", "\" class=\"d-flex flex-row align-items-center\">\n        ", "\n        <span class=\"w-100\">", "</span>\n      </div>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<div class=\"px-1 fas fa-caret-right caret ", "\"></div>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<li key=", " data-id=\"treeViewLi", "\" class=", "></li>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<ul key=", " data-id=\"treeViewUl", "\" class=\"", " ml-0 px-2\">", "</ul>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .li_tv {\n    list-style-type: none;\n    -webkit-margin-before: 0px;\n    -webkit-margin-after: 0px;\n    -webkit-margin-start: 0px;\n    -webkit-margin-end: 0px;\n    -webkit-padding-start: 0px;\n  }\n  .ul_tv {\n    list-style-type: none;\n    -webkit-margin-before: 0px;\n    -webkit-margin-after: 0px;\n    -webkit-margin-start: 0px;\n    -webkit-margin-end: 0px;\n    -webkit-padding-start: 0px;\n  }\n  .caret_tv {\n    width: 10px;\n    flex-shrink: 0;\n    padding-right: 5px;\n  }\n  .label_item {\n    word-break: break-all;\n  }\n  .label_key {\n    min-width: 15%;\n    max-width: 80%;\n    word-break: break-word;\n  }\n  .label_value {\n    min-width: 10%;\n  }\n  .cursor_pointer {\n    cursor: pointer;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");
/**
 * TreeView
 *  - extendable by specifying custom `extractData` and `formatSelf` function
 *  - trigger `nodeClick` and `leafClick`
 */


var TreeView = /*#__PURE__*/function () {
  function TreeView(opts) {
    _classCallCheck(this, TreeView);

    this.event = new EventManager();
    this.extractData = opts.extractData || this.extractDataDefault;
    this.formatSelf = opts.formatSelf || this.formatSelfDefault;
    this.loadMore = opts.loadMore;
    this.view = null;
    this.expandPath = [];
  }

  _createClass(TreeView, [{
    key: "render",
    value: function render(json, expand) {
      var view = this.renderProperties(json, expand);

      if (!this.view) {
        this.view = view;
      }

      return view;
    }
  }, {
    key: "update",
    value: function update(json) {
      if (this.view) {
        yo.update(this.view, this.render(json));
      }
    }
  }, {
    key: "renderObject",
    value: function renderObject(item, parent, key, expand, keyPath) {
      var _this = this;

      var data = this.extractData(item, parent, key);
      var children = (data.children || []).map(function (child, index) {
        return _this.renderObject(child.value, data, child.key, expand, keyPath + '/' + child.key);
      });
      return this.formatData(key, data, children, expand, keyPath);
    }
  }, {
    key: "renderProperties",
    value: function renderProperties(json, expand, key) {
      var _this2 = this;

      key = key || '';
      var children = Object.keys(json).map(function (innerkey) {
        return _this2.renderObject(json[innerkey], json, innerkey, expand, innerkey);
      });
      return yo(_templateObject2(), key, key, css.ul_tv, children);
    }
  }, {
    key: "formatData",
    value: function formatData(key, data, children, expand, keyPath) {
      var self = this;
      var li = yo(_templateObject3(), keyPath, keyPath, css.li_tv);
      var caret = yo(_templateObject4(), css.caret_tv);
      var label = yo(_templateObject5(), keyPath, keyPath, caret, self.formatSelf(key, data, li));
      var expanded = self.expandPath.includes(keyPath);
      li.appendChild(label);

      if (data.children) {
        var list = yo(_templateObject6(), keyPath, keyPath, css.ul_tv, children);
        list.style.display = expanded ? 'block' : 'none';
        caret.className = list.style.display === 'none' ? "fas fa-caret-right caret ".concat(css.caret_tv) : "fas fa-caret-down caret ".concat(css.caret_tv);
        caret.setAttribute('data-id', "treeViewToggle".concat(keyPath));

        label.onclick = function () {
          self.expand(keyPath);

          if (self.isExpanded(keyPath)) {
            if (!self.expandPath.includes(keyPath)) self.expandPath.push(keyPath);
          } else {
            self.expandPath = self.expandPath.filter(function (path) {
              return !path.startsWith(keyPath);
            });
          }
        };

        label.oncontextmenu = function (event) {
          self.event.trigger('nodeRightClick', [keyPath, data, label, event]);
        };

        li.appendChild(list);

        if (data.hasNext) {
          list.appendChild(yo(_templateObject7(), css.cursor_pointer, function () {
            return self.loadMore(data.cursor);
          }));
        }
      } else {
        caret.style.visibility = 'hidden';

        label.oncontextmenu = function (event) {
          self.event.trigger('leafRightClick', [keyPath, data, label, event]);
        };

        label.onclick = function (event) {
          self.event.trigger('leafClick', [keyPath, data, label, event]);
        };
      }

      return li;
    }
  }, {
    key: "isExpanded",
    value: function isExpanded(path) {
      var current = this.nodeAt(path);

      if (current) {
        return current.style.display !== 'none';
      }

      return false;
    }
  }, {
    key: "expand",
    value: function expand(path) {
      var caret = this.caretAt(path);
      var node = this.nodeAt(path);

      if (node) {
        node.style.display = node.style.display === 'none' ? 'block' : 'none';
        caret.className = node.style.display === 'none' ? "fas fa-caret-right caret ".concat(css.caret_tv) : "fas fa-caret-down caret ".concat(css.caret_tv);
        this.event.trigger('nodeClick', [path, node]);
      }
    }
  }, {
    key: "caretAt",
    value: function caretAt(path) {
      var label = this.labelAt(path);

      if (label) {
        return label.querySelector('.caret');
      }
    }
  }, {
    key: "itemAt",
    value: function itemAt(path) {
      return this.view.querySelector("li[key=\"".concat(path, "\"]"));
    }
  }, {
    key: "labelAt",
    value: function labelAt(path) {
      return this.view.querySelector("div[key=\"".concat(path, "\"]"));
    }
  }, {
    key: "nodeAt",
    value: function nodeAt(path) {
      return this.view.querySelector("ul[key=\"".concat(path, "\"]"));
    }
  }, {
    key: "updateNodeFromJSON",
    value: function updateNodeFromJSON(path, jsonTree, expand) {
      var newTree = this.renderProperties(jsonTree, expand, path);
      var current = this.nodeAt(path);

      if (current && current.parentElement) {
        current.parentElement.replaceChild(newTree, current);
      }
    }
  }, {
    key: "formatSelfDefault",
    value: function formatSelfDefault(key, data) {
      return yo(_templateObject8(), css.label_item, css.label_key, key, css.label_value, data.self);
    }
  }, {
    key: "extractDataDefault",
    value: function extractDataDefault(item, parent, key) {
      var ret = {};

      if (item instanceof Array) {
        ret.children = item.map(function (item, index) {
          return {
            key: index,
            value: item
          };
        });
        ret.self = 'Array';
        ret.isNode = true;
        ret.isLeaf = false;
      } else if (item instanceof Object) {
        ret.children = Object.keys(item).map(function (key) {
          return {
            key: key,
            value: item[key]
          };
        });
        ret.self = 'Object';
        ret.isNode = true;
        ret.isLeaf = false;
      } else {
        ret.self = item;
        ret.children = null;
        ret.isNode = false;
        ret.isLeaf = true;
      }

      return ret;
    }
  }]);

  return TreeView;
}();

module.exports = TreeView;

/***/ }),

/***/ "./app/ui/auto-complete-popup.js":
/*!***************************************!*\
  !*** ./app/ui/auto-complete-popup.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n              <div data-id=\"autoCompletePopUpAutoCompleteItem\" class=\"", " ", " item ", "\">\n                  <div value=", " onclick=", ">\n                    ", " \n                  </div>\n                  <div>\n                    ", "\n                  </div>\n              </div>\n            "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", " alert alert-secondary\">\n        <div>\n          ", "\n        </div>\n        <div class=\"", "\">\n          <div class=\"", "\">Page ", " of ", "</div>\n        </div>\n      </div>\n    "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var EventManager = remixLib.EventManager;

var Commands = __webpack_require__(/*! ../../lib/commands */ "./lib/commands.js"); // -------------- styling ----------------------


var css = __webpack_require__(/*! ./styles/auto-complete-popup-styles */ "./app/ui/styles/auto-complete-popup-styles.js");
/* USAGE:

  var autoCompletePopup = new AutoCompletePopup({
    options: []
  })
  autoCompletePopup.event.register('handleSelect', function (input) { })
  autoCompletePopup.event.register('updateList', function () { })

*/


var AutoCompletePopup = /*#__PURE__*/function () {
  function AutoCompletePopup() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AutoCompletePopup);

    var self = this;
    self.event = new EventManager();
    self.isOpen = false;
    self.opts = opts;
    self.data = {
      _options: []
    };
    self._components = {};
    self._view = null;
    self._startingElement = 0;
    self._elementsToShow = 4;
    self._selectedElement = 0;
    this.extraCommands = [];
  }

  _createClass(AutoCompletePopup, [{
    key: "render",
    value: function render() {
      var self = this;
      var autoComplete = yo(_templateObject(), css.popup, self.data._options.map(function (item, index) {
        return yo(_templateObject2(), css.autoCompleteItem, css.listHandlerHide, self._selectedElement === index ? 'border border-primary' : '', index, function (event) {
          self.handleSelect(event.srcElement.innerText);
        }, getKeyOf(item), getValueOf(item));
      }), css.listHandlerHide, css.pageNumberAlignment, self._startingElement / self._elementsToShow + 1, Math.ceil(self.data._options.length / self._elementsToShow));

      function setUpPopUp(autoComplete) {
        handleOpenPopup(autoComplete);
        handleListSize(autoComplete);
      }

      function handleOpenPopup(autoComplete) {
        autoComplete.style.display = self.data._options.length > 0 ? 'block' : 'none';
      }

      function handleListSize(autoComplete) {
        if (self.data._options.length >= self._startingElement) {
          for (var i = self._startingElement; i < self._elementsToShow + self._startingElement; i++) {
            var el = autoComplete.querySelectorAll('.item')[i];

            if (el) {
              el.classList.remove(css.listHandlerHide);
              el.classList.add(css.listHandlerShow);
            }
          }
        }
      }

      setUpPopUp(autoComplete);
      if (!this._view) this._view = autoComplete;
      return autoComplete;
    }
  }, {
    key: "handleSelect",
    value: function handleSelect(text) {
      this.removeAutoComplete();
      this.event.trigger('handleSelect', [text]);
    }
  }, {
    key: "moveUp",
    value: function moveUp() {
      if (this._selectedElement === 0) return;
      this._selectedElement--;
      this._startingElement = this._selectedElement > 0 ? this._selectedElement - 1 : 0;
      this.event.trigger('updateList');
      yo.update(this._view, this.render());
    }
  }, {
    key: "moveDown",
    value: function moveDown() {
      if (this.data._options.length <= this._selectedElement + 1) return;
      this._selectedElement++;
      this._startingElement = this._selectedElement - 1;
      this.event.trigger('updateList');
      yo.update(this._view, this.render());
    }
  }, {
    key: "handleAutoComplete",
    value: function handleAutoComplete(event, inputString) {
      var _this = this;

      if (this.isOpen && (event.which === 27 || event.which === 8 || event.which === 46)) {
        // backspace or any key that should remove the autocompletion
        this.removeAutoComplete();
        return true;
      }

      if (this.isOpen && (event.which === 13 || event.which === 9)) {
        // enter and tab (validate completion)
        event.preventDefault();

        if (this.data._options[this._selectedElement]) {
          this.handleSelect(getKeyOf(this.data._options[this._selectedElement]));
        }

        this.removeAutoComplete();
        return true;
      }

      if (this.isOpen && event.which === 38) {
        // move up
        event.preventDefault();
        this.isOpen = true;
        this.moveUp();
        return true;
      }

      if (this.isOpen && event.which === 40) {
        // move down
        event.preventDefault();
        this.isOpen = true;
        this.moveDown();
        return true;
      }

      if (event.which === 13 || event.which === 9) {
        // enter || tab and autocompletion is off, just returning false
        return false;
      }

      var textList = inputString.split(' ');
      var autoCompleteInput = textList.length > 1 ? textList[textList.length - 1] : textList[0];

      if (inputString.length >= 2) {
        // more than 2 letters, start completion
        this.data._options = [];
        Commands.allPrograms.forEach(function (item) {
          var program = getKeyOf(item);

          if (program.substring(0, program.length - 1).includes(autoCompleteInput.trim())) {
            _this.data._options.push(item);
          } else if (autoCompleteInput.trim().includes(program) || program === autoCompleteInput.trim()) {
            Commands.allCommands.forEach(function (item) {
              var command = getKeyOf(item);

              if (command.includes(autoCompleteInput.trim())) {
                _this.data._options.push(item);
              }
            });
          }
        });
        this.extraCommands.forEach(function (item) {
          var command = getKeyOf(item);

          if (command.includes(autoCompleteInput.trim())) {
            _this.data._options.push(item);
          }
        });

        if (this.data._options.length === 1 && event.which === 9) {
          // if only one option and tab is pressed, we resolve it
          event.preventDefault();
          textList.pop();
          textList.push(getKeyOf(this.data._options[0]));
          this.handleSelect("".concat(textList).replace(/,/g, ' '));
          this.removeAutoComplete();
          return;
        }

        if (this.data._options.length) this.isOpen = true;
        yo.update(this._view, this.render());
        return true;
      }

      return false;
    }
  }, {
    key: "removeAutoComplete",
    value: function removeAutoComplete() {
      if (!this.isOpen) return;
      this._view.style.display = 'none';
      this.isOpen = false;
      this.data._options = [];
      this._startingElement = 0;
      this._selectedElement = 0;
      yo.update(this._view, this.render());
    }
  }, {
    key: "extendAutocompletion",
    value: function extendAutocompletion() {
      var _this2 = this;

      // TODO: this is not using the appManager interface. Terminal should be put as module
      this.opts.appManager.event.on('activate', /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(profile) {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (profile.methods) {
                    _context.next = 2;
                    break;
                  }

                  return _context.abrupt("return");

                case 2:
                  profile.methods.forEach(function (method) {
                    var key = "remix.call('".concat(profile.name, "', '").concat(method, "')");
                    var keyValue = {};
                    keyValue[key] = "call ".concat(profile.name, " - ").concat(method);
                    if (_this2.extraCommands.includes(keyValue)) return;

                    _this2.extraCommands.push(keyValue);
                  });

                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
    }
  }]);

  return AutoCompletePopup;
}();

function getKeyOf(item) {
  return Object.keys(item)[0];
}

function getValueOf(item) {
  return Object.values(item)[0];
}

module.exports = AutoCompletePopup;

/***/ }),

/***/ "./app/ui/card.js":
/*!************************!*\
  !*** ./app/ui/card.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n  .cardContainer {\n    padding             : 0 24px 16px;\n    margin              : 0;\n    background          : none;\n  }\n  .arrow {\n    font-weight         : bold;\n    cursor              : pointer;\n    font-size           : 14px;\n  }\n  .arrow:hover {\n  }\n\n"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", " list-group-item border-0\">\n        ", "\n        ", "\n      </div>"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n    <div class=\"d-flex justify-content-between align-items-center\" onclick=", ">\n      <div class=\"pr-1 d-flex flex-row\">\n        <div>", "</div>\n        ", "\n      </div>\n      <div>", "</div>\n    </div>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<div>", "</div>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n    <div>", "</div>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<i class=\"", " fas fa-angle-down\" onclick=\"", "\"></i>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["<div></div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

module.exports = /*#__PURE__*/function () {
  function Card(api, events, opts) {
    _classCallCheck(this, Card);

    var self = this;
    self._api = api;
    self._events = events;
    self._opts = opts;
    self._view = {};
    self.event = new EventManager();
  }

  _createClass(Card, [{
    key: "render",
    value: function render() {
      var _this = this;

      var self = this;
      if (self._view.el) return self._view.el;
      self._view.cardBody = yo(_templateObject());
      self._view.arrow = yo(_templateObject2(), css.arrow, function () {
        return trigger(_this);
      });
      self._view.expandCollapseButton = yo(_templateObject3(), self._view.arrow);
      self._view.statusBar = yo(_templateObject4(), self._opts.collapsedView);
      self._view.cardHeader = yo(_templateObject5(), function () {
        return trigger(self._view.arrow);
      }, self._opts.title, self._view.statusBar, self._view.expandCollapseButton);

      function trigger(el) {
        var body = self._view.cardBody;
        var status = self._view.statusBar;

        if (el.classList) {
          el.classList.toggle('fa-angle-up');
          var arrow = el.classList.toggle('fa-angle-down') ? 'up' : 'down';
          self.event.trigger('expandCollapseCard', [arrow, body, status]);
        }
      } // HTML


      self._view.el = yo(_templateObject6(), css.cardContainer, self._view.cardHeader, self._view.cardBody);
      return self._view.el;
    }
  }]);

  return Card;
}();

var css = csjs(_templateObject7());

/***/ }),

/***/ "./app/ui/confirmDialog.js":
/*!*********************************!*\
  !*** ./app/ui/confirmDialog.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n  <div>\n    <div>You are creating a transaction on the main network. Click confirm if you are sure to continue.</div>\n    <div class=", ">\n      <div>From: ", "</div>\n      <div>To: ", "</div>\n      <div>Amount: ", " Ether</div>\n      <div>Gas estimation: ", "</div>\n      <div>Gas limit: ", "</div>\n      <div>Gas price: <input id='gasprice' oninput=", " /> Gwei <span> (visit <a target='_blank' href='https://ethgasstation.info'>ethgasstation.info</a> to get more info about gas price)</span></div>\n      <div>Max transaction fee:<span id='txfee'></span></div>\n      <div>Data:</div>\n      <pre class=", ">", " ", "</pre>\n    </div>\n    <div class=", ">\n      <input id='confirmsetting' type=\"checkbox\">\n      <i class=\"fas fa-exclamation-triangle\" aria-hidden=\"true\"></i> Do not ask for confirmation again. (the setting will not be persisted for the next page reload)\n    </div>\n  </div>\n  "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .txInfoBox {\n  }\n  .wrapword {\n    white-space: pre-wrap;       /* Since CSS 2.1 */\n    white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */\n    white-space: -pre-wrap;      /* Opera 4-6 */\n    white-space: -o-pre-wrap;    /* Opera 7 */\n    word-wrap: break-word;       /* Internet Explorer 5.5+ */\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var copyToClipboard = __webpack_require__(/*! ./copy-to-clipboard */ "./app/ui/copy-to-clipboard.js");

var css = csjs(_templateObject()); // TODO: self is not actually used and can be removed

function confirmDialog(tx, amount, gasEstimation, self, newGasPriceCb, initialParamsCb) {
  var onGasPriceChange = function onGasPriceChange() {
    var gasPrice = el.querySelector('#gasprice').value;
    newGasPriceCb(gasPrice, function (txFeeText, priceStatus) {
      el.querySelector('#txfee').innerHTML = txFeeText;
      el.gasPriceStatus = priceStatus;
    });
  };

  var el = yo(_templateObject2(), css.txInfoBox, tx.from, tx.to ? tx.to : '(Contract Creation)', amount, gasEstimation, tx.gas, onGasPriceChange, css.wrapword, tx.data && tx.data.length > 50 ? tx.data.substring(0, 49) + '...' : tx.data, copyToClipboard(function () {
    return tx.data;
  }), css.checkbox);
  initialParamsCb(function (txFeeText, gasPriceValue, gasPriceStatus) {
    if (txFeeText) {
      el.querySelector('#txfee').innerHTML = txFeeText;
    }

    if (gasPriceValue) {
      el.querySelector('#gasprice').value = gasPriceValue;
      onGasPriceChange();
    }

    if (gasPriceStatus !== undefined) {
      el.gasPriceStatus = gasPriceStatus;
    }
  });
  return el;
}

module.exports = confirmDialog;

/***/ }),

/***/ "./app/ui/contextMenu.js":
/*!*******************************!*\
  !*** ./app/ui/contextMenu.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n    <div id=\"menuItemsContainer\" class=\"p-1 ", " bg-light shadow border\">\n     <ul id='menuitems'>", " ", "</ul>\n    </div>\n  "]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<li id=\"menuitem", "\" class=", "><a href=", " target=\"_blank\">", "</a></li>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral([""]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<li id=\"menuitem", "\" class=", ">", "</li>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n    .container\n    {\n      display: none;\n      position: fixed;\n      border-radius: 2px;\n      z-index: 1000;\n      box-shadow: 0 0 4px var(--dark);\n    }\n    .liitem\n    {\n      padding: 2px;\n      padding-left: 6px;\n      cursor: pointer;\n      color: var(--text-dark);\n      background-color: var(--light);\n    }\n    .liitem:hover\n    {\n      background-color:  var(--secondary);\n    }\n    #menuitems\n    {\n      list-style: none;\n      margin: 0px;\n    }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js"); // -------------- copyToClipboard ----------------------


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());

module.exports = function (event, items, linkItems) {
  event.preventDefault();

  function hide(event, force) {
    if (container && container.parentElement && (force || event.target !== container)) {
      container.parentElement.removeChild(container);
    }

    window.removeEventListener('click', hide);
  }

  var menu = Object.keys(items).map(function (item, index) {
    var current = yo(_templateObject2(), item.toLowerCase(), css.liitem, item);

    current.onclick = function () {
      hide(null, true);
      items[item]();
    };

    return current;
  });
  var menuForLinks = yo(_templateObject3());

  if (linkItems) {
    menuForLinks = Object.keys(linkItems).map(function (item, index) {
      var current = yo(_templateObject4(), item.toLowerCase(), css.liitem, linkItems[item], item);

      current.onclick = function () {
        hide(null, true);
      };

      return current;
    });
  }

  var container = yo(_templateObject5(), css.container, menu, menuForLinks);
  container.style.left = event.pageX + 'px';
  container.style.top = event.pageY + 'px';
  container.style.display = 'block';
  document.querySelector('body').appendChild(container);
  var menuItemsContainer = document.getElementById('menuItemsContainer');
  var boundary = menuItemsContainer.getBoundingClientRect();

  if (boundary.bottom > (window.innerHeight || document.documentElement.clientHeight)) {
    menuItemsContainer.style.position = 'absolute';
    menuItemsContainer.style.bottom = '10px';
    menuItemsContainer.style.top = null;
  }

  setTimeout(function () {
    window.addEventListener('click', hide);
  }, 500);
  return {
    hide: hide
  };
};

/***/ }),

/***/ "./app/ui/copy-to-clipboard.js":
/*!*************************************!*\
  !*** ./app/ui/copy-to-clipboard.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject2() {
  var data = _taggedTemplateLiteral(["<i title=\"", "\" class=\"", " far ", " p-2\" data-id=\"copyToClipboardCopyIcon\" aria-hidden=\"true\"></i>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .copyIcon {\n    margin-left: 5px;\n    cursor: pointer;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js"); // -------------- copyToClipboard ----------------------


var copy = __webpack_require__(/*! copy-text-to-clipboard */ "../../../node_modules/copy-text-to-clipboard/index.js");

var addTooltip = __webpack_require__(/*! ./tooltip */ "./app/ui/tooltip.js"); // -------------- styling ----------------------


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());

module.exports = function copyToClipboard(getContent) {
  var tip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Copy value to clipboard';
  var icon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'fa-copy';
  var copyIcon = yo(_templateObject2(), tip, css.copyIcon, icon);

  copyIcon.onclick = function (event) {
    event.stopPropagation();
    var copiableContent;

    try {
      copiableContent = getContent();
    } catch (e) {
      addTooltip(e.message);
      return;
    }

    if (copiableContent) {
      // module `copy` keeps last copied thing in the memory, so don't show tooltip if nothing is copied, because nothing was added to memory
      try {
        if (typeof copiableContent !== 'string') {
          copiableContent = JSON.stringify(copiableContent, null, '\t');
        }
      } catch (e) {}

      copy(copiableContent);
      addTooltip('Copied value to clipboard.');
    } else {
      addTooltip('Cannot copy empty content!');
    }
  };

  return copyIcon;
};

/***/ }),

/***/ "./app/ui/landing-page/landing-page.js":
/*!*********************************************!*\
  !*** ./app/ui/landing-page/landing-page.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LandingPage = void 0;

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../../package.json */ "../../../package.json"));

var _engineWeb = __webpack_require__(/*! @remixproject/engine-web */ "../../../node_modules/@remixproject/engine-web/index.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject15() {
  var data = _taggedTemplateLiteral(["<span>please checkout <a class='text-primary' href=\"https://github.com/Crypto-Punkers/resolver-engine\" target='_blank'>https://github.com/Crypto-Punkers/resolver-engine</a> for more information</span>"]);

  _templateObject15 = function _templateObject15() {
    return data;
  };

  return data;
}

function _templateObject14() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", " d-flex\" data-id=\"landingPageHomeContainer\">\n        <div class=\"", " bg-light\">\n          <div class=\"d-flex justify-content-between\">\n            <div class=\"d-flex flex-column\">\n              <div class=\"border-bottom d-flex justify-content-between clearfix py-3 mb-4\">\n                <div class=\"mx-4 w-100\">\n                  ", "\n                  <audio id=\"remiAudio\" muted=false src=\"assets/audio/remiGuitar-single-power-chord-A-minor.wav\"></audio>\n                </div>\n              </div>\n              <div class=\"row ", " mx-4\" data-id=\"landingPageHpSections\">\n                <div class=\"ml-3\">\n                  <div class=\"plugins mb-5\">\n                  <h4>Featured Plugins</h4>\n                  <div class=\"d-flex flex-row pt-2\">\n                    ", "\n                    ", "\n                    ", "\n                    ", "\n                    ", "\n                    ", "\n                  </div>\n                </div>\n                  <div class=\"d-flex\">\n                    <div class=\"file\">\n                      <h4>File</h4>\n                      <p class=\"mb-1\">\n                        <i class=\"mr-1 far fa-file\"></i>\n                        <span class=\"ml-1 mb-1 ", "\" onclick=", ">New File</span>\n                      </p>\n                      <p class=\"mb-1\">\n                        <i class=\"mr-1 far fa-file-alt\"></i>\n                        <label class=\"ml-1 ", " ", " ", "\">\n                          Open Files\n                          <input title=\"open file\" type=\"file\" onchange=\"", "\" multiple />\n                        </label>\n                      </p>\n                      <p class=\"mb-1\">\n                        <i class=\"far fa-hdd\"></i>\n                        <span class=\"ml-1 ", "\" onclick=", ">Connect to Localhost</span>\n                      </p>\n                      <p class=\"mt-3 mb-0\"><label>IMPORT FROM:</label></p>\n                      <div class=\"btn-group\">\n                        <button class=\"btn mr-1 btn-secondary\" data-id=\"landingPageImportFromGistButton\" onclick=\"", "\">Gist</button>\n                        <button class=\"btn mx-1 btn-secondary\" onclick=\"", "\">GitHub</button>\n                        <button class=\"btn mx-1 btn-secondary\" onclick=\"", "\">Swarm</button>\n                        <button class=\"btn mx-1 btn-secondary\" onclick=\"", "\">Ipfs</button>\n                        <button class=\"btn mx-1 btn-secondary\" onclick=\"", "\">https</button>\n                        <button class=\"btn mx-1 btn-secondary  text-nowrap\" onclick=\"", "\">Resolver-engine</button>\n                      </div><!-- end of btn-group -->\n                    </div><!-- end of div.file -->\n                    <div class=\"ml-4 pl-4\">\n                      <h4>Resources</h4>\n                      <p class=\"mb-1\">\n                        <i class=\"mr-1 fas fa-book\"></i>\n                        <a class=\"", "\" target=\"__blank\" href=\"https://remix-ide.readthedocs.io/en/latest/#\">Documentation</a>\n                      </p>\n                      <p class=\"mb-1\">\n                        <i class=\"mr-1 fab fa-gitter\"></i>\n                        <a class=\"", "\" target=\"__blank\" href=\"https://gitter.im/ethereum/remix\">Gitter channel</a>\n                        </p>\n                      <p class=\"mb-1\">\n                        ", "\n                        <a class=\"", "\" target=\"__blank\" href=\"https://remix-project.org\">Featuring website</a>\n                      </p>\n                      <p>\n                        <i class=\"fab fa-ethereum ", "\"></i>\n                        <span class=\"", "\" onclick=", ">Old experience</span>\n                      </p>\n                    </div>\n                  </div>\n                </div>\n              </div><!-- end of hpSections -->\n            </div>\n            <div class=\"d-flex flex-column ", "\">\n              <div class=\"d-flex pr-3 py-2 align-self-end\"  id=\"remixIDEMediaPanelsTitle\">\n                ", "\n                ", "\n              </div>\n              <div class=\"mr-3 d-flex bg-light ", "\" id=\"remixIDEMediaPanels\">\n                ", "\n                ", "\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    "]);

  _templateObject14 = function _templateObject14() {
    return data;
  };

  return data;
}

function _templateObject13() {
  var data = _taggedTemplateLiteral(["<script src=\"https://www.twilik.com/assets/retainable/rss-embed/retainable-rss-embed.js\"></script>"]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteral(["<img class=", " src=\"assets/img/guitarRemiCroped.webp\" onclick=\"", "\"></img>"]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function _templateObject11() {
  var data = _taggedTemplateLiteral(["<img id='remixHhomeWebsite' class=\"mr-1 ", "\" src=\"", "\"></img>"]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["\n        <button\n          class=\"btn border-secondary d-flex mr-3 text-nowrap justify-content-center flex-column align-items-center ", "\"\n          data-id=\"landingPageStartSolidity\"\n          onclick=", "\n        >\n          <img class=\"m-2 align-self-center ", "\" id=", " src=\"", "\">\n          <label class=\"text-uppercase text-dark ", "\">", "</label>\n        </button>\n      "]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _templateObject9() {
  var data = _taggedTemplateLiteral(["<div class=\"p-1\"><a>", "</a></div>"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["\n        <div class=\"p-2\">\n          <span>Enter the ", " you would like to load.</span>\n          <div>", "</div>\n          <div>e.g ", "</div>\n        </div>"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"px-2 ", "\">\n        <a class=\"twitter-timeline\"\n          data-width=\"350\"\n          data-theme=\"", "\"\n          data-chrome=\"nofooter noheader transparent\"\n          data-tweet-limit=\"8\"\n          href=\"https://twitter.com/EthereumRemix\"\n        >\n        </a>\n        <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n      </div>\n    "]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n      <div id=\"remixIDE_MediumBlock\" class=\"p-2 mx-0 mb-0 d-none ", "\">\n        <div id=\"medium-widget\" class=\"p-3 ", "\">\n          <div\n            id=\"retainable-rss-embed\"\n            data-rss=\"https://medium.com/feed/remix-ide\"\n            data-maxcols=\"1\"\n            data-layout=\"grid\"\n            data-poststyle=\"external\"\n            data-readmore=\"More...\"\n            data-buttonclass=\"btn mb-3\"\n            data-offset=\"-100\"\n          >\n-        </div>\n        </div>\n      </div>\n    "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n      <div id=\"remixIDE_TwitterBlock\" class=\"p-2 mx-0 mb-0 d-none ", "\">\n        ", "\n      </div>\n    "]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<button\n      class=\"btn-danger p-2 m-1 border rounded-circle ", " fab fa-medium\"\n      id=\"remixIDEHomeMediumbtn\"\n      onclick=", "\n    ></button>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<button\n      class=\"btn-info p-2 m-1 border rounded-circle ", " fab fa-twitter\"\n      id=\"remixIDEHomeTwitterbtn\"\n      onclick=", "\n    ></button>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"px-2 ", "\">\n        <a class=\"twitter-timeline\"\n          data-width=\"350\"\n          data-theme=\"", "\"\n          data-chrome=\"nofooter noheader transparent\"\n          data-tweet-limit=\"8\"\n          href=\"https://twitter.com/EthereumRemix\"\n        >\n        </a>\n        <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n      </div>\n    "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .text {\n    cursor: pointer;\n    font-weight: normal;\n    max-width: 300px;\n    user-select: none;\n  }\n  .text:hover {\n    text-decoration: underline;\n  }\n  .homeContainer {\n    user-select: none;\n    overflow-y: hidden;\n  }\n  .mainContent {\n    overflow-y: auto;\n    flex-grow: 3;\n  }\n  .hpLogoContainer {\n    margin: 30px;\n    padding-right: 90px;\n  }\n  .mediaBadge {\n   font-size: 2em;\n   height: 2em;\n   width: 2em;\n  }\n  .mediaBadge:focus {\n    outline: none;\n  }\n  .image {\n    height: 1em;\n    width: 1em;\n    text-align: center;\n  }\n  .logoImg {\n    height: 10em;\n  }\n  .hpSections {\n  }\n  .rightPanel {\n    right: 0;\n    position: absolute;\n    z-index: 3;\n  }\n  .remixHomeMedia {\n    overflow-y: auto;\n    overflow-x: hidden;\n    max-height: 720px;\n  }\n  .panels {\n    box-shadow: 0px 0px 13px -7px;\n  }\n  .labelIt {\n    margin-bottom: 0;\n  }\n  .bigLabelSize {\n    font-size: 13px;\n  }\n  .seeAll {\n    margin-top: 7px;\n    white-space: nowrap;\n  }\n  .importFrom p {\n    margin-right: 10px;\n  }\n  .logoContainer img{\n    height: 150px;\n    opacity: 0.7;\n  }\n  .envLogo {\n    height: 16px;\n  }\n  .cursorStyle {\n    cursor: pointer;\n  }\n  .envButton {\n    width: 120px;\n    height: 70px;\n  }\n  .media {\n    overflow: hidden;\n    width: 400px;\n    transition: .5s ease-out;\n    z-index: 1000;\n  }\n}\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var globalRegistry = __webpack_require__(/*! ../../../global/registry */ "./global/registry.js");

var CompilerImport = __webpack_require__(/*! ../../compiler/compiler-imports */ "./app/compiler/compiler-imports.js");

var modalDialogCustom = __webpack_require__(/*! ../modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var tooltip = __webpack_require__(/*! ../tooltip */ "./app/ui/tooltip.js");

var GistHandler = __webpack_require__(/*! ../../../lib/gist-handler */ "./lib/gist-handler.js");

var QueryParams = __webpack_require__(/*! ../../../lib/query-params.js */ "./lib/query-params.js");

var css = csjs(_templateObject());
var profile = {
  name: 'home',
  displayName: 'Home',
  methods: [],
  events: [],
  description: ' - ',
  icon: 'assets/img/remixLogo.webp',
  location: 'mainPanel',
  version: packageJson.version
};

var LandingPage = /*#__PURE__*/function (_ViewPlugin) {
  _inherits(LandingPage, _ViewPlugin);

  var _super = _createSuper(LandingPage);

  function LandingPage(appManager, verticalIcons) {
    var _this;

    _classCallCheck(this, LandingPage);

    _this = _super.call(this, profile);
    _this.profile = profile;
    _this.appManager = appManager;
    _this.verticalIcons = verticalIcons;
    _this.gistHandler = new GistHandler();
    var themeQuality = globalRegistry.get('themeModule').api.currentTheme().quality;
    window.addEventListener('resize', function () {
      return _this.adjustMediaPanel();
    });
    window.addEventListener('click', function (e) {
      return _this.hideMediaPanel(e);
    });
    _this.twitterFrame = yo(_templateObject2(), css.media, themeQuality);
    _this.badgeTwitter = yo(_templateObject3(), css.mediaBadge, function (e) {
      return _this.showMediaPanel(e);
    });
    _this.badgeMedium = yo(_templateObject4(), css.mediaBadge, function (e) {
      return _this.showMediaPanel(e);
    });
    _this.twitterPanel = yo(_templateObject5(), css.remixHomeMedia, _this.twitterFrame);
    _this.mediumPanel = yo(_templateObject6(), css.remixHomeMedia, css.media);

    _this.adjustMediaPanel();

    globalRegistry.get('themeModule').api.events.on('themeChanged', function (theme) {
      _this.onThemeChanged(theme.quality);
    });
    return _this;
  }

  _createClass(LandingPage, [{
    key: "adjustMediaPanel",
    value: function adjustMediaPanel() {
      this.twitterPanel.style.maxHeight = Math.max(window.innerHeight - 150, 200) + 'px';
      this.mediumPanel.style.maxHeight = Math.max(window.innerHeight - 150, 200) + 'px';
    }
  }, {
    key: "hideMediaPanel",
    value: function hideMediaPanel(e) {
      var mediaPanelsTitle = document.getElementById('remixIDEMediaPanelsTitle');
      var mediaPanels = document.getElementById('remixIDEMediaPanels');
      if (!mediaPanelsTitle || !mediaPanels) return;

      if (!mediaPanelsTitle.contains(e.target) && !mediaPanels.contains(e.target)) {
        this.mediumPanel.classList.remove('d-block');
        this.mediumPanel.classList.add('d-none');
        this.twitterPanel.classList.remove('d-block');
        this.twitterPanel.classList.add('d-none');
      }
    }
  }, {
    key: "onThemeChanged",
    value: function onThemeChanged(themeQuality) {
      var twitterFrame = yo(_templateObject7(), css.media, themeQuality);
      yo.update(this.twitterFrame, twitterFrame);
      var invertNum = themeQuality === 'dark' ? 1 : 0;
      if (this.solEnv.getElementsByTagName('img')[0]) this.solEnv.getElementsByTagName('img')[0].style.filter = "invert(".concat(invertNum, ")");
      if (this.debuggerEnv.getElementsByTagName('img')[0]) this.debuggerEnv.getElementsByTagName('img')[0].style.filter = "invert(".concat(invertNum, ")");
      if (this.solhintEnv.getElementsByTagName('img')[0]) this.solhintEnv.getElementsByTagName('img')[0].style.filter = "invert(".concat(invertNum, ")");
      if (this.learnEthEnv.getElementsByTagName('img')[0]) this.learnEthEnv.getElementsByTagName('img')[0].style.filter = "invert(".concat(invertNum, ")");
      if (this.sourcifyEnv.getElementsByTagName('img')[0]) this.sourcifyEnv.getElementsByTagName('img')[0].style.filter = "invert(".concat(invertNum, ")");
      if (this.moreEnv.getElementsByTagName('img')[0]) this.moreEnv.getElementsByTagName('img')[0].style.filter = "invert(".concat(invertNum, ")");
      if (this.websiteIcon) this.websiteIcon.style.filter = "invert(".concat(invertNum, ")");
    }
  }, {
    key: "showMediaPanel",
    value: function showMediaPanel(e) {
      if (e.target.id === 'remixIDEHomeTwitterbtn') {
        this.mediumPanel.classList.remove('d-block');
        this.mediumPanel.classList.add('d-none');
        this.twitterPanel.classList.toggle('d-block');
      } else {
        this.twitterPanel.classList.remove('d-block');
        this.twitterPanel.classList.add('d-none');
        this.mediumPanel.classList.toggle('d-block');
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var load = function load(service, item, examples, info) {
        var compilerImport = new CompilerImport();
        var fileProviders = globalRegistry.get('fileproviders').api;
        var msg = yo(_templateObject8(), item, info, examples.map(function (url) {
          return yo(_templateObject9(), url);
        }));
        modalDialogCustom.prompt("Import from ".concat(service), msg, null, function (target) {
          if (target !== '') {
            compilerImport["import"](target, function (loadingMsg) {
              tooltip(loadingMsg);
            }, function (error, content, cleanUrl, type, url) {
              if (error) {
                modalDialogCustom.alert(error);
              } else {
                fileProviders.browser.addExternal(type + '/' + cleanUrl, content, url);

                _this2.verticalIcons.select('fileExplorers');
              }
            });
          }
        });
      };

      var startSolidity = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _this2.appManager.activatePlugin(['solidity', 'udapp', 'solidityStaticAnalysis', 'solidityUnitTesting']);

                case 2:
                  _this2.verticalIcons.select('solidity');

                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function startSolidity() {
          return _ref.apply(this, arguments);
        };
      }();

      var startDebugger = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return _this2.appManager.activatePlugin('debugger');

                case 2:
                  _this2.verticalIcons.select('debugger');

                case 3:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function startDebugger() {
          return _ref2.apply(this, arguments);
        };
      }();

      var startSolhint = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return _this2.appManager.activatePlugin(['solidity', 'solhint']);

                case 2:
                  _this2.verticalIcons.select('solhint');

                case 3:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function startSolhint() {
          return _ref3.apply(this, arguments);
        };
      }();

      var startLearnEth = /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return _this2.appManager.activatePlugin(['solidity', 'LearnEth', 'solidityUnitTesting']);

                case 2:
                  _this2.verticalIcons.select('LearnEth');

                case 3:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        return function startLearnEth() {
          return _ref4.apply(this, arguments);
        };
      }();

      var startSourceVerify = /*#__PURE__*/function () {
        var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return _this2.appManager.activatePlugin(['solidity', 'source-verification']);

                case 2:
                  _this2.verticalIcons.select('source-verification');

                case 3:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        return function startSourceVerify() {
          return _ref5.apply(this, arguments);
        };
      }();

      var startPluginManager = /*#__PURE__*/function () {
        var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.next = 2;
                  return _this2.appManager.activatePlugin('pluginManager');

                case 2:
                  _this2.verticalIcons.select('pluginManager');

                case 3:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));

        return function startPluginManager() {
          return _ref6.apply(this, arguments);
        };
      }();

      var createNewFile = function createNewFile() {
        _this2.call('fileExplorers', 'createNewFile');
      };

      var uploadFile = function uploadFile(target) {
        _this2.call('fileExplorers', 'uploadFile', target);
      };

      var connectToLocalhost = function connectToLocalhost() {
        _this2.appManager.activatePlugin('remixd');
      };

      var importFromGist = function importFromGist() {
        _this2.gistHandler.loadFromGist({
          gist: ''
        }, globalRegistry.get('filemanager').api);

        _this2.verticalIcons.select('fileExplorers');
      };

      globalRegistry.get('themeModule').api.events.on('themeChanged', function (theme) {
        globalRegistry.get('themeModule').api.fixInvert(document.getElementById('remixLogo'));
        globalRegistry.get('themeModule').api.fixInvert(document.getElementById('solidityLogo'));
        globalRegistry.get('themeModule').api.fixInvert(document.getElementById('debuggerLogo'));
        globalRegistry.get('themeModule').api.fixInvert(document.getElementById('learnEthLogo'));
        globalRegistry.get('themeModule').api.fixInvert(document.getElementById('workshopLogo'));
        globalRegistry.get('themeModule').api.fixInvert(document.getElementById('moreLogo'));
        globalRegistry.get('themeModule').api.fixInvert(document.getElementById('solhintLogo'));
      });

      var createLargeButton = function createLargeButton(imgPath, envID, envText, callback) {
        return yo(_templateObject10(), css.envButton, function () {
          return callback();
        }, css.envLogo, envID, imgPath, css.cursorStyle, envText);
      }; // main


      this.solEnv = createLargeButton('assets/img/solidityLogo.webp', 'solidityLogo', 'Solidity', startSolidity); // Featured

      this.debuggerEnv = createLargeButton('assets/img/debuggerLogo.webp', 'debuggerLogo', 'Debugger', startDebugger);
      this.solhintEnv = createLargeButton('assets/img/solhintLogo.png', 'solhintLogo', 'solhint linter', startSolhint);
      this.learnEthEnv = createLargeButton('assets/img/learnEthLogo.webp', 'learnEthLogo', 'LearnEth', startLearnEth);
      this.sourcifyEnv = createLargeButton('assets/img/sourcifyLogo.webp', 'sourcifyLogo', 'Sourcify', startSourceVerify);
      this.moreEnv = createLargeButton('assets/img/moreLogo.webp', 'moreLogo', 'More', startPluginManager);
      this.websiteIcon = yo(_templateObject11(), css.image, profile.icon);
      var themeQuality = globalRegistry.get('themeModule').api.currentTheme().quality;
      var invertNum = themeQuality === 'dark' ? 1 : 0;
      this.solEnv.getElementsByTagName('img')[0].style.filter = "invert(".concat(invertNum, ")");
      this.debuggerEnv.getElementsByTagName('img')[0].style.filter = "invert(".concat(invertNum, ")");
      this.solhintEnv.getElementsByTagName('img')[0].style.filter = "invert(".concat(invertNum, ")");
      this.learnEthEnv.getElementsByTagName('img')[0].style.filter = "invert(".concat(invertNum, ")");
      this.sourcifyEnv.getElementsByTagName('img')[0].style.filter = "invert(".concat(invertNum, ")");
      this.moreEnv.getElementsByTagName('img')[0].style.filter = "invert(".concat(invertNum, ")");
      this.websiteIcon.style.filter = "invert(".concat(invertNum, ")");

      var switchToPreviousVersion = function switchToPreviousVersion() {
        var query = new QueryParams();
        query.update({
          appVersion: '0.7.7'
        });
        document.location.reload();
      };

      var img = yo(_templateObject12(), css.logoImg, function () {
        return playRemi();
      });

      var playRemi = /*#__PURE__*/function () {
        var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
          return regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.next = 2;
                  return document.getElementById('remiAudio').play();

                case 2:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7);
        }));

        return function playRemi() {
          return _ref7.apply(this, arguments);
        };
      }(); // to retrieve medium posts


      document.body.appendChild(yo(_templateObject13()));
      var container = yo(_templateObject14(), css.homeContainer, css.mainContent, img, css.hpSections, this.solEnv, this.learnEthEnv, this.solhintEnv, this.sourcifyEnv, this.debuggerEnv, this.moreEnv, css.text, function () {
        return createNewFile();
      }, css.labelIt, css.bigLabelSize, css.text, function (event) {
        event.stopPropagation();
        uploadFile(event.target);
      }, css.text, function () {
        return connectToLocalhost();
      }, function () {
        return importFromGist();
      }, function () {
        return load('Github', 'github URL', ['https://github.com/0xcert/ethereum-erc721/src/contracts/tokens/nf-token-metadata.sol', 'https://github.com/OpenZeppelin/openzeppelin-solidity/blob/67bca857eedf99bf44a4b6a0fc5b5ed553135316/contracts/access/Roles.sol', 'github:OpenZeppelin/openzeppelin-solidity/contracts/ownership/Ownable.sol#v2.1.2']);
      }, function () {
        return load('Swarm', 'bzz-raw URL', ['bzz-raw://<swarm-hash>']);
      }, function () {
        return load('Ipfs', 'ipfs URL', ['ipfs://<ipfs-hash>']);
      }, function () {
        return load('Https', 'http/https raw content', ['https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/master/contracts/token/ERC20/ERC20.sol']);
      }, function () {
        return load('@resolver-engine', 'resolver-engine URL', ['github:OpenZeppelin/openzeppelin-solidity/contracts/ownership/Ownable.sol#v2.1.2'], yo(_templateObject15()));
      }, css.text, css.text, this.websiteIcon, css.text, css.image, css.text, function () {
        return switchToPreviousVersion();
      }, css.rightPanel, this.badgeTwitter, this.badgeMedium, css.panels, this.mediumPanel, this.twitterPanel);
      return container;
    }
  }]);

  return LandingPage;
}(_engineWeb.ViewPlugin);

exports.LandingPage = LandingPage;

/***/ }),

/***/ "./app/ui/modal-dialog-custom.js":
/*!***************************************!*\
  !*** ./app/ui/modal-dialog-custom.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject9() {
  var data = _taggedTemplateLiteral(["<div>", "<div>", "</div></div>"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["\n    <input\n      type=", "\n      name='prompt_text'\n      id='prompt_text'\n      class=\"", " form-control\"\n      value='", "'\n      data-id=\"modalDialogCustomPromptText\"\n      oninput=\"", "\"\n    >\n  "]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["<div>", "</div>"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["<div>", "<div>", "</div></div>"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n      <textarea\n        id=\"prompt_text\"\n        data-id=\"modalDialogCustomPromptText\"\n        class=", "\n        rows=\"4\"\n        cols=\"50\"\n        oninput=\"", "\"\n      ></textarea>\n    "]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<div>", "<div>", "</div></div>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n      <div>\n        <input id=\"prompt1\" type=\"password\" name='prompt_text' class=\"", "\" oninput=\"", "\">\n        <br>\n        <br>\n        <input id=\"prompt2\" type=\"password\" name='prompt_text' class=\"", "\" oninput=\"", "\">\n      </div>\n    "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<div>", "</div>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["<div>", "</div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var modal = __webpack_require__(/*! ./modaldialog.js */ "./app/ui/modaldialog.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = __webpack_require__(/*! ./styles/modal-dialog-custom-styles */ "./app/ui/styles/modal-dialog-custom-styles.js");

module.exports = {
  alert: function alert(title, text) {
    if (text) return modal(title, yo(_templateObject(), text), null, {
      label: null
    });
    return modal('', yo(_templateObject2(), title), null, {
      label: null
    });
  },
  prompt: function prompt(title, text, inputValue, ok, cancel, focus) {
    return _prompt(title, text, false, inputValue, ok, cancel, focus);
  },
  promptPassphrase: function promptPassphrase(title, text, inputValue, ok, cancel) {
    return _prompt(title, text, true, inputValue, ok, cancel);
  },
  promptPassphraseCreation: function promptPassphraseCreation(ok, cancel) {
    var text = 'Please provide a Passphrase for the account creation';
    var input = yo(_templateObject3(), css.prompt_text, function (e) {
      return validateInput(e);
    }, css.prompt_text, function (e) {
      return validateInput(e);
    });
    return modal(null, yo(_templateObject4(), text, input), {
      fn: function fn() {
        if (typeof ok === 'function') {
          if (input.querySelector('#prompt1').value === input.querySelector('#prompt2').value) {
            ok(null, input.querySelector('#prompt1').value);
          } else {
            ok('Passphase does not match');
          }
        }
      }
    }, {
      fn: function fn() {
        if (typeof cancel === 'function') cancel();
      }
    });
  },
  promptMulti: function promptMulti(_ref, ok, cancel) {
    var title = _ref.title,
        text = _ref.text,
        inputValue = _ref.inputValue;
    if (!inputValue) inputValue = '';
    var input = yo(_templateObject5(), css.prompt_text, function (e) {
      return validateInput(e);
    });
    return modal(title, yo(_templateObject6(), text, input), {
      fn: function fn() {
        if (typeof ok === 'function') ok(document.getElementById('prompt_text').value);
      }
    }, {
      fn: function fn() {
        if (typeof cancel === 'function') cancel();
      }
    });
  },
  confirm: function confirm(title, text, ok, cancel) {
    return modal(title, yo(_templateObject7(), text), {
      fn: function fn() {
        if (typeof ok === 'function') ok();
      }
    }, {
      fn: function fn() {
        if (typeof cancel === 'function') cancel();
      }
    });
  }
};

var validateInput = function validateInput(e) {
  if (!document.getElementById('modal-footer-ok')) return;

  if (e.target.value === '') {
    document.getElementById('modal-footer-ok').classList.add('disabled');
    document.getElementById('modal-footer-ok').style.pointerEvents = 'none';
  } else {
    document.getElementById('modal-footer-ok').classList.remove('disabled');
    document.getElementById('modal-footer-ok').style.pointerEvents = 'auto';
  }
};

function _prompt(title, text, hidden, inputValue, ok, cancel, focus) {
  if (!inputValue) inputValue = '';
  var type = hidden ? 'password' : 'text';
  var input = yo(_templateObject8(), type, css.prompt_text, inputValue, function (e) {
    return validateInput(e);
  });
  modal(title, yo(_templateObject9(), text, input), {
    fn: function fn() {
      if (typeof ok === 'function') ok(document.getElementById('prompt_text').value);
    }
  }, {
    fn: function fn() {
      if (typeof cancel === 'function') cancel();
    }
  }, focus ? '#prompt_text' : undefined);
}

/***/ }),

/***/ "./app/ui/modaldialog.js":
/*!*******************************!*\
  !*** ./app/ui/modaldialog.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  <div id=\"modal-dialog\" data-id=\"modalDialogContainer\" data-backdrop=\"static\" data-keyboard=\"false\" class=\"modal\" tabindex=\"-1\" role=\"dialog\">\n    <div id=\"modal-background\" class=\"modal-dialog\" role=\"document\">\n      <div class=\"modal-content ", " ", "\">\n        <div class=\"modal-header\">\n          <h6 id=\"modal-title-h6\" class=\"modal-title\" data-id=\"modalDialogModalTitle\"></h6>\n          <span class=\"modal-close\">\n            <i id=\"modal-close\" title=\"Close\" class=\"fas fa-times\" aria-hidden=\"true\"></i>\n          </span>\n        </div>\n        <div id=\"modal-body-id\" class=\"modal-body ", "\" data-id=\"modalDialogModalBody\"> - </div>\n        <div class=\"modal-footer\" data-id=\"modalDialogModalFooter\" autofocus>\n          <span id=\"modal-footer-ok\" class=\"", " modal-ok btn btn-sm btn-light\" tabindex='5'>OK</span>\n          <span id=\"modal-footer-cancel\" class=\"", " modal-cancel btn btn-sm btn-light\" tabindex='10' data-dismiss=\"modal\">Cancel</span>\n        </div>\n      </div>\n    </div>\n  </div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = __webpack_require__(/*! ./styles/modaldialog-styles */ "./app/ui/styles/modaldialog-styles.js");

var incomingModal = false; // in case modals are queued, ensure we are not hiding the last one.

module.exports = function (title, content, ok, cancel, focusSelector, opts) {
  var agreed = true;
  var footerIsActive = false;
  opts = opts || {};
  var container = document.getElementById('modal-dialog');

  if (!container) {
    document.querySelector('body').appendChild(html(opts));
    container = document.getElementById('modal-dialog');
    incomingModal = false;
  } else incomingModal = true;

  var closeDiv = document.getElementById('modal-close');
  if (opts.hideClose) closeDiv.style.display = 'none';
  var okDiv = document.getElementById('modal-footer-ok');
  okDiv.innerHTML = ok && ok.label !== undefined ? ok.label : 'OK';
  okDiv.style.display = okDiv.innerHTML === '' ? 'none' : 'inline-block';
  var cancelDiv = document.getElementById('modal-footer-cancel');
  cancelDiv.innerHTML = cancel && cancel.label !== undefined ? cancel.label : 'Cancel';
  cancelDiv.style.display = cancelDiv.innerHTML === '' ? 'none' : 'inline-block';
  var modal = document.getElementById('modal-body-id');
  var modalTitle = document.getElementById('modal-title-h6');
  modalTitle.innerHTML = '';
  if (title) modalTitle.innerText = title;
  modal.innerHTML = '';
  if (content) modal.appendChild(content);
  setFocusOn('ok');
  show();

  function setFocusOn(btn) {
    var okDiv = document.getElementById('modal-footer-ok');
    var cancelDiv = document.getElementById('modal-footer-cancel');

    if (btn === 'ok') {
      okDiv.className = okDiv.className.replace(/\bbtn-light\b/g, 'btn-dark');
      cancelDiv.className = cancelDiv.className.replace(/\bbtn-dark\b/g, 'btn-light');
    } else {
      cancelDiv.className = cancelDiv.className.replace(/\bbtn-light\b/g, 'btn-dark');
      okDiv.className = okDiv.className.replace(/\bbtn-dark\b/g, 'btn-light');
    }
  }

  function okListener() {
    removeEventListener();
    if (ok && ok.fn && agreed) ok.fn();
    if (!incomingModal) hide();
    incomingModal = false;
  }

  function cancelListener() {
    removeEventListener();
    if (cancel && cancel.fn) cancel.fn();
    if (!incomingModal) hide();
    incomingModal = false;
  }

  function modalKeyEvent(e) {
    if (e.keyCode === 27) {
      // Esc
      cancelListener();
    } else if (e.keyCode === 13) {
      // Enter
      e.preventDefault();
      okListener();
    } else if (e.keyCode === 37 && footerIsActive) {
      // Arrow Left
      e.preventDefault();
      agreed = true;
      setFocusOn('ok');
    } else if (e.keyCode === 39 && footerIsActive) {
      // Arrow Right
      e.preventDefault();
      agreed = false;
      setFocusOn('cancel');
    }
  }

  function hide() {
    if (!container) return;
    container.style.display = 'none';
    if (container.parentElement) container.parentElement.removeChild(container);
    container = null;
    incomingModal = false;
  }

  function show() {
    if (!container) return;
    container.style.display = 'block';

    if (focusSelector) {
      var focusTarget = document.querySelector(".modal ".concat(focusSelector));

      if (focusTarget) {
        focusTarget.focus();

        if (typeof focusTarget.setSelectionRange === 'function') {
          focusTarget.setSelectionRange(0, focusTarget.value.length);
        }
      }
    }
  }

  function removeEventListener() {
    okDiv.removeEventListener('click', okListener);
    cancelDiv.removeEventListener('click', cancelListener);
    closeDiv.removeEventListener('click', cancelListener);
    document.removeEventListener('keydown', modalKeyEvent);

    if (document.getElementById('modal-background')) {
      document.getElementById('modal-background').removeEventListener('click', cancelListener);
    }
  }

  okDiv.addEventListener('click', okListener);
  cancelDiv.addEventListener('click', cancelListener);
  closeDiv.addEventListener('click', cancelListener);
  document.addEventListener('keydown', modalKeyEvent);
  var modalDialog = document.getElementById('modal-dialog');

  if (modalDialog) {
    modalDialog.addEventListener('click', function (e) {
      footerIsActive = document.activeElement === modalDialog;

      if (e.toElement === modalDialog) {
        cancelListener(); // click is outside of modal-content
      }
    });
  }

  return {
    container: container,
    okListener: okListener,
    cancelListener: cancelListener,
    hide: hide
  };
};

function html(opts) {
  return yo(_templateObject(), css.modalContent, opts["class"], css.modalBody, css.modalFooterOk, css.modalFooterCancel);
}

/***/ }),

/***/ "./app/ui/multiParamManager.js":
/*!*************************************!*\
  !*** ./app/ui/multiParamManager.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject8() {
  var data = _taggedTemplateLiteral(["\n      <div class=\"", "\">\n        ", " ", "\n      </div>\n    "]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["<div class=\"", "\" >\n      <div class=\"", " text-dark\" >\n        <div onclick=", " class=\"", "\">\n          <div class=\"", " run-instance-multi-title\">", "</div>\n          <i class='fas fa-angle-up ", "'></i>\n        </div>\n        ", "\n        <div class=\"", " ", "\" >\n          ", "\n            ", "\n        </div>\n      </div>\n    </div>"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["<button onclick=", " class=\"", "\" data-id=\"multiParamManagerExpandedButton\"></button>"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n    <div class=\"", " pt-2\">\n      ", "\n      ", "\n      <i class=\"fas fa-angle-down ", "\" onclick=", " title=", " ></i>\n    </div>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<button onclick=", " class=\"", " ", " btn btn-sm\" data-id=\"multiParamManagerFuncButton\">", "</button>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<input class=\"form-control\" data-id=\"multiParamManagerBasicInputField\"></input>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<div class=\"", "\"><label for=\"", "\"> ", ": </label><input class=\"form-control\" placeholder=\"", "\" title=\"", "\" data-id=\"multiParamManagerInput", "\"></div>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["<div>\n        ", "\n      </div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = __webpack_require__(/*! ../../universal-dapp-styles */ "./universal-dapp-styles.js");

var copyToClipboard = __webpack_require__(/*! ./copy-to-clipboard */ "./app/ui/copy-to-clipboard.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var txFormat = remixLib.execution.txFormat;

var MultiParamManager = /*#__PURE__*/function () {
  /**
    *
    * @param {bool} lookupOnly
    * @param {Object} funABI
    * @param {Function} clickMultiCallBack
    * @param {string} inputs
    * @param {string} title
    * @param {string} evmBC
    *
    */
  function MultiParamManager(lookupOnly, funABI, clickCallBack, inputs, title, evmBC, isDeploy) {
    _classCallCheck(this, MultiParamManager);

    this.lookupOnly = lookupOnly;
    this.funABI = funABI;
    this.clickCallBack = clickCallBack;
    this.inputs = inputs;
    this.title = title;
    this.evmBC = evmBC;
    this.basicInputField = null;
    this.multiFields = null;
    this.isDeploy = isDeploy;
  }

  _createClass(MultiParamManager, [{
    key: "switchMethodViewOn",
    value: function switchMethodViewOn() {
      this.contractActionsContainerSingle.style.display = 'none';
      this.contractActionsContainerMulti.style.display = 'flex';
      this.makeMultiVal();
    }
  }, {
    key: "switchMethodViewOff",
    value: function switchMethodViewOff() {
      this.contractActionsContainerSingle.style.display = 'flex';
      this.contractActionsContainerMulti.style.display = 'none';
      var multiValString = this.getMultiValsString();
      if (multiValString) this.basicInputField.value = multiValString;
    }
  }, {
    key: "getValue",
    value: function getValue(item, index) {
      var valStr = item.value.join('');
      return valStr;
    }
  }, {
    key: "getMultiValsString",
    value: function getMultiValsString() {
      var valArray = this.multiFields.querySelectorAll('input');
      var ret = '';
      var valArrayTest = [];

      for (var j = 0; j < valArray.length; j++) {
        if (ret !== '') ret += ',';
        var elVal = valArray[j].value;
        valArrayTest.push(elVal);
        elVal = elVal.replace(/(^|,\s+|,)(\d+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted number by quoted number

        elVal = elVal.replace(/(^|,\s+|,)(0[xX][0-9a-fA-F]+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted hex string by quoted hex string

        try {
          JSON.parse(elVal);
        } catch (e) {
          elVal = '"' + elVal + '"';
        }

        ret += elVal;
      }

      var valStringTest = valArrayTest.join('');

      if (valStringTest) {
        return ret;
      } else {
        return '';
      }
    }
  }, {
    key: "emptyInputs",
    value: function emptyInputs() {
      var valArray = this.multiFields.querySelectorAll('input');

      for (var k = 0; k < valArray.length; k++) {
        valArray[k].value = '';
      }

      this.basicInputField.value = '';
    }
  }, {
    key: "makeMultiVal",
    value: function makeMultiVal() {
      var inputString = this.basicInputField.value;

      if (inputString) {
        inputString = inputString.replace(/(^|,\s+|,)(\d+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted number by quoted number

        inputString = inputString.replace(/(^|,\s+|,)(0[xX][0-9a-fA-F]+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted hex string by quoted hex string

        var inputJSON = JSON.parse('[' + inputString + ']');
        var multiInputs = this.multiFields.querySelectorAll('input');

        for (var k = 0; k < multiInputs.length; k++) {
          if (inputJSON[k]) {
            multiInputs[k].value = JSON.stringify(inputJSON[k]);
          }
        }
      }
    }
  }, {
    key: "createMultiFields",
    value: function createMultiFields() {
      if (this.funABI.inputs) {
        return yo(_templateObject(), this.funABI.inputs.map(function (inp) {
          return yo(_templateObject2(), css.multiArg, inp.name, inp.name, inp.type, inp.name, inp.name);
        }));
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this = this;

      var title;

      if (this.title) {
        title = this.title;
      } else if (this.funABI.name) {
        title = this.funABI.name;
      } else {
        title = this.funABI.type === 'receive' ? '(receive)' : '(fallback)';
      }

      this.basicInputField = yo(_templateObject3());
      this.basicInputField.setAttribute('placeholder', this.inputs);
      this.basicInputField.setAttribute('title', this.inputs);
      this.basicInputField.setAttribute('data-id', this.inputs);

      var onClick = function onClick() {
        _this.clickCallBack(_this.funABI.inputs, _this.basicInputField.value);
      };

      var width = this.isDeploy ? '' : 'w-50';
      var funcButton = yo(_templateObject4(), function () {
        return onClick();
      }, css.instanceButton, width, title);
      this.contractActionsContainerSingle = yo(_templateObject5(), css.contractActionsContainerSingle, funcButton, this.basicInputField, css.methCaret, function () {
        return _this.switchMethodViewOn();
      }, title);
      this.multiFields = this.createMultiFields();

      var multiOnClick = function multiOnClick() {
        var valsString = _this.getMultiValsString();

        if (valsString) {
          _this.clickCallBack(_this.funABI.inputs, valsString);
        } else {
          _this.clickCallBack(_this.funABI.inputs, '');
        }
      };

      var expandedButton = yo(_templateObject6(), function () {
        multiOnClick();
      }, css.instanceButton);
      this.contractActionsContainerMulti = yo(_templateObject7(), css.contractActionsContainerMulti, css.contractActionsContainerMultiInner, function () {
        _this.switchMethodViewOff();
      }, css.multiHeader, css.multiTitle, title, css.methCaret, this.multiFields, css.group, css.multiArg, copyToClipboard(function () {
        var multiString = _this.getMultiValsString();

        var multiJSON = JSON.parse('[' + multiString + ']');
        var encodeObj;

        if (_this.evmBC) {
          encodeObj = txFormat.encodeData(_this.funABI, multiJSON, _this.evmBC);
        } else {
          encodeObj = txFormat.encodeData(_this.funABI, multiJSON);
        }

        if (encodeObj.error) {
          throw new Error(encodeObj.error);
        } else {
          return encodeObj.data;
        }
      }, 'Encode values of input fields & copy to clipboard', 'fa-clipboard'), expandedButton);
      var contractProperty = yo(_templateObject8(), css.contractProperty, this.contractActionsContainerSingle, this.contractActionsContainerMulti);

      if (this.lookupOnly) {
        // call. stateMutability is either pure or view
        expandedButton.setAttribute('title', title + ' - call');
        expandedButton.innerHTML = 'call';
        expandedButton.classList.add('btn-info');
        expandedButton.setAttribute('data-id', title + ' - call');
        funcButton.setAttribute('title', title + ' - call');
        funcButton.classList.add('btn-info');
        funcButton.setAttribute('data-id', title + ' - call');
      } else if (this.funABI.stateMutability === 'payable' || this.funABI.payable) {
        // transact. stateMutability = payable
        expandedButton.setAttribute('title', title + ' - transact (payable)');
        expandedButton.innerHTML = 'transact';
        expandedButton.classList.add('btn-danger');
        expandedButton.setAttribute('data-id', title + ' - transact (payable)');
        funcButton.setAttribute('title', title + ' - transact (payable)');
        funcButton.classList.add('btn-danger');
        funcButton.setAttribute('data-id', title + ' - transact (payable)');
      } else {
        // transact. stateMutability = nonpayable
        expandedButton.setAttribute('title', title + ' - transact (not payable)');
        expandedButton.innerHTML = 'transact';
        expandedButton.classList.add('btn-warning');
        expandedButton.setAttribute('data-id', title + ' - transact (not payable)');
        funcButton.classList.add('btn-warning');
        funcButton.setAttribute('title', title + ' - transact (not payable)');
        funcButton.setAttribute('data-id', title + ' - transact (not payable)');
      }

      if (this.funABI.inputs && this.funABI.inputs.length > 0) {
        contractProperty.classList.add(css.hasArgs);
      } else if (this.funABI.type === 'fallback' || this.funABI.type === 'receive') {
        contractProperty.classList.add(css.hasArgs);
        this.basicInputField.setAttribute('title', "'(".concat(this.funABI.type, "')")); // probably should pass name instead

        this.contractActionsContainerSingle.querySelector('i').style.visibility = 'hidden';
        this.basicInputField.setAttribute('data-id', "'(".concat(this.funABI.type, "')"));
      } else {
        this.contractActionsContainerSingle.querySelector('i').style.visibility = 'hidden';
        this.basicInputField.style.visibility = 'hidden';
      }

      return contractProperty;
    }
  }]);

  return MultiParamManager;
}();

module.exports = MultiParamManager;

/***/ }),

/***/ "./app/ui/persmission-handler.js":
/*!***************************************!*\
  !*** ./app/ui/persmission-handler.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PermissionHandler = void 0;

function _templateObject10() {
  var data = _taggedTemplateLiteral(["<i>No description Provided</i>"]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["<i>No description Provided</i>"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["\n      <section class=\"", "\">\n        ", "\n        <article>\n          <h4 data-id=\"permissionHandlerMessage\">", " :</h4>\n          <h6>", "</h6>\n          <p>", "</p>\n          <h6>", " :</p>\n          <p>", "</p>\n          ", "\n        </article>\n\n        <article class=\"", "\">\n          <div class=\"form-check\">\n            ", "\n            <label class=\"form-check-label\" for=\"remember\" data-id=\"permissionHandlerRememberChoice\">Remember this choice</label>\n          </div>\n          <button class=\"btn btn-sm\" onclick=\"", "\">Reset all Permissions</button>\n        </article>\n      </section>\n    "]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n      <div>\n        <h6>Description</h6>\n        <p>", "</p>\n      </div>\n    "]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n      <article class=\"", "\">\n        ", "\n        <i class=\"fas fa-arrow-right\"></i>\n        ", "\n      </article>\n    "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["<img id=\"permissionModalImagesTo\" src=\"", "\" />"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<img id=\"permissionModalImagesFrom\" src=\"", "\" />"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<input type=\"checkbox\" onchange=\"", "\" class=\"form-check-input\" id=\"remember\" data-id=\"permissionHandlerRememberUnchecked\">"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<input type=\"checkbox\" onchange=\"", "\" checkbox class=\"form-check-input\" id=\"remember\" data-id=\"permissionHandlerRememberChecked\">"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n.permission h4 {\n  text-transform: uppercase;\n  text-align: center;\n}\n.permission h6 {\n  text-transform: uppercase;\n}\n.remember {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n.images {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  padding: 10px;\n}\n.images img {\n  width: 40px;\n  height: 40px;\n}\n.images i {\n  margin: 0 20px;\n}\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

/* global localStorage */
var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var addTooltip = __webpack_require__(/*! ./tooltip */ "./app/ui/tooltip.js");

var modalDialog = __webpack_require__(/*! ./modaldialog */ "./app/ui/modaldialog.js");

var globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var css = csjs(_templateObject());

function notAllowWarning(from, to, method) {
  return "".concat(from.displayName || from.name, " is not allowed to call ").concat(method, " method of ").concat(to.displayName || to.name, ".");
}

var PermissionHandler = /*#__PURE__*/function () {
  function PermissionHandler() {
    _classCallCheck(this, PermissionHandler);

    this.permissions = this._getFromLocal();
    this.currentVersion = 1; // here we remove the old permissions saved before adding 'permissionVersion'
    // since with v1 the structure has been changed because of new engine ^0.2.0-alpha.6 changes

    if (!localStorage.getItem('permissionVersion')) {
      localStorage.setItem('plugins/permissions', '');
      localStorage.setItem('permissionVersion', this.currentVersion);
    }
  }

  _createClass(PermissionHandler, [{
    key: "_getFromLocal",
    value: function _getFromLocal() {
      var permission = localStorage.getItem('plugins/permissions');
      return permission ? JSON.parse(permission) : {};
    }
  }, {
    key: "persistPermissions",
    value: function persistPermissions() {
      var permissions = JSON.stringify(this.permissions);
      localStorage.setItem('plugins/permissions', permissions);
    }
  }, {
    key: "clear",
    value: function clear() {
      localStorage.removeItem('plugins/permissions');
      addTooltip('All Permissions have been reset');
    }
    /**
     * Show a message to ask the user for a permission
     * @param {PluginProfile} from The name and hash of the plugin that make the call
     * @param {ModuleProfile} to The name of the plugin that receive the call
     * @param {string} method The name of the function to be called
     * @param {string} message from the caller plugin to add more details if needed
     * @returns {Promise<{ allow: boolean; remember: boolean }} Answer from the user to the permission
     */

  }, {
    key: "openPermission",
    value: function () {
      var _openPermission = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(from, to, method, message) {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  modalDialog("Permission needed for ".concat(to.displayName || to.name), _this.form(from, to, method, message), {
                    label: 'Accept',
                    fn: function fn() {
                      if (_this.permissions[to.name][method][from.name]) {
                        _this.permissions[to.name][method][from.name] = {
                          allow: true,
                          hash: from.hash
                        };

                        _this.persistPermissions();
                      }

                      resolve(true);
                    }
                  }, {
                    label: 'Decline',
                    fn: function fn() {
                      if (_this.permissions[to.name][method][from.name]) {
                        _this.permissions[to.name][method][from.name] = {
                          allow: false,
                          hash: from.hash
                        };

                        _this.persistPermissions();
                      }

                      reject(notAllowWarning(from, to, method));
                    }
                  });
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function openPermission(_x, _x2, _x3, _x4) {
        return _openPermission.apply(this, arguments);
      }

      return openPermission;
    }()
    /**
     * Check if a plugin has the permission to call another plugin and askPermission if needed
     * @param {PluginProfile} from the profile of the plugin that make the call
     * @param {ModuleProfile} to The profile of the module that receive the call
     * @param {string} method The name of the function to be called
     * @param {string} message from the caller plugin to add more details if needed
     * @returns {Promise<boolean>}
     */

  }, {
    key: "askPermission",
    value: function () {
      var _askPermission = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(from, to, method, message) {
        var _this$permissions$to$, allow, hash, warning;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                this.permissions = this._getFromLocal();
                if (!this.permissions[to.name]) this.permissions[to.name] = {};
                if (!this.permissions[to.name][method]) this.permissions[to.name][method] = {};

                if (this.permissions[to.name][method][from.name]) {
                  _context2.next = 6;
                  break;
                }

                return _context2.abrupt("return", this.openPermission(from, to, method, message));

              case 6:
                _this$permissions$to$ = this.permissions[to.name][method][from.name], allow = _this$permissions$to$.allow, hash = _this$permissions$to$.hash;

                if (allow) {
                  _context2.next = 11;
                  break;
                }

                warning = notAllowWarning(from, to, method);
                addTooltip(warning);
                return _context2.abrupt("return", false);

              case 11:
                return _context2.abrupt("return", hash === from.hash ? true // Allow
                : this.openPermission(from, to, method, message));

              case 14:
                _context2.prev = 14;
                _context2.t0 = _context2["catch"](0);
                throw new Error(_context2.t0);

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 14]]);
      }));

      function askPermission(_x5, _x6, _x7, _x8) {
        return _askPermission.apply(this, arguments);
      }

      return askPermission;
    }()
    /**
     * The permission form
     * @param {PluginProfile} from The name and hash of the plugin that make the call
     * @param {ModuleProfile} to The name of the plugin that receive the call
     * @param {string} method The name of te methode to be called
     * @param {string} message from the caller plugin to add more details if needed
     */

  }, {
    key: "form",
    value: function form(from, to, method, message) {
      var _this2 = this;

      var fromName = from.displayName || from.name;
      var toName = to.displayName || to.name;
      var remember = this.permissions[to.name][method][from.name];

      var switchMode = function switchMode(e) {
        e.target.checked ? _this2.permissions[to.name][method][from.name] = {} : delete _this2.permissions[to.name][method][from.name];
      };

      var rememberSwitch = remember ? yo(_templateObject2(), switchMode) : yo(_templateObject3(), switchMode);
      var text = "\"".concat(fromName, "\" ").concat(remember ? 'has changed and' : '', " would like to access to \"").concat(method, "\" of \"").concat(toName, "\"");
      var imgFrom = yo(_templateObject4(), from.icon);
      var imgTo = yo(_templateObject5(), to.icon);
      var pluginsImages = yo(_templateObject6(), css.images, imgFrom, imgTo);
      globalRegistry.get('themeModule').api.fixInvert(imgFrom);
      globalRegistry.get('themeModule').api.fixInvert(imgTo);
      var pluginMessage = message ? yo(_templateObject7(), message) : '';
      return yo(_templateObject8(), css.permission, pluginsImages, text, fromName, from.description || yo(_templateObject9()), toName, to.description || yo(_templateObject10()), pluginMessage, css.remember, rememberSwitch, function (_) {
        return _this2.clear();
      });
    }
  }]);

  return PermissionHandler;
}();

exports.PermissionHandler = PermissionHandler;

/***/ }),

/***/ "./app/ui/renderer.js":
/*!****************************!*\
  !*** ./app/ui/renderer.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject4() {
  var data = _taggedTemplateLiteral(["<div class=\"sol ", " ", "\"><div class=\"close\" data-id=\"renderer\"><i class=\"fas fa-times\"></i></div></div>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<pre></pre>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<span></span>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["<span>", "</span>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var $ = __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = __webpack_require__(/*! ./styles/renderer-styles */ "./app/ui/styles/renderer-styles.js");

var globlalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");
/**
 * After refactor, the renderer is only used to render error/warning
 * TODO: This don't need to be an object anymore. Simplify and just export the renderError function.
 *
 */


function Renderer(localRegistry) {
  var self = this;
  self._components = {};
  self._components.registry = localRegistry || globlalRegistry; // dependencies

  self._deps = {
    fileManager: self._components.registry.get('filemanager').api,
    config: self._components.registry.get('config').api
  };

  if (document && document.head) {
    document.head.appendChild(css);
  }
}

Renderer.prototype._error = function (file, error) {
  var self = this;

  var editor = self._components.registry.get('editor').api;

  if (file === self._deps.config.get('currentFile')) {
    editor.addAnnotation(error);
  }
};

Renderer.prototype._errorClick = function (errFile, errLine, errCol) {
  var self = this;

  var editor = self._components.registry.get('editor').api;

  if (errFile !== self._deps.config.get('currentFile')) {
    // TODO: refactor with this._components.contextView.jumpTo
    var provider = self._deps.fileManager.fileProviderOf(errFile);

    if (provider) {
      provider.exists(errFile, function (error, exist) {
        if (error) return console.log(error);

        self._deps.fileManager.open(errFile);

        editor.gotoLine(errLine, errCol);
      });
    }
  } else {
    editor.gotoLine(errLine, errCol);
  }
};

function getPositionDetails(msg) {
  var result = {}; // To handle some compiler warning without location like SPDX license warning etc

  if (!msg.includes(':')) return {
    errLine: -1,
    errCol: -1,
    errFile: msg
  }; // extract line / column

  var position = msg.match(/^(.*?):([0-9]*?):([0-9]*?)?/);
  result.errLine = position ? parseInt(position[2]) - 1 : -1;
  result.errCol = position ? parseInt(position[3]) : -1; // extract file

  position = msg.match(/^(https:.*?|http:.*?|.*?):/);
  result.errFile = position ? position[1] : '';
  return result;
}
/**
 * format msg like error or warning,
 *
 * @param {String or DOMElement} message
 * @param {DOMElement} container
 * @param {Object} options {
 *  useSpan,
 *  noAnnotations,
 *  click:(Function),
 *  type:(
 *    warning,
 *    error
 *  ),
 *  errFile,
 *  errLine,
 *  errCol
 * }
 */


Renderer.prototype.error = function (message, container, opt) {
  var _this = this;

  if (!message) return;
  if (container === undefined) return;
  opt = opt || {};
  var text;

  if (typeof message === 'string') {
    text = message;
    message = yo(_templateObject(), message);
  } else if (message.innerText) {
    text = message.innerText;
  } // ^ e.g:
  // browser/gm.sol: Warning: Source file does not specify required compiler version! Consider adding "pragma solidity ^0.6.12
  // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0/contracts/introspection/IERC1820Registry.sol:3:1: ParserError: Source file requires different compiler version (current compiler is 0.7.4+commit.3f05b770.Emscripten.clang) - note that nightly builds are considered to be strictly less than the released version


  var position = getPositionDetails(text); // For compiler version 0.8.0 and upcoming versions, errors and warning will be reported in a different way
  // Above method regex will return type of error as 'errFile'
  // Comparison of 'errFile' with passed error type will ensure the reporter type

  if (!position.errFile || opt.errorType && opt.errorType === position.errFile) {
    // Updated error reported includes '-->' before file details
    var errorDetails = text.split('-->'); // errorDetails[1] will have file details

    position = getPositionDetails(errorDetails[1]);
  }

  opt.errLine = position.errLine;
  opt.errCol = position.errCol;
  opt.errFile = position.errFile.trim();

  if (!opt.noAnnotations && opt.errFile) {
    this._error(opt.errFile, {
      row: opt.errLine,
      column: opt.errCol,
      text: text,
      type: opt.type
    });
  }

  var $pre = $(opt.useSpan ? yo(_templateObject2()) : yo(_templateObject3())).html(message);
  var classList = opt.type === 'error' ? 'alert alert-danger' : 'alert alert-warning';
  var $error = $(yo(_templateObject4(), opt.type, classList)).prepend($pre);
  $(container).append($error);
  $error.click(function (ev) {
    if (opt.click) {
      opt.click(message);
    } else if (opt.errFile !== undefined && opt.errLine !== undefined && opt.errCol !== undefined) {
      _this._errorClick(opt.errFile, opt.errLine, opt.errCol);
    }
  });
  $error.find('.close').click(function (ev) {
    ev.preventDefault();
    $error.remove();
    return false;
  });
};

module.exports = Renderer;

/***/ }),

/***/ "./app/ui/sendTxCallbacks.js":
/*!***********************************!*\
  !*** ./app/ui/sendTxCallbacks.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n        <div>Gas estimation errored with the following message (see below).\n        The transaction execution will likely fail. Do you want to force sending? <br>", "</div>\n      "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var confirmDialog = __webpack_require__(/*! ./confirmDialog */ "./app/ui/confirmDialog.js");

var modalCustom = __webpack_require__(/*! ./modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var modalDialog = __webpack_require__(/*! ./modaldialog */ "./app/ui/modaldialog.js");

var typeConversion = remixLib.execution.typeConversion;

var Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

module.exports = {
  getCallBacksWithContext: function getCallBacksWithContext(udappUI, blockchain) {
    var callbacks = {};
    callbacks.confirmationCb = confirmationCb;
    callbacks.continueCb = continueCb;
    callbacks.promptCb = promptCb;
    callbacks.udappUI = udappUI;
    callbacks.blockchain = blockchain;
    return callbacks;
  }
};

var continueCb = function continueCb(error, continueTxExecution, cancelCb) {
  if (error) {
    var msg = typeof error !== 'string' ? error.message : error;
    modalDialog('Gas estimation failed', yo(_templateObject(), msg), {
      label: 'Send Transaction',
      fn: function fn() {
        return continueTxExecution();
      }
    }, {
      label: 'Cancel Transaction',
      fn: function fn() {
        return cancelCb();
      }
    });
  } else {
    continueTxExecution();
  }
};

var promptCb = function promptCb(okCb, cancelCb) {
  modalCustom.promptPassphrase('Passphrase requested', 'Personal mode is enabled. Please provide passphrase of account', '', okCb, cancelCb);
};

var confirmationCb = function confirmationCb(network, tx, gasEstimation, continueTxExecution, cancelCb) {
  var self = this;

  if (network.name !== 'Main') {
    return continueTxExecution(null);
  }

  var amount = Web3.utils.fromWei(typeConversion.toInt(tx.value), 'ether');
  var content = confirmDialog(tx, amount, gasEstimation, self.udappUI, function (gasPrice, cb) {
    var txFeeText, priceStatus; // TODO: this try catch feels like an anti pattern, can/should be
    // removed, but for now keeping the original logic

    try {
      var fee = Web3.utils.toBN(tx.gas).mul(Web3.utils.toBN(Web3.utils.toWei(gasPrice.toString(10), 'gwei')));
      txFeeText = ' ' + Web3.utils.fromWei(fee.toString(10), 'ether') + ' Ether';
      priceStatus = true;
    } catch (e) {
      txFeeText = ' Please fix this issue before sending any transaction. ' + e.message;
      priceStatus = false;
    }

    cb(txFeeText, priceStatus);
  }, function (cb) {
    self.blockchain.web3().eth.getGasPrice(function (error, gasPrice) {
      var warnMessage = ' Please fix this issue before sending any transaction. ';

      if (error) {
        return cb('Unable to retrieve the current network gas price.' + warnMessage + error);
      }

      try {
        var gasPriceValue = Web3.utils.fromWei(gasPrice.toString(10), 'gwei');
        cb(null, gasPriceValue);
      } catch (e) {
        cb(warnMessage + e.message, null, false);
      }
    });
  });
  modalDialog('Confirm transaction', content, {
    label: 'Confirm',
    fn: function fn() {
      self.blockchain.config.setUnpersistedProperty('doNotShowTransactionConfirmationAgain', content.querySelector('input#confirmsetting').checked); // TODO: check if this is check is still valid given the refactor

      if (!content.gasPriceStatus) {
        cancelCb('Given gas price is not correct');
      } else {
        var gasPrice = Web3.utils.toWei(content.querySelector('#gasprice').value, 'gwei');
        continueTxExecution(gasPrice);
      }
    }
  }, {
    label: 'Cancel',
    fn: function fn() {
      return cancelCb('Transaction canceled by user.');
    }
  });
};

/***/ }),

/***/ "./app/ui/styles/auto-complete-popup-styles.js":
/*!*****************************************************!*\
  !*** ./app/ui/styles/auto-complete-popup-styles.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .popup             {\n    position         : absolute;\n    text-align       : left;\n    display          : none;\n    width            : 95%;\n    font-family      : monospace;\n    background-color : var(--secondary);\n    overflow         : auto;\n    padding-bottom   : 13px;\n    z-index          : 80;\n    bottom           : 1em;\n    border-width     : 4px;\n    left             : 2em;\n  }\n\n  .autoCompleteItem {\n    padding          : 4px;\n    border-radius    : 2px;\n  }\n\n  .popup a {\n    cursor           : pointer;\n  }\n\n  .listHandlerShow   {\n    display          : block;\n  }\n\n  .listHandlerHide   {\n    display          : none;\n  }\n\n  .listHandlerButtonShow {\n    position         : fixed;\n    width            : 46%;\n  }\n\n  .pageNumberAlignment {\n    font-size        : 10px;\n    float            : right;\n  }\n\n  .modalContent {\n    position         : absolute;\n    margin-left      : 20%;\n    margin-bottom    : 32px;\n    bottom           : 0px;\n    padding          : 0;\n    line-height      : 18px;\n    font-size        : 12px;\n    width            : 40%;\n    box-shadow       : 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);\n    -webkit-animation-name: animatebottom;\n    -webkit-animation-duration: 0.4s;\n    animation-name   : animatetop;\n    animation-duration: 0.4s\n  }\n\n  @-webkit-keyframes animatetop {\n    from {bottom: -300px; opacity: 0}\n    to {bottom: 0; opacity: 1}\n  }\n\n  @keyframes animatetop {\n    from {bottom: -300px; opacity: 0}\n    to {bottom: 0; opacity: 1}\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());
module.exports = css;

/***/ }),

/***/ "./app/ui/styles/modal-dialog-custom-styles.js":
/*!*****************************************************!*\
  !*** ./app/ui/styles/modal-dialog-custom-styles.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .prompt_text {\n    width: 100%;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());
module.exports = css;

/***/ }),

/***/ "./app/ui/styles/modaldialog-styles.js":
/*!*********************************************!*\
  !*** ./app/ui/styles/modaldialog-styles.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n\n  .modalFooter {\n  }\n  .modalContent {\n    box-shadow: 0 0 8px 10000px rgba(0,0,0,0.6),0 6px 20px 0 rgba(0,0,0,0.19);\n    -webkit-animation-name: animatetop;\n    -webkit-animation-duration: 0.4s;\n    animation-name: animatetop;\n    animation-duration: 0.4s\n  }\n  .modalBody {\n    word-break: break-word;\n    overflow-y: auto;\n    max-height: 600px;\n  }\n  .modalFooterOk {\n  }\n  .modalFooterCancel {\n  }\n  @-webkit-keyframes animatetop {\n    from {top: -300px; opacity: 0}\n    to {top: 0; opacity: 1}\n  }\n  @keyframes animatetop {\n    from {top: -300px; opacity: 0}\n    to {top: 0; opacity: 1}\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());
module.exports = css;

/***/ }),

/***/ "./app/ui/styles/renderer-styles.js":
/*!******************************************!*\
  !*** ./app/ui/styles/renderer-styles.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["<style>\n.sol.success,\n.sol.error,\n.sol.warning {\n    white-space: pre-line;\n    word-wrap: break-word;\n    cursor: pointer;\n    position: relative;\n    margin: 0.5em 0 1em 0;\n    border-radius: 5px;\n    line-height: 20px;\n    padding: 8px 15px;\n}\n\n.sol.success pre,\n.sol.error pre,\n.sol.warning pre {\n    white-space: pre-line;\n    overflow-y: hidden;\n    background-color: transparent;\n    margin: 0;\n    font-size: 12px;\n    border: 0 none;\n    padding: 0;\n    border-radius: 0;\n}\n\n.sol.success .close,\n.sol.error .close,\n.sol.warning .close {\n    white-space: pre-line;\n    font-weight: bold;\n    position: absolute;\n    color: hsl(0, 0%, 0%); /* black in style-guide.js */\n    top: 0;\n    right: 0;\n    padding: 0.5em;\n}\n\n.sol.error {\n}\n\n.sol.warning {\n}\n\n.sol.success {\n  /* background-color:  // styles.rightPanel.message_Success_BackgroundColor; */\n}</style>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = yo(_templateObject());
module.exports = css;

/***/ }),

/***/ "./app/ui/styles/tooltip-styles.js":
/*!*****************************************!*\
  !*** ./app/ui/styles/tooltip-styles.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .tooltip {\n    z-index: 1001;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    position: fixed;\n    min-height: 50px;\n    padding: 16px 24px 12px;\n    border-radius: 3px;\n    bottom: -300;\n    left: 40%;\n    font-size: 14px;\n    text-align: center;\n    bottom: 0;\n    flex-direction: row;\n  }\n  @-webkit-keyframes animatebottom  {\n    0% {bottom: -300px}\n    100% {bottom: 0}\n  }\n  @keyframes animatebottom  {\n    0% {bottom: -300px}\n    100% {bottom: 0}\n  }\n  @-webkit-keyframes animatetop  {\n    0% {bottom: 0}\n    100% {bottom: -300px}\n  }\n  @keyframes animatetop  {\n    0% {bottom: 0}\n    100% {bottom: -300px}\n  }\n  .animateTop {\n    -webkit-animation-name: animatetop;\n    -webkit-animation-duration: 2s;\n    animation-name: animatetop;\n    animation-duration: 2s;\n  }\n  .animateBottom {\n    -webkit-animation-name: animatebottom;\n    -webkit-animation-duration: 2s;\n    animation-name: animatebottom;\n    animation-duration: 2s;    \n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());
module.exports = css;

/***/ }),

/***/ "./app/ui/svgLogo.js":
/*!***************************!*\
  !*** ./app/ui/svgLogo.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.basicLogo = basicLogo;

var _yoYo = _interopRequireDefault(__webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["<svg id=\"Ebene_2\" data-name=\"Ebene 2\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 105 100\"> \n<path d=\"M91.84,35a.09.09,0,0,1-.1-.07,41,41,0,0,0-79.48,0,.09.09,0,0,1-.1.07C9.45,35,1,35.35,1,42.53c0,8.56,1,16,6,20.32,2.16,1.85,5.81,2.3,9.27,2.22a44.4,44.4,0,0,0,6.45-.68.09.09,0,0,0,.06-.15A34.81,34.81,0,0,1,17,45c0-.1,0-.21,0-.31a35,35,0,0,1,70,0c0,.1,0,.21,0,.31a34.81,34.81,0,0,1-5.78,19.24.09.09,0,0,0,.06.15,44.4,44.4,0,0,0,6.45.68c3.46.08,7.11-.37,9.27-2.22,5-4.27,6-11.76,6-20.32C103,35.35,94.55,35,91.84,35Z\"/>\n<path d=\"M52,74,25.4,65.13a.1.1,0,0,0-.1.17L51.93,91.93a.1.1,0,0,0,.14,0L78.7,65.3a.1.1,0,0,0-.1-.17L52,74A.06.06,0,0,1,52,74Z\"/>\n<path d=\"M75.68,46.9,82,45a.09.09,0,0,0,.08-.09,29.91,29.91,0,0,0-.87-6.94.11.11,0,0,0-.09-.08l-6.43-.58a.1.1,0,0,1-.06-.18l4.78-4.18a.13.13,0,0,0,0-.12,30.19,30.19,0,0,0-3.65-6.07.09.09,0,0,0-.11,0l-5.91,2a.1.1,0,0,1-.12-.14L72.19,23a.11.11,0,0,0,0-.12,29.86,29.86,0,0,0-5.84-4.13.09.09,0,0,0-.11,0l-4.47,4.13a.1.1,0,0,1-.17-.07l.09-6a.1.1,0,0,0-.07-.1,30.54,30.54,0,0,0-7-1.47.1.1,0,0,0-.1.07l-2.38,5.54a.1.1,0,0,1-.18,0l-2.37-5.54a.11.11,0,0,0-.11-.06,30,30,0,0,0-7,1.48.12.12,0,0,0-.07.1l.08,6.05a.09.09,0,0,1-.16.07L37.8,18.76a.11.11,0,0,0-.12,0,29.75,29.75,0,0,0-5.83,4.13.11.11,0,0,0,0,.12l2.59,5.6a.11.11,0,0,1-.13.14l-5.9-2a.11.11,0,0,0-.12,0,30.23,30.23,0,0,0-3.62,6.08.11.11,0,0,0,0,.12l4.79,4.19a.1.1,0,0,1-.06.17L23,37.91a.1.1,0,0,0-.09.07A29.9,29.9,0,0,0,22,44.92a.1.1,0,0,0,.07.1L28.4,47a.1.1,0,0,1,0,.18l-5.84,3.26a.16.16,0,0,0,0,.11,30.17,30.17,0,0,0,2.1,6.76c.32.71.67,1.4,1,2.08a.1.1,0,0,0,.06,0L52,68.16H52l26.34-8.78a.1.1,0,0,0,.06-.05,30.48,30.48,0,0,0,3.11-8.88.1.1,0,0,0-.05-.11l-5.83-3.26A.1.1,0,0,1,75.68,46.9Z\"/>\n</svg>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function basicLogo() {
  return (0, _yoYo["default"])(_templateObject());
}

/***/ }),

/***/ "./app/ui/tooltip.js":
/*!***************************!*\
  !*** ./app/ui/tooltip.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n        <div data-shared=\"tooltipPopup\" class=\"", " alert alert-info p-2\"  onmouseenter=", " onmouseleave=", ">\n          <span class=\"px-2\">\n            ", "\n            ", "\n            ", "\n          </span>\n          <span style=\"align-self: baseline;\">\n            <button data-id=\"tooltipCloseButton\" class=\"fas fa-times btn-info mx-1 p-0\" onclick=", "></button>\n          </span>\n        </div>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n      <button class=\"btn btn-secondary btn-sm mx-3\" style=\"white-space: nowrap;\" onclick=", ">Show full message</button>\n      "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["<div></div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

/* global Element */
var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = __webpack_require__(/*! ./styles/tooltip-styles */ "./app/ui/styles/tooltip-styles.js");

var modal = __webpack_require__(/*! ./modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");
/**
 * Open a tooltip
 * @param {string} tooltipText The text shown by the tooltip
 * @param {function} [action] Returns An HTMLElement to display for action
 */


module.exports = function addTooltip(tooltipText, action, opts) {
  action = action || function () {
    return yo(_templateObject());
  };

  var t = new Toaster();
  return t.render(tooltipText, action(t), opts);
};

var Toaster = /*#__PURE__*/function () {
  function Toaster() {
    _classCallCheck(this, Toaster);
  }

  _createClass(Toaster, [{
    key: "hide",
    value: function hide() {
      var _this = this;

      if (this.id) clearTimeout(this.id);
      setTimeout(function () {
        // remove from body after the animation is finished
        if (_this.tooltip.parentElement) _this.tooltip.parentElement.removeChild(_this.tooltip);
      }, 2000);
      animation(this.tooltip, css.animateTop.className);
    }
  }, {
    key: "render",
    value: function render(tooltipText, actionElement, opts) {
      var _this2 = this;

      opts = defaultOptions(opts);
      var canShorten = true;

      if (tooltipText instanceof Element) {
        canShorten = false;
      } else {
        if (_typeof(tooltipText) === 'object') {
          if (tooltipText.message) {
            tooltipText = tooltipText.message;
          } else {
            try {
              tooltipText = JSON.stringify(tooltipText);
            } catch (e) {}
          }
        }
      }

      return new Promise(function (resolve, reject) {
        var shortTooltipText = canShorten && tooltipText.length > 201 ? tooltipText.substring(0, 200) + '...' : tooltipText;
        _this2.resolveFn = resolve;

        function showFullMessage() {
          modal.alert(tooltipText);
        }

        function closeTheToaster(self) {
          self.hide();
          over();
          resolve();
        }

        var button = tooltipText.length > 201 ? yo(_templateObject2(), function () {
          return showFullMessage();
        }) : '';
        _this2.tooltip = yo(_templateObject3(), css.tooltip, function () {
          over();
        }, function () {
          out();
        }, shortTooltipText, button, actionElement, function () {
          return closeTheToaster(_this2);
        });

        var timeOut = function timeOut() {
          return setTimeout(function () {
            if (_this2.id) {
              _this2.hide();

              resolve();
            }
          }, opts.time);
        };

        var over = function over() {
          if (_this2.id) {
            clearTimeout(_this2.id);
            _this2.id = null;
          }
        };

        var out = function out() {
          if (!_this2.id) _this2.id = timeOut();
        };

        _this2.id = timeOut();
        document.body.appendChild(_this2.tooltip);
        animation(_this2.tooltip, css.animateBottom.className);
      });
    }
  }]);

  return Toaster;
}();

var defaultOptions = function defaultOptions(opts) {
  opts = opts || {};
  return {
    time: opts.time || 7000
  };
};

var animation = function animation(tooltip, anim) {
  tooltip.classList.remove(css.animateTop.className);
  tooltip.classList.remove(css.animateBottom.className); // eslint-disable-next-line

  void tooltip.offsetWidth; // trick for restarting the animation

  tooltip.classList.add(anim);
};

/***/ }),

/***/ "./app/ui/txLogger.js":
/*!****************************!*\
  !*** ./app/ui/txLogger.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject29() {
  var data = _taggedTemplateLiteral(["\n    <tr class=\"", "\">\n      <td class=\"", "\" data-shared=\"key_", "\"> value </td>\n      <td class=\"", "\" data-id=\"txLoggerTableValue", "\" data-shared=\"pair_", "\">", " wei\n        ", "\n      </td>\n    </tr>\n  "]);

  _templateObject29 = function _templateObject29() {
    return data;
  };

  return data;
}

function _templateObject28() {
  var data = _taggedTemplateLiteral(["\n    <tr class=\"", "\">\n      <td class=\"", "\" data-shared=\"key_", "\"> logs </td>\n      <td class=\"", "\" id=\"logs\" data-id=\"txLoggerTableLogs", "\" data-shared=\"pair_", "\">\n        ", "\n        ", "\n        ", "\n      </td>\n    </tr>\n  "]);

  _templateObject28 = function _templateObject28() {
    return data;
  };

  return data;
}

function _templateObject27() {
  var data = _taggedTemplateLiteral(["\n    <tr class=\"", "\">\n      <td class=\"", "\" data-shared=\"key_", "\"> decoded output </td>\n      <td class=\"", "\" id=\"decodedoutput\" data-id=\"txLoggerTableDecodedOutput", "\" data-shared=\"pair_", "\">", "\n        ", "\n      </td>\n    </tr>"]);

  _templateObject27 = function _templateObject27() {
    return data;
  };

  return data;
}

function _templateObject26() {
  var data = _taggedTemplateLiteral(["\n    <tr class=\"", "\">\n      <td class=\"", "\" data-shared=\"key_", "\"> decoded input </td>\n      <td class=\"", "\" data-id=\"txLoggerTableDecodedInput", "\" data-shared=\"pair_", "\">", "\n        ", "\n      </td>\n    </tr>"]);

  _templateObject26 = function _templateObject26() {
    return data;
  };

  return data;
}

function _templateObject25() {
  var data = _taggedTemplateLiteral(["\n    <tr class=\"", "\">\n      <td class=\"", "\" data-shared=\"key_", "\"> input </td>\n      <td class=\"", "\" data-id=\"txLoggerTableInput", "\" data-shared=\"pair_", "\">", "\n        ", "\n      </td>\n    </tr>\n  "]);

  _templateObject25 = function _templateObject25() {
    return data;
  };

  return data;
}

function _templateObject24() {
  var data = _taggedTemplateLiteral(["\n    <tr class=\"", "\">\n      <td class=\"", "\" data-shared=\"key_", "\"> hash </td>\n      <td class=\"", "\" data-id=\"txLoggerTableHash", "\" data-shared=\"pair_", "\">", "\n        ", "\n      </td>\n    </tr>\n  "]);

  _templateObject24 = function _templateObject24() {
    return data;
  };

  return data;
}

function _templateObject23() {
  var data = _taggedTemplateLiteral(["\n    <tr class=\"", "\">\n      <td class=\"", "\" data-shared=\"key_", "\"> execution cost </td>\n      <td class=\"", "\" data-id=\"txLoggerTableExecutionHash", "\" data-shared=\"pair_", "\">", " gas ", "\n        ", "\n      </td>\n    </tr>"]);

  _templateObject23 = function _templateObject23() {
    return data;
  };

  return data;
}

function _templateObject22() {
  var data = _taggedTemplateLiteral(["\n    <tr class=\"", "\">\n      <td class=\"", "\" data-shared=\"key_", "\"> transaction cost </td>\n      <td class=\"", "\" data-id=\"txLoggerTableTransactionCost", "\" data-shared=\"pair_", "\">", " gas ", "\n        ", "\n      </td>\n    </tr>"]);

  _templateObject22 = function _templateObject22() {
    return data;
  };

  return data;
}

function _templateObject21() {
  var data = _taggedTemplateLiteral(["\n    <tr class=\"", "\">\n      <td class=\"", "\" data-shared=\"key_", "\"> gas </td>\n      <td class=\"", "\" data-id=\"txLoggerTableGas", "\" data-shared=\"pair_", "\">", " gas\n        ", "\n      </td>\n    </tr>\n  "]);

  _templateObject21 = function _templateObject21() {
    return data;
  };

  return data;
}

function _templateObject20() {
  var data = _taggedTemplateLiteral(["\n    <tr class=\"", "\">\n    <td class=\"", "\" data-shared=\"key_", "\"> to </td>\n    <td class=\"", "\" data-id=\"txLoggerTableTo", "\" data-shared=\"pair_", "\">", "\n      ", "\n    </td>\n    </tr>\n  "]);

  _templateObject20 = function _templateObject20() {
    return data;
  };

  return data;
}

function _templateObject19() {
  var data = _taggedTemplateLiteral(["\n    <tr class=\"", "\">\n      <td class=\"", " ", "\" data-shared=\"key_", "\"> from </td>\n      <td class=\"", "\" data-id=\"txLoggerTableFrom", "\" data-shared=\"pair_", "\">", "\n        ", "\n      </td>\n    </tr>\n  "]);

  _templateObject19 = function _templateObject19() {
    return data;
  };

  return data;
}

function _templateObject18() {
  var data = _taggedTemplateLiteral(["\n    <tr class=\"", "\">\n      <td class=\"", "\" data-shared=\"key_", "\"> contract address </td>\n      <td class=\"", "\" data-id=\"txLoggerTableContractAddress", "\" data-shared=\"pair_", "\">", "\n        ", "\n      </td>\n    </tr>\n  "]);

  _templateObject18 = function _templateObject18() {
    return data;
  };

  return data;
}

function _templateObject17() {
  var data = _taggedTemplateLiteral(["\n    <tr class=\"", "\">\n      <td class=\"", "\" data-shared=\"key_", "\"> transaction hash </td>\n      <td class=\"", "\" data-id=\"txLoggerTableHash", "\" data-shared=\"pair_", "\">", "\n        ", "\n      </td>\n    </tr>\n  "]);

  _templateObject17 = function _templateObject17() {
    return data;
  };

  return data;
}

function _templateObject16() {
  var data = _taggedTemplateLiteral(["\n      <tr class=\"", "\">\n        <td class=\"", "\" data-shared=\"key_", "\"> status </td>\n        <td class=\"", "\" data-id=\"txLoggerTableStatus", "\" data-shared=\"pair_", "\">", "", "</td>\n      </tr>"]);

  _templateObject16 = function _templateObject16() {
    return data;
  };

  return data;
}

function _templateObject15() {
  var data = _taggedTemplateLiteral(["<table class=\"", "\" id=\"txTable\" data-id=\"txLoggerTable", "\"></table>"]);

  _templateObject15 = function _templateObject15() {
    return data;
  };

  return data;
}

function _templateObject14() {
  var data = _taggedTemplateLiteral(["<i class=\"", " fas fa-angle-down\"></i>"]);

  _templateObject14 = function _templateObject14() {
    return data;
  };

  return data;
}

function _templateObject13() {
  var data = _taggedTemplateLiteral(["<i class=\"", " fas fa-angle-up\"></i>"]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteral(["\n      <div>\n        <span class=", ">\n          <span class='", "'>[block:", " txIndex:", "]</span>\n          <div class=", "><span class=", ">from:</span> ", "</div>\n          <div class=", "><span class=", ">to:</span> ", "</div>\n          <div class=", "><span class=", ">value:</span> ", " wei</div>\n        </span>\n      </div>"]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function _templateObject11() {
  var data = _taggedTemplateLiteral(["\n      <div>\n        <span class=", ">\n        <span class='", "'>[block:", " txIndex:", "]</span>\n          <div class=", "><span class=", ">from:</span> ", "</div>\n          <div class=", "><span class=", ">to:</span> ", "</div>\n          <div class=", "><span class=", ">value:</span> ", " wei</div>\n          <div class=", "><span class=", ">data:</span> ", "</div>\n          <div class=", "><span class=", ">logs:</span> ", "</div>\n          <div class=", "><span class=", ">hash:</span> ", "</div>\n        </span>\n      </div>"]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["\n      <div>\n        <span class=", ">\n          <span class=", ">[vm]</span>\n          <div class=", "><span class=", ">from:</span> ", "</div>\n          <div class=", "><span class=", ">to:</span> ", "</div>\n          <div class=", "><span class=", ">value:</span> ", " wei</div>\n          <div class=", "><span class=", ">data:</span> ", "</div>\n          <div class=", "><span class=", ">logs:</span> ", "</div>\n          <div class=", "><span class=", ">hash:</span> ", "</div>\n        </span>\n      </div>"]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["<i class=\"", " ", " fas fa-circle-thin\" title='Status not available' ></i>"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["<i class=\"", " ", " fas fa-times-circle\"></i>"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["<i class=\"", " ", "\">call</i>"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["<i class=\"", " ", " fas fa-check-circle\"></i>"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n    <span class=", ">\n      <span class='", "'><div class=", ">[<span class=", ">block:", " - </span> 0 transactions]</span></span>\n    </span>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n    <span id=\"tx", "\">\n      <div class=\"", "\" onclick=", ">\n        ", "\n        ", "\n        <div class=", ">\n          <div class=\"", " btn btn-primary btn-sm\" onclick=", ">Debug</div>\n        </div>\n        <i class=\"", " fas fa-angle-down\"></i>\n      </div>\n    </span>\n  "]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n    <span id=\"tx", "\">\n      <div class=\"", "\" onclick=", ">\n        ", "\n        <span class=", ">\n          <span class=", ">[call]</span>\n          <div class=", "><span class=", ">from:</span> ", "</div>\n          <div class=", "><span class=", ">to:</span> ", "</div>\n          <div class=", "><span class=", ">data:</span> ", "</div>\n        </span>\n        <div class=", ">\n          <div class=\"", " btn btn-primary btn-sm\" onclick=", ">Debug</div>\n        </div>\n        <i class=\"", " fas fa-angle-down\"></i>\n      </div>\n    </span>\n  "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n    <span id=\"tx", "\" data-id=\"txLogger", "\">\n      <div class=\"", "\" onclick=", ">\n        ", "\n        ", "\n        <div class=", ">\n          <button\n            class=\"", " btn btn-primary btn-sm\"\n            data-shared=\"txLoggerDebugButton\"\n            data-id=\"txLoggerDebugButton", "\"\n            onclick=", "\n          >\n            Debug\n          </div>\n        </div>\n        <i class=\"", " fas fa-angle-down\"></i>\n      </div>\n    </span>\n  "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .log {\n    display: flex;\n    cursor: pointer;\n    align-items: center;\n    cursor: pointer;\n  }\n  .log:hover {\n    opacity: 0.8;\n  }\n  .arrow {\n    color: var(--text-info);\n    font-size: 20px;\n    cursor: pointer;\n    display: flex;\n    margin-left: 10px;\n  }\n  .arrow:hover {\n    color: var(--secondary);\n  }\n  .txLog {\n  }\n  .txStatus {\n    display: flex;\n    font-size: 20px;\n    margin-right: 20px;\n    float: left;\n  }\n  .succeeded {\n    color: var(--success);\n  }\n  .failed {\n    color: var(--danger);\n  }\n  .notavailable {\n  }\n  .call {\n    font-size: 7px;\n    border-radius: 50%;\n    min-width: 20px;\n    min-height: 20px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    color: var(--text-info);\n    text-transform: uppercase;\n    font-weight: bold;\n  }\n  .txItem {\n    color: var(--text-info);\n    margin-right: 5px;\n    float: left;\n  }\n  .txItemTitle {\n    font-weight: bold;\n  }\n  .tx {\n    color: var(--text-info);\n    font-weight: bold;\n    float: left;\n    margin-right: 10px;\n  }\n  .txTable,\n  .tr,\n  .td {\n    border-collapse: collapse;\n    font-size: 10px;\n    color: var(--text-info);\n    border: 1px solid var(--text-info);\n  }\n  #txTable {\n    margin-top: 1%;\n    margin-bottom: 5%;\n    align-self: center;\n    width: 85%;\n  }\n  .tr, .td {\n    padding: 4px;\n    vertical-align: baseline;\n  }\n  .td:first-child {\n    min-width: 30%;\n    width: 30%;\n    align-items: baseline;\n    font-weight: bold;\n  }\n  .tableTitle {\n    width: 25%;\n  }\n  .buttons {\n    display: flex;\n    margin-left: auto;\n  }\n  .debug {\n    white-space: nowrap;\n  }\n  .debug:hover {\n    opacity: 0.8;\n  }"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var copyToClipboard = __webpack_require__(/*! ./copy-to-clipboard */ "./app/ui/copy-to-clipboard.js"); // -------------- styling ----------------------


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

var helper = __webpack_require__(/*! ../../lib/helper */ "./lib/helper.js");

var modalDialog = __webpack_require__(/*! ./modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var typeConversion = remixLib.execution.typeConversion;

var globlalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var css = csjs(_templateObject());
/**
  * This just export a function that register to `newTransaction` and forward them to the logger.
  *
  */

var TxLogger = function TxLogger(terminal, blockchain) {
  var _this = this;

  _classCallCheck(this, TxLogger);

  this.event = new EventManager();
  this.seen = {};

  function filterTx(value, query) {
    if (value.length) {
      return helper.find(value, query);
    }

    return false;
  }

  this.eventsDecoder = globlalRegistry.get('eventsDecoder').api;
  this.txListener = globlalRegistry.get('txlistener').api;
  this.terminal = terminal; // dependencies

  this._deps = {
    compilersArtefacts: globlalRegistry.get('compilersartefacts').api
  };
  this.logKnownTX = this.terminal.registerCommand('knownTransaction', function (args, cmds, append) {
    var data = args[0];
    var el;

    if (data.tx.isCall) {
      el = renderCall(_this, data);
    } else {
      el = renderKnownTransaction(_this, data, blockchain);
    }

    _this.seen[data.tx.hash] = el;
    append(el);
  }, {
    activate: true,
    filterFn: filterTx
  });
  this.logUnknownTX = this.terminal.registerCommand('unknownTransaction', function (args, cmds, append) {
    // triggered for transaction AND call
    var data = args[0];
    var el = renderUnknownTransaction(_this, data, blockchain);
    append(el);
  }, {
    activate: false,
    filterFn: filterTx
  });
  this.logEmptyBlock = this.terminal.registerCommand('emptyBlock', function (args, cmds, append) {
    var data = args[0];
    var el = renderEmptyBlock(_this, data);
    append(el);
  }, {
    activate: true
  });
  this.txListener.event.register('newBlock', function (block) {
    if (!block.transactions || block.transactions && !block.transactions.length) {
      _this.logEmptyBlock({
        block: block
      });
    }
  });
  this.txListener.event.register('newTransaction', function (tx, receipt) {
    log(_this, tx, receipt);
  });
  this.txListener.event.register('newCall', function (tx) {
    log(_this, tx, null);
  });
  this.terminal.updateJournal({
    type: 'select',
    value: 'unknownTransaction'
  });
  this.terminal.updateJournal({
    type: 'select',
    value: 'knownTransaction'
  });
};

function debug(e, data, self) {
  e.stopPropagation();

  if (data.tx.isCall && data.tx.envMode !== 'vm') {
    modalDialog.alert('Cannot debug this call. Debugging calls is only possible in JavaScript VM mode.');
  } else {
    self.event.trigger('debuggingRequested', [data.tx.hash]);
  }
}

function log(self, tx, receipt) {
  var resolvedTransaction = self.txListener.resolvedTransaction(tx.hash);

  if (resolvedTransaction) {
    var compiledContracts = null;

    if (self._deps.compilersArtefacts.__last) {
      compiledContracts = self._deps.compilersArtefacts.__last.getContracts();
    }

    self.eventsDecoder.parseLogs(tx, resolvedTransaction.contractName, compiledContracts, function (error, logs) {
      if (!error) {
        self.logKnownTX({
          tx: tx,
          receipt: receipt,
          resolvedData: resolvedTransaction,
          logs: logs
        });
      }
    });
  } else {
    // contract unknown - just displaying raw tx.
    self.logUnknownTX({
      tx: tx,
      receipt: receipt
    });
  }
}

function renderKnownTransaction(self, data, blockchain) {
  var from = data.tx.from;
  var to = data.resolvedData.contractName + '.' + data.resolvedData.fn;
  var obj = {
    from: from,
    to: to
  };
  var txType = 'knownTx';
  var tx = yo(_templateObject2(), data.tx.hash, data.tx.hash, css.log, function (e) {
    return txDetails(e, tx, data, obj);
  }, checkTxStatus(data.receipt, txType), context(self, {
    from: from,
    to: to,
    data: data
  }, blockchain), css.buttons, css.debug, data.tx.hash, function (e) {
    return debug(e, data, self);
  }, css.arrow);
  return tx;
}

function renderCall(self, data) {
  var to = data.resolvedData.contractName + '.' + data.resolvedData.fn;
  var from = data.tx.from ? data.tx.from : ' - ';
  var input = data.tx.input ? helper.shortenHexData(data.tx.input) : '';
  var obj = {
    from: from,
    to: to
  };
  var txType = 'call';
  var tx = yo(_templateObject3(), data.tx.hash, css.log, function (e) {
    return txDetails(e, tx, data, obj);
  }, checkTxStatus(data.tx, txType), css.txLog, css.tx, css.txItem, css.txItemTitle, from, css.txItem, css.txItemTitle, to, css.txItem, css.txItemTitle, input, css.buttons, css.debug, function (e) {
    return debug(e, data, self);
  }, css.arrow);
  return tx;
}

function renderUnknownTransaction(self, data, blockchain) {
  var from = data.tx.from;
  var to = data.tx.to;
  var obj = {
    from: from,
    to: to
  };
  var txType = 'unknown' + (data.tx.isCall ? 'Call' : 'Tx');
  var tx = yo(_templateObject4(), data.tx.hash, css.log, function (e) {
    return txDetails(e, tx, data, obj);
  }, checkTxStatus(data.receipt || data.tx, txType), context(self, {
    from: from,
    to: to,
    data: data
  }, blockchain), css.buttons, css.debug, function (e) {
    return debug(e, data, self);
  }, css.arrow);
  return tx;
}

function renderEmptyBlock(self, data) {
  return yo(_templateObject5(), css.txLog, css.tx, css.txItem, css.txItemTitle, data.block.number);
}

function checkTxStatus(tx, type) {
  if (tx.status === '0x1' || tx.status === true) {
    return yo(_templateObject6(), css.txStatus, css.succeeded);
  }

  if (type === 'call' || type === 'unknownCall') {
    return yo(_templateObject7(), css.txStatus, css.call);
  } else if (tx.status === '0x0' || tx.status === false) {
    return yo(_templateObject8(), css.txStatus, css.failed);
  } else {
    return yo(_templateObject9(), css.txStatus, css.notavailable);
  }
}

function context(self, opts, blockchain) {
  var data = opts.data || '';
  var from = opts.from ? helper.shortenHexData(opts.from) : '';
  var to = opts.to;
  if (data.tx.to) to = to + ' ' + helper.shortenHexData(data.tx.to);
  var val = data.tx.value;
  var hash = data.tx.hash ? helper.shortenHexData(data.tx.hash) : '';
  var input = data.tx.input ? helper.shortenHexData(data.tx.input) : '';
  var logs = data.logs && data.logs.decoded && data.logs.decoded.length ? data.logs.decoded.length : 0;
  var block = data.receipt ? data.receipt.blockNumber : data.tx.blockNumber || '';
  var i = data.receipt ? data.receipt.transactionIndex : data.tx.transactionIndex;
  var value = val ? typeConversion.toInt(val) : 0;

  if (blockchain.getProvider() === 'vm') {
    return yo(_templateObject10(), css.txLog, css.tx, css.txItem, css.txItemTitle, from, css.txItem, css.txItemTitle, to, css.txItem, css.txItemTitle, value, css.txItem, css.txItemTitle, input, css.txItem, css.txItemTitle, logs, css.txItem, css.txItemTitle, hash);
  } else if (blockchain.getProvider() !== 'vm' && data.resolvedData) {
    return yo(_templateObject11(), css.txLog, css.tx, block, i, css.txItem, css.txItemTitle, from, css.txItem, css.txItemTitle, to, css.txItem, css.txItemTitle, value, css.txItem, css.txItemTitle, input, css.txItem, css.txItemTitle, logs, css.txItem, css.txItemTitle, hash);
  } else {
    to = helper.shortenHexData(to);
    hash = helper.shortenHexData(data.tx.blockHash);
    return yo(_templateObject12(), css.txLog, css.tx, block, i, css.txItem, css.txItemTitle, from, css.txItem, css.txItemTitle, to, css.txItem, css.txItemTitle, value);
  }
}

module.exports = TxLogger; // helpers

function txDetails(e, tx, data, obj) {
  var from = obj.from;
  var to = obj.to;
  var arrowUp = yo(_templateObject13(), css.arrow);
  var arrowDown = yo(_templateObject14(), css.arrow);
  var blockElement = e.target;

  while (true) {
    // get the parent block element
    if (blockElement.className.startsWith('block')) break;else if (blockElement.parentElement) {
      blockElement = blockElement.parentElement;
    } else break;
  }

  var table = blockElement.querySelector("#".concat(tx.id, " [class^=\"txTable\"]"));
  var log = blockElement.querySelector("#".concat(tx.id, " [class^='log']"));
  var arrow = blockElement.querySelector("#".concat(tx.id, " [class^='arrow']"));

  if (table && table.parentNode) {
    tx.removeChild(table);
    log.removeChild(arrow);
    log.appendChild(arrowDown);
  } else {
    log.removeChild(arrow);
    log.appendChild(arrowUp);
    table = createTable({
      hash: data.tx.hash,
      status: data.receipt ? data.receipt.status : null,
      isCall: data.tx.isCall,
      contractAddress: data.tx.contractAddress,
      data: data.tx,
      from: from,
      to: to,
      gas: data.tx.gas,
      input: data.tx.input,
      'decoded input': data.resolvedData && data.resolvedData.params ? JSON.stringify(typeConversion.stringify(data.resolvedData.params), null, '\t') : ' - ',
      'decoded output': data.resolvedData && data.resolvedData.decodedReturnValue ? JSON.stringify(typeConversion.stringify(data.resolvedData.decodedReturnValue), null, '\t') : ' - ',
      logs: data.logs,
      val: data.tx.value,
      transactionCost: data.tx.transactionCost,
      executionCost: data.tx.executionCost
    });
    tx.appendChild(table);
  }
}

function createTable(opts) {
  var table = yo(_templateObject15(), css.txTable, opts.hash);

  if (!opts.isCall) {
    var msg = '';

    if (opts.status !== undefined && opts.status !== null) {
      if (opts.status === '0x0' || opts.status === false) {
        msg = ' Transaction mined but execution failed';
      } else if (opts.status === '0x1' || opts.status === true) {
        msg = ' Transaction mined and execution succeed';
      }
    } else {
      msg = ' Status not available at the moment';
    }

    table.appendChild(yo(_templateObject16(), css.tr, css.td, opts.hash, css.td, opts.hash, opts.hash, opts.status, msg));
  }

  var transactionHash = yo(_templateObject17(), css.tr, css.td, opts.hash, css.td, opts.hash, opts.hash, opts.hash, copyToClipboard(function () {
    return opts.hash;
  }));
  table.appendChild(transactionHash);
  var contractAddress = yo(_templateObject18(), css.tr, css.td, opts.hash, css.td, opts.hash, opts.hash, opts.contractAddress, copyToClipboard(function () {
    return opts.contractAddress;
  }));
  if (opts.contractAddress) table.appendChild(contractAddress);
  var from = yo(_templateObject19(), css.tr, css.td, css.tableTitle, opts.hash, css.td, opts.hash, opts.hash, opts.from, copyToClipboard(function () {
    return opts.from;
  }));
  if (opts.from) table.appendChild(from);
  var toHash;
  var data = opts.data; // opts.data = data.tx

  if (data.to) {
    toHash = opts.to + ' ' + data.to;
  } else {
    toHash = opts.to;
  }

  var to = yo(_templateObject20(), css.tr, css.td, opts.hash, css.td, opts.hash, opts.hash, toHash, copyToClipboard(function () {
    return data.to ? data.to : toHash;
  }));
  if (opts.to) table.appendChild(to);
  var gas = yo(_templateObject21(), css.tr, css.td, opts.hash, css.td, opts.hash, opts.hash, opts.gas, copyToClipboard(function () {
    return opts.gas;
  }));
  if (opts.gas) table.appendChild(gas);
  var callWarning = '';

  if (opts.isCall) {
    callWarning = '(Cost only applies when called by a contract)';
  }

  if (opts.transactionCost) {
    table.appendChild(yo(_templateObject22(), css.tr, css.td, opts.hash, css.td, opts.hash, opts.hash, opts.transactionCost, callWarning, copyToClipboard(function () {
      return opts.transactionCost;
    })));
  }

  if (opts.executionCost) {
    table.appendChild(yo(_templateObject23(), css.tr, css.td, opts.hash, css.td, opts.hash, opts.hash, opts.executionCost, callWarning, copyToClipboard(function () {
      return opts.executionCost;
    })));
  }

  var hash = yo(_templateObject24(), css.tr, css.td, opts.hash, css.td, opts.hash, opts.hash, opts.hash, copyToClipboard(function () {
    return opts.hash;
  }));
  if (opts.hash) table.appendChild(hash);
  var input = yo(_templateObject25(), css.tr, css.td, opts.hash, css.td, opts.hash, opts.hash, helper.shortenHexData(opts.input), copyToClipboard(function () {
    return opts.input;
  }));
  if (opts.input) table.appendChild(input);

  if (opts['decoded input']) {
    var inputDecoded = yo(_templateObject26(), css.tr, css.td, opts.hash, css.td, opts.hash, opts.hash, opts['decoded input'], copyToClipboard(function () {
      return opts['decoded input'];
    }));
    table.appendChild(inputDecoded);
  }

  if (opts['decoded output']) {
    var outputDecoded = yo(_templateObject27(), css.tr, css.td, opts.hash, css.td, opts.hash, opts.hash, opts['decoded output'], copyToClipboard(function () {
      return opts['decoded output'];
    }));
    table.appendChild(outputDecoded);
  }

  var stringified = ' - ';

  if (opts.logs && opts.logs.decoded) {
    stringified = typeConversion.stringify(opts.logs.decoded);
  }

  var logs = yo(_templateObject28(), css.tr, css.td, opts.hash, css.td, opts.hash, opts.hash, JSON.stringify(stringified, null, '\t'), copyToClipboard(function () {
    return JSON.stringify(stringified, null, '\t');
  }), copyToClipboard(function () {
    return JSON.stringify(opts.logs.raw || '0');
  }));
  if (opts.logs) table.appendChild(logs);
  var val = opts.val != null ? typeConversion.toInt(opts.val) : 0;
  val = yo(_templateObject29(), css.tr, css.td, opts.hash, css.td, opts.hash, opts.hash, val, copyToClipboard(function () {
    return "".concat(val, " wei");
  }));
  if (opts.val) table.appendChild(val);
  return table;
}

/***/ }),

/***/ "./app/ui/universal-dapp-ui.js":
/*!*************************************!*\
  !*** ./app/ui/universal-dapp-ui.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global */


function _templateObject9() {
  var data = _taggedTemplateLiteral(["<div class=\"", "\" >", "</div>"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["<div class=", "></div>"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n    <div class=\"d-flex flex-column\">\n      <div class=\"d-flex flex-row justify-content-between mt-2\">\n        <div class=\"py-2 border-top d-flex justify-content-start flex-grow-1\">\n          Low level interactions\n        </div>\n        <a\n          href=\"https://solidity.readthedocs.io/en/v0.6.2/contracts.html#receive-ether-function\"\n          title=\"check out docs for using 'receive'/'fallback'\"\n          target=\"_blank\"\n        >\n          <i aria-hidden=\"true\" class=\"fas fa-info my-2 mr-1\"></i>\n        </a>\n      </div>\n      <div class=\"d-flex flex-column align-items-start\">\n        <label class=\"\">CALLDATA</label>\n        <div class=\"d-flex justify-content-end w-100 align-items-center\">\n          ", "\n          <button id=\"deployAndRunLLTxSendTransaction\" data-id=\"pluginManagerSettingsDeployAndRunLLTxSendTransaction\" class=\"", " p-0 w-50 btn border-warning text-warning\" title=\"Send data to contract.\" onclick=", ">Transact</button>\n        </div>\n      </div>\n      <div>\n        ", "\n      </div>\n    </div>\n  "]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n    <label id=\"deployAndRunLLTxError\" class=\"text-danger my-2\"></label>\n  "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n    <input id=\"deployAndRunLLTxCalldata\" class=\"", " form-control\" title=\"The Calldata to send to fallback function of the contract.\">\n  "]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n    <div class=\"", "\" data-id=\"universalDappUiContractActionWrapper\">\n    </div>\n  "]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n    <button\n      class=\"", " mr-1 p-1 btn btn-secondary align-items-center\"\n      data-id=\"universalDappUiUdappClose\"\n      onclick=", "\n      title=\"Remove from the list\"\n    >\n      <i class=\"", " fas fa-times\" aria-hidden=\"true\"></i>\n    </button>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n    <div class=\"", " alert alert-secondary\">\n      <button data-id=\"universalDappUiTitleExpander\" class=\"btn ", "\" onclick=\"", "\">\n        <i class=\"fas fa-angle-right\" aria-hidden=\"true\"></i>\n      </button>\n      <div class=\"input-group ", "\">\n        <div class=\"", " input-group-prepend\">\n          <span class=\"input-group-text ", "\">\n            ", " at ", " (", ")\n          </span>\n        </div>\n        <div class=\"btn-group\">\n          <button class=\"btn p-1 btn-secondary\">", "</button>\n        </div>\n      </div>\n    </div>\n  "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["<div class=\"instance run-instance border-dark ", " ", "\" id=\"instance", "\" data-shared=\"universalDappUiInstance\"></div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var $ = __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var ethJSUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

var BN = ethJSUtil.BN;

var helper = __webpack_require__(/*! ../../lib/helper */ "./lib/helper.js");

var copyToClipboard = __webpack_require__(/*! ./copy-to-clipboard */ "./app/ui/copy-to-clipboard.js");

var css = __webpack_require__(/*! ../../universal-dapp-styles */ "./universal-dapp-styles.js");

var MultiParamManager = __webpack_require__(/*! ./multiParamManager */ "./app/ui/multiParamManager.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var txFormat = remixLib.execution.txFormat;
var txHelper = remixLib.execution.txHelper;

var TreeView = __webpack_require__(/*! ./TreeView */ "./app/ui/TreeView.js");

var txCallBacks = __webpack_require__(/*! ./sendTxCallbacks */ "./app/ui/sendTxCallbacks.js");

function UniversalDAppUI(blockchain, logCallback) {
  this.blockchain = blockchain;
  this.logCallback = logCallback;
  this.compilerData = {
    contractsDetails: {}
  };
}

function decodeResponseToTreeView(response, fnabi) {
  var treeView = new TreeView({
    extractData: function extractData(item, parent, key) {
      var ret = {};

      if (BN.isBN(item)) {
        ret.self = item.toString(10);
        ret.children = [];
      } else {
        ret = treeView.extractDataDefault(item, parent, key);
      }

      return ret;
    }
  });
  return treeView.render(txFormat.decodeResponse(response, fnabi));
}

UniversalDAppUI.prototype.renderInstance = function (contract, address, contractName) {
  var noInstances = document.querySelector('[data-id="deployAndRunNoInstanceText"]');

  if (noInstances) {
    noInstances.parentNode.removeChild(noInstances);
  }

  var abi = txHelper.sortAbiFunction(contract.abi);
  return this.renderInstanceFromABI(abi, address, contractName);
}; // TODO this function was named before "appendChild".
// this will render an instance: contract name, contract address, and all the public functions
// basically this has to be called for the "atAddress" (line 393) and when a contract creation succeed
// this returns a DOM element


UniversalDAppUI.prototype.renderInstanceFromABI = function (contractABI, address, contractName) {
  var _this = this;

  var self = this;
  address = (address.slice(0, 2) === '0x' ? '' : '0x') + address.toString('hex');
  address = ethJSUtil.toChecksumAddress(address);
  var instance = yo(_templateObject(), css.instance, css.hidesub, address);
  var context = this.blockchain.context();
  var shortAddress = helper.shortenAddress(address);
  var title = yo(_templateObject2(), css.title, css.titleExpander, function (e) {
    toggleClass(e);
  }, css.nameNbuts, css.titleText, css.spanTitleText, contractName, shortAddress, context, copyToClipboard(function () {
    return address;
  }));
  var close = yo(_templateObject3(), css.udappClose, remove, css.closeIcon);
  title.querySelector('.btn-group').appendChild(close);
  var contractActionsWrapper = yo(_templateObject4(), css.cActionsWrapper);

  function remove() {
    instance.remove(); // @TODO perhaps add a callack here to warn the caller that the instance has been removed
  }

  function toggleClass(e) {
    $(instance).toggleClass("".concat(css.hidesub, " bg-light")); // e.currentTarget.querySelector('i')

    e.currentTarget.querySelector('i').classList.toggle('fa-angle-right');
    e.currentTarget.querySelector('i').classList.toggle('fa-angle-down');
  }

  instance.appendChild(title);
  instance.appendChild(contractActionsWrapper);
  $.each(contractABI, function (i, funABI) {
    if (funABI.type !== 'function') {
      return;
    } // @todo getData cannot be used with overloaded functions


    contractActionsWrapper.appendChild(_this.getCallButton({
      funABI: funABI,
      address: address,
      contractABI: contractABI,
      contractName: contractName
    }));
  });
  var calldataInput = yo(_templateObject5(), css.calldataInput);
  var llIError = yo(_templateObject6()); // constract LLInteractions elements

  var lowLevelInteracions = yo(_templateObject7(), calldataInput, css.instanceButton, function () {
    return sendData();
  }, llIError);

  function sendData() {
    function setLLIError(text) {
      llIError.innerText = text;
    }

    setLLIError('');
    var fallback = txHelper.getFallbackInterface(contractABI);
    var receive = txHelper.getReceiveInterface(contractABI);
    var args = {
      funABI: fallback || receive,
      address: address,
      contractName: contractName,
      contractABI: contractABI
    };
    var amount = document.querySelector('#value').value;

    if (amount !== '0') {
      // check for numeric and receive/fallback
      if (!helper.isNumeric(amount)) {
        return setLLIError('Value to send should be a number');
      } else if (!receive && !(fallback && fallback.stateMutability === 'payable')) {
        return setLLIError("In order to receive Ether transfer the contract should have either 'receive' or payable 'fallback' function");
      }
    }

    var calldata = calldataInput.value;

    if (calldata) {
      if (calldata.length < 4 && helper.is0XPrefixed(calldata)) {
        return setLLIError('The calldata should be a valid hexadecimal value with size of at least one byte.');
      } else {
        if (helper.is0XPrefixed(calldata)) {
          calldata = calldata.substr(2, calldata.length);
        }

        if (!helper.isHexadecimal(calldata)) {
          return setLLIError('The calldata should be a valid hexadecimal value.');
        }
      }

      if (!fallback) {
        return setLLIError("'Fallback' function is not defined");
      }
    }

    if (!receive && !fallback) return setLLIError('Both \'receive\' and \'fallback\' functions are not defined'); // we have to put the right function ABI:
    // if receive is defined and that there is no calldata => receive function is called
    // if fallback is defined => fallback function is called

    if (receive && !calldata) args.funABI = receive;else if (fallback) args.funABI = fallback;
    if (!args.funABI) return setLLIError('Please define a \'Fallback\' function to send calldata and a either \'Receive\' or payable \'Fallback\' to send ethers');
    self.runTransaction(false, args, null, calldataInput.value, null);
  }

  contractActionsWrapper.appendChild(lowLevelInteracions);
  return instance;
}; // TODO this is used by renderInstance when a new instance is displayed.
// this returns a DOM element.


UniversalDAppUI.prototype.getCallButton = function (args) {
  var self = this;
  var outputOverride = yo(_templateObject8(), css.value); // show return value

  var isConstant = args.funABI.constant !== undefined ? args.funABI.constant : false;
  var lookupOnly = args.funABI.stateMutability === 'view' || args.funABI.stateMutability === 'pure' || isConstant;
  var multiParamManager = new MultiParamManager(lookupOnly, args.funABI, function (valArray, inputsValues) {
    return self.runTransaction(lookupOnly, args, valArray, inputsValues, outputOverride);
  }, self.blockchain.getInputs(args.funABI));
  var contractActionsContainer = yo(_templateObject9(), css.contractActionsContainer, multiParamManager.render());
  contractActionsContainer.appendChild(outputOverride);
  return contractActionsContainer;
};

UniversalDAppUI.prototype.runTransaction = function (lookupOnly, args, valArr, inputsValues, outputOverride) {
  var functionName = args.funABI.type === 'function' ? args.funABI.name : "(".concat(args.funABI.type, ")");
  var logMsg = "".concat(lookupOnly ? 'call' : 'transact', " to ").concat(args.contractName, ".").concat(functionName);
  var callbacksInContext = txCallBacks.getCallBacksWithContext(this, this.blockchain);

  var outputCb = function outputCb(returnValue) {
    if (outputOverride) {
      var decoded = decodeResponseToTreeView(returnValue, args.funABI);
      outputOverride.innerHTML = '';
      outputOverride.appendChild(decoded);
    }
  };

  var params = args.funABI.type !== 'fallback' ? inputsValues : '';
  this.blockchain.runOrCallContractMethod(args.contractName, args.contractAbi, args.funABI, inputsValues, args.address, params, lookupOnly, logMsg, this.logCallback, outputCb, callbacksInContext.confirmationCb.bind(callbacksInContext), callbacksInContext.continueCb.bind(callbacksInContext), callbacksInContext.promptCb.bind(callbacksInContext));
};

module.exports = UniversalDAppUI;

/***/ }),

/***/ "./assets/js/editor/darkTheme.js":
/*!***************************************!*\
  !*** ./assets/js/editor/darkTheme.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable */
ace.define("ace/theme/remixDark", ["require", "exports", "module", "ace/lib/dom"], function (acequire, exports, module) {
  exports.isDark = true;
  exports.cssClass = "ace-remixDark";
  exports.cssText = ".ace-remixDark .ace_gutter {\
  background: #2a2c3f;\
  color: #8789a1;\
  border-right: 1px solid #282828;\
  }\
  .ace-remixDark .ace_gutter-cell.ace_warning {\
  background-image: none;\
  background: #FC0;\
  border-left: none;\
  padding-left: 0;\
  color: #000;\
  }\
  .ace-remixDark .ace_gutter-cell.ace_error {\
  background-position: -6px center;\
  background-image: none;\
  background: #F10;\
  border-left: none;\
  padding-left: 0;\
  color: #000;\
  }\
  .ace-remixDark .ace_print-margin {\
  border-left: 1px solid #555;\
  right: 0;\
  background: #1D1D1D;\
  }\
  .ace-remixDark {\
  background-color: #222336;\
  color: #a2a3bd;\
  }\
  .ace-remixDark .ace_cursor {\
  border-left: 2px solid #FFFFFF;\
  }\
  .ace-remixDark .ace_cursor.ace_overwrite {\
  border-left: 0px;\
  border-bottom: 1px solid #FFFFFF;\
  }\
  .ace-remixDark .ace_marker-layer .ace_selection {\
  background: #494836;\
  }\
  .ace-remixDark .ace_marker-layer .ace_step {\
  background: rgb(198, 219, 174);\
  }\
  .ace-remixDark .ace_marker-layer .ace_bracket {\
  margin: -1px 0 0 -1px;\
  border: 1px solid #FCE94F;\
  }\
  .ace-remixDark .ace_marker-layer .ace_active-line {\
  background: #262843;\
  }\
  .ace-remixDark .ace_gutter-active-line {\
  background-color: #363950;\
  }\
  .ace-remixDark .ace_invisible {\
  color: #404040;\
  }\
  .ace-remixDark .ace_rparen {\
    color: #d4d7ed;\
  }\
  .ace-remixDark .ace_lparen {\
    color: #d4d7ed;\
  }\
  .ace-remixDark .ace_keyword {\
  color:#ffa76d;\
  }\
  .ace-remixDark .ace_keyword.ace_operator {\
  color:#eceeff;\
  }\
  .ace-remixDark .ace_constant {\
  color:#1EDAFB;\
  }\
  .ace-remixDark .ace_constant.ace_language {\
  color:#FDC251;\
  }\
  .ace-remixDark .ace_constant.ace_library {\
  color:#8DFF0A;\
  }\
  .ace-remixDark .ace_constant.ace_numeric {\
  color:#eceeff;\
  }\
  .ace-remixDark .ace_invalid {\
  color:#FFFFFF;\
  background-color:#990000;\
  }\
  .ace-remixDark .ace_invalid.ace_deprecated {\
  color:#FFFFFF;\
  background-color:#990000;\
  }\
  .ace-remixDark .ace_support {\
  color: #999;\
  }\
  .ace-remixDark .ace_support.ace_function {\
  color:#3fe2a7;\
  }\
  .ace-remixDark .ace_function {\
  color:#3fe2a7;\
  }\
  .ace-remixDark .ace_string {\
  color:#eceeff;\
  }\
  .ace-remixDark .ace_comment {\
  color:#a7a7a7;\
  font-style:italic;\
  padding-bottom: 0px;\
  }\
  .ace-remixDark .ace_type {\
  color:#75ceef;\
  }]\
  .ace-remixDark .ace_visibility (\
    color:#f7d777;\
  )\
  .ace-remixDark .ace_identifier {\
    color:#bec1dd;\
  }\
  .ace-remixDark .ace_modifier {\
    color:#efff2f;\
  }\
  .ace-remixDark .ace-boolean {\
    color:#ff86ac;\
  }\
  .ace-remixDark .ace_statemutability {\
    color:#FFCC00;\
  }\
  .ace-remixDark .ace_variable {\
  color:#e0bb83;\
  }\
  .ace-remixDark .ace_meta.ace_tag {\
  color:#BE53E6;\
  }\
  .ace-remixDark .ace_entity.ace_other.ace_attribute-name {\
  color:#4aa8fd;\
  }\
  .ace-remixDark .ace_markup.ace_underline {\
  text-decoration: underline;\
  }\
  .ace-remixDark .ace_fold-widget {\
  text-align: center;\
  }\
  .ace-remixDark .ace_fold-widget:hover {\
  color: #777;\
  }\
  .ace-remixDark .ace_fold-widget.ace_start,\
  .ace-remixDark .ace_fold-widget.ace_end,\
  .ace-remixDark .ace_fold-widget.ace_closed{\
  background: none;\
  border: none;\
  box-shadow: none;\
  }\
  .ace-remixDark .ace_fold-widget.ace_start:after {\
  content: ''\
  }\
  .ace-remixDark .ace_fold-widget.ace_end:after {\
  content: ''\
  }\
  .ace-remixDark .ace_fold-widget.ace_closed:after {\
  content: ''\
  }\
  .ace-remixDark .ace_indent-guide {\
  border-right:1px dotted #333;\
  margin-right:-1px;\
  }\
  .ace-remixDark .ace_fold { \
  background: #222; \
  border-radius: 3px; \
  color: #7AF; \
  border: none; \
  }\
  .ace-remixDark .ace_fold:hover {\
  background: #CCC; \
  color: #000;\
  }\
  ";
  var dom = acequire("../lib/dom");
  dom.importCssString(exports.cssText, exports.cssClass);
});

/***/ }),

/***/ "./blockchain/blockchain.js":
/*!**********************************!*\
  !*** ./blockchain/blockchain.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var txFormat = remixLib.execution.txFormat;
var txExecution = remixLib.execution.txExecution;
var typeConversion = remixLib.execution.typeConversion;
var Txlistener = remixLib.execution.txListener;
var TxRunner = remixLib.execution.txRunner;
var txHelper = remixLib.execution.txHelper;
var EventManager = remixLib.EventManager;
var executionContext = remixLib.execution.executionContext;

var Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

var async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

var _require = __webpack_require__(/*! events */ "../../../node_modules/events/events.js"),
    EventEmitter = _require.EventEmitter;

var _require2 = __webpack_require__(/*! ./txResultHelper */ "./blockchain/txResultHelper.js"),
    resultToRemixTx = _require2.resultToRemixTx;

var VMProvider = __webpack_require__(/*! ./providers/vm.js */ "./blockchain/providers/vm.js");

var InjectedProvider = __webpack_require__(/*! ./providers/injected.js */ "./blockchain/providers/injected.js");

var NodeProvider = __webpack_require__(/*! ./providers/node.js */ "./blockchain/providers/node.js");

var Blockchain = /*#__PURE__*/function () {
  // NOTE: the config object will need to be refactored out in remix-lib
  function Blockchain(config) {
    var _this = this;

    _classCallCheck(this, Blockchain);

    this.event = new EventManager();
    this.executionContext = executionContext;
    this.events = new EventEmitter();
    this.config = config;
    this.txRunner = new TxRunner({}, {
      config: config,
      detectNetwork: function detectNetwork(cb) {
        _this.executionContext.detectNetwork(cb);
      },
      personalMode: function personalMode() {
        return _this.getProvider() === 'web3' ? _this.config.get('settings/personal-mode') : false;
      }
    }, this.executionContext);
    this.executionContext.event.register('contextChanged', this.resetEnvironment.bind(this));
    this.networkcallid = 0;
    this.setupEvents();
    this.setupProviders();
  }

  _createClass(Blockchain, [{
    key: "setupEvents",
    value: function setupEvents() {
      var _this2 = this;

      this.executionContext.event.register('contextChanged', function (context, silent) {
        _this2.event.trigger('contextChanged', [context, silent]);
      });
      this.executionContext.event.register('addProvider', function (network) {
        _this2.event.trigger('addProvider', [network]);
      });
      this.executionContext.event.register('removeProvider', function (name) {
        _this2.event.trigger('removeProvider', [name]);
      });
    }
  }, {
    key: "setupProviders",
    value: function setupProviders() {
      this.providers = {};
      this.providers.vm = new VMProvider(this.executionContext);
      this.providers.injected = new InjectedProvider(this.executionContext);
      this.providers.web3 = new NodeProvider(this.executionContext, this.config);
    }
  }, {
    key: "getCurrentProvider",
    value: function getCurrentProvider() {
      var provider = this.getProvider();
      if (this.providers[provider]) return this.providers[provider];
      return this.providers.web3; // default to the common type of provider
    }
    /** Return the list of accounts */
    // note: the dual promise/callback is kept for now as it was before

  }, {
    key: "getAccounts",
    value: function getAccounts(cb) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        _this3.getCurrentProvider().getAccounts(function (error, accounts) {
          if (cb) {
            return cb(error, accounts);
          }

          if (error) {
            reject(error);
          }

          resolve(accounts);
        });
      });
    }
  }, {
    key: "deployContractAndLibraries",
    value: function deployContractAndLibraries(selectedContract, args, contractMetadata, compilerContracts, callbacks, confirmationCb) {
      var _this4 = this;

      var continueCb = callbacks.continueCb,
          promptCb = callbacks.promptCb,
          statusCb = callbacks.statusCb,
          finalCb = callbacks.finalCb;
      var constructor = selectedContract.getConstructorInterface();
      txFormat.buildData(selectedContract.name, selectedContract.object, compilerContracts, true, constructor, args, function (error, data) {
        if (error) return statusCb("creation of ".concat(selectedContract.name, " errored: ") + error);
        statusCb("creation of ".concat(selectedContract.name, " pending..."));

        _this4.createContract(selectedContract, data, continueCb, promptCb, confirmationCb, finalCb);
      }, statusCb, function (data, runTxCallback) {
        // called for libraries deployment
        _this4.runTx(data, confirmationCb, continueCb, promptCb, runTxCallback);
      });
    }
  }, {
    key: "deployContractWithLibrary",
    value: function deployContractWithLibrary(selectedContract, args, contractMetadata, compilerContracts, callbacks, confirmationCb) {
      var _this5 = this;

      var continueCb = callbacks.continueCb,
          promptCb = callbacks.promptCb,
          statusCb = callbacks.statusCb,
          finalCb = callbacks.finalCb;
      var constructor = selectedContract.getConstructorInterface();
      txFormat.encodeConstructorCallAndLinkLibraries(selectedContract.object, args, constructor, contractMetadata.linkReferences, selectedContract.bytecodeLinkReferences, function (error, data) {
        if (error) return statusCb("creation of ".concat(selectedContract.name, " errored: ") + (error.message ? error.message : error));
        statusCb("creation of ".concat(selectedContract.name, " pending..."));

        _this5.createContract(selectedContract, data, continueCb, promptCb, confirmationCb, finalCb);
      });
    }
  }, {
    key: "createContract",
    value: function createContract(selectedContract, data, continueCb, promptCb, confirmationCb, finalCb) {
      if (data) {
        data.contractName = selectedContract.name;
        data.linkReferences = selectedContract.bytecodeLinkReferences;
        data.contractABI = selectedContract.abi;
      }

      this.runTx({
        data: data,
        useCall: false
      }, confirmationCb, continueCb, promptCb, function (error, txResult, address) {
        if (error) {
          return finalCb("creation of ".concat(selectedContract.name, " errored: ").concat(error.message ? error.message : error));
        }

        if (txResult.result.status && txResult.result.status === '0x0') {
          return finalCb("creation of ".concat(selectedContract.name, " errored: transaction execution failed"));
        }

        finalCb(null, selectedContract, address);
      });
    }
  }, {
    key: "determineGasPrice",
    value: function determineGasPrice(cb) {
      var _this6 = this;

      this.getCurrentProvider().getGasPrice(function (error, gasPrice) {
        var warnMessage = ' Please fix this issue before sending any transaction. ';

        if (error) {
          return cb('Unable to retrieve the current network gas price.' + warnMessage + error);
        }

        try {
          var gasPriceValue = _this6.fromWei(gasPrice, false, 'gwei');

          cb(null, gasPriceValue);
        } catch (e) {
          cb(warnMessage + e.message, null, false);
        }
      });
    }
  }, {
    key: "getInputs",
    value: function getInputs(funABI) {
      if (!funABI.inputs) {
        return '';
      }

      return txHelper.inputParametersDeclarationToString(funABI.inputs);
    }
  }, {
    key: "fromWei",
    value: function fromWei(value, doTypeConversion, unit) {
      if (doTypeConversion) {
        return Web3.utils.fromWei(typeConversion.toInt(value), unit || 'ether');
      }

      return Web3.utils.fromWei(value.toString(10), unit || 'ether');
    }
  }, {
    key: "toWei",
    value: function toWei(value, unit) {
      return Web3.utils.toWei(value, unit || 'gwei');
    }
  }, {
    key: "calculateFee",
    value: function calculateFee(gas, gasPrice, unit) {
      return Web3.utils.toBN(gas).mul(Web3.utils.toBN(Web3.utils.toWei(gasPrice.toString(10), unit || 'gwei')));
    }
  }, {
    key: "determineGasFees",
    value: function determineGasFees(tx) {
      var _this7 = this;

      var determineGasFeesCb = function determineGasFeesCb(gasPrice, cb) {
        var txFeeText, priceStatus; // TODO: this try catch feels like an anti pattern, can/should be
        // removed, but for now keeping the original logic

        try {
          var fee = _this7.calculateFee(tx.gas, gasPrice);

          txFeeText = ' ' + _this7.fromWei(fee, false, 'ether') + ' Ether';
          priceStatus = true;
        } catch (e) {
          txFeeText = ' Please fix this issue before sending any transaction. ' + e.message;
          priceStatus = false;
        }

        cb(txFeeText, priceStatus);
      };

      return determineGasFeesCb;
    }
  }, {
    key: "changeExecutionContext",
    value: function changeExecutionContext(context, confirmCb, infoCb, cb) {
      return this.executionContext.executionContextChange(context, null, confirmCb, infoCb, cb);
    }
  }, {
    key: "setProviderFromEndpoint",
    value: function setProviderFromEndpoint(target, context, cb) {
      return this.executionContext.setProviderFromEndpoint(target, context, cb);
    }
  }, {
    key: "updateNetwork",
    value: function updateNetwork(cb) {
      this.executionContext.detectNetwork(function (err) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            id = _ref.id,
            name = _ref.name;

        if (err) {
          return cb(err);
        }

        cb(null, {
          id: id,
          name: name
        });
      });
    }
  }, {
    key: "detectNetwork",
    value: function detectNetwork(cb) {
      return this.executionContext.detectNetwork(cb);
    }
  }, {
    key: "getProvider",
    value: function getProvider() {
      return this.executionContext.getProvider();
    }
  }, {
    key: "isWeb3Provider",
    value: function isWeb3Provider() {
      var isVM = this.getProvider() === 'vm';
      var isInjected = this.getProvider() === 'injected';
      return !isVM && !isInjected;
    }
  }, {
    key: "isInjectedWeb3",
    value: function isInjectedWeb3() {
      return this.getProvider() === 'injected';
    }
  }, {
    key: "signMessage",
    value: function signMessage(message, account, passphrase, cb) {
      this.getCurrentProvider().signMessage(message, account, passphrase, cb);
    }
  }, {
    key: "web3",
    value: function web3() {
      // @todo(https://github.com/ethereum/remix-project/issues/431)
      var isVM = this.getProvider() === 'vm';

      if (isVM) {
        return this.providers.vm.web3;
      }

      return this.executionContext.web3();
    }
  }, {
    key: "getTxListener",
    value: function getTxListener(opts) {
      opts.event = {
        // udapp: this.udapp.event
        udapp: this.event
      };
      var txlistener = new Txlistener(opts, this.executionContext);
      return txlistener;
    }
  }, {
    key: "runOrCallContractMethod",
    value: function runOrCallContractMethod(contractName, contractAbi, funABI, value, address, callType, lookupOnly, logMsg, logCallback, outputCb, confirmationCb, continueCb, promptCb) {
      var _this8 = this;

      // contractsDetails is used to resolve libraries
      txFormat.buildData(contractName, contractAbi, {}, false, funABI, callType, function (error, data) {
        if (error) {
          return logCallback("".concat(logMsg, " errored: ").concat(error, " "));
        }

        if (!lookupOnly) {
          logCallback("".concat(logMsg, " pending ... "));
        } else {
          logCallback("".concat(logMsg));
        }

        if (funABI.type === 'fallback') data.dataHex = value;
        var useCall = funABI.stateMutability === 'view' || funABI.stateMutability === 'pure';

        _this8.runTx({
          to: address,
          data: data,
          useCall: useCall
        }, confirmationCb, continueCb, promptCb, function (error, txResult, _address, returnValue) {
          if (error) {
            return logCallback("".concat(logMsg, " errored: ").concat(error, " "));
          }

          if (lookupOnly) {
            outputCb(returnValue);
          }
        });
      }, function (msg) {
        logCallback(msg);
      }, function (data, runTxCallback) {
        // called for libraries deployment
        _this8.runTx(data, confirmationCb, runTxCallback, promptCb, function () {});
      });
    }
  }, {
    key: "context",
    value: function context() {
      return this.executionContext.isVM() ? 'memory' : 'blockchain';
    } // NOTE: the config is only needed because exectuionContext.init does
    // if config.get('settings/always-use-vm'), we can simplify this later

  }, {
    key: "resetAndInit",
    value: function resetAndInit(config, transactionContextAPI) {
      this.transactionContextAPI = transactionContextAPI;
      this.executionContext.init(config);
      this.executionContext.stopListenOnLastBlock();
      this.executionContext.listenOnLastBlock();
      this.resetEnvironment();
    }
  }, {
    key: "addProvider",
    value: function addProvider(provider) {
      this.executionContext.addProvider(provider);
    }
  }, {
    key: "removeProvider",
    value: function removeProvider(name) {
      this.executionContext.removeProvider(name);
    } // TODO : event should be triggered by Udapp instead of TxListener

    /** Listen on New Transaction. (Cannot be done inside constructor because txlistener doesn't exist yet) */

  }, {
    key: "startListening",
    value: function startListening(txlistener) {
      var _this9 = this;

      txlistener.event.register('newTransaction', function (tx) {
        _this9.events.emit('newTransaction', tx);
      });
    }
  }, {
    key: "resetEnvironment",
    value: function resetEnvironment() {
      var _this10 = this;

      this.getCurrentProvider().resetEnvironment(); // TODO: most params here can be refactored away in txRunner
      // this.txRunner = new TxRunner(this.providers.vm.accounts, {

      this.txRunner = new TxRunner(this.providers.vm.RemixSimulatorProvider.Accounts.accounts, {
        // TODO: only used to check value of doNotShowTransactionConfirmationAgain property
        config: this.config,
        // TODO: to refactor, TxRunner already has access to executionContext
        detectNetwork: function detectNetwork(cb) {
          _this10.executionContext.detectNetwork(cb);
        },
        personalMode: function personalMode() {
          return _this10.getProvider() === 'web3' ? _this10.config.get('settings/personal-mode') : false;
        }
      }, this.executionContext);
      this.txRunner.event.register('transactionBroadcasted', function (txhash) {
        _this10.executionContext.detectNetwork(function (error, network) {
          if (error || !network) return;

          _this10.event.trigger('transactionBroadcasted', [txhash, network.name]);
        });
      });
    }
    /**
     * Create a VM Account
     * @param {{privateKey: string, balance: string}} newAccount The new account to create
     */

  }, {
    key: "createVMAccount",
    value: function createVMAccount(newAccount) {
      if (this.getProvider() !== 'vm') {
        throw new Error('plugin API does not allow creating a new account through web3 connection. Only vm mode is allowed');
      }

      return this.providers.vm.createVMAccount(newAccount);
    }
  }, {
    key: "newAccount",
    value: function newAccount(_password, passwordPromptCb, cb) {
      return this.getCurrentProvider().newAccount(passwordPromptCb, cb);
    }
    /** Get the balance of an address, and convert wei to ether */

  }, {
    key: "getBalanceInEther",
    value: function getBalanceInEther(address, cb) {
      this.getCurrentProvider().getBalanceInEther(address, cb);
    }
  }, {
    key: "pendingTransactionsCount",
    value: function pendingTransactionsCount() {
      return Object.keys(this.txRunner.pendingTxs).length;
    }
    /**
     * This function send a tx only to javascript VM or testnet, will return an error for the mainnet
     * SHOULD BE TAKEN CAREFULLY!
     *
     * @param {Object} tx    - transaction.
     */

  }, {
    key: "sendTransaction",
    value: function sendTransaction(tx) {
      var _this11 = this;

      return new Promise(function (resolve, reject) {
        _this11.executionContext.detectNetwork(function (error, network) {
          if (error) return reject(error);

          if (network.name === 'Main' && network.id === '1') {
            return reject(new Error('It is not allowed to make this action against mainnet'));
          }

          _this11.txRunner.rawRun(tx, function (network, tx, gasEstimation, continueTxExecution, cancelCb) {
            continueTxExecution();
          }, function (error, continueTxExecution, cancelCb) {
            if (error) {
              reject(error);
            } else {
              continueTxExecution();
            }
          }, function (okCb, cancelCb) {
            okCb();
          }, function (error, result) {
            if (error) return reject(error);

            try {
              resolve(resultToRemixTx(result));
            } catch (e) {
              reject(e);
            }
          });
        });
      });
    }
  }, {
    key: "runTx",
    value: function runTx(args, confirmationCb, continueCb, promptCb, cb) {
      var _this12 = this;

      var self = this;
      async.waterfall([function getGasLimit(next) {
        if (self.transactionContextAPI.getGasLimit) {
          return self.transactionContextAPI.getGasLimit(next);
        }

        next(null, 3000000);
      }, function queryValue(gasLimit, next) {
        if (args.value) {
          return next(null, args.value, gasLimit);
        }

        if (args.useCall || !self.transactionContextAPI.getValue) {
          return next(null, 0, gasLimit);
        }

        self.transactionContextAPI.getValue(function (err, value) {
          next(err, value, gasLimit);
        });
      }, function getAccount(value, gasLimit, next) {
        if (args.from) {
          return next(null, args.from, value, gasLimit);
        }

        if (self.transactionContextAPI.getAddress) {
          return self.transactionContextAPI.getAddress(function (err, address) {
            next(err, address, value, gasLimit);
          });
        }

        self.getAccounts(function (err, accounts) {
          var address = accounts[0];
          if (err) return next(err);
          if (!address) return next('No accounts available'); // if (self.executionContext.isVM() && !self.providers.vm.accounts[address]) {

          if (self.executionContext.isVM() && !self.providers.vm.RemixSimulatorProvider.Accounts.accounts[address]) {
            return next('Invalid account selected');
          }

          next(null, address, value, gasLimit);
        });
      }, function runTransaction(fromAddress, value, gasLimit, next) {
        var tx = {
          to: args.to,
          data: args.data.dataHex,
          useCall: args.useCall,
          from: fromAddress,
          value: value,
          gasLimit: gasLimit,
          timestamp: args.data.timestamp
        };
        var payLoad = {
          funAbi: args.data.funAbi,
          funArgs: args.data.funArgs,
          contractBytecode: args.data.contractBytecode,
          contractName: args.data.contractName,
          contractABI: args.data.contractABI,
          linkReferences: args.data.linkReferences
        };
        var timestamp = Date.now();

        if (tx.timestamp) {
          timestamp = tx.timestamp;
        }

        self.event.trigger('initiatingTransaction', [timestamp, tx, payLoad]);
        self.txRunner.rawRun(tx, confirmationCb, continueCb, promptCb, function (error, result) {
          if (error) return next(error);
          var rawAddress = self.executionContext.isVM() ? result.result.createdAddress : result.result.contractAddress;
          var eventName = tx.useCall ? 'callExecuted' : 'transactionExecuted';
          self.event.trigger(eventName, [error, tx.from, tx.to, tx.data, tx.useCall, result, timestamp, payLoad, rawAddress]);

          if (error && typeof error !== 'string') {
            if (error.message) error = error.message;else {
              try {
                error = 'error: ' + JSON.stringify(error);
              } catch (e) {}
            }
          }

          next(error, result);
        });
      }], function (error, txResult) {
        if (error) {
          return cb(error);
        }

        var isVM = _this12.executionContext.isVM();

        if (isVM) {
          var vmError = txExecution.checkVMError(txResult);

          if (vmError.error) {
            return cb(vmError.message);
          }
        }

        var address = null;
        var returnValue = null;

        if (txResult && txResult.result) {
          address = isVM ? txResult.result.createdAddress : txResult.result.contractAddress; // if it's not the VM, we don't have return value. We only have the transaction, and it does not contain the return value.

          returnValue = txResult.result.execResult && isVM ? txResult.result.execResult.returnValue : txResult.result;
        }

        cb(error, txResult, address, returnValue);
      });
    }
  }]);

  return Blockchain;
}();

module.exports = Blockchain;

/***/ }),

/***/ "./blockchain/pluginUDapp.js":
/*!***********************************!*\
  !*** ./blockchain/pluginUDapp.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __webpack_require__(/*! events */ "../../../node_modules/events/events.js"),
    EventEmitter = _require.EventEmitter;

var PluginUdapp = /*#__PURE__*/function () {
  function PluginUdapp(blockchain) {
    _classCallCheck(this, PluginUdapp);

    this.blockchain = blockchain;
    this.events = new EventEmitter();
    this.setupEvents();
  }

  _createClass(PluginUdapp, [{
    key: "setupEvents",
    value: function setupEvents() {
      var _this = this;

      this.blockchain.events.on('newTransaction', function (tx, receipt) {
        _this.events.emit('newTransaction', tx, receipt);
      });
    }
  }, {
    key: "createVMAccount",
    value: function createVMAccount(newAccount) {
      return this.blockchain.createVMAccount(newAccount);
    }
  }, {
    key: "sendTransaction",
    value: function sendTransaction(tx) {
      return this.blockchain.sendTransaction(tx);
    }
  }, {
    key: "getAccounts",
    value: function getAccounts(cb) {
      return this.blockchain.getAccounts(cb);
    }
  }, {
    key: "pendingTransactionsCount",
    value: function pendingTransactionsCount() {
      return this.blockchain.pendingTransactionsCount();
    }
  }]);

  return PluginUdapp;
}();

module.exports = PluginUdapp;

/***/ }),

/***/ "./blockchain/providers/injected.js":
/*!******************************************!*\
  !*** ./blockchain/providers/injected.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

var _require = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js"),
    stripHexPrefix = _require.stripHexPrefix,
    hashPersonalMessage = _require.hashPersonalMessage;

var InjectedProvider = /*#__PURE__*/function () {
  function InjectedProvider(executionContext) {
    _classCallCheck(this, InjectedProvider);

    this.executionContext = executionContext;
  }

  _createClass(InjectedProvider, [{
    key: "getAccounts",
    value: function getAccounts(cb) {
      return this.executionContext.web3().eth.getAccounts(cb);
    }
  }, {
    key: "newAccount",
    value: function newAccount(passwordPromptCb, cb) {
      var _this = this;

      passwordPromptCb(function (passphrase) {
        _this.executionContext.web3().personal.newAccount(passphrase, cb);
      });
    }
  }, {
    key: "resetEnvironment",
    value: function resetEnvironment() {}
  }, {
    key: "getBalanceInEther",
    value: function getBalanceInEther(address, cb) {
      address = stripHexPrefix(address);
      this.executionContext.web3().eth.getBalance(address, function (err, res) {
        if (err) {
          return cb(err);
        }

        cb(null, Web3.utils.fromWei(res.toString(10), 'ether'));
      });
    }
  }, {
    key: "getGasPrice",
    value: function getGasPrice(cb) {
      this.executionContext.web3().eth.getGasPrice(cb);
    }
  }, {
    key: "signMessage",
    value: function signMessage(message, account, _passphrase, cb) {
      var messageHash = hashPersonalMessage(Buffer.from(message));

      try {
        this.executionContext.web3().eth.personal.sign(message, account, function (error, signedData) {
          cb(error, '0x' + messageHash.toString('hex'), signedData);
        });
      } catch (e) {
        cb(e.message);
      }
    }
  }, {
    key: "getProvider",
    value: function getProvider() {
      return 'injected';
    }
  }]);

  return InjectedProvider;
}();

module.exports = InjectedProvider;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./blockchain/providers/node.js":
/*!**************************************!*\
  !*** ./blockchain/providers/node.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

var _require = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js"),
    stripHexPrefix = _require.stripHexPrefix,
    hashPersonalMessage = _require.hashPersonalMessage;

var Personal = __webpack_require__(/*! web3-eth-personal */ "../../../node_modules/web3-eth-personal/src/index.js");

var NodeProvider = /*#__PURE__*/function () {
  function NodeProvider(executionContext, config) {
    _classCallCheck(this, NodeProvider);

    this.executionContext = executionContext;
    this.config = config;
  }

  _createClass(NodeProvider, [{
    key: "getAccounts",
    value: function getAccounts(cb) {
      if (this.config.get('settings/personal-mode')) {
        return this.executionContext.web3().personal.getListAccounts(cb);
      }

      return this.executionContext.web3().eth.getAccounts(cb);
    }
  }, {
    key: "newAccount",
    value: function newAccount(passwordPromptCb, cb) {
      var _this = this;

      if (!this.config.get('settings/personal-mode')) {
        return cb('Not running in personal mode');
      }

      passwordPromptCb(function (passphrase) {
        _this.executionContext.web3().personal.newAccount(passphrase, cb);
      });
    }
  }, {
    key: "resetEnvironment",
    value: function resetEnvironment() {}
  }, {
    key: "getBalanceInEther",
    value: function getBalanceInEther(address, cb) {
      address = stripHexPrefix(address);
      this.executionContext.web3().eth.getBalance(address, function (err, res) {
        if (err) {
          return cb(err);
        }

        cb(null, Web3.utils.fromWei(res.toString(10), 'ether'));
      });
    }
  }, {
    key: "getGasPrice",
    value: function getGasPrice(cb) {
      this.executionContext.web3().eth.getGasPrice(cb);
    }
  }, {
    key: "signMessage",
    value: function signMessage(message, account, passphrase, cb) {
      var messageHash = hashPersonalMessage(Buffer.from(message));

      try {
        var personal = new Personal(this.executionContext.web3().currentProvider);
        personal.sign(message, account, passphrase, function (error, signedData) {
          cb(error, '0x' + messageHash.toString('hex'), signedData);
        });
      } catch (e) {
        cb(e.message);
      }
    }
  }, {
    key: "getProvider",
    value: function getProvider() {
      return this.executionContext.getProvider();
    }
  }]);

  return NodeProvider;
}();

module.exports = NodeProvider;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./blockchain/providers/vm.js":
/*!************************************!*\
  !*** ./blockchain/providers/vm.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

var _require = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js"),
    BN = _require.BN,
    privateToAddress = _require.privateToAddress,
    stripHexPrefix = _require.stripHexPrefix,
    hashPersonalMessage = _require.hashPersonalMessage;

var RemixSimulator = __webpack_require__(/*! @remix-project/remix-simulator */ "../../../dist/libs/remix-simulator/src/index.js");

var VMProvider = /*#__PURE__*/function () {
  function VMProvider(executionContext) {
    _classCallCheck(this, VMProvider);

    this.executionContext = executionContext;
    this.RemixSimulatorProvider = new RemixSimulator.Provider({
      executionContext: this.executionContext
    });
    this.RemixSimulatorProvider.init();
    this.web3 = new Web3(this.RemixSimulatorProvider);
    this.accounts = {};
  }

  _createClass(VMProvider, [{
    key: "getAccounts",
    value: function getAccounts(cb) {
      this.web3.eth.getAccounts(function (err, accounts) {
        if (err) {
          return cb('No accounts?');
        }

        return cb(null, accounts);
      });
    }
  }, {
    key: "resetEnvironment",
    value: function resetEnvironment() {
      this.RemixSimulatorProvider.Accounts.resetAccounts();
      this.accounts = {};
    } // TODO: is still here because of the plugin API
    // can be removed later when we update the API

  }, {
    key: "createVMAccount",
    value: function createVMAccount(newAccount) {
      var privateKey = newAccount.privateKey,
          balance = newAccount.balance;

      this.RemixSimulatorProvider.Accounts._addAccount(privateKey, balance);

      var privKey = Buffer.from(privateKey, 'hex');
      return '0x' + privateToAddress(privKey).toString('hex');
    }
  }, {
    key: "newAccount",
    value: function newAccount(_passwordPromptCb, cb) {
      this.RemixSimulatorProvider.Accounts.newAccount(cb);
    }
  }, {
    key: "getBalanceInEther",
    value: function getBalanceInEther(address, cb) {
      address = stripHexPrefix(address);
      this.web3.eth.getBalance(address, function (err, res) {
        if (err) {
          return cb(err);
        }

        cb(null, Web3.utils.fromWei(new BN(res).toString(10), 'ether'));
      });
    }
  }, {
    key: "getGasPrice",
    value: function getGasPrice(cb) {
      this.web3.eth.getGasPrice(cb);
    }
  }, {
    key: "signMessage",
    value: function signMessage(message, account, _passphrase, cb) {
      var messageHash = hashPersonalMessage(Buffer.from(message));
      this.web3.eth.sign(message, account, function (error, signedData) {
        if (error) {
          return cb(error);
        }

        cb(null, '0x' + messageHash.toString('hex'), signedData);
      });
    }
  }, {
    key: "getProvider",
    value: function getProvider() {
      return 'vm';
    }
  }]);

  return VMProvider;
}();

module.exports = VMProvider;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./blockchain/txResultHelper.js":
/*!**************************************!*\
  !*** ./blockchain/txResultHelper.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _require = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js"),
    bufferToHex = _require.bufferToHex,
    isHexString = _require.isHexString;

function convertToPrefixedHex(input) {
  if (input === undefined || input === null || isHexString(input)) {
    return input;
  } else if (Buffer.isBuffer(input)) {
    return bufferToHex(input);
  }

  return '0x' + input.toString(16);
}
/*
 txResult.result can be 3 different things:
 - VM call or tx: ethereumjs-vm result object
 - Node transaction: object returned from eth.getTransactionReceipt()
 - Node call: return value from function call (not an object)

 Also, VM results use BN and Buffers, Node results use hex strings/ints,
 So we need to normalize the values to prefixed hex strings
*/


function resultToRemixTx(txResult) {
  var result = txResult.result,
      transactionHash = txResult.transactionHash;
  var status = result.status,
      execResult = result.execResult,
      gasUsed = result.gasUsed,
      createdAddress = result.createdAddress,
      contractAddress = result.contractAddress;
  var returnValue, errorMessage;

  if (isHexString(result)) {
    returnValue = result;
  } else if (execResult !== undefined) {
    returnValue = execResult.returnValue;
    errorMessage = execResult.exceptionError;
  }

  return {
    transactionHash: transactionHash,
    status: status,
    gasUsed: convertToPrefixedHex(gasUsed),
    error: errorMessage,
    "return": convertToPrefixedHex(returnValue),
    createdAddress: convertToPrefixedHex(createdAddress || contractAddress)
  };
}

module.exports = {
  resultToRemixTx: resultToRemixTx
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./config.js":
/*!*******************!*\
  !*** ./config.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CONFIG_FILE = '.remix.config';

var EventEmitter = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

function Config(storage) {
  this.items = {};
  this.unpersistedItems = {};
  this.events = new EventEmitter(); // load on instantiation

  try {
    var config = storage.get(CONFIG_FILE);

    if (config) {
      this.items = JSON.parse(config);
    }
  } catch (exception) {}

  this.exists = function (key) {
    return this.items[key] !== undefined;
  };

  this.get = function (key) {
    this.ensureStorageUpdated(key);
    return this.items[key];
  };

  this.set = function (key, content) {
    this.items[key] = content;

    try {
      storage.set(CONFIG_FILE, JSON.stringify(this.items));
      this.events.emit(key + '_changed', content);
    } catch (exception) {}
  };

  this.ensureStorageUpdated = function (key) {
    if (key === 'currentFile') {
      if (this.items[key] && this.items[key] !== '' && this.items[key].indexOf('config/') !== 0 && this.items[key].indexOf('browser/') !== 0 && this.items[key].indexOf('localhost/') !== 0 && this.items[key].indexOf('swarm/') !== 0 && this.items[key].indexOf('gist/') !== 0 && this.items[key].indexOf('github/') !== 0 && this.items[key].indexOf('ipfs/') !== 0 && this.items[key].indexOf('http/') !== 0 && this.items[key].indexOf('https/') !== 0) {
        this.items[key] = 'browser/' + this.items[key];
      }
    }
  };

  this.getUnpersistedProperty = function (key) {
    return this.unpersistedItems[key];
  }; // TODO: this only used for *one* property "doNotShowTransactionConfirmationAgain"
  // and can be removed once it's refactored away in txRunner


  this.setUnpersistedProperty = function (key, value) {
    this.unpersistedItems[key] = value;
  };
}

module.exports = Config;

/***/ }),

/***/ "./framingService.js":
/*!***************************!*\
  !*** ./framingService.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FramingService = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FramingService = /*#__PURE__*/function () {
  function FramingService(sidePanel, verticalIcon, mainView, resizeFeature) {
    _classCallCheck(this, FramingService);

    this.sidePanel = sidePanel;
    this.verticalIcon = verticalIcon;
    this.mainPanel = mainView.getAppPanel();
    this.mainView = mainView;
    this.resizeFeature = resizeFeature;
  }

  _createClass(FramingService, [{
    key: "start",
    value: function start(params) {
      var _this = this;

      this.sidePanel.events.on('toggle', function () {
        _this.resizeFeature.panel.clientWidth !== 0 ? _this.resizeFeature.hidePanel() : _this.resizeFeature.showPanel();
      });
      this.sidePanel.events.on('showing', function () {
        if (_this.resizeFeature.panel.clientWidth === 0) _this.resizeFeature.showPanel();
      });
      this.mainPanel.events.on('toggle', function () {
        _this.resizeFeature.showPanel();
      });
      this.verticalIcon.select('fileExplorers');
      document.addEventListener('keypress', function (e) {
        if (e.shiftKey && e.ctrlKey) {
          if (e.code === 'KeyF') {
            // Ctrl+Shift+F
            _this.verticalIcon.select('fileExplorers');
          } else if (e.code === 'KeyA') {
            // Ctrl+Shift+A
            _this.verticalIcon.select('pluginManager');
          } else if (e.code === 'KeyS') {
            //  Ctrl+Shift+S
            _this.verticalIcon.select('settings');
          }

          e.preventDefault();
        }
      });
      if (params.minimizeterminal) this.mainView.minimizeTerminal();
      if (params.minimizesidepanel) this.resizeFeature.hidePanel();
    }
  }, {
    key: "embed",
    value: function embed() {
      this.mainView.minimizeTerminal();
      this.resizeFeature.hidePanel();
    }
  }]);

  return FramingService;
}();

exports.FramingService = FramingService;

/***/ }),

/***/ "./global/registry.js":
/*!****************************!*\
  !*** ./global/registry.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = new (__webpack_require__(/*! ../registry.js */ "./registry.js"))();

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // require('@babel/polyfill')

var App = __webpack_require__(/*! ./app.js */ "./app.js");

var app = new App({});
document.body.appendChild(app.render());
app.init(); // @TODO: refactor to remove

/***/ }),

/***/ "./lib/cmdInterpreterAPI.js":
/*!**********************************!*\
  !*** ./lib/cmdInterpreterAPI.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject3() {
  var data = _taggedTemplateLiteral(["<br>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<div>", ": ", "</div>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["<div></div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

var EventManager = __webpack_require__(/*! ../lib/events */ "./lib/events.js");

var CompilerImport = __webpack_require__(/*! ../app/compiler/compiler-imports */ "./app/compiler/compiler-imports.js");

var toolTip = __webpack_require__(/*! ../app/ui/tooltip */ "./app/ui/tooltip.js");

var globalRegistry = __webpack_require__(/*! ../global/registry */ "./global/registry.js");

var SourceHighlighter = __webpack_require__(/*! ../app/editor/sourceHighlighter */ "./app/editor/sourceHighlighter.js");

var GistHandler = __webpack_require__(/*! ./gist-handler */ "./lib/gist-handler.js");

var CmdInterpreterAPI = /*#__PURE__*/function () {
  function CmdInterpreterAPI(terminal, localRegistry, blockchain) {
    _classCallCheck(this, CmdInterpreterAPI);

    var self = this;
    self.event = new EventManager();
    self.blockchain = blockchain;
    self._components = {};
    self._components.registry = localRegistry || globalRegistry;
    self._components.terminal = terminal;
    self._components.sourceHighlighter = new SourceHighlighter();
    self._components.fileImport = new CompilerImport();
    self._components.gistHandler = new GistHandler();
    self._deps = {
      fileManager: self._components.registry.get('filemanager').api,
      editor: self._components.registry.get('editor').api,
      compilersArtefacts: self._components.registry.get('compilersartefacts').api,
      offsetToLineColumnConverter: self._components.registry.get('offsettolinecolumnconverter').api
    };
    self.commandHelp = {
      'remix.loadgist(id)': 'Load a gist in the file explorer.',
      'remix.loadurl(url)': 'Load the given url in the file explorer. The url can be of type github, swarm, ipfs or raw http',
      'remix.execute(filepath)': 'Run the script specified by file path. If filepath is empty, script currently displayed in the editor is executed.',
      'remix.exeCurrent()': 'Run the script currently displayed in the editor',
      'remix.help()': 'Display this help message'
    };
  }

  _createClass(CmdInterpreterAPI, [{
    key: "log",
    value: function log() {
      arguments[0] != null ? this._components.terminal.commands.html(arguments[0]) : this._components.terminal.commands.html(arguments[1]);
    }
  }, {
    key: "loadgist",
    value: function loadgist(id, cb) {
      var self = this;

      self._components.gistHandler.loadFromGist({
        gist: id
      }, this._deps.fileManager);

      if (cb) cb();
    }
  }, {
    key: "loadurl",
    value: function loadurl(url, cb) {
      var self = this;

      self._components.fileImport["import"](url, function (loadingMsg) {
        toolTip(loadingMsg);
      }, function (err, content, cleanUrl, type, url) {
        if (err) {
          toolTip("Unable to load ".concat(url, ": ").concat(err));
          if (cb) cb(err);
        } else {
          self._deps.fileManager.writeFile(type + '/' + cleanUrl, content);

          try {
            content = JSON.parse(content);
            async.eachOfSeries(content.sources, function (value, file, callbackSource) {
              var url = value.urls[0]; // @TODO retrieve all other contents ?

              self._components.fileImport["import"](url, function (loadingMsg) {
                toolTip(loadingMsg);
              }, /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(error, content, cleanUrl, type, url) {
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          if (!error) {
                            _context.next = 5;
                            break;
                          }

                          toolTip("Cannot retrieve the content of ".concat(url, ": ").concat(error));
                          return _context.abrupt("return", callbackSource("Cannot retrieve the content of ".concat(url, ": ").concat(error)));

                        case 5:
                          _context.prev = 5;
                          _context.next = 8;
                          return self._deps.fileManager.writeFile(type + '/' + cleanUrl, content);

                        case 8:
                          callbackSource();
                          _context.next = 14;
                          break;

                        case 11:
                          _context.prev = 11;
                          _context.t0 = _context["catch"](5);
                          callbackSource(_context.t0.message);

                        case 14:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, null, [[5, 11]]);
                }));

                return function (_x, _x2, _x3, _x4, _x5) {
                  return _ref.apply(this, arguments);
                };
              }());
            }, function (error) {
              if (cb) cb(error);
            });
          } catch (e) {}

          if (cb) cb();
        }
      });
    }
  }, {
    key: "exeCurrent",
    value: function exeCurrent(cb) {
      return this.execute(undefined, cb);
    }
  }, {
    key: "execute",
    value: function execute(file, cb) {
      var self = this;

      function _execute(content, cb) {
        if (!content) {
          toolTip('no content to execute');
          if (cb) cb();
          return;
        }

        self._components.terminal.commands.script(content);
      }

      if (typeof file === 'undefined') {
        var content = self._deps.editor.currentContent();

        _execute(content, cb);

        return;
      }

      var provider = self._deps.fileManager.fileProviderOf(file);

      if (!provider) {
        toolTip("provider for path ".concat(file, " not found"));
        if (cb) cb();
        return;
      }

      provider.get(file, function (error, content) {
        if (error) {
          toolTip(error);
          if (cb) cb();
          return;
        }

        _execute(content, cb);
      });
    }
  }, {
    key: "help",
    value: function help(cb) {
      var self = this;
      var help = yo(_templateObject());

      for (var k in self.commandHelp) {
        help.appendChild(yo(_templateObject2(), k, self.commandHelp[k]));
        help.appendChild(yo(_templateObject3()));
      }

      self._components.terminal.commands.html(help);

      if (cb) cb();
      return '';
    }
  }]);

  return CmdInterpreterAPI;
}();

module.exports = CmdInterpreterAPI;

/***/ }),

/***/ "./lib/commands.js":
/*!*************************!*\
  !*** ./lib/commands.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var allPrograms = [{
  ethers: 'The ethers.js library is a compact and complete JavaScript library for Ethereum.'
}, {
  remix: 'Ethereum IDE and tools for the web.'
}, {
  web3: 'The web3.js library is a collection of modules which contain specific functionality for the ethereum ecosystem.'
}, {
  swarmgw: 'This library can be used to upload/download files to Swarm via https://swarm-gateways.net/.'
}];
var allCommands = [{
  'remix.execute(filepath)': 'Run the script specified by file path. If filepath is empty, script currently displayed in the editor is executed.'
}, {
  'remix.exeCurrent()': 'Run the script currently displayed in the editor.'
}, {
  'remix.help()': 'Display this help message.'
}, {
  'remix.loadgist(id)': 'Load a gist in the file explorer.'
}, {
  'remix.loadurl(url)': 'Load the given url in the file explorer. The url can be of type github, swarm or ipfs.'
}, {
  'swarmgw.get(url, cb)': 'Download files from Swarm via https://swarm-gateways.net/'
}, {
  'swarmgw.put(content, cb)': 'Upload files to Swarm via https://swarm-gateways.net/'
}, {
  'ethers.Contract': 'This API provides a graceful connection to a contract deployed on the blockchain, simplifying calling and querying its functions and handling all the binary protocol and conversion as necessarily.'
}, {
  'ethers.HDNode': 'A Hierarchical Deterministic Wallet represents a large tree of private keys which can reliably be reproduced from an initial seed.'
}, {
  'ethers.Interface': 'The Interface Object is a meta-class that accepts a Solidity (or compatible) Application Binary Interface (ABI) and populates functions to deal with encoding and decoding the parameters to pass in and results returned.'
}, {
  'ethers.providers': 'A Provider abstracts a connection to the Ethereum blockchain, for issuing queries and sending state changing transactions.'
}, {
  'ethers.SigningKey': 'The SigningKey interface provides an abstraction around the secp256k1 elliptic curve cryptography library.'
}, {
  'ethers.utils': 'The utility functions exposed in both the ethers umbrella package and the ethers-utils.'
}, {
  'ethers.utils.AbiCoder': 'Create a new ABI Coder object'
}, {
  'ethers.utils.RLP': 'This encoding method is used internally for several aspects of Ethereum, such as encoding transactions and determining contract addresses.'
}, {
  'ethers.Wallet': 'A wallet manages a private/public key pair which is used to cryptographically sign transactions and prove ownership on the Ethereum network.'
}, {
  'ethers.version': 'Contains the version of the ethers container object.'
}, {
  'web3.eth': 'Eth module for interacting with the Ethereum network.'
}, {
  'web3.eth.accounts': 'The web3.eth.accounts contains functions to generate Ethereum accounts and sign transactions and data.'
}, {
  'web3.eth.abi': 'The web3.eth.abi functions let you de- and encode parameters to ABI (Application Binary Interface) for function calls to the EVM (Ethereum Virtual Machine).'
}, {
  'web3.eth.ens': 'The web3.eth.ens functions let you interacting with ENS.'
}, {
  'web3.eth.Iban': 'The web3.eth.Iban function lets convert Ethereum addresses from and to IBAN and BBAN.'
}, {
  'web3.eth.net': 'Net module for interacting with network properties.'
}, {
  'web3.eth.personal': 'Personal module for interacting with the Ethereum accounts.'
}, {
  'web3.eth.subscribe': 'The web3.eth.subscribe function lets you subscribe to specific events in the blockchain.'
}, {
  'web3.givenProvider': 'When using web3.js in an Ethereum compatible browser, it will set with the current native provider by that browser. Will return the given provider by the (browser) environment, otherwise null.'
}, {
  'web3.modules': 'Contains the version of the web3 container object.'
}, {
  'web3.providers': 'Contains the current available providers.'
}, {
  'web3.shh': 'Shh module for interacting with the whisper protocol'
}, {
  'web3.utils': 'This package provides utility functions for Ethereum dapps and other web3.js packages.'
}, {
  'web3.version': 'Contains the version of the web3 container object.'
}, {
  'web3.eth.clearSubscriptions();': 'Resets subscriptions.'
}, {
  'web3.eth.Contract(jsonInterface[, address][, options])': 'The web3.eth.Contract object makes it easy to interact with smart contracts on the ethereum blockchain.'
}, {
  'web3.eth.accounts.create([entropy]);': 'The web3.eth.accounts contains functions to generate Ethereum accounts and sign transactions and data.'
}, {
  'web3.eth.getAccounts();': 'Retrieve the list of accounts'
}, {
  'web3.eth.accounts.privateKeyToAccount(privateKey [, ignoreLength ]);': 'Get the account from the private key'
}, {
  'web3.eth.accounts.signTransaction(tx, privateKey [, callback]);': 'Sign Transaction'
}, {
  'web3.eth.accounts.recoverTransaction(rawTransaction);': 'Sign Transaction'
}, {
  'web3.eth.accounts.hashMessage(message);': 'Hash message'
}];
module.exports = {
  allPrograms: allPrograms,
  allCommands: allCommands
};

/***/ }),

/***/ "./lib/events.js":
/*!***********************!*\
  !*** ./lib/events.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

var EventManager = remixLib.EventManager;
module.exports = EventManager;

/***/ }),

/***/ "./lib/gist-handler.js":
/*!*****************************!*\
  !*** ./lib/gist-handler.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var modalDialogCustom = __webpack_require__(/*! ../app/ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var request = __webpack_require__(/*! request */ "../../../node_modules/request/index.js"); // Allowing window to be overriden for testing


function GistHandler(_window) {
  var _this = this;

  if (_window !== undefined) {
    modalDialogCustom = _window;
  }

  this.handleLoad = function (params, cb) {
    if (!cb) cb = function cb() {};
    var loadingFromGist = false;
    var gistId;

    if (params.gist === '') {
      loadingFromGist = true;
      modalDialogCustom.prompt('Load a Gist', 'Enter the ID of the Gist or URL you would like to load.', null, function (target) {
        if (target !== '') {
          gistId = getGistId(target);

          if (gistId) {
            cb(gistId);
          } else {
            modalDialogCustom.alert('Error while loading gist. Please provide a valid Gist ID or URL.');
          }
        }
      });
      return loadingFromGist;
    } else {
      gistId = params.gist;
      loadingFromGist = !!gistId;
    }

    if (loadingFromGist) {
      cb(gistId);
    }

    return loadingFromGist;
  };

  function getGistId(str) {
    var idr = /[0-9A-Fa-f]{8,}/;
    var match = idr.exec(str);
    return match ? match[0] : null;
  }

  this.loadFromGist = function (params, fileManager) {
    var gistProvider = fileManager.fileProviderOf('browser');
    var self = _this;
    return self.handleLoad(params, function (gistId) {
      request.get({
        url: "https://api.github.com/gists/".concat(gistId),
        json: true
      }, function (error, response) {
        var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        if (error || !data.files) {
          modalDialogCustom.alert("Gist load error: ".concat(error || data.message));
          return;
        }

        var obj = {};
        Object.keys(data.files).forEach(function (element) {
          obj['/gists/' + gistId + '/' + element] = data.files[element];
        });
        fileManager.setBatchFiles(obj, 'browser', true, function (errorLoadingFile) {
          if (!errorLoadingFile) {
            gistProvider.id = gistId;
            gistProvider.origGistFiles = data.files;
          }
        });
      });
    });
  };
}

module.exports = GistHandler;

/***/ }),

/***/ "./lib/helper.js":
/*!***********************!*\
  !*** ./lib/helper.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

var ethJSUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

module.exports = {
  shortenAddress: function shortenAddress(address, etherBalance) {
    var len = address.length;
    return address.slice(0, 5) + '...' + address.slice(len - 5, len) + (etherBalance ? ' (' + etherBalance.toString() + ' ether)' : '');
  },
  addressToString: function addressToString(address) {
    if (!address) return null;

    if (typeof address !== 'string') {
      address = address.toString('hex');
    }

    if (address.indexOf('0x') === -1) {
      address = '0x' + address;
    }

    return ethJSUtil.toChecksumAddress(address);
  },
  shortenHexData: function shortenHexData(data) {
    if (!data) return '';
    if (data.length < 5) return data;
    var len = data.length;
    return data.slice(0, 5) + '...' + data.slice(len - 5, len);
  },
  createNonClashingNameWithPrefix: function createNonClashingNameWithPrefix(name, fileProvider, prefix, cb) {
    if (!name) name = 'Undefined';
    var counter = '';
    var ext = 'sol';
    var reg = /(.*)\.([^.]+)/g;
    var split = reg.exec(name);

    if (split) {
      name = split[1];
      ext = split[2];
    }

    var exist = true;
    async.whilst(function () {
      return exist;
    }, function (callback) {
      fileProvider.exists(name + counter + prefix + '.' + ext, function (error, currentExist) {
        if (error) {
          callback(error);
        } else {
          exist = currentExist;
          if (exist) counter = (counter | 0) + 1;
          callback();
        }
      });
    }, function (error) {
      cb(error, name + counter + prefix + '.' + ext);
    });
  },
  createNonClashingName: function createNonClashingName(name, fileProvider, cb) {
    this.createNonClashingNameWithPrefix(name, fileProvider, '', cb);
  },
  checkSpecialChars: function checkSpecialChars(name) {
    return name.match(/[:*?"<>\\'|]/) != null;
  },
  isHexadecimal: function isHexadecimal(value) {
    return /^[0-9a-fA-F]+$/.test(value) && value.length % 2 === 0;
  },
  is0XPrefixed: function is0XPrefixed(value) {
    return value.substr(0, 2) === '0x';
  },
  isNumeric: function isNumeric(value) {
    return /^\+?(0|[1-9]\d*)$/.test(value);
  },
  isValidHash: function isValidHash(hash) {
    // 0x prefixed, hexadecimal, 64digit
    var hexValue = hash.slice(2, hash.length);
    return this.is0XPrefixed(hash) && /^[0-9a-fA-F]{64}$/.test(hexValue);
  },
  find: find
};

function findDeep(object, fn) {
  var found = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    "break": false,
    value: undefined
  };
  if (_typeof(object) !== 'object' || object === null) return;

  for (var i in object) {
    if (found["break"]) break;
    var el = object[i];
    if (el && el.innerText !== undefined && el.innerText !== null) el = el.innerText;

    if (fn(el, i, object)) {
      found.value = el;
      found["break"] = true;
      break;
    } else {
      findDeep(el, fn, found);
    }
  }

  return found.value;
}

function find(args, query) {
  query = query.trim();
  var isMatch = !!findDeep(args, function check(value, key) {
    if (value === undefined || value === null) return false;
    if (typeof value === 'function') return false;
    if (_typeof(value) === 'object') return false;
    var contains = String(value).indexOf(query.trim()) !== -1;
    return contains;
  });
  return isMatch;
}

/***/ }),

/***/ "./lib/offsetToLineColumnConverter.js":
/*!********************************************!*\
  !*** ./lib/offsetToLineColumnConverter.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OffsetToLineColumnConverter = void 0;

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../package.json */ "../../../package.json"));

var _remixDebug = __webpack_require__(/*! @remix-project/remix-debug */ "../../../dist/libs/remix-debug/src/index.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var profile = {
  name: 'offsetToLineColumnConverter',
  methods: ['offsetToLineColumn'],
  events: [],
  version: packageJson.version
};

var OffsetToLineColumnConverter = /*#__PURE__*/function (_Plugin) {
  _inherits(OffsetToLineColumnConverter, _Plugin);

  var _super = _createSuper(OffsetToLineColumnConverter);

  function OffsetToLineColumnConverter() {
    var _this;

    _classCallCheck(this, OffsetToLineColumnConverter);

    _this = _super.call(this, profile);
    _this.lineBreakPositionsByContent = {};
    _this.sourceMappingDecoder = _remixDebug.sourceMappingDecoder;
    return _this;
  }
  /**
   * Convert offset representation with line/column representation.
   * This is also used to resolve the content:
   * @arg file is the index of the file in the content sources array and content sources array does have filename as key and not index.
   * So we use the asts (which references both index and filename) to look up the actual content targeted by the @arg file index.
   * @param {{start, length}} rawLocation - offset location
   * @param {number} file - The index where to find the source in the sources parameters
   * @param {Object.<string, {content}>} sources - Map of content sources
   * @param {Object.<string, {ast, id}>} asts - Map of content sources
   */


  _createClass(OffsetToLineColumnConverter, [{
    key: "offsetToLineColumn",
    value: function offsetToLineColumn(rawLocation, file, sources, asts) {
      if (!this.lineBreakPositionsByContent[file]) {
        var sourcesArray = Object.keys(sources);

        if (!asts || file === 0 && sourcesArray.length === 1) {
          // if we don't have ast, we process the only one available content (applicable also for compiler older than 0.4.12)
          this.lineBreakPositionsByContent[file] = this.sourceMappingDecoder.getLinebreakPositions(sources[sourcesArray[0]].content);
        } else {
          for (var filename in asts) {
            var source = asts[filename];

            if (source.id === file) {
              this.lineBreakPositionsByContent[file] = this.sourceMappingDecoder.getLinebreakPositions(sources[filename].content);
              break;
            }
          }
        }
      }

      return this.sourceMappingDecoder.convertOffsetToLineColumn(rawLocation, this.lineBreakPositionsByContent[file]);
    }
    /**
     * Convert offset representation with line/column representation.
     * @param {{start, length}} rawLocation - offset location
     * @param {number} file - The index where to find the source in the sources parameters
     * @param {string} content - source
     */

  }, {
    key: "offsetToLineColumnWithContent",
    value: function offsetToLineColumnWithContent(rawLocation, file, content) {
      this.lineBreakPositionsByContent[file] = this.sourceMappingDecoder.getLinebreakPositions(content);
      return this.sourceMappingDecoder.convertOffsetToLineColumn(rawLocation, this.lineBreakPositionsByContent[file]);
    }
    /**
     * Clear the cache
     */

  }, {
    key: "clear",
    value: function clear() {
      this.lineBreakPositionsByContent = {};
    }
    /**
     * called by plugin API
     */

  }, {
    key: "activate",
    value: function activate() {
      var _this2 = this;

      this.on('solidity', 'compilationFinished', function () {
        _this2.clear();
      });
    }
  }]);

  return OffsetToLineColumnConverter;
}(_engine.Plugin);

exports.OffsetToLineColumnConverter = OffsetToLineColumnConverter;

/***/ }),

/***/ "./lib/panels-resize.js":
/*!******************************!*\
  !*** ./lib/panels-resize.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<div onmousedown=", " class=", "></div>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<div class=", "></div>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .dragbar            {\n    width             : 2px;\n    height            : 100%;\n    cursor            : col-resize;\n    z-index           : 999;\n  }\n  .ghostbar           {\n    width             : 3px;\n    background-color  : var(--primary);\n    opacity           : 0.5;\n    position          : absolute;\n    cursor            : col-resize;\n    z-index           : 9999;\n    top               : 0;\n    bottom            : 0;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());

var PanelsResize = /*#__PURE__*/function () {
  function PanelsResize(panel) {
    _classCallCheck(this, PanelsResize);

    this.panel = panel;
    var string = panel.style.minWidth;
    this.minWidth = string.length > 2 ? parseInt(string.substring(0, string.length - 2)) : 0;
  }

  _createClass(PanelsResize, [{
    key: "render",
    value: function render() {
      var _this = this;

      this.ghostbar = yo(_templateObject2(), css.ghostbar);

      var mousedown = function mousedown(event) {
        event.preventDefault();

        if (event.which === 1) {
          moveGhostbar(event);
          document.body.appendChild(_this.ghostbar);
          document.addEventListener('mousemove', moveGhostbar);
          document.addEventListener('mouseup', removeGhostbar);
          document.addEventListener('keydown', cancelGhostbar);
        }
      };

      var cancelGhostbar = function cancelGhostbar(event) {
        if (event.keyCode === 27) {
          document.body.removeChild(_this.ghostbar);
          document.removeEventListener('mousemove', moveGhostbar);
          document.removeEventListener('mouseup', removeGhostbar);
          document.removeEventListener('keydown', cancelGhostbar);
        }
      };

      var moveGhostbar = function moveGhostbar(event) {
        _this.ghostbar.style.left = event.x + 'px';
      };

      var removeGhostbar = function removeGhostbar(event) {
        document.body.removeChild(_this.ghostbar);
        document.removeEventListener('mousemove', moveGhostbar);
        document.removeEventListener('mouseup', removeGhostbar);
        document.removeEventListener('keydown', cancelGhostbar);

        _this.setPosition(event);
      };

      return yo(_templateObject3(), mousedown, css.dragbar);
    }
  }, {
    key: "calculatePanelWidth",
    value: function calculatePanelWidth(event) {
      return event.x - this.panel.offsetLeft;
    }
  }, {
    key: "setPosition",
    value: function setPosition(event) {
      var panelWidth = this.calculatePanelWidth(event); // close the panel if the width is less than a minWidth

      if (panelWidth > this.minWidth - 10 || this.panel.style.display === 'none') {
        this.panel.style.width = panelWidth + 'px';
        this.showPanel();
      } else this.hidePanel();
    }
  }, {
    key: "hidePanel",
    value: function hidePanel() {
      this.panel.style.display = 'none';
    }
  }, {
    key: "showPanel",
    value: function showPanel() {
      this.panel.style.display = 'flex';
    }
  }]);

  return PanelsResize;
}();

exports["default"] = PanelsResize;

/***/ }),

/***/ "./lib/publishOnIpfs.js":
/*!******************************!*\
  !*** ./lib/publishOnIpfs.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

var IpfsClient = __webpack_require__(/*! ipfs-mini */ "../../../node_modules/ipfs-mini/src/index.js");

var ipfsNodes = [new IpfsClient({
  host: 'ipfs.komputing.org',
  port: 443,
  protocol: 'https'
}), new IpfsClient({
  host: 'ipfs.infura.io',
  port: 5001,
  protocol: 'https'
}), new IpfsClient({
  host: '127.0.0.1',
  port: 5001,
  protocol: 'http'
})];

module.exports = function (contract, fileManager, cb, ipfsVerifiedPublishCallBack) {
  // gather list of files to publish
  var sources = [];
  var metadata;

  try {
    metadata = JSON.parse(contract.metadata);
  } catch (e) {
    return cb(e);
  }

  if (metadata === undefined) {
    return cb('No metadata');
  }

  async.eachSeries(Object.keys(metadata.sources), function (fileName, cb) {
    // find hash
    var hash = null;

    try {
      // we try extract the hash defined in the metadata.json
      // in order to check if the hash that we get after publishing is the same as the one located in metadata.json
      // if it's not the same, we throw "hash mismatch between solidity bytecode and uploaded content"
      // if we don't find the hash in the metadata.json, the check is not done.
      //
      // TODO: refactor this with publishOnSwarm
      if (metadata.sources[fileName].urls) {
        metadata.sources[fileName].urls.forEach(function (url) {
          if (url.includes('ipfs')) hash = url.match('dweb:/ipfs/(.+)')[1];
        });
      }
    } catch (e) {
      return cb('Error while extracting the hash from metadata.json');
    }

    fileManager.fileProviderOf(fileName).get(fileName, function (error, content) {
      if (error) {
        console.log(error);
      } else {
        sources.push({
          content: content,
          hash: hash,
          filename: fileName
        });
      }

      cb();
    });
  }, function (error) {
    if (error) {
      cb(error);
    } else {
      // publish the list of sources in order, fail if any failed
      var uploaded = [];
      async.eachSeries(sources, function (item, cb) {
        ipfsVerifiedPublish(item.content, item.hash, function (error, result) {
          try {
            item.hash = result.url.match('dweb:/ipfs/(.+)')[1];
          } catch (e) {
            item.hash = '<Metadata inconsistency> - ' + item.fileName;
          }

          if (!error && ipfsVerifiedPublishCallBack) ipfsVerifiedPublishCallBack(item);
          item.output = result;
          uploaded.push(item);
          cb(error);
        });
      }, function () {
        var metadataContent = JSON.stringify(metadata);
        ipfsVerifiedPublish(metadataContent, '', function (error, result) {
          try {
            contract.metadataHash = result.url.match('dweb:/ipfs/(.+)')[1];
          } catch (e) {
            contract.metadataHash = '<Metadata inconsistency> - metadata.json';
          }

          if (!error && ipfsVerifiedPublishCallBack) {
            ipfsVerifiedPublishCallBack({
              content: metadataContent,
              hash: contract.metadataHash
            });
          }

          uploaded.push({
            content: contract.metadata,
            hash: contract.metadataHash,
            filename: 'metadata.json',
            output: result
          });
          cb(error, uploaded);
        });
      });
    }
  });
};

function ipfsVerifiedPublish(_x, _x2, _x3) {
  return _ipfsVerifiedPublish.apply(this, arguments);
}

function _ipfsVerifiedPublish() {
  _ipfsVerifiedPublish = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(content, expectedHash, cb) {
    var results;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return severalGatewaysPush(content);

          case 3:
            results = _context.sent;

            if (expectedHash && results !== expectedHash) {
              cb(null, {
                message: 'hash mismatch between solidity bytecode and uploaded content.',
                url: 'dweb:/ipfs/' + results,
                hash: results
              });
            } else {
              cb(null, {
                message: 'ok',
                url: 'dweb:/ipfs/' + results,
                hash: results
              });
            }

            _context.next = 10;
            break;

          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](0);
            cb(_context.t0);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 7]]);
  }));
  return _ipfsVerifiedPublish.apply(this, arguments);
}

function severalGatewaysPush(content) {
  var invert = function invert(p) {
    return new Promise(function (resolve, reject) {
      return p.then(reject)["catch"](resolve);
    });
  }; // Invert res and rej


  var promises = ipfsNodes.map(function (node) {
    return invert(node.add(content));
  });
  return invert(Promise.all(promises));
}

/***/ }),

/***/ "./lib/publishOnSwarm.js":
/*!*******************************!*\
  !*** ./lib/publishOnSwarm.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

var swarmgw = __webpack_require__(/*! swarmgw */ "../../../node_modules/swarmgw/index.js")();

module.exports = function (contract, fileManager, cb, swarmVerifiedPublishCallBack) {
  // gather list of files to publish
  var sources = [];
  var metadata;

  try {
    metadata = JSON.parse(contract.metadata);
  } catch (e) {
    return cb(e);
  }

  if (metadata === undefined) {
    return cb('No metadata');
  }

  async.eachSeries(Object.keys(metadata.sources), function (fileName, cb) {
    // find hash
    var hash = null;

    try {
      // we try extract the hash defined in the metadata.json
      // in order to check if the hash that we get after publishing is the same as the one located in metadata.json
      // if it's not the same, we throw "hash mismatch between solidity bytecode and uploaded content"
      // if we don't find the hash in the metadata.json, the check is not done.
      //
      // TODO: refactor this with publishOnIpfs
      if (metadata.sources[fileName].urls) {
        metadata.sources[fileName].urls.forEach(function (url) {
          if (url.includes('bzz')) hash = url.match('(bzzr|bzz-raw)://(.+)')[1];
        });
      }
    } catch (e) {
      return cb('Error while extracting the hash from metadata.json');
    }

    fileManager.fileProviderOf(fileName).get(fileName, function (error, content) {
      if (error) {
        console.log(error);
      } else {
        sources.push({
          content: content,
          hash: hash,
          filename: fileName
        });
      }

      cb();
    });
  }, function (error) {
    if (error) {
      cb(error);
    } else {
      // publish the list of sources in order, fail if any failed
      var uploaded = [];
      async.eachSeries(sources, function (item, cb) {
        swarmVerifiedPublish(item.content, item.hash, function (error, result) {
          try {
            item.hash = result.url.match('bzz-raw://(.+)')[1];
          } catch (e) {
            item.hash = '<Metadata inconsistency> - ' + item.fileName;
          }

          if (!error && swarmVerifiedPublishCallBack) swarmVerifiedPublishCallBack(item);
          item.output = result;
          uploaded.push(item); // TODO this is a fix cause Solidity metadata does not contain the right swarm hash (poc 0.3)

          metadata.sources[item.filename].urls[0] = result.url;
          cb(error);
        });
      }, function () {
        var metadataContent = JSON.stringify(metadata);
        swarmVerifiedPublish(metadataContent, '', function (error, result) {
          try {
            contract.metadataHash = result.url.match('bzz-raw://(.+)')[1];
          } catch (e) {
            contract.metadataHash = '<Metadata inconsistency> - metadata.json';
          }

          if (!error && swarmVerifiedPublishCallBack) {
            swarmVerifiedPublishCallBack({
              content: metadataContent,
              hash: contract.metadataHash
            });
          }

          uploaded.push({
            content: contract.metadata,
            hash: contract.metadataHash,
            filename: 'metadata.json',
            output: result
          });
          cb(error, uploaded);
        });
      });
    }
  });
};

function swarmVerifiedPublish(content, expectedHash, cb) {
  swarmgw.put(content, function (err, ret) {
    if (err) {
      cb(err);
    } else if (expectedHash && ret !== expectedHash) {
      cb(null, {
        message: 'hash mismatch between solidity bytecode and uploaded content.',
        url: 'bzz-raw://' + ret,
        hash: ret
      });
    } else {
      cb(null, {
        message: 'ok',
        url: 'bzz-raw://' + ret,
        hash: ret
      });
    }
  });
}

/***/ }),

/***/ "./lib/query-params.js":
/*!*****************************!*\
  !*** ./lib/query-params.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Allowing window to be overriden for testing

function QueryParams(_window) {
  if (_window === undefined) _window = window;

  this.get = function () {
    var qs = _window.location.hash.substr(1);

    if (_window.location.search.length > 0) {
      // use legacy query params instead of hash
      _window.location.hash = _window.location.search.substr(1);
      _window.location.search = '';
    }

    var params = {};
    var parts = qs.split('&');

    for (var x in parts) {
      var keyValue = parts[x].split('=');

      if (keyValue[0] !== '') {
        params[keyValue[0]] = keyValue[1];
      }
    }

    return params;
  };

  this.update = function (params) {
    var currentParams = this.get();
    var keys = Object.keys(params);

    for (var x in keys) {
      currentParams[keys[x]] = params[keys[x]];
    }

    var queryString = '#';
    var updatedKeys = Object.keys(currentParams);

    for (var y in updatedKeys) {
      queryString += updatedKeys[y] + '=' + currentParams[updatedKeys[y]] + '&';
    }

    _window.location.hash = queryString.slice(0, -1);
  };
}

module.exports = QueryParams;

/***/ }),

/***/ "./lib/remixBleach.js":
/*!****************************!*\
  !*** ./lib/remixBleach.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var he = _interopRequireWildcard(__webpack_require__(/*! he */ "../../../node_modules/he/he.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * remixBleach
 * a minimal html sanitizer
 * credits to cam@onswipe.com
 */
var remixBleach = {
  matcher: /<\/?([a-zA-Z0-9]+)*(.*?)\/?>/igm,
  whitelist: ['a', 'b', 'p', 'em', 'strong'],
  analyze: function analyze(html) {
    html = String(html) || '';
    var matches = [];
    var match; // extract all tags

    var _loop = function _loop() {
      var attrr = match[2].split(' ');
      var attrs = []; // extract attributes from the tag

      attrr.shift();
      attrr.forEach(function (attr) {
        attr = attr.split('=');
        var attrName = attr[0];
        var attrValue = attr.length > 1 ? attr.slice(1).join('=') : null; // remove quotes from attributes

        if (attrValue && attrValue.charAt(0).match(/'|"/)) attrValue = attrValue.slice(1);
        if (attrValue && attrValue.charAt(attrValue.length - 1).match(/'|"/)) attrValue = attrValue.slice(0, -1);
        attr = {
          name: attrName,
          value: attrValue
        };
        if (!attr.value) delete attr.value;
        if (attr.name) attrs.push(attr);
      });
      tag = {
        full: match[0],
        name: match[1],
        attr: attrs
      };
      matches.push(tag);
    };

    while ((match = remixBleach.matcher.exec(html)) != null) {
      var tag;

      _loop();
    }

    return matches;
  },
  sanitize: function sanitize(html, options) {
    html = String(html) || '';
    options = options || {};
    var mode = options.mode || 'white';
    var list = options.list || remixBleach.whitelist;
    var matches = remixBleach.analyze(html);

    if (mode === 'white' && list.indexOf('script') === -1 || mode === 'black' && list.indexOf('script') !== -1) {
      html = html.replace(/<script(.*?)>(.*?[\r\n])*?(.*?)(.*?[\r\n])*?<\/script>/gim, '');
    }

    if (mode === 'white' && list.indexOf('style') === -1 || mode === 'black' && list.indexOf('style') !== -1) {
      html = html.replace(/<style(.*?)>(.*?[\r\n])*?(.*?)(.*?[\r\n])*?<\/style>/gim, '');
    }

    matches.forEach(function (tag) {
      if (mode === 'white') {
        if (list.indexOf(tag.name) === -1) {
          html = html.replace(tag.full, '');
        }
      } else if (mode === 'black') {
        if (list.indexOf(tag.name) !== -1) {
          html = html.replace(tag.full, '');
        }
      } else {
        throw new Error('Unknown sanitization mode "' + mode + '"');
      }
    });
    if (options.encode_entities) html = he.encode(html);
    return html;
  }
};
module.exports = remixBleach;

/***/ }),

/***/ "./loadFilesFromParent.js":
/*!********************************!*\
  !*** ./loadFilesFromParent.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function (fileManager) {
  // The event listener needs to be registered as early as possible, because the
  // parent will send the message upon the "load" event.
  var filesToLoad = null;

  var loadFilesCallback = function loadFilesCallback(files) {
    filesToLoad = files;
  }; // will be replaced later


  window.addEventListener('message', function (ev) {
    if (_typeof(ev.data) === _typeof([]) && ev.data[0] === 'loadFiles') {
      loadFilesCallback(ev.data[1]);
    }
  }, false); // Replace early callback with instant response

  loadFilesCallback = function loadFilesCallback(files) {
    fileManager.setBatchFiles(files);
  }; // Run if we did receive an event from remote instance while starting up


  if (filesToLoad !== null) {
    fileManager.setBatchFiles(filesToLoad);
  }
};

/***/ }),

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./index */ "./index.js");

/***/ }),

/***/ "./migrateFileSystem.js":
/*!******************************!*\
  !*** ./migrateFileSystem.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/src/index.js");

/*
  Migrating the files to the BrowserFS storage instead or raw localstorage
*/
var _default = function _default(fileProvider) {
  var fileStorage = new _remixLib.Storage('sol:');
  var flag = 'status';
  var fileStorageBrowserFS = new _remixLib.Storage('remix_browserFS_migration:');
  if (fileStorageBrowserFS.get(flag) === 'done') return;
  fileStorage.keys().forEach(function (path) {
    if (path !== '.remix.config') {
      var content = fileStorage.get(path);
      fileProvider.set(path, content); // TODO https://github.com/ethereum/remix-ide/issues/2377
      // fileStorage.remove(path) we don't want to remove it as we are still supporting the old version

      console.log('file migrated', path);
    }
  });
  fileStorageBrowserFS.set(flag, 'done');
};

exports["default"] = _default;

/***/ }),

/***/ "./publishToStorage.js":
/*!*****************************!*\
  !*** ./publishToStorage.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = publish;

function _templateObject7() {
  var data = _taggedTemplateLiteral(["<span>Metadata of \"", "\" was published successfully.<br> <pre>", "</pre> </span>"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["<div><b>", "</b> : <pre>", "</pre></div>"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["<div>", "</div>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<span>Failed to publish metadata file to ", ", please check the ", " gateways is available.<br />\n            ", "</span>"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<span>Metadata of \"", "\" was published successfully.<br> <pre>", "</pre> </span>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<div><b>", "</b> : <pre>", "</pre></div>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["<div>", "</div>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var publishOnSwarm = __webpack_require__(/*! ./lib/publishOnSwarm */ "./lib/publishOnSwarm.js");

var publishOnIpfs = __webpack_require__(/*! ./lib/publishOnIpfs */ "./lib/publishOnIpfs.js");

var modalDialogCustom = __webpack_require__(/*! ./app/ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

function publish(storage, fileProvider, fileManager, contract) {
  if (contract) {
    if (contract.metadata === undefined || contract.metadata.length === 0) {
      modalDialogCustom.alert('This contract may be abstract, may not implement an abstract parent\'s methods completely or not invoke an inherited contract\'s constructor correctly.');
    } else {
      if (storage === 'swarm') {
        publishOnSwarm(contract, fileManager, function (err, uploaded) {
          if (err) {
            try {
              err = JSON.stringify(err);
            } catch (e) {}

            console.log("Failed to publish metadata file to swarm, please check the Swarm gateways is available ( swarm-gateways.net ) ".concat(err));
          } else {
            var result = yo(_templateObject(), uploaded.map(function (value) {
              return yo(_templateObject2(), value.filename, value.output.url);
            }));
            modalDialogCustom.alert("Published ".concat(contract.name, "'s Metadata"), yo(_templateObject3(), contract.name.toLowerCase(), result));
          }
        }, function (item) {
          // triggered each time there's a new verified publish (means hash correspond)
          fileProvider.addExternal('swarm/' + item.hash, item.content);
        });
      } else {
        publishOnIpfs(contract, fileManager, function (err, uploaded) {
          if (err) {
            try {
              err = JSON.stringify(err);
            } catch (e) {}

            modalDialogCustom.alert(yo(_templateObject4(), storage, storage, err));
          } else {
            var result = yo(_templateObject5(), uploaded.map(function (value) {
              return yo(_templateObject6(), value.filename, value.output.url);
            }));
            modalDialogCustom.alert("Published ".concat(contract.name, "'s Metadata"), yo(_templateObject7(), contract.name.toLowerCase(), result));
          }
        }, function (item) {
          // triggered each time there's a new verified publish (means hash correspond)
          fileProvider.addExternal('ipfs/' + item.hash, item.content);
        });
      }
    }
  }
}

/***/ }),

/***/ "./registry.js":
/*!*********************!*\
  !*** ./registry.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// const moduleID = require('./module-id.js')
module.exports = /*#__PURE__*/function () {
  function registry() {
    _classCallCheck(this, registry);

    this.state = {};
  }

  _createClass(registry, [{
    key: "put",
    value: function put(_ref) {
      var api = _ref.api,
          name = _ref.name;
      // const serveruid = moduleID() + '.' + (name || '')
      if (this.state[name]) return this.state[name];
      var server = {
        // uid: serveruid,
        api: api
      };
      this.state[name] = {
        server: server
      };
      return server;
    }
  }, {
    key: "get",
    value: function get(name) {
      // const clientuid = moduleID()
      var state = this.state[name];
      if (!state) return;
      var server = state.server;
      return server;
    }
  }]);

  return registry;
}();

/***/ }),

/***/ "./remixAppManager.js":
/*!****************************!*\
  !*** ./remixAppManager.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNative = isNative;
exports.canActivate = canActivate;
exports.RemixAppManager = void 0;

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var _engineWeb = __webpack_require__(/*! @remixproject/engine-web */ "../../../node_modules/@remixproject/engine-web/index.js");

var _events = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

var _queryParams = _interopRequireDefault(__webpack_require__(/*! ./lib/query-params */ "./lib/query-params.js"));

var _persmissionHandler = __webpack_require__(/*! ./app/ui/persmission-handler */ "./app/ui/persmission-handler.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var requiredModules = [// services + layout views + system views
'manager', 'compilerArtefacts', 'compilerMetadata', 'contextualListener', 'editor', 'offsetToLineColumnConverter', 'network', 'theme', 'fileManager', 'contentImport', 'web3Provider', 'scriptRunner', 'fetchAndCompile', 'mainPanel', 'hiddenPanel', 'sidePanel', 'menuicons', 'fileExplorers', 'terminal', 'settings', 'pluginManager', 'tabs', 'udapp'];

function isNative(name) {
  var nativePlugins = ['vyper', 'workshops', 'debugger', 'remixd', 'menuicons'];
  return nativePlugins.includes(name) || requiredModules.includes(name);
}
/**
 * Checks if plugin caller 'from' is allowed to activate plugin 'to'
 * The caller can have 'canActivate' as a optional property in the plugin profile.
 * This is an array containing the 'name' property of the plugin it wants to call.
 * canActivate = ['plugin1-to-call','plugin2-to-call',....]
 * or the plugin is allowed by default because it is native
 *
 * @param {any, any}
 * @returns {boolean}
 */


function canActivate(from, to) {
  return ['ethdoc'].includes(from.name) || isNative(from.name) || to && from && from.canActivate && from.canActivate.includes[to.name];
}

var RemixAppManager = /*#__PURE__*/function (_PluginManager) {
  _inherits(RemixAppManager, _PluginManager);

  var _super = _createSuper(RemixAppManager);

  function RemixAppManager() {
    var _this;

    _classCallCheck(this, RemixAppManager);

    _this = _super.call(this);
    _this.event = new _events.EventEmitter();
    _this.pluginsDirectory = 'https://raw.githubusercontent.com/ethereum/remix-plugins-directory/master/build/metadata.json';
    _this.pluginLoader = new PluginLoader();
    _this.permissionHandler = new _persmissionHandler.PermissionHandler();
    return _this;
  }

  _createClass(RemixAppManager, [{
    key: "canActivatePlugin",
    value: function () {
      var _canActivatePlugin = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(from, to) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", canActivate(from, to));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function canActivatePlugin(_x, _x2) {
        return _canActivatePlugin.apply(this, arguments);
      }

      return canActivatePlugin;
    }()
  }, {
    key: "canDeactivatePlugin",
    value: function () {
      var _canDeactivatePlugin = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(from, to) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!requiredModules.includes(to.name)) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return", false);

              case 2:
                return _context2.abrupt("return", isNative(from.name));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function canDeactivatePlugin(_x3, _x4) {
        return _canDeactivatePlugin.apply(this, arguments);
      }

      return canDeactivatePlugin;
    }()
  }, {
    key: "canCall",
    value: function () {
      var _canCall = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(from, to, method, message) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(to !== this.currentRequest.from)) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return", false);

              case 2:
                if (!isNative(from)) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return", true);

              case 4:
                _context3.next = 6;
                return this.permissionHandler.askPermission(this.profiles[from], this.profiles[to], method, message);

              case 6:
                return _context3.abrupt("return", _context3.sent);

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function canCall(_x5, _x6, _x7, _x8) {
        return _canCall.apply(this, arguments);
      }

      return canCall;
    }()
  }, {
    key: "onPluginActivated",
    value: function onPluginActivated(plugin) {
      this.pluginLoader.set(plugin, this.actives);
      this.event.emit('activate', plugin);
    }
  }, {
    key: "getAll",
    value: function getAll() {
      var _this2 = this;

      return Object.keys(this.profiles).map(function (p) {
        return _this2.profiles[p];
      });
    }
  }, {
    key: "getIds",
    value: function getIds() {
      return Object.keys(this.profiles);
    }
  }, {
    key: "onPluginDeactivated",
    value: function onPluginDeactivated(plugin) {
      this.pluginLoader.set(plugin, this.actives);
      this.event.emit('deactivate', plugin);
    }
  }, {
    key: "isRequired",
    value: function isRequired(name) {
      // excluding internal use plugins
      return requiredModules.includes(name);
    }
  }, {
    key: "registeredPlugins",
    value: function () {
      var _registeredPlugins = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var plugins, res, savedPlugins;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                _context4.next = 3;
                return fetch(this.pluginsDirectory);

              case 3:
                res = _context4.sent;
                _context4.next = 6;
                return res.json();

              case 6:
                plugins = _context4.sent;
                localStorage.setItem('plugins-directory', JSON.stringify(plugins));
                _context4.next = 15;
                break;

              case 10:
                _context4.prev = 10;
                _context4.t0 = _context4["catch"](0);
                console.log('getting plugins list from localstorage...');
                savedPlugins = localStorage.getItem('plugins-directory');

                if (savedPlugins) {
                  try {
                    plugins = JSON.parse(savedPlugins);
                  } catch (e) {
                    console.error(e);
                  }
                }

              case 15:
                return _context4.abrupt("return", plugins.map(function (plugin) {
                  return new _engineWeb.IframePlugin(plugin);
                }));

              case 16:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[0, 10]]);
      }));

      function registeredPlugins() {
        return _registeredPlugins.apply(this, arguments);
      }

      return registeredPlugins;
    }()
  }]);

  return RemixAppManager;
}(_engine.PluginManager);
/** @class Reference loaders.
 *  A loader is a get,set based object which load a workspace from a defined sources.
 *  (localStorage, queryParams)
 **/


exports.RemixAppManager = RemixAppManager;

var PluginLoader = /*#__PURE__*/function () {
  _createClass(PluginLoader, [{
    key: "currentLoader",
    get: function get() {
      return this.loaders[this.current];
    }
  }]);

  function PluginLoader() {
    var _this3 = this;

    _classCallCheck(this, PluginLoader);

    var queryParams = new _queryParams["default"]();
    this.donotAutoReload = ['remixd']; // that would be a bad practice to force loading some plugins at page load.

    this.loaders = {};
    this.loaders.localStorage = {
      set: function set(plugin, actives) {
        if (!_this3.donotAutoReload.includes(plugin.name)) {
          localStorage.setItem('workspace', JSON.stringify(actives));
        }
      },
      get: function get() {
        return JSON.parse(localStorage.getItem('workspace'));
      }
    };
    this.loaders.queryParams = {
      set: function set() {},
      get: function get() {
        var _queryParams$get = queryParams.get(),
            activate = _queryParams$get.activate;

        if (!activate) return [];
        return activate.split(',');
      }
    };
    this.current = queryParams.get().activate ? 'queryParams' : 'localStorage';
  }

  _createClass(PluginLoader, [{
    key: "set",
    value: function set(plugin, actives) {
      this.currentLoader.set(plugin, actives);
    }
  }, {
    key: "get",
    value: function get() {
      return this.currentLoader.get();
    }
  }]);

  return PluginLoader;
}();

/***/ }),

/***/ "./remixEngine.js":
/*!************************!*\
  !*** ./remixEngine.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemixEngine = void 0;

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/index.js");

var _events = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var RemixEngine = /*#__PURE__*/function (_Engine) {
  _inherits(RemixEngine, _Engine);

  var _super = _createSuper(RemixEngine);

  function RemixEngine() {
    var _this;

    _classCallCheck(this, RemixEngine);

    _this = _super.call(this);
    _this.event = new _events.EventEmitter();
    return _this;
  }

  _createClass(RemixEngine, [{
    key: "setPluginOption",
    value: function setPluginOption(_ref) {
      var name = _ref.name,
          kind = _ref.kind;
      if (kind === 'provider') return {
        queueTimeout: 60000 * 2
      };
      if (name === 'LearnEth') return {
        queueTimeout: 60000
      };
      return {
        queueTimeout: 10000
      };
    }
  }, {
    key: "onRegistration",
    value: function onRegistration(plugin) {
      this.event.emit('onRegistration', plugin);
    }
  }]);

  return RemixEngine;
}(_engine.Engine);

exports.RemixEngine = RemixEngine;

/***/ }),

/***/ "./universal-dapp-styles.js":
/*!**********************************!*\
  !*** ./universal-dapp-styles.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  .instanceTitleContainer {\n    display: flex;\n    align-items: center;\n  }\n  .calldataInput{\n    height: 32px;\n  }\n  .title {\n    display: flex;\n    justify-content: space-between;\n    font-size: 11px;\n    width: 100%;\n    overflow: hidden;\n    word-break: break-word;\n    line-height: initial;\n    overflow: visible;\n    padding: 0 0 8px;\n    margin: 0;\n    background: none;\n    border: none;\n  }\n  .title button {\n    background: none;\n    border: none;\n  }\n  .titleLine {\n    display: flex;\n    align-items: baseline;\n  }\n  .titleText {\n    word-break: break-word;\n    width: 100%;\n    border: none;\n    overflow: hidden;\n  }\n  .spanTitleText {\n    line-height: 12px;\n    padding: 0;\n    font-size: 11px;\n    width:100%;\n    border: none;\n    background: none;\n    text-transform: uppercase;\n    overflow: hidden;\n  }\n  .inputGroupText {\n    width: 100%;\n  }\n  .title .copy {\n    color: var(--primary);\n  }\n  .titleExpander {\n    padding: 5px 7px;\n  }\n  .nameNbuts {\n    display: contents;\n    flex-wrap: nowrap;\n    width: 100%;\n  }\n  .instance {\n    display: block;\n    flex-direction: column;\n    margin-bottom: 12px;\n    background: none;\n    border-radius: 2px;\n  }\n  .instance.hidesub {\n    border-bottom: 1px solid;\n  }\n  .instance.hidesub .title {\n      display: flex;\n  }\n  .instance.hidesub .udappClose {\n      display: flex;\n  }\n  .instance.hidesub > * {\n    display: none;\n  }\n  .methCaret {\n    min-width: 12px;\n    width: 12px;\n    margin-left: 4px;\n    cursor: pointer;\n    font-size: 16px;\n    line-height: 0.6;\n    vertical-align: middle;\n    padding: 0;\n  }\n  .cActionsWrapper {\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0.25rem;\n    border-top-rightt-radius: 0;\n    border-bottom-right-radius: 0.25rem;\n    padding: 8px 10px 7px;\n  }\n  .group:after {\n    content: \"\";\n    display: table;\n    clear: both;\n  }\n  .buttonsContainer {\n    margin-top: 2%;\n    display: flex;\n    overflow: hidden;\n  }\n  .instanceButton {\n    height: 32px;\n    border-radius: 3px;\n    white-space: nowrap;\n    font-size: 11px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n  .closeIcon {\n    font-size: 12px;\n    cursor: pointer;\n    margin-left: 5px;\n  }\n  .udappClose {\n    display: flex;\n    justify-content: flex-end;\n  }\n  .contractProperty {\n    width:100%;\n  }\n  .contractProperty.hasArgs input {\n    padding: .36em;\n    border-radius: 5px;\n  }\n  .contractProperty .contractActionsContainerSingle input{\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n  .contractProperty button {\n    min-width: 100px;\n    width: 100px;\n    margin:0;\n    word-break: inherit;\n  }\n  .contractProperty button:disabled {\n    cursor: not-allowed;\n    background-color: white;\n    border-color: lightgray;\n  }\n  .contractProperty.constant button {\n    min-width: 100px;\n    width: 100px;\n    margin:0;\n    word-break: inherit;\n    outline: none;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n  .contractProperty > .value {\n    box-sizing: border-box;\n    float: left;\n    align-self: center;\n    margin-left: 4px;\n  }\n  .contractActionsContainer {\n    width: 100%;\n    margin-bottom: 8px;\n  }\n  .contractActionsContainerSingle {\n    display: flex;\n    width: 100%;\n  }\n  .contractActionsContainerSingle i {\n    line-height: 2;\n  }\n  .contractActionsContainerMulti {\n    display:none;\n    width: 100%;\n  }\n  .contractActionsContainerMultiInner {\n    width: 100%;\n    padding: 16px 8px 16px 14px;\n    border-radius: 3px;\n    margin-bottom: 8px;\n  }\n  .multiHeader {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 8px;\n    text-align: left;\n    font-size: 10px;\n    font-weight: bold;\n  }\n  .contractActionsContainerMultiInner .multiTitle {\n    padding-left: 10px;\n  }\n  .contractProperty .multiTitle {\n    padding: 0;\n    line-height: 16px;\n    display: inline-block;\n    font-size: 12px;\n    font-weight: bold;\n    cursor: default;\n  }\n  .contractProperty .contractActionsContainerMultiInner .multiArg label{\n    text-align: right;\n  }\n  .multiHeader .methCaret {\n    float: right;\n    margin-right: 0;\n  }\n  .contractProperty.constant .multiTitle {\n    display: inline-block;\n    width: 90%;\n    /* font-size: 10px; */\n    height: 25px;\n    padding-left: 20px;\n    font-weight: bold;\n    line-height: 25px;\n    cursor: default;\n  }\n  .multiArg {\n    display: flex;\n    align-items: center;\n    justify-content: flex-end;\n    margin-top: 4px;\n  }\n  .multiArg input{\n    padding: 5px;\n  }\n  .multiArg label {\n    width: auto;\n    padding: 0;\n    margin: 0 4px 0 0;\n    font-size: 10px;\n    line-height: 12px;\n    text-align: right;\n    word-break: initial;\n  }\n  .multiArg button {\n    max-width: 100px;\n    border-radius: 3px;\n    border-width: 1px;\n    width: inherit;\n  }\n  .multiHeader button {\n    display: inline-block;\n    width: 94%;\n  }\n  .hasArgs .multiArg input {\n    border-left: 1px solid #dddddd;\n    width: 67%;\n  }\n  .hasArgs input {\n    display: block;\n    height: 32px;\n    border: 1px solid #dddddd;\n    padding: .36em;\n    border-left: none;\n    padding: 8px 8px 8px 10px;\n    font-size: 10px !important;\n  }\n  .hasArgs button {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n    border-right: 0;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    font-size: 11px;\n  }\n  .hasArgs .contractActionsContainerMulti button {\n    border-radius: 3px;\n  }\n  .contractActionsContainerMultiInner .multiArg i {\n    padding-right: 10px;\n  }\n  .hideWarningsContainer {\n    display: flex;\n    align-items: center;\n    margin-left: 2%\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs(_templateObject());
module.exports = css;

/***/ }),

/***/ 0:
/*!***********************!*\
  !*** multi ./main.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /home/circleci/remix-project/apps/remix-ide/src/main.js */"./main.js");


/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 10:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 11:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 12:
/*!*************************************!*\
  !*** decompress-response (ignored) ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 3:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 4:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 5:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 6:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 7:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 8:
/*!*****************************!*\
  !*** ./leveldown (ignored) ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 9:
/*!****************************!*\
  !*** ./nextTick (ignored) ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

},[[0,"runtime","vendor"]]]);
//# sourceMappingURL=main.js.map