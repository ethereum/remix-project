{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e6e0cff5-81af-4ba2-98d0-2931183b0eca",
   "metadata": {},
   "outputs": [],
   "source": [
    "{\n",
    "  \"language\": \"Solidity\",\n",
    "  \"sources\": {\n",
    "    \"dcdollarcoin.sol\": {\n",
    "      \"content\": \"pragma solidity ^0.8.23;\\n\\ncontract dcdollarcoin {\\n    function initializer(\\n        string memory symbol,\\n        address platformReferrer,\\n        address currency,\\n        int24 tickLower\\n    ) public initializer {\\n        // Validate\\n        \\n        // the creation parameters\\n        if (payoutRecipient_ == address(0)) {\\n            revert AddressZero();\\n        }\\n\\n        // Set base contract state\\n        __ERC20_init(name_, symbol_);\\n        __ERC20Permit_init(name_);\\n        __MultiOwnable_init(owners_);\\n        __ReentrancyGuard_init();\\n\\n        // Set mutable state\\n        _setPayoutRecipient(payoutRecipient_);\\n        _setContractURI(tokenURI_);\\n\\n        // Set immutable state\\n        platformReferrer = platformReferrer_ == address(0) ? protocolRewardRecipient : platformReferrer_;\\n        currency = currency_ == address(0) ? WETH : currency_;\\n\\n        // Mint the total supply\\n        _mint(address(this), MAX_TOTAL_SUPPLY);\\n\\n        // Distribute the creator launch reward\\n        _transfer(address(this), payoutRecipient, CREATOR_LAUNCH_REWARD);\\n\\n        // Approve the transfer of the remaining supply to the pool\\n        IERC20(address(this)).safeIncreaseAllowance(address(nonfungiblePositionManager), POOL_LAUNCH_SUPPLY);\\n\\n        // Deploy the pool\\n        _deployPool(tickLower_);\\n    }\\n\\n    /// @notice Executes a buy order\\n    /// @param recipient The recipient address of the coins\\n    /// @param orderSize The amount of coins to buy\\n    /// @param tradeReferrer The address of the trade referrer\\n    /// @param sqrtPriceLimitX96 The price limit for Uniswap V3 pool swap\\n    function buy(\\n        address recipient,\\n        uint256 orderSize,\\n        uint256 minAmountOut,\\n        uint160 sqrtPriceLimitX96,\\n        address tradeReferrer\\n    ) public payable nonReentrant returns (uint256, uint256) {\\n        // Ensure the recipient is not the zero address\\n        if (recipient == address(0)) {\\n            revert AddressZero();\\n        }\\n\\n        // Calculate the trade reward\\n        uint256 tradeReward = _calculateReward(orderSize, TOTAL_FEE_BPS);\\n\\n        // Calculate the remaining size\\n        uint256 trueOrderSize = orderSize - tradeReward;\\n\\n        // Handle incoming currency\\n        _handleIncomingCurrency(orderSize, trueOrderSize);\\n\\n        // Set up the swap parameters\\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\\n            tokenIn: currency,\\n            tokenOut: address(this),\\n            fee: LP_FEE,\\n            recipient: recipient,\\n            amountIn: trueOrderSize,\\n            amountOutMinimum: minAmountOut,\\n            sqrtPriceLimitX96: sqrtPriceLimitX96\\n        });\\n\\n        // Execute the swap\\n        uint256 amountOut = ISwapRouter(swapRouter).exactInputSingle(params);\\n\\n        _handleTradeRewards(tradeReward, tradeReferrer);\\n\\n        _handleMarketRewards();\\n\\n        emit CoinBuy(msg.sender, recipient, tradeReferrer, amountOut, currency, tradeReward, trueOrderSize);\\n\\n        return (orderSize, amountOut);\\n    }\\n\\n    /// @notice Executes a sell order\\n    /// @param recipient The recipient of the currency\\n    /// @param orderSize The amount of coins to sell\\n    /// @param minAmountOut The minimum amount of currency to receive\\n    /// @param sqrtPriceLimitX96 The price limit for the swap\\n    /// @param tradeReferrer The address of the trade referrer\\n    function sell(\\n        address recipient,\\n        uint256 orderSize,\\n        uint256 minAmountOut,\\n        uint160 sqrtPriceLimitX96,\\n        address tradeReferrer\\n    ) public nonReentrant returns (uint256, uint256) {\\n        // Ensure the recipient is not the zero address\\n        if (recipient == address(0)) {\\n            revert AddressZero();\\n        }\\n\\n        // Record the coin balance of this contract before the swap\\n        uint256 beforeCoinBalance = balanceOf(address(this));\\n\\n        // Transfer the coins from the seller to this contract\\n        transfer(address(this), orderSize);\\n\\n        // Approve the Uniswap V3 swap router\\n        this.approve(swapRouter, orderSize);\\n\\n        // Set the swap parameters\\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\\n            tokenIn: address(this),\\n            tokenOut: currency,\\n            fee: LP_FEE,\\n            recipient: address(this),\\n            amountIn: orderSize,\\n            amountOutMinimum: minAmountOut,\\n            sqrtPriceLimitX96: sqrtPriceLimitX96\\n        });\\n\\n        // Execute the swap\\n        uint256 amountOut = ISwapRouter(swapRouter).exactInputSingle(params);\\n\\n        // Record the coin balance of this contract after the swap\\n        uint256 afterCoinBalance = balanceOf(address(this));\\n\\n        // If the swap was partially executed:\\n        if (afterCoinBalance > beforeCoinBalance) {\\n            // Calculate the refund\\n            uint256 coinRefund = afterCoinBalance - beforeCoinBalance;\\n\\n            // Update the order size\\n            orderSize -= coinRefund;\\n\\n            // Transfer the refund back to the seller\\n            _transfer(address(this), recipient, coinRefund);\\n        }\\n\\n        // If currency is WETH, convert to ETH\\n        if (currency == WETH) {\\n            IWETH(WETH).withdraw(amountOut);\\n        }\\n\\n        // Calculate the trade reward\\n        uint256 tradeReward = _calculateReward(amountOut, TOTAL_FEE_BPS);\\n\\n        // Calculate the payout after the fee\\n        uint256 payoutSize = amountOut - tradeReward;\\n\\n        _handlePayout(payoutSize, recipient);\\n\\n        _handleTradeRewards(tradeReward, tradeReferrer);\\n\\n        _handleMarketRewards();\\n\\n        emit CoinSell(msg.sender, recipient, tradeReferrer, orderSize, currency, tradeReward, payoutSize);\\n\\n        return (orderSize, payoutSize);\\n    }\\n\\n    /// @notice Enables a user to burn their tokens\\n    /// @param amount The amount of tokens to burn\\n    function burn(uint256 amount) external {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    /// @notice Force claim any accrued secondary rewards from the market's liquidity position.\\n    /// @param pushEthRewards Whether to push the ETH directly to the recipients.\\n    function claimSecondaryRewards(bool pushEthRewards) external nonReentrant {\\n        MarketRewards memory rewards = _handleMarketRewards();\\n\\n        if (pushEthRewards && rewards.totalAmountCurrency > 0 && currency == WETH) {\\n            IProtocolRewards(protocolRewards).withdrawFor(payoutRecipient, rewards.creatorPayoutAmountCurrency);\\n            IProtocolRewards(protocolRewards).withdrawFor(platformReferrer, rewards.platformReferrerAmountCurrency);\\n            IProtocolRewards(protocolRewards).withdrawFor(protocolRewardRecipient, rewards.protocolAmountCurrency);\\n        }\\n    }\\n\\n    /// @notice Set the creator's payout address\\n    /// @param newPayoutRecipient The new recipient address\\n    function setPayoutRecipient(address newPayoutRecipient) external onlyOwner {\\n        _setPayoutRecipient(newPayoutRecipient);\\n    }\\n\\n    /// @notice Set the contract URI\\n    /// @param newURI The new URI\\n    function setContractURI(string memory newURI) external onlyOwner {\\n        _setContractURI(newURI);\\n    }\\n\\n    /// @notice The contract metadata\\n    function contractURI() external view returns (string memory) {\\n        return tokenURI;\\n    }\\n\\n    /// @notice ERC165 interface support\\n    /// @param interfaceId The interface ID to check\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return\\n            interfaceId == type(ICoin).interfaceId ||\\n            interfaceId == type(ICoinComments).interfaceId ||\\n            interfaceId == type(IERC7572).interfaceId ||\\n            interfaceId == type(IERC165).interfaceId;\\n    }\\n\\n    /// @notice Receives ETH converted from WETH\\n    receive() external payable {\\n        if (msg.sender != WETH) {\\n            revert OnlyWeth();\\n        }\\n    }\\n\\n    /// @dev For receiving the Uniswap V3 LP NFT on market graduation.\\n    function onERC721Received(address, address, uint256, bytes calldata) external view returns (bytes4) {\\n        if (msg.sender != poolAddress) revert OnlyPool();\\n\\n        return this.onERC721Received.selector;\\n    }\\n\\n    /// @dev No-op to allow a swap on the pool to set the correct initial price, if needed\\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata) external {}\\n\\n    /// @dev Overrides ERC20's _update function to\\n    ///      - Prevent transfers to the pool if the market has not graduated.\\n    ///      - Emit the superset `WowTokenTransfer` event with each ERC20 transfer.\\n    function _update(address from, address to, uint256 value) internal virtual override {\\n        super._update(from, to, value);\\n\\n        emit CoinTransfer(from, to, value, balanceOf(from), balanceOf(to));\\n    }\\n\\n    /// @dev Used to set the payout recipient on coin creation and updates\\n    /// @param newPayoutRecipient The new recipient address\\n    function _setPayoutRecipient(address newPayoutRecipient) internal {\\n        if (newPayoutRecipient == address(0)) {\\n            revert AddressZero();\\n        }\\n\\n        emit CoinPayoutRecipientUpdated(msg.sender, payoutRecipient, newPayoutRecipient);\\n\\n        payoutRecipient = newPayoutRecipient;\\n    }\\n\\n    /// @dev Used to set the contract URI on coin creation and updates\\n    /// @param newURI The new URI\\n    function _setContractURI(string memory newURI) internal {\\n        emit ContractMetadataUpdated(msg.sender, newURI, name());\\n        emit ContractURIUpdated();\\n\\n        tokenURI = newURI;\\n    }\\n\\n    /// @dev Deploy the pool\\n    function _deployPool(int24 tickLower_) internal {\\n        // If WETH is the pool's currency, validate the lower tick\\n        if (currency == WETH && tickLower_ < LP_TICK_LOWER_WETH) {\\n            revert InvalidWethLowerTick();\\n        }\\n\\n        // Note: This validation happens on the Uniswap pool already; reverting early here for clarity\\n        // If currency is not WETH: ensure lower tick is less than upper tick and satisfies the 200 tick spacing requirement for 1% Uniswap V3 pools\\n        if (currency != WETH && (tickLower_ >= LP_TICK_UPPER || tickLower_ % 200 != 0)) {\\n            revert InvalidCurrencyLowerTick();\\n        }\\n\\n        // Sort the token addresses\\n        address token0 = address(this) < currency ? address(this) : currency;\\n        address token1 = address(this) < currency ? currency : address(this);\\n\\n        // If the coin is token0\\n        bool isCoinToken0 = token0 == address(this);\\n\\n        // Determine the tick values\\n        int24 tickLower = isCoinToken0 ? tickLower_ : -LP_TICK_UPPER;\\n        int24 tickUpper = isCoinToken0 ? LP_TICK_UPPER : -tickLower_;\\n\\n        // Calculate the starting price for the pool\\n        uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(isCoinToken0 ? tickLower : tickUpper);\\n\\n        // Determine the initial liquidity amounts\\n        uint256 amount0 = isCoinToken0 ? POOL_LAUNCH_SUPPLY : 0;\\n        uint256 amount1 = isCoinToken0 ? 0 : POOL_LAUNCH_SUPPLY;\\n\\n        // Create and initialize the pool\\n        poolAddress = INonfungiblePositionManager(nonfungiblePositionManager).createAndInitializePoolIfNecessary(token0, token1, LP_FEE, sqrtPriceX96);\\n\\n        // Construct the LP data\\n        INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager.MintParams({\\n            token0: token0,\\n            token1: token1,\\n            fee: LP_FEE,\\n            tickLower: tickLower,\\n            tickUpper: tickUpper,\\n            amount0Desired: amount0,\\n            amount1Desired: amount1,\\n            amount0Min: 0,\\n            amount1Min: 0,\\n            recipient: address(this),\\n            deadline: block.timestamp\\n        });\\n\\n        // Mint the LP\\n        (lpTokenId, , , ) = INonfungiblePositionManager(nonfungiblePositionManager).mint(params);\\n    }\\n\\n    /// @dev Handles incoming currency transfers for buy orders; if WETH is the currency the caller has the option to send native-ETH\\n    /// @param orderSize The total size of the order in the currency\\n    /// @param trueOrderSize The actual amount being used for the swap after fees\\n    function _handleIncomingCurrency(uint256 orderSize, uint256 trueOrderSize) internal {\\n        if (currency == WETH && msg.value > 0) {\\n            if (msg.value != orderSize) {\\n                revert EthAmountMismatch();\\n            }\\n\\n            if (msg.value < MIN_ORDER_SIZE) {\\n                revert EthAmountTooSmall();\\n            }\\n\\n            IWETH(WETH).deposit{value: trueOrderSize}();\\n            IWETH(WETH).approve(swapRouter, trueOrderSize);\\n        } else {\\n            // Ensure ETH is not sent with a non-ETH pair\\n            if (msg.value != 0) {\\n                revert EthTransferInvalid();\\n            }\\n\\n            uint256 beforeBalance = IERC20(currency).balanceOf(address(this));\\n            IERC20(currency).safeTransferFrom(msg.sender, address(this), orderSize);\\n            uint256 afterBalance = IERC20(currency).balanceOf(address(this));\\n\\n            if ((afterBalance - beforeBalance) != orderSize) {\\n                revert ERC20TransferAmountMismatch();\\n            }\\n\\n            IERC20(currency).approve(swapRouter, trueOrderSize);\\n        }\\n    }\\n\\n    /// @dev Handles sending ETH and ERC20 payouts and refunds to recipients\\n    /// @param orderPayout The amount of currency to pay out\\n    /// @param recipient The address to receive the payout\\n    function _handlePayout(uint256 orderPayout, address recipient) internal {\\n        if (currency == WETH) {\\n            Address.sendValue(payable(recipient), orderPayout);\\n        } else {\\n            IERC20(currency).safeTransfer(recipient, orderPayout);\\n        }\\n    }\\n\\n    /// @dev Handles calculating and depositing fees to an escrow protocol rewards contract\\n    function _handleTradeRewards(uint256 totalValue, address _tradeReferrer) internal {\\n        if (_tradeReferrer == address(0)) {\\n            _tradeReferrer = protocolRewardRecipient;\\n        }\\n\\n        uint256 tokenCreatorFee = _calculateReward(totalValue, TOKEN_CREATOR_FEE_BPS);\\n        uint256 platformReferrerFee = _calculateReward(totalValue, PLATFORM_REFERRER_FEE_BPS);\\n        uint256 tradeReferrerFee = _calculateReward(totalValue, TRADE_REFERRER_FEE_BPS);\\n        uint256 protocolFee = totalValue - tokenCreatorFee - platformReferrerFee - tradeReferrerFee;\\n\\n        if (currency == WETH) {\\n            address[] memory recipients = new address[](4);\\n            uint256[] memory amounts = new uint256[](4);\\n            bytes4[] memory reasons = new bytes4[](4);\\n\\n            recipients[0] = payoutRecipient;\\n            amounts[0] = tokenCreatorFee;\\n            reasons[0] = bytes4(keccak256(\\\"COIN_CREATOR_REWARD\\\"));\\n\\n            recipients[1] = platformReferrer;\\n            amounts[1] = platformReferrerFee;\\n            reasons[1] = bytes4(keccak256(\\\"COIN_PLATFORM_REFERRER_REWARD\\\"));\\n\\n            recipients[2] = _tradeReferrer;\\n            amounts[2] = tradeReferrerFee;\\n            reasons[2] = bytes4(keccak256(\\\"COIN_TRADE_REFERRER_REWARD\\\"));\\n\\n            recipients[3] = protocolRewardRecipient;\\n            amounts[3] = protocolFee;\\n            reasons[3] = bytes4(keccak256(\\\"COIN_PROTOCOL_REWARD\\\"));\\n\\n            IProtocolRewards(protocolRewards).depositBatch{value: totalValue}(recipients, amounts, reasons, \\\"\\\");\\n        }\\n\\n        if (currency != WETH) {\\n            IERC20(currency).safeTransfer(payoutRecipient, tokenCreatorFee);\\n            IERC20(currency).safeTransfer(platformReferrer, platformReferrerFee);\\n            IERC20(currency).safeTransfer(_tradeReferrer, tradeReferrerFee);\\n            IERC20(currency).safeTransfer(protocolRewardRecipient, protocolFee);\\n        }\\n\\n        emit CoinTradeRewards(\\n            payoutRecipient,\\n            platformReferrer,\\n            _tradeReferrer,\\n            protocolRewardRecipient,\\n            tokenCreatorFee,\\n            platformReferrerFee,\\n            tradeReferrerFee,\\n            protocolFee,\\n            currency\\n        );\\n    }\\n\\n    function _handleMarketRewards() internal returns (MarketRewards memory) {\\n        INonfungiblePositionManager.CollectParams memory params = INonfungiblePositionManager.CollectParams({\\n            tokenId: lpTokenId,\\n            recipient: address(this),\\n            amount0Max: type(uint128).max,\\n            amount1Max: type(uint128).max\\n        });\\n\\n        (uint256 totalAmountToken0, uint256 totalAmountToken1) = INonfungiblePositionManager(nonfungiblePositionManager).collect(params);\\n\\n        address token0 = currency < address(this) ? currency : address(this);\\n        address token1 = currency < address(this) ? address(this) : currency;\\n\\n        MarketRewards memory rewards;\\n\\n        rewards = _transferMarketRewards(token0, totalAmountToken0, rewards);\\n        rewards = _transferMarketRewards(token1, totalAmountToken1, rewards);\\n\\n        emit CoinMarketRewards(payoutRecipient, platformReferrer, protocolRewardRecipient, currency, rewards);\\n\\n        return rewards;\\n    }\\n\\n    function _transferMarketRewards(address token, uint256 totalAmount, MarketRewards memory rewards) internal returns (MarketRewards memory) {\\n        if (totalAmount > 0) {\\n            uint256 creatorPayout = _calculateReward(totalAmount, CREATOR_MARKET_REWARD_BPS);\\n            uint256 platformReferrerPayout = _calculateReward(totalAmount, PLATFORM_REFERRER_MARKET_REWARD_BPS);\\n            uint256 protocolPayout = totalAmount - creatorPayout - platformReferrerPayout;\\n\\n            if (token == WETH) {\\n                IWETH(WETH).withdraw(totalAmount);\\n\\n                rewards.totalAmountCurrency = totalAmount;\\n                rewards.creatorPayoutAmountCurrency = creatorPayout;\\n                rewards.platformReferrerAmountCurrency = platformReferrerPayout;\\n                rewards.protocolAmountCurrency = protocolPayout;\\n\\n                address[] memory recipients = new address[](3);\\n                recipients[0] = payoutRecipient;\\n                recipients[1] = platformReferrer;\\n                recipients[2] = protocolRewardRecipient;\\n\\n                uint256[] memory amounts = new uint256[](3);\\n                amounts[0] = rewards.creatorPayoutAmountCurrency;\\n                amounts[1] = rewards.platformReferrerAmountCurrency;\\n                amounts[2] = rewards.protocolAmountCurrency;\\n\\n                bytes4[] memory reasons = new bytes4[](3);\\n                reasons[0] = bytes4(keccak256(\\\"COIN_CREATOR_MARKET_REWARD\\\"));\\n                reasons[1] = bytes4(keccak256(\\\"COIN_PLATFORM_REFERRER_MARKET_REWARD\\\"));\\n                reasons[2] = bytes4(keccak256(\\\"COIN_PROTOCOL_MARKET_REWARD\\\"));\\n\\n                IProtocolRewards(protocolRewards).depositBatch{value: totalAmount}(recipients, amounts, reasons, \\\"\\\");\\n            } else if (token == address(this)) {\\n                rewards.totalAmountCoin = totalAmount;\\n                rewards.creatorPayoutAmountCoin = creatorPayout;\\n                rewards.platformReferrerAmountCoin = platformReferrerPayout;\\n                rewards.protocolAmountCoin = protocolPayout;\\n\\n                _transfer(address(this), payoutRecipient, rewards.creatorPayoutAmountCoin);\\n                _transfer(address(this), platformReferrer, rewards.platformReferrerAmountCoin);\\n                _transfer(address(this), protocolRewardRecipient, rewards.protocolAmountCoin);\\n            } else {\\n                rewards.totalAmountCurrency = totalAmount;\\n                rewards.creatorPayoutAmountCurrency = creatorPayout;\\n                rewards.platformReferrerAmountCurrency = platformReferrerPayout;\\n                rewards.protocolAmountCurrency = protocolPayout;\\n\\n                IERC20(currency).safeTransfer(payoutRecipient, creatorPayout);\\n                IERC20(currency).safeTransfer(platformReferrer, platformReferrerPayout);\\n                IERC20(currency).safeTransfer(protocolRewardRecipient, protocolPayout);\\n            }\\n        }\\n\\n        return rewards;\\n    }\\n\\n    /// @dev Utility for computing amounts in basis points.\\n    function _calculateReward(uint256 amount, uint256 bps) internal pure returns (uint256) {\\n        return (amount * bps) / 10000;\\n    }\\n}\\n\"\n",
    "    }\n",
    "  },\n",
    "  \"settings\": {\n",
    "    \"optimizer\": {\n",
    "      \"enabled\": true,\\n      \"runs\": 200\\n    },\n",
    "    \"outputSelection\": {\n",
    "      \"*\": {\n",
    "        \"*\": [\\n          \"abi\",\\n          \"evm.bytecode\",\\n          \"evm.deployedBytecode\",\\n          \"metadata\"\\n        ]\\n      }\\n    }\n",
    "  }\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "57ad7691-8e9f-47f9-9123-14bbf1d390d9",
   "metadata": {},
   "outputs": [
    {
     "ename": "SyntaxError",
     "evalue": "invalid syntax (1836874139.py, line 1)",
     "output_type": "error",
     "traceback": [
      "\u001b[0;36m  Cell \u001b[0;32mIn[1], line 1\u001b[0;36m\u001b[0m\n\u001b[0;31m    // SPDX-License-Identifier: MIT\u001b[0m\n\u001b[0m    ^\u001b[0m\n\u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m invalid syntax\n"
     ]
    }
   ],
   "source": [
    "// SPDX-License-Identifier: MIT\n",
    "pragma solidity ^0.8.23;\n",
    "\n",
    "import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n",
    "import {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n",
    "import {ICoin} from \"./interfaces/ICoin.sol\";\n",
    "import {ICoinComments} from \"./interfaces/ICoinComments.sol\";\n",
    "import {IERC7572} from \"./interfaces/IERC7572.sol\";\n",
    "import {INonfungiblePositionManager} from \"./interfaces/INonfungiblePositionManager.sol\";\n",
    "import {IUniswapV3Pool} from \"./interfaces/IUniswapV3Pool.sol\";\n",
    "import {ISwapRouter} from \"./interfaces/ISwapRouter.sol\";\n",
    "import {IProtocolRewards} from \"./interfaces/IProtocolRewards.sol\";\n",
    "import {IWETH} from \"./interfaces/IWETH.sol\";\n",
    "\n",
    "import {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n",
    "import {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\n",
    "import {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n",
    "import {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n",
    "import {ContractVersionBase} from \"./version/ContractVersionBase.sol\";\n",
    "import {CoinConstants} from \"./utils/CoinConstants.sol\";\n",
    "import {MultiOwnable} from \"./utils/MultiOwnable.sol\";\n",
    "import {TickMath} from \"./utils/TickMath.sol\";\n",
    "\n",
    "/*\n",
    "     $$$$$$\\   $$$$$$\\  $$$$$$\\ $$\\   $$\\ \n",
    "    $$  __$$\\ $$  __$$\\ \\_$$  _|$$$\\  $$ |\n",
    "    $$ /  \\__|$$ /  $$ |  $$ |  $$$$\\ $$ |\n",
    "    $$ |      $$ |  $$ |  $$ |  $$ $$\\$$ |\n",
    "    $$ |      $$ |  $$ |  $$ |  $$ \\$$$$ |\n",
    "    $$ |  $$\\ $$ |  $$ |  $$ |  $$ |\\$$$ |\n",
    "    \\$$$$$$  | $$$$$$  |$$$$$$\\ $$ | \\$$ |\n",
    "     \\______/  \\______/ \\______|\\__|  \\__|\n",
    "*/\n",
    "contract Coin is ICoin, CoinConstants, ContractVersionBase, ERC20PermitUpgradeable, MultiOwnable, ReentrancyGuardUpgradeable {\n",
    "    using SafeERC20 for IERC20;\n",
    "\n",
    "    address public immutable WETH;\n",
    "    address public immutable nonfungiblePositionManager;\n",
    "    address public immutable swapRouter;\n",
    "    address public immutable protocolRewards;\n",
    "    address public immutable protocolRewardRecipient;\n",
    "\n",
    "    address public payoutRecipient;\n",
    "    address public platformReferrer;\n",
    "    address public poolAddress;\n",
    "    address public currency;\n",
    "    uint256 public lpTokenId;\n",
    "    string public tokenURI;\n",
    "\n",
    "    constructor(\n",
    "        address _protocolRewardRecipient,\n",
    "        address _protocolRewards,\n",
    "        address _weth,\n",
    "        address _nonfungiblePositionManager,\n",
    "        address _swapRouter\n",
    "    ) initializer {\n",
    "        if (_protocolRewardRecipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_protocolRewards == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_weth == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_nonfungiblePositionManager == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_swapRouter == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        protocolRewardRecipient = _protocolRewardRecipient;\n",
    "        protocolRewards = _protocolRewards;\n",
    "        WETH = _weth;\n",
    "        nonfungiblePositionManager = _nonfungiblePositionManager;\n",
    "        swapRouter = _swapRouter;\n",
    "    }\n",
    "\n",
    "    /// @notice Initializes a new coin\n",
    "    /// @param payoutRecipient_ The address of the coin creator\n",
    "    /// @param tokenURI_ The metadata URI\n",
    "    /// @param name_ The coin name\n",
    "    /// @param symbol_ The coin symbol\n",
    "    /// @param platformReferrer_ The address of the platform referrer\n",
    "    /// @param currency_ The address of the currency\n",
    "    /// @param tickLower_ The tick lower for the Uniswap V3 pool; ignored for ETH/WETH\n",
    "    function initialize(\n",
    "        address payoutRecipient_,\n",
    "        address[] memory owners_,\n",
    "        string memory tokenURI_,\n",
    "        string memory name_,\n",
    "        string memory symbol_,\n",
    "        address platformReferrer_,\n",
    "        address currency_,\n",
    "        int24 tickLower_\n",
    "    ) public initializer {\n",
    "        // Validate the creation parameters\n",
    "        if (payoutRecipient_ == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        // Set base contract state\n",
    "        __ERC20_init(name_, symbol_);\n",
    "        __ERC20Permit_init(name_);\n",
    "        __MultiOwnable_init(owners_);\n",
    "        __ReentrancyGuard_init();\n",
    "\n",
    "        // Set mutable state\n",
    "        _setPayoutRecipient(payoutRecipient_);\n",
    "        _setContractURI(tokenURI_);\n",
    "\n",
    "        // Set immutable state\n",
    "        platformReferrer = platformReferrer_ == address(0) ? protocolRewardRecipient : platformReferrer_;\n",
    "        currency = currency_ == address(0) ? WETH : currency_;\n",
    "\n",
    "        // Mint the total supply\n",
    "        _mint(address(this), MAX_TOTAL_SUPPLY);\n",
    "\n",
    "        // Distribute the creator launch reward\n",
    "        _transfer(address(this), payoutRecipient, CREATOR_LAUNCH_REWARD);\n",
    "\n",
    "        // Approve the transfer of the remaining supply to the pool\n",
    "        IERC20(address(this)).safeIncreaseAllowance(address(nonfungiblePositionManager), POOL_LAUNCH_SUPPLY);\n",
    "\n",
    "        // Deploy the pool\n",
    "        _deployPool(tickLower_);\n",
    "    }\n",
    "\n",
    "    /// @notice Executes a buy order\n",
    "    /// @param recipient The recipient address of the coins\n",
    "    /// @param orderSize The amount of coins to buy\n",
    "    /// @param tradeReferrer The address of the trade referrer\n",
    "    /// @param sqrtPriceLimitX96 The price limit for Uniswap V3 pool swap\n",
    "    function buy(\n",
    "        address recipient,\n",
    "        uint256 orderSize,\n",
    "        uint256 minAmountOut,\n",
    "        uint160 sqrtPriceLimitX96,\n",
    "        address tradeReferrer\n",
    "    ) public payable nonReentrant returns (uint256, uint256) {\n",
    "        // Ensure the recipient is not the zero address\n",
    "        if (recipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        // Calculate the trade reward\n",
    "        uint256 tradeReward = _calculateReward(orderSize, TOTAL_FEE_BPS);\n",
    "\n",
    "        // Calculate the remaining size\n",
    "        uint256 trueOrderSize = orderSize - tradeReward;\n",
    "\n",
    "        // Handle incoming currency\n",
    "        _handleIncomingCurrency(orderSize, trueOrderSize);\n",
    "\n",
    "        // Set up the swap parameters\n",
    "        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n",
    "            tokenIn: currency,\n",
    "            tokenOut: address(this),\n",
    "            fee: LP_FEE,\n",
    "            recipient: recipient,\n",
    "            amountIn: trueOrderSize,\n",
    "            amountOutMinimum: minAmountOut,\n",
    "            sqrtPriceLimitX96: sqrtPriceLimitX96\n",
    "        });\n",
    "\n",
    "        // Execute the swap\n",
    "        uint256 amountOut = ISwapRouter(swapRouter).exactInputSingle(params);\n",
    "\n",
    "        _handleTradeRewards(tradeReward, tradeReferrer);\n",
    "\n",
    "        _handleMarketRewards();\n",
    "\n",
    "        emit CoinBuy(msg.sender, recipient, tradeReferrer, amountOut, currency, tradeReward, trueOrderSize);\n",
    "\n",
    "        return (orderSize, amountOut);\n",
    "    }\n",
    "\n",
    "    /// @notice Executes a sell order\n",
    "    /// @param recipient The recipient of the currency\n",
    "    /// @param orderSize The amount of coins to sell\n",
    "    /// @param minAmountOut The minimum amount of currency to receive\n",
    "    /// @param sqrtPriceLimitX96 The price limit for the swap\n",
    "    /// @param tradeReferrer The address of the trade referrer\n",
    "    function sell(\n",
    "        address recipient,\n",
    "        uint256 orderSize,\n",
    "        uint256 minAmountOut,\n",
    "        uint160 sqrtPriceLimitX96,\n",
    "        address tradeReferrer\n",
    "    ) public nonReentrant returns (uint256, uint256) {\n",
    "        // Ensure the recipient is not the zero address\n",
    "        if (recipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        // Record the coin balance of this contract before the swap\n",
    "        uint256 beforeCoinBalance = balanceOf(address(this));\n",
    "\n",
    "        // Transfer the coins from the seller to this contract\n",
    "        transfer(address(this), orderSize);\n",
    "\n",
    "        // Approve the Uniswap V3 swap router\n",
    "        this.approve(swapRouter, orderSize);\n",
    "\n",
    "        // Set the swap parameters\n",
    "        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n",
    "            tokenIn: address(this),\n",
    "            tokenOut: currency,\n",
    "            fee: LP_FEE,\n",
    "            recipient: address(this),\n",
    "            amountIn: orderSize,\n",
    "            amountOutMinimum: minAmountOut,\n",
    "            sqrtPriceLimitX96: sqrtPriceLimitX96\n",
    "        });\n",
    "\n",
    "        // Execute the swap\n",
    "        uint256 amountOut = ISwapRouter(swapRouter).exactInputSingle(params);\n",
    "\n",
    "        // Record the coin balance of this contract after the swap\n",
    "        uint256 afterCoinBalance = balanceOf(address(this));\n",
    "\n",
    "        // If the swap was partially executed:\n",
    "        if (afterCoinBalance > beforeCoinBalance) {\n",
    "            // Calculate the refund\n",
    "            uint256 coinRefund = afterCoinBalance - beforeCoinBalance;\n",
    "\n",
    "            // Update the order size\n",
    "            orderSize -= coinRefund;\n",
    "\n",
    "            // Transfer the refund back to the seller\n",
    "            _transfer(address(this), recipient, coinRefund);\n",
    "        }\n",
    "\n",
    "        // If currency is WETH, convert to ETH\n",
    "        if (currency == WETH) {\n",
    "            IWETH(WETH).withdraw(amountOut);\n",
    "        }\n",
    "\n",
    "        // Calculate the trade reward\n",
    "        uint256 tradeReward = _calculateReward(amountOut, TOTAL_FEE_BPS);\n",
    "\n",
    "        // Calculate the payout after the fee\n",
    "        uint256 payoutSize = amountOut - tradeReward;\n",
    "\n",
    "        _handlePayout(payoutSize, recipient);\n",
    "\n",
    "        _handleTradeRewards(tradeReward, tradeReferrer);\n",
    "\n",
    "        _handleMarketRewards();\n",
    "\n",
    "        emit CoinSell(msg.sender, recipient, tradeReferrer, orderSize, currency, tradeReward, payoutSize);\n",
    "\n",
    "        return (orderSize, payoutSize);\n",
    "    }\n",
    "\n",
    "    /// @notice Enables a user to burn their tokens\n",
    "    /// @param amount The amount of tokens to burn\n",
    "    function burn(uint256 amount) external {\n",
    "        _burn(msg.sender, amount);\n",
    "    }\n",
    "\n",
    "    /// @notice Force claim any accrued secondary rewards from the market's liquidity position.\n",
    "    /// @dev This function is a fallback, secondary rewards will be claimed automatically on each buy and sell.\n",
    "    /// @param pushEthRewards Whether to push the ETH directly to the recipients.\n",
    "    function claimSecondaryRewards(bool pushEthRewards) external nonReentrant {\n",
    "        MarketRewards memory rewards = _handleMarketRewards();\n",
    "\n",
    "        if (pushEthRewards && rewards.totalAmountCurrency > 0 && currency == WETH) {\n",
    "            IProtocolRewards(protocolRewards).withdrawFor(payoutRecipient, rewards.creatorPayoutAmountCurrency);\n",
    "            IProtocolRewards(protocolRewards).withdrawFor(platformReferrer, rewards.platformReferrerAmountCurrency);\n",
    "            IProtocolRewards(protocolRewards).withdrawFor(protocolRewardRecipient, rewards.protocolAmountCurrency);\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @notice Set the creator's payout address\n",
    "    /// @param newPayoutRecipient The new recipient address\n",
    "    function setPayoutRecipient(address newPayoutRecipient) external onlyOwner {\n",
    "        _setPayoutRecipient(newPayoutRecipient);\n",
    "    }\n",
    "\n",
    "    /// @notice Set the contract URI\n",
    "    /// @param newURI The new URI\n",
    "    function setContractURI(string memory newURI) external onlyOwner {\n",
    "        _setContractURI(newURI);\n",
    "    }\n",
    "\n",
    "    /// @notice The contract metadata\n",
    "    function contractURI() external view returns (string memory) {\n",
    "        return tokenURI;\n",
    "    }\n",
    "\n",
    "    /// @notice ERC165 interface support\n",
    "    /// @param interfaceId The interface ID to check\n",
    "    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n",
    "        return\n",
    "            interfaceId == type(ICoin).interfaceId ||\n",
    "            interfaceId == type(ICoinComments).interfaceId ||\n",
    "            interfaceId == type(IERC7572).interfaceId ||\n",
    "            interfaceId == type(IERC165).interfaceId;\n",
    "    }\n",
    "\n",
    "    /// @notice Receives ETH converted from WETH\n",
    "    receive() external payable {\n",
    "        if (msg.sender != WETH) {\n",
    "            revert OnlyWeth();\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @dev For receiving the Uniswap V3 LP NFT on market graduation.\n",
    "    function onERC721Received(address, address, uint256, bytes calldata) external view returns (bytes4) {\n",
    "        if (msg.sender != poolAddress) revert OnlyPool();\n",
    "\n",
    "        return this.onERC721Received.selector;\n",
    "    }\n",
    "\n",
    "    /// @dev No-op to allow a swap on the pool to set the correct initial price, if needed\n",
    "    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata) external {}\n",
    "\n",
    "    /// @dev Overrides ERC20's _update function to\n",
    "    ///      - Prevent transfers to the pool if the market has not graduated.\n",
    "    ///      - Emit the superset `WowTokenTransfer` event with each ERC20 transfer.\n",
    "    function _update(address from, address to, uint256 value) internal virtual override {\n",
    "        super._update(from, to, value);\n",
    "\n",
    "        emit CoinTransfer(from, to, value, balanceOf(from), balanceOf(to));\n",
    "    }\n",
    "\n",
    "    /// @dev Used to set the payout recipient on coin creation and updates\n",
    "    /// @param newPayoutRecipient The new recipient address\n",
    "    function _setPayoutRecipient(address newPayoutRecipient) internal {\n",
    "        if (newPayoutRecipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        emit CoinPayoutRecipientUpdated(msg.sender, payoutRecipient, newPayoutRecipient);\n",
    "\n",
    "        payoutRecipient = newPayoutRecipient;\n",
    "    }\n",
    "\n",
    "    /// @dev Used to set the contract URI on coin creation and updates\n",
    "    /// @param newURI The new URI\n",
    "    function _setContractURI(string memory newURI) internal {\n",
    "        emit ContractMetadataUpdated(msg.sender, newURI, name());\n",
    "        emit ContractURIUpdated();\n",
    "\n",
    "        tokenURI = newURI;\n",
    "    }\n",
    "\n",
    "    /// @dev Deploy the pool\n",
    "    function _deployPool(int24 tickLower_) internal {\n",
    "        // If WETH is the pool's currency, validate the lower tick\n",
    "        if (currency == WETH && tickLower_ < LP_TICK_LOWER_WETH) {\n",
    "            revert InvalidWethLowerTick();\n",
    "        }\n",
    "\n",
    "        // Note: This validation happens on the Uniswap pool already; reverting early here for clarity\n",
    "        // If currency is not WETH: ensure lower tick is less than upper tick and satisfies the 200 tick spacing requirement for 1% Uniswap V3 pools\n",
    "        if (currency != WETH && (tickLower_ >= LP_TICK_UPPER || tickLower_ % 200 != 0)) {\n",
    "            revert InvalidCurrencyLowerTick();\n",
    "        }\n",
    "\n",
    "        // Sort the token addresses\n",
    "        address token0 = address(this) < currency ? address(this) : currency;\n",
    "        address token1 = address(this) < currency ? currency : address(this);\n",
    "\n",
    "        // If the coin is token0\n",
    "        bool isCoinToken0 = token0 == address(this);\n",
    "\n",
    "        // Determine the tick values\n",
    "        int24 tickLower = isCoinToken0 ? tickLower_ : -LP_TICK_UPPER;\n",
    "        int24 tickUpper = isCoinToken0 ? LP_TICK_UPPER : -tickLower_;\n",
    "\n",
    "        // Calculate the starting price for the pool\n",
    "        uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(isCoinToken0 ? tickLower : tickUpper);\n",
    "\n",
    "        // Determine the initial liquidity amounts\n",
    "        uint256 amount0 = isCoinToken0 ? POOL_LAUNCH_SUPPLY : 0;\n",
    "        uint256 amount1 = isCoinToken0 ? 0 : POOL_LAUNCH_SUPPLY;\n",
    "\n",
    "        // Create and initialize the pool\n",
    "        poolAddress = INonfungiblePositionManager(nonfungiblePositionManager).createAndInitializePoolIfNecessary(token0, token1, LP_FEE, sqrtPriceX96);\n",
    "\n",
    "        // Construct the LP data\n",
    "        INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager.MintParams({\n",
    "            token0: token0,\n",
    "            token1: token1,\n",
    "            fee: LP_FEE,\n",
    "            tickLower: tickLower,\n",
    "            tickUpper: tickUpper,\n",
    "            amount0Desired: amount0,\n",
    "            amount1Desired: amount1,\n",
    "            amount0Min: 0,\n",
    "            amount1Min: 0,\n",
    "            recipient: address(this),\n",
    "            deadline: block.timestamp\n",
    "        });\n",
    "\n",
    "        // Mint the LP\n",
    "        (lpTokenId, , , ) = INonfungiblePositionManager(nonfungiblePositionManager).mint(params);\n",
    "    }\n",
    "\n",
    "    /// @dev Handles incoming currency transfers for buy orders; if WETH is the currency the caller has the option to send native-ETH\n",
    "    /// @param orderSize The total size of the order in the currency\n",
    "    /// @param trueOrderSize The actual amount being used for the swap after fees\n",
    "    function _handleIncomingCurrency(uint256 orderSize, uint256 trueOrderSize) internal {\n",
    "        if (currency == WETH && msg.value > 0) {\n",
    "            if (msg.value != orderSize) {\n",
    "                revert EthAmountMismatch();\n",
    "            }\n",
    "\n",
    "            if (msg.value < MIN_ORDER_SIZE) {\n",
    "                revert EthAmountTooSmall();\n",
    "            }\n",
    "\n",
    "            IWETH(WETH).deposit{value: trueOrderSize}();\n",
    "            IWETH(WETH).approve(swapRouter, trueOrderSize);\n",
    "        } else {\n",
    "            // Ensure ETH is not sent with a non-ETH pair\n",
    "            if (msg.value != 0) {\n",
    "                revert EthTransferInvalid();\n",
    "            }\n",
    "\n",
    "            uint256 beforeBalance = IERC20(currency).balanceOf(address(this));\n",
    "            IERC20(currency).safeTransferFrom(msg.sender, address(this), orderSize);\n",
    "            uint256 afterBalance = IERC20(currency).balanceOf(address(this));\n",
    "\n",
    "            if ((afterBalance - beforeBalance) != orderSize) {\n",
    "                revert ERC20TransferAmountMismatch();\n",
    "            }\n",
    "\n",
    "            IERC20(currency).approve(swapRouter, trueOrderSize);\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @dev Handles sending ETH and ERC20 payouts and refunds to recipients\n",
    "    /// @param orderPayout The amount of currency to pay out\n",
    "    /// @param recipient The address to receive the payout\n",
    "    function _handlePayout(uint256 orderPayout, address recipient) internal {\n",
    "        if (currency == WETH) {\n",
    "            Address.sendValue(payable(recipient), orderPayout);\n",
    "        } else {\n",
    "            IERC20(currency).safeTransfer(recipient, orderPayout);\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @dev Handles calculating and depositing fees to an escrow protocol rewards contract\n",
    "    function _handleTradeRewards(uint256 totalValue, address _tradeReferrer) internal {\n",
    "        if (_tradeReferrer == address(0)) {\n",
    "            _tradeReferrer = protocolRewardRecipient;\n",
    "        }\n",
    "\n",
    "        uint256 tokenCreatorFee = _calculateReward(totalValue, TOKEN_CREATOR_FEE_BPS);\n",
    "        uint256 platformReferrerFee = _calculateReward(totalValue, PLATFORM_REFERRER_FEE_BPS);\n",
    "        uint256 tradeReferrerFee = _calculateReward(totalValue, TRADE_REFERRER_FEE_BPS);\n",
    "        uint256 protocolFee = totalValue - tokenCreatorFee - platformReferrerFee - tradeReferrerFee;\n",
    "\n",
    "        if (currency == WETH) {\n",
    "            address[] memory recipients = new address[](4);\n",
    "            uint256[] memory amounts = new uint256[](4);\n",
    "            bytes4[] memory reasons = new bytes4[](4);\n",
    "\n",
    "            recipients[0] = payoutRecipient;\n",
    "            amounts[0] = tokenCreatorFee;\n",
    "            reasons[0] = bytes4(keccak256(\"COIN_CREATOR_REWARD\"));\n",
    "\n",
    "            recipients[1] = platformReferrer;\n",
    "            amounts[1] = platformReferrerFee;\n",
    "            reasons[1] = bytes4(keccak256(\"COIN_PLATFORM_REFERRER_REWARD\"));\n",
    "\n",
    "            recipients[2] = _tradeReferrer;\n",
    "            amounts[2] = tradeReferrerFee;\n",
    "            reasons[2] = bytes4(keccak256(\"COIN_TRADE_REFERRER_REWARD\"));\n",
    "\n",
    "            recipients[3] = protocolRewardRecipient;\n",
    "            amounts[3] = protocolFee;\n",
    "            reasons[3] = bytes4(keccak256(\"COIN_PROTOCOL_REWARD\"));\n",
    "\n",
    "            IProtocolRewards(protocolRewards).depositBatch{value: totalValue}(recipients, amounts, reasons, \"\");\n",
    "        }\n",
    "\n",
    "        if (currency != WETH) {\n",
    "            IERC20(currency).safeTransfer(payoutRecipient, tokenCreatorFee);\n",
    "            IERC20(currency).safeTransfer(platformReferrer, platformReferrerFee);\n",
    "            IERC20(currency).safeTransfer(_tradeReferrer, tradeReferrerFee);\n",
    "            IERC20(currency).safeTransfer(protocolRewardRecipient, protocolFee);\n",
    "        }\n",
    "\n",
    "        emit CoinTradeRewards(\n",
    "            payoutRecipient,\n",
    "            platformReferrer,\n",
    "            _tradeReferrer,\n",
    "            protocolRewardRecipient,\n",
    "            tokenCreatorFee,\n",
    "            platformReferrerFee,\n",
    "            tradeReferrerFee,\n",
    "            protocolFee,\n",
    "            currency\n",
    "        );\n",
    "    }\n",
    "\n",
    "    function _handleMarketRewards() internal returns (MarketRewards memory) {\n",
    "        INonfungiblePositionManager.CollectParams memory params = INonfungiblePositionManager.CollectParams({\n",
    "            tokenId: lpTokenId,\n",
    "            recipient: address(this),\n",
    "            amount0Max: type(uint128).max,\n",
    "            amount1Max: type(uint128).max\n",
    "        });\n",
    "\n",
    "        (uint256 totalAmountToken0, uint256 totalAmountToken1) = INonfungiblePositionManager(nonfungiblePositionManager).collect(params);\n",
    "\n",
    "        address token0 = currency < address(this) ? currency : address(this);\n",
    "        address token1 = currency < address(this) ? address(this) : currency;\n",
    "\n",
    "        MarketRewards memory rewards;\n",
    "\n",
    "        rewards = _transferMarketRewards(token0, totalAmountToken0, rewards);\n",
    "        rewards = _transferMarketRewards(token1, totalAmountToken1, rewards);\n",
    "\n",
    "        emit CoinMarketRewards(payoutRecipient, platformReferrer, protocolRewardRecipient, currency, rewards);\n",
    "\n",
    "        return rewards;\n",
    "    }\n",
    "\n",
    "    function _transferMarketRewards(address token, uint256 totalAmount, MarketRewards memory rewards) internal returns (MarketRewards memory) {\n",
    "        if (totalAmount > 0) {\n",
    "            uint256 creatorPayout = _calculateReward(totalAmount, CREATOR_MARKET_REWARD_BPS);\n",
    "            uint256 platformReferrerPayout = _calculateReward(totalAmount, PLATFORM_REFERRER_MARKET_REWARD_BPS);\n",
    "            uint256 protocolPayout = totalAmount - creatorPayout - platformReferrerPayout;\n",
    "\n",
    "            if (token == WETH) {\n",
    "                IWETH(WETH).withdraw(totalAmount);\n",
    "\n",
    "                rewards.totalAmountCurrency = totalAmount;\n",
    "                rewards.creatorPayoutAmountCurrency = creatorPayout;\n",
    "                rewards.platformReferrerAmountCurrency = platformReferrerPayout;\n",
    "                rewards.protocolAmountCurrency = protocolPayout;\n",
    "\n",
    "                address[] memory recipients = new address[](3);\n",
    "                recipients[0] = payoutRecipient;\n",
    "                recipients[1] = platformReferrer;\n",
    "                recipients[2] = protocolRewardRecipient;\n",
    "\n",
    "                uint256[] memory amounts = new uint256[](3);\n",
    "                amounts[0] = rewards.creatorPayoutAmountCurrency;\n",
    "                amounts[1] = rewards.platformReferrerAmountCurrency;\n",
    "                amounts[2] = rewards.protocolAmountCurrency;\n",
    "\n",
    "                bytes4[] memory reasons = new bytes4[](3);\n",
    "                reasons[0] = bytes4(keccak256(\"COIN_CREATOR_MARKET_REWARD\"));\n",
    "                reasons[1] = bytes4(keccak256(\"COIN_PLATFORM_REFERRER_MARKET_REWARD\"));\n",
    "                reasons[2] = bytes4(keccak256(\"COIN_PROTOCOL_MARKET_REWARD\"));\n",
    "\n",
    "                IProtocolRewards(protocolRewards).depositBatch{value: totalAmount}(recipients, amounts, reasons, \"\");\n",
    "            } else if (token == address(this)) {\n",
    "                rewards.totalAmountCoin = totalAmount;\n",
    "                rewards.creatorPayoutAmountCoin = creatorPayout;\n",
    "                rewards.platformReferrerAmountCoin = platformReferrerPayout;\n",
    "                rewards.protocolAmountCoin = protocolPayout;\n",
    "\n",
    "                _transfer(address(this), payoutRecipient, rewards.creatorPayoutAmountCoin);\n",
    "                _transfer(address(this), platformReferrer, rewards.platformReferrerAmountCoin);\n",
    "                _transfer(address(this), protocolRewardRecipient, rewards.protocolAmountCoin);\n",
    "            } else {\n",
    "                rewards.totalAmountCurrency = totalAmount;\n",
    "                rewards.creatorPayoutAmountCurrency = creatorPayout;\n",
    "                rewards.platformReferrerAmountCurrency = platformReferrerPayout;\n",
    "                rewards.protocolAmountCurrency = protocolPayout;\n",
    "\n",
    "                IERC20(currency).safeTransfer(payoutRecipient, creatorPayout);\n",
    "                IERC20(currency).safeTransfer(platformReferrer, platformReferrerPayout);\n",
    "                IERC20(currency).safeTransfer(protocolRewardRecipient, protocolPayout);\n",
    "            }\n",
    "        }\n",
    "\n",
    "        return rewards;\n",
    "    }\n",
    "\n",
    "    /// @dev Utility for computing amounts in basis points.\n",
    "    function _calculateReward(uint256 amount, uint256 bps) internal pure returns (uint256) {\n",
    "        return (amount * bps) / 10_000;\n",
    "    }\n",
    "}// SPDX-License-Identifier: MIT\n",
    "pragma solidity ^0.8.23;\n",
    "\n",
    "import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n",
    "import {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n",
    "import {ICoin} from \"./interfaces/ICoin.sol\";\n",
    "import {ICoinComments} from \"./interfaces/ICoinComments.sol\";\n",
    "import {IERC7572} from \"./interfaces/IERC7572.sol\";\n",
    "import {INonfungiblePositionManager} from \"./interfaces/INonfungiblePositionManager.sol\";\n",
    "import {IUniswapV3Pool} from \"./interfaces/IUniswapV3Pool.sol\";\n",
    "import {ISwapRouter} from \"./interfaces/ISwapRouter.sol\";\n",
    "import {IProtocolRewards} from \"./interfaces/IProtocolRewards.sol\";\n",
    "import {IWETH} from \"./interfaces/IWETH.sol\";\n",
    "\n",
    "import {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n",
    "import {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\n",
    "import {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n",
    "import {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n",
    "import {ContractVersionBase} from \"./version/ContractVersionBase.sol\";\n",
    "import {CoinConstants} from \"./utils/CoinConstants.sol\";\n",
    "import {MultiOwnable} from \"./utils/MultiOwnable.sol\";\n",
    "import {TickMath} from \"./utils/TickMath.sol\";\n",
    "\n",
    "/*\n",
    "     $$$$$$\\   $$$$$$\\  $$$$$$\\ $$\\   $$\\ \n",
    "    $$  __$$\\ $$  __$$\\ \\_$$  _|$$$\\  $$ |\n",
    "    $$ /  \\__|$$ /  $$ |  $$ |  $$$$\\ $$ |\n",
    "    $$ |      $$ |  $$ |  $$ |  $$ $$\\$$ |\n",
    "    $$ |      $$ |  $$ |  $$ |  $$ \\$$$$ |\n",
    "    $$ |  $$\\ $$ |  $$ |  $$ |  $$ |\\$$$ |\n",
    "    \\$$$$$$  | $$$$$$  |$$$$$$\\ $$ | \\$$ |\n",
    "     \\______/  \\______/ \\______|\\__|  \\__|\n",
    "*/\n",
    "contract Coin is ICoin, CoinConstants, ContractVersionBase, ERC20PermitUpgradeable, MultiOwnable, ReentrancyGuardUpgradeable {\n",
    "    using SafeERC20 for IERC20;\n",
    "\n",
    "    address public immutable WETH;\n",
    "    address public immutable nonfungiblePositionManager;\n",
    "    address public immutable swapRouter;\n",
    "    address public immutable protocolRewards;\n",
    "    address public immutable protocolRewardRecipient;\n",
    "\n",
    "    address public payoutRecipient;\n",
    "    address public platformReferrer;\n",
    "    address public poolAddress;\n",
    "    address public currency;\n",
    "    uint256 public lpTokenId;\n",
    "    string public tokenURI;\n",
    "\n",
    "    constructor(\n",
    "        address _protocolRewardRecipient,\n",
    "        address _protocolRewards,\n",
    "        address _weth,\n",
    "        address _nonfungiblePositionManager,\n",
    "        address _swapRouter\n",
    "    ) initializer {\n",
    "        if (_protocolRewardRecipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_protocolRewards == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_weth == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_nonfungiblePositionManager == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_swapRouter == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        protocolRewardRecipient = _protocolRewardRecipient;\n",
    "        protocolRewards = _protocolRewards;\n",
    "        WETH = _weth;\n",
    "        nonfungiblePositionManager = _nonfungiblePositionManager;\n",
    "        swapRouter = _swapRouter;\n",
    "    }\n",
    "\n",
    "    /// @notice Initializes a new coin\n",
    "    /// @param payoutRecipient_ The address of the coin creator\n",
    "    /// @param tokenURI_ The metadata URI\n",
    "    /// @param name_ The coin name\n",
    "    /// @param symbol_ The coin symbol\n",
    "    /// @param platformReferrer_ The address of the platform referrer\n",
    "    /// @param currency_ The address of the currency\n",
    "    /// @param tickLower_ The tick lower for the Uniswap V3 pool; ignored for ETH/WETH\n",
    "    function initialize(\n",
    "        address payoutRecipient_,\n",
    "        address[] memory owners_,\n",
    "        string memory tokenURI_,\n",
    "        string memory name_,\n",
    "        string memory symbol_,\n",
    "        address platformReferrer_,\n",
    "        address currency_,\n",
    "        int24 tickLower_\n",
    "    ) public initializer {\n",
    "        // Validate the creation parameters\n",
    "        if (payoutRecipient_ == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        // Set base contract state\n",
    "        __ERC20_init(name_, symbol_);\n",
    "        __ERC20Permit_init(name_);\n",
    "        __MultiOwnable_init(owners_);\n",
    "        __ReentrancyGuard_init();\n",
    "\n",
    "        // Set mutable state\n",
    "        _setPayoutRecipient(payoutRecipient_);\n",
    "        _setContractURI(tokenURI_);\n",
    "\n",
    "        // Set immutable state\n",
    "        platformReferrer = platformReferrer_ == address(0) ? protocolRewardRecipient : platformReferrer_;\n",
    "        currency = currency_ == address(0) ? WETH : currency_;\n",
    "\n",
    "        // Mint the total supply\n",
    "        _mint(address(this), MAX_TOTAL_SUPPLY);\n",
    "\n",
    "        // Distribute the creator launch reward\n",
    "        _transfer(address(this), payoutRecipient, CREATOR_LAUNCH_REWARD);\n",
    "\n",
    "        // Approve the transfer of the remaining supply to the pool\n",
    "        IERC20(address(this)).safeIncreaseAllowance(address(nonfungiblePositionManager), POOL_LAUNCH_SUPPLY);\n",
    "\n",
    "        // Deploy the pool\n",
    "        _deployPool(tickLower_);\n",
    "    }\n",
    "\n",
    "    /// @notice Executes a buy order\n",
    "    /// @param recipient The recipient address of the coins\n",
    "    /// @param orderSize The amount of coins to buy\n",
    "    /// @param tradeReferrer The address of the trade referrer\n",
    "    /// @param sqrtPriceLimitX96 The price limit for Uniswap V3 pool swap\n",
    "    function buy(\n",
    "        address recipient,\n",
    "        uint256 orderSize,\n",
    "        uint256 minAmountOut,\n",
    "        uint160 sqrtPriceLimitX96,\n",
    "        address tradeReferrer\n",
    "    ) public payable nonReentrant returns (uint256, uint256) {\n",
    "        // Ensure the recipient is not the zero address\n",
    "        if (recipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        // Calculate the trade reward\n",
    "        uint256 tradeReward = _calculateReward(orderSize, TOTAL_FEE_BPS);\n",
    "\n",
    "        // Calculate the remaining size\n",
    "        uint256 trueOrderSize = orderSize - tradeReward;\n",
    "\n",
    "        // Handle incoming currency\n",
    "        _handleIncomingCurrency(orderSize, trueOrderSize);\n",
    "\n",
    "        // Set up the swap parameters\n",
    "        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n",
    "            tokenIn: currency,\n",
    "            tokenOut: address(this),\n",
    "            fee: LP_FEE,\n",
    "            recipient: recipient,\n",
    "            amountIn: trueOrderSize,\n",
    "            amountOutMinimum: minAmountOut,\n",
    "            sqrtPriceLimitX96: sqrtPriceLimitX96\n",
    "        });\n",
    "\n",
    "        // Execute the swap\n",
    "        uint256 amountOut = ISwapRouter(swapRouter).exactInputSingle(params);\n",
    "\n",
    "        _handleTradeRewards(tradeReward, tradeReferrer);\n",
    "\n",
    "        _handleMarketRewards();\n",
    "\n",
    "        emit CoinBuy(msg.sender, recipient, tradeReferrer, amountOut, currency, tradeReward, trueOrderSize);\n",
    "\n",
    "        return (orderSize, amountOut);\n",
    "    }\n",
    "\n",
    "    /// @notice Executes a sell order\n",
    "    /// @param recipient The recipient of the currency\n",
    "    /// @param orderSize The amount of coins to sell\n",
    "    /// @param minAmountOut The minimum amount of currency to receive\n",
    "    /// @param sqrtPriceLimitX96 The price limit for the swap\n",
    "    /// @param tradeReferrer The address of the trade referrer\n",
    "    function sell(\n",
    "        address recipient,\n",
    "        uint256 orderSize,\n",
    "        uint256 minAmountOut,\n",
    "        uint160 sqrtPriceLimitX96,\n",
    "        address tradeReferrer\n",
    "    ) public nonReentrant returns (uint256, uint256) {\n",
    "        // Ensure the recipient is not the zero address\n",
    "        if (recipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        // Record the coin balance of this contract before the swap\n",
    "        uint256 beforeCoinBalance = balanceOf(address(this));\n",
    "\n",
    "        // Transfer the coins from the seller to this contract\n",
    "        transfer(address(this), orderSize);\n",
    "\n",
    "        // Approve the Uniswap V3 swap router\n",
    "        this.approve(swapRouter, orderSize);\n",
    "\n",
    "        // Set the swap parameters\n",
    "        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n",
    "            tokenIn: address(this),\n",
    "            tokenOut: currency,\n",
    "            fee: LP_FEE,\n",
    "            recipient: address(this),\n",
    "            amountIn: orderSize,\n",
    "            amountOutMinimum: minAmountOut,\n",
    "            sqrtPriceLimitX96: sqrtPriceLimitX96\n",
    "        });\n",
    "\n",
    "        // Execute the swap\n",
    "        uint256 amountOut = ISwapRouter(swapRouter).exactInputSingle(params);\n",
    "\n",
    "        // Record the coin balance of this contract after the swap\n",
    "        uint256 afterCoinBalance = balanceOf(address(this));\n",
    "\n",
    "        // If the swap was partially executed:\n",
    "        if (afterCoinBalance > beforeCoinBalance) {\n",
    "            // Calculate the refund\n",
    "            uint256 coinRefund = afterCoinBalance - beforeCoinBalance;\n",
    "\n",
    "            // Update the order size\n",
    "            orderSize -= coinRefund;\n",
    "\n",
    "            // Transfer the refund back to the seller\n",
    "            _transfer(address(this), recipient, coinRefund);\n",
    "        }\n",
    "\n",
    "        // If currency is WETH, convert to ETH\n",
    "        if (currency == WETH) {\n",
    "            IWETH(WETH).withdraw(amountOut);\n",
    "        }\n",
    "\n",
    "        // Calculate the trade reward\n",
    "        uint256 tradeReward = _calculateReward(amountOut, TOTAL_FEE_BPS);\n",
    "\n",
    "        // Calculate the payout after the fee\n",
    "        uint256 payoutSize = amountOut - tradeReward;\n",
    "\n",
    "        _handlePayout(payoutSize, recipient);\n",
    "\n",
    "        _handleTradeRewards(tradeReward, tradeReferrer);\n",
    "\n",
    "        _handleMarketRewards();\n",
    "\n",
    "        emit CoinSell(msg.sender, recipient, tradeReferrer, orderSize, currency, tradeReward, payoutSize);\n",
    "\n",
    "        return (orderSize, payoutSize);\n",
    "    }\n",
    "\n",
    "    /// @notice Enables a user to burn their tokens\n",
    "    /// @param amount The amount of tokens to burn\n",
    "    function burn(uint256 amount) external {\n",
    "        _burn(msg.sender, amount);\n",
    "    }\n",
    "\n",
    "    /// @notice Force claim any accrued secondary rewards from the market's liquidity position.\n",
    "    /// @dev This function is a fallback, secondary rewards will be claimed automatically on each buy and sell.\n",
    "    /// @param pushEthRewards Whether to push the ETH directly to the recipients.\n",
    "    function claimSecondaryRewards(bool pushEthRewards) external nonReentrant {\n",
    "        MarketRewards memory rewards = _handleMarketRewards();\n",
    "\n",
    "        if (pushEthRewards && rewards.totalAmountCurrency > 0 && currency == WETH) {\n",
    "            IProtocolRewards(protocolRewards).withdrawFor(payoutRecipient, rewards.creatorPayoutAmountCurrency);\n",
    "            IProtocolRewards(protocolRewards).withdrawFor(platformReferrer, rewards.platformReferrerAmountCurrency);\n",
    "            IProtocolRewards(protocolRewards).withdrawFor(protocolRewardRecipient, rewards.protocolAmountCurrency);\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @notice Set the creator's payout address\n",
    "    /// @param newPayoutRecipient The new recipient address\n",
    "    function setPayoutRecipient(address newPayoutRecipient) external onlyOwner {\n",
    "        _setPayoutRecipient(newPayoutRecipient);\n",
    "    }\n",
    "\n",
    "    /// @notice Set the contract URI\n",
    "    /// @param newURI The new URI\n",
    "    function setContractURI(string memory newURI) external onlyOwner {\n",
    "        _setContractURI(newURI);\n",
    "    }\n",
    "\n",
    "    /// @notice The contract metadata\n",
    "    function contractURI() external view returns (string memory) {\n",
    "        return tokenURI;\n",
    "    }\n",
    "\n",
    "    /// @notice ERC165 interface support\n",
    "    /// @param interfaceId The interface ID to check\n",
    "    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n",
    "        return\n",
    "            interfaceId == type(ICoin).interfaceId ||\n",
    "            interfaceId == type(ICoinComments).interfaceId ||\n",
    "            interfaceId == type(IERC7572).interfaceId ||\n",
    "            interfaceId == type(IERC165).interfaceId;\n",
    "    }\n",
    "\n",
    "    /// @notice Receives ETH converted from WETH\n",
    "    receive() external payable {\n",
    "        if (msg.sender != WETH) {\n",
    "            revert OnlyWeth();\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @dev For receiving the Uniswap V3 LP NFT on market graduation.\n",
    "    function onERC721Received(address, address, uint256, bytes calldata) external view returns (bytes4) {\n",
    "        if (msg.sender != poolAddress) revert OnlyPool();\n",
    "\n",
    "        return this.onERC721Received.selector;\n",
    "    }\n",
    "\n",
    "    /// @dev No-op to allow a swap on the pool to set the correct initial price, if needed\n",
    "    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata) external {}\n",
    "\n",
    "    /// @dev Overrides ERC20's _update function to\n",
    "    ///      - Prevent transfers to the pool if the market has not graduated.\n",
    "    ///      - Emit the superset `WowTokenTransfer` event with each ERC20 transfer.\n",
    "    function _update(address from, address to, uint256 value) internal virtual override {\n",
    "        super._update(from, to, value);\n",
    "\n",
    "        emit CoinTransfer(from, to, value, balanceOf(from), balanceOf(to));\n",
    "    }\n",
    "\n",
    "    /// @dev Used to set the payout recipient on coin creation and updates\n",
    "    /// @param newPayoutRecipient The new recipient address\n",
    "    function _setPayoutRecipient(address newPayoutRecipient) internal {\n",
    "        if (newPayoutRecipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        emit CoinPayoutRecipientUpdated(msg.sender, payoutRecipient, newPayoutRecipient);\n",
    "\n",
    "        payoutRecipient = newPayoutRecipient;\n",
    "    }\n",
    "\n",
    "    /// @dev Used to set the contract URI on coin creation and updates\n",
    "    /// @param newURI The new URI\n",
    "    function _setContractURI(string memory newURI) internal {\n",
    "        emit ContractMetadataUpdated(msg.sender, newURI, name());\n",
    "        emit ContractURIUpdated();\n",
    "\n",
    "        tokenURI = newURI;\n",
    "    }\n",
    "\n",
    "    /// @dev Deploy the pool\n",
    "    function _deployPool(int24 tickLower_) internal {\n",
    "        // If WETH is the pool's currency, validate the lower tick\n",
    "        if (currency == WETH && tickLower_ < LP_TICK_LOWER_WETH) {\n",
    "            revert InvalidWethLowerTick();\n",
    "        }\n",
    "\n",
    "        // Note: This validation happens on the Uniswap pool already; reverting early here for clarity\n",
    "        // If currency is not WETH: ensure lower tick is less than upper tick and satisfies the 200 tick spacing requirement for 1% Uniswap V3 pools\n",
    "        if (currency != WETH && (tickLower_ >= LP_TICK_UPPER || tickLower_ % 200 != 0)) {\n",
    "            revert InvalidCurrencyLowerTick();\n",
    "        }\n",
    "\n",
    "        // Sort the token addresses\n",
    "        address token0 = address(this) < currency ? address(this) : currency;\n",
    "        address token1 = address(this) < currency ? currency : address(this);\n",
    "\n",
    "        // If the coin is token0\n",
    "        bool isCoinToken0 = token0 == address(this);\n",
    "\n",
    "        // Determine the tick values\n",
    "        int24 tickLower = isCoinToken0 ? tickLower_ : -LP_TICK_UPPER;\n",
    "        int24 tickUpper = isCoinToken0 ? LP_TICK_UPPER : -tickLower_;\n",
    "\n",
    "        // Calculate the starting price for the pool\n",
    "        uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(isCoinToken0 ? tickLower : tickUpper);\n",
    "\n",
    "        // Determine the initial liquidity amounts\n",
    "        uint256 amount0 = isCoinToken0 ? POOL_LAUNCH_SUPPLY : 0;\n",
    "        uint256 amount1 = isCoinToken0 ? 0 : POOL_LAUNCH_SUPPLY;\n",
    "\n",
    "        // Create and initialize the pool\n",
    "        poolAddress = INonfungiblePositionManager(nonfungiblePositionManager).createAndInitializePoolIfNecessary(token0, token1, LP_FEE, sqrtPriceX96);\n",
    "\n",
    "        // Construct the LP data\n",
    "        INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager.MintParams({\n",
    "            token0: token0,\n",
    "            token1: token1,\n",
    "            fee: LP_FEE,\n",
    "            tickLower: tickLower,\n",
    "            tickUpper: tickUpper,\n",
    "            amount0Desired: amount0,\n",
    "            amount1Desired: amount1,\n",
    "            amount0Min: 0,\n",
    "            amount1Min: 0,\n",
    "            recipient: address(this),\n",
    "            deadline: block.timestamp\n",
    "        });\n",
    "\n",
    "        // Mint the LP\n",
    "        (lpTokenId, , , ) = INonfungiblePositionManager(nonfungiblePositionManager).mint(params);\n",
    "    }\n",
    "\n",
    "    /// @dev Handles incoming currency transfers for buy orders; if WETH is the currency the caller has the option to send native-ETH\n",
    "    /// @param orderSize The total size of the order in the currency\n",
    "    /// @param trueOrderSize The actual amount being used for the swap after fees\n",
    "    function _handleIncomingCurrency(uint256 orderSize, uint256 trueOrderSize) internal {\n",
    "        if (currency == WETH && msg.value > 0) {\n",
    "            if (msg.value != orderSize) {\n",
    "                revert EthAmountMismatch();\n",
    "            }\n",
    "\n",
    "            if (msg.value < MIN_ORDER_SIZE) {\n",
    "                revert EthAmountTooSmall();\n",
    "            }\n",
    "\n",
    "            IWETH(WETH).deposit{value: trueOrderSize}();\n",
    "            IWETH(WETH).approve(swapRouter, trueOrderSize);\n",
    "        } else {\n",
    "            // Ensure ETH is not sent with a non-ETH pair\n",
    "            if (msg.value != 0) {\n",
    "                revert EthTransferInvalid();\n",
    "            }\n",
    "\n",
    "            uint256 beforeBalance = IERC20(currency).balanceOf(address(this));\n",
    "            IERC20(currency).safeTransferFrom(msg.sender, address(this), orderSize);\n",
    "            uint256 afterBalance = IERC20(currency).balanceOf(address(this));\n",
    "\n",
    "            if ((afterBalance - beforeBalance) != orderSize) {\n",
    "                revert ERC20TransferAmountMismatch();\n",
    "            }\n",
    "\n",
    "            IERC20(currency).approve(swapRouter, trueOrderSize);\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @dev Handles sending ETH and ERC20 payouts and refunds to recipients\n",
    "    /// @param orderPayout The amount of currency to pay out\n",
    "    /// @param recipient The address to receive the payout\n",
    "    function _handlePayout(uint256 orderPayout, address recipient) internal {\n",
    "        if (currency == WETH) {\n",
    "            Address.sendValue(payable(recipient), orderPayout);\n",
    "        } else {\n",
    "            IERC20(currency).safeTransfer(recipient, orderPayout);\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @dev Handles calculating and depositing fees to an escrow protocol rewards contract\n",
    "    function _handleTradeRewards(uint256 totalValue, address _tradeReferrer) internal {\n",
    "        if (_tradeReferrer == address(0)) {\n",
    "            _tradeReferrer = protocolRewardRecipient;\n",
    "        }\n",
    "\n",
    "        uint256 tokenCreatorFee = _calculateReward(totalValue, TOKEN_CREATOR_FEE_BPS);\n",
    "        uint256 platformReferrerFee = _calculateReward(totalValue, PLATFORM_REFERRER_FEE_BPS);\n",
    "        uint256 tradeReferrerFee = _calculateReward(totalValue, TRADE_REFERRER_FEE_BPS);\n",
    "        uint256 protocolFee = totalValue - tokenCreatorFee - platformReferrerFee - tradeReferrerFee;\n",
    "\n",
    "        if (currency == WETH) {\n",
    "            address[] memory recipients = new address[](4);\n",
    "            uint256[] memory amounts = new uint256[](4);\n",
    "            bytes4[] memory reasons = new bytes4[](4);\n",
    "\n",
    "            recipients[0] = payoutRecipient;\n",
    "            amounts[0] = tokenCreatorFee;\n",
    "            reasons[0] = bytes4(keccak256(\"COIN_CREATOR_REWARD\"));\n",
    "\n",
    "            recipients[1] = platformReferrer;\n",
    "            amounts[1] = platformReferrerFee;\n",
    "            reasons[1] = bytes4(keccak256(\"COIN_PLATFORM_REFERRER_REWARD\"));\n",
    "\n",
    "            recipients[2] = _tradeReferrer;\n",
    "            amounts[2] = tradeReferrerFee;\n",
    "            reasons[2] = bytes4(keccak256(\"COIN_TRADE_REFERRER_REWARD\"));\n",
    "\n",
    "            recipients[3] = protocolRewardRecipient;\n",
    "            amounts[3] = protocolFee;\n",
    "            reasons[3] = bytes4(keccak256(\"COIN_PROTOCOL_REWARD\"));\n",
    "\n",
    "            IProtocolRewards(protocolRewards).depositBatch{value: totalValue}(recipients, amounts, reasons, \"\");\n",
    "        }\n",
    "\n",
    "        if (currency != WETH) {\n",
    "            IERC20(currency).safeTransfer(payoutRecipient, tokenCreatorFee);\n",
    "            IERC20(currency).safeTransfer(platformReferrer, platformReferrerFee);\n",
    "            IERC20(currency).safeTransfer(_tradeReferrer, tradeReferrerFee);\n",
    "            IERC20(currency).safeTransfer(protocolRewardRecipient, protocolFee);\n",
    "        }\n",
    "\n",
    "        emit CoinTradeRewards(\n",
    "            payoutRecipient,\n",
    "            platformReferrer,\n",
    "            _tradeReferrer,\n",
    "            protocolRewardRecipient,\n",
    "            tokenCreatorFee,\n",
    "            platformReferrerFee,\n",
    "            tradeReferrerFee,\n",
    "            protocolFee,\n",
    "            currency\n",
    "        );\n",
    "    }\n",
    "\n",
    "    function _handleMarketRewards() internal returns (MarketRewards memory) {\n",
    "        INonfungiblePositionManager.CollectParams memory params = INonfungiblePositionManager.CollectParams({\n",
    "            tokenId: lpTokenId,\n",
    "            recipient: address(this),\n",
    "            amount0Max: type(uint128).max,\n",
    "            amount1Max: type(uint128).max\n",
    "        });\n",
    "\n",
    "        (uint256 totalAmountToken0, uint256 totalAmountToken1) = INonfungiblePositionManager(nonfungiblePositionManager).collect(params);\n",
    "\n",
    "        address token0 = currency < address(this) ? currency : address(this);\n",
    "        address token1 = currency < address(this) ? address(this) : currency;\n",
    "\n",
    "        MarketRewards memory rewards;\n",
    "\n",
    "        rewards = _transferMarketRewards(token0, totalAmountToken0, rewards);\n",
    "        rewards = _transferMarketRewards(token1, totalAmountToken1, rewards);\n",
    "\n",
    "        emit CoinMarketRewards(payoutRecipient, platformReferrer, protocolRewardRecipient, currency, rewards);\n",
    "\n",
    "        return rewards;\n",
    "    }\n",
    "\n",
    "    function _transferMarketRewards(address token, uint256 totalAmount, MarketRewards memory rewards) internal returns (MarketRewards memory) {\n",
    "        if (totalAmount > 0) {\n",
    "            uint256 creatorPayout = _calculateReward(totalAmount, CREATOR_MARKET_REWARD_BPS);\n",
    "            uint256 platformReferrerPayout = _calculateReward(totalAmount, PLATFORM_REFERRER_MARKET_REWARD_BPS);\n",
    "            uint256 protocolPayout = totalAmount - creatorPayout - platformReferrerPayout;\n",
    "\n",
    "            if (token == WETH) {\n",
    "                IWETH(WETH).withdraw(totalAmount);\n",
    "\n",
    "                rewards.totalAmountCurrency = totalAmount;\n",
    "                rewards.creatorPayoutAmountCurrency = creatorPayout;\n",
    "                rewards.platformReferrerAmountCurrency = platformReferrerPayout;\n",
    "                rewards.protocolAmountCurrency = protocolPayout;\n",
    "\n",
    "                address[] memory recipients = new address[](3);\n",
    "                recipients[0] = payoutRecipient;\n",
    "                recipients[1] = platformReferrer;\n",
    "                recipients[2] = protocolRewardRecipient;\n",
    "\n",
    "                uint256[] memory amounts = new uint256[](3);\n",
    "                amounts[0] = rewards.creatorPayoutAmountCurrency;\n",
    "                amounts[1] = rewards.platformReferrerAmountCurrency;\n",
    "                amounts[2] = rewards.protocolAmountCurrency;\n",
    "\n",
    "                bytes4[] memory reasons = new bytes4[](3);\n",
    "                reasons[0] = bytes4(keccak256(\"COIN_CREATOR_MARKET_REWARD\"));\n",
    "                reasons[1] = bytes4(keccak256(\"COIN_PLATFORM_REFERRER_MARKET_REWARD\"));\n",
    "                reasons[2] = bytes4(keccak256(\"COIN_PROTOCOL_MARKET_REWARD\"));\n",
    "\n",
    "                IProtocolRewards(protocolRewards).depositBatch{value: totalAmount}(recipients, amounts, reasons, \"\");\n",
    "            } else if (token == address(this)) {\n",
    "                rewards.totalAmountCoin = totalAmount;\n",
    "                rewards.creatorPayoutAmountCoin = creatorPayout;\n",
    "                rewards.platformReferrerAmountCoin = platformReferrerPayout;\n",
    "                rewards.protocolAmountCoin = protocolPayout;\n",
    "\n",
    "                _transfer(address(this), payoutRecipient, rewards.creatorPayoutAmountCoin);\n",
    "                _transfer(address(this), platformReferrer, rewards.platformReferrerAmountCoin);\n",
    "                _transfer(address(this), protocolRewardRecipient, rewards.protocolAmountCoin);\n",
    "            } else {\n",
    "                rewards.totalAmountCurrency = totalAmount;\n",
    "                rewards.creatorPayoutAmountCurrency = creatorPayout;\n",
    "                rewards.platformReferrerAmountCurrency = platformReferrerPayout;\n",
    "                rewards.protocolAmountCurrency = protocolPayout;\n",
    "\n",
    "                IERC20(currency).safeTransfer(payoutRecipient, creatorPayout);\n",
    "                IERC20(currency).safeTransfer(platformReferrer, platformReferrerPayout);\n",
    "                IERC20(currency).safeTransfer(protocolRewardRecipient, protocolPayout);\n",
    "            }\n",
    "        }\n",
    "\n",
    "        return rewards;\n",
    "    }\n",
    "\n",
    "    /// @dev Utility for computing amounts in basis points.\n",
    "    function _calculateReward(uint256 amount, uint256 bps) internal pure returns (uint256) {\n",
    "        return (amount * bps) / 10_000;\n",
    "    }\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "2529e094-c5b0-4e2b-a58d-64a990a23035",
   "metadata": {},
   "outputs": [
    {
     "ename": "SyntaxError",
     "evalue": "invalid syntax (1836874139.py, line 1)",
     "output_type": "error",
     "traceback": [
      "\u001b[0;36m  Cell \u001b[0;32mIn[1], line 1\u001b[0;36m\u001b[0m\n\u001b[0;31m    // SPDX-License-Identifier: MIT\u001b[0m\n\u001b[0m    ^\u001b[0m\n\u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m invalid syntax\n"
     ]
    }
   ],
   "source": [
    "// SPDX-License-Identifier: MIT\n",
    "pragma solidity ^0.8.23;\n",
    "\n",
    "import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n",
    "import {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n",
    "import {ICoin} from \"./interfaces/ICoin.sol\";\n",
    "import {ICoinComments} from \"./interfaces/ICoinComments.sol\";\n",
    "import {IERC7572} from \"./interfaces/IERC7572.sol\";\n",
    "import {INonfungiblePositionManager} from \"./interfaces/INonfungiblePositionManager.sol\";\n",
    "import {IUniswapV3Pool} from \"./interfaces/IUniswapV3Pool.sol\";\n",
    "import {ISwapRouter} from \"./interfaces/ISwapRouter.sol\";\n",
    "import {IProtocolRewards} from \"./interfaces/IProtocolRewards.sol\";\n",
    "import {IWETH} from \"./interfaces/IWETH.sol\";\n",
    "\n",
    "import {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n",
    "import {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\n",
    "import {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n",
    "import {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n",
    "import {ContractVersionBase} from \"./version/ContractVersionBase.sol\";\n",
    "import {CoinConstants} from \"./utils/CoinConstants.sol\";\n",
    "import {MultiOwnable} from \"./utils/MultiOwnable.sol\";\n",
    "import {TickMath} from \"./utils/TickMath.sol\";\n",
    "\n",
    "/*\n",
    "     $$$$$$\\   $$$$$$\\  $$$$$$\\ $$\\   $$\\ \n",
    "    $$  __$$\\ $$  __$$\\ \\_$$  _|$$$\\  $$ |\n",
    "    $$ /  \\__|$$ /  $$ |  $$ |  $$$$\\ $$ |\n",
    "    $$ |      $$ |  $$ |  $$ |  $$ $$\\$$ |\n",
    "    $$ |      $$ |  $$ |  $$ |  $$ \\$$$$ |\n",
    "    $$ |  $$\\ $$ |  $$ |  $$ |  $$ |\\$$$ |\n",
    "    \\$$$$$$  | $$$$$$  |$$$$$$\\ $$ | \\$$ |\n",
    "     \\______/  \\______/ \\______|\\__|  \\__|\n",
    "*/\n",
    "contract Coin is ICoin, CoinConstants, ContractVersionBase, ERC20PermitUpgradeable, MultiOwnable, ReentrancyGuardUpgradeable {\n",
    "    using SafeERC20 for IERC20;\n",
    "\n",
    "    address public immutable WETH;\n",
    "    address public immutable nonfungiblePositionManager;\n",
    "    address public immutable swapRouter;\n",
    "    address public immutable protocolRewards;\n",
    "    address public immutable protocolRewardRecipient;\n",
    "\n",
    "    address public payoutRecipient;\n",
    "    address public platformReferrer;\n",
    "    address public poolAddress;\n",
    "    address public currency;\n",
    "    uint256 public lpTokenId;\n",
    "    string public tokenURI;\n",
    "\n",
    "    constructor(\n",
    "        address _protocolRewardRecipient,\n",
    "        address _protocolRewards,\n",
    "        address _weth,\n",
    "        address _nonfungiblePositionManager,\n",
    "        address _swapRouter\n",
    "    ) initializer {\n",
    "        if (_protocolRewardRecipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_protocolRewards == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_weth == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_nonfungiblePositionManager == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_swapRouter == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        protocolRewardRecipient = _protocolRewardRecipient;\n",
    "        protocolRewards = _protocolRewards;\n",
    "        WETH = _weth;\n",
    "        nonfungiblePositionManager = _nonfungiblePositionManager;\n",
    "        swapRouter = _swapRouter;\n",
    "    }\n",
    "\n",
    "    /// @notice Initializes a new coin\n",
    "    /// @param payoutRecipient_ The address of the coin creator\n",
    "    /// @param tokenURI_ The metadata URI\n",
    "    /// @param name_ The coin name\n",
    "    /// @param symbol_ The coin symbol\n",
    "    /// @param platformReferrer_ The address of the platform referrer\n",
    "    /// @param currency_ The address of the currency\n",
    "    /// @param tickLower_ The tick lower for the Uniswap V3 pool; ignored for ETH/WETH\n",
    "    function initialize(\n",
    "        address payoutRecipient_,\n",
    "        address[] memory owners_,\n",
    "        string memory tokenURI_,\n",
    "        string memory name_,\n",
    "        string memory symbol_,\n",
    "        address platformReferrer_,\n",
    "        address currency_,\n",
    "        int24 tickLower_\n",
    "    ) public initializer {\n",
    "        // Validate the creation parameters\n",
    "        if (payoutRecipient_ == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        // Set base contract state\n",
    "        __ERC20_init(name_, symbol_);\n",
    "        __ERC20Permit_init(name_);\n",
    "        __MultiOwnable_init(owners_);\n",
    "        __ReentrancyGuard_init();\n",
    "\n",
    "        // Set mutable state\n",
    "        _setPayoutRecipient(payoutRecipient_);\n",
    "        _setContractURI(tokenURI_);\n",
    "\n",
    "        // Set immutable state\n",
    "        platformReferrer = platformReferrer_ == address(0) ? protocolRewardRecipient : platformReferrer_;\n",
    "        currency = currency_ == address(0) ? WETH : currency_;\n",
    "\n",
    "        // Mint the total supply\n",
    "        _mint(address(this), MAX_TOTAL_SUPPLY);\n",
    "\n",
    "        // Distribute the creator launch reward\n",
    "        _transfer(address(this), payoutRecipient, CREATOR_LAUNCH_REWARD);\n",
    "\n",
    "        // Approve the transfer of the remaining supply to the pool\n",
    "        IERC20(address(this)).safeIncreaseAllowance(address(nonfungiblePositionManager), POOL_LAUNCH_SUPPLY);\n",
    "\n",
    "        // Deploy the pool\n",
    "        _deployPool(tickLower_);\n",
    "    }\n",
    "\n",
    "    /// @notice Executes a buy order\n",
    "    /// @param recipient The recipient address of the coins\n",
    "    /// @param orderSize The amount of coins to buy\n",
    "    /// @param tradeReferrer The address of the trade referrer\n",
    "    /// @param sqrtPriceLimitX96 The price limit for Uniswap V3 pool swap\n",
    "    function buy(\n",
    "        address recipient,\n",
    "        uint256 orderSize,\n",
    "        uint256 minAmountOut,\n",
    "        uint160 sqrtPriceLimitX96,\n",
    "        address tradeReferrer\n",
    "    ) public payable nonReentrant returns (uint256, uint256) {\n",
    "        // Ensure the recipient is not the zero address\n",
    "        if (recipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        // Calculate the trade reward\n",
    "        uint256 tradeReward = _calculateReward(orderSize, TOTAL_FEE_BPS);\n",
    "\n",
    "        // Calculate the remaining size\n",
    "        uint256 trueOrderSize = orderSize - tradeReward;\n",
    "\n",
    "        // Handle incoming currency\n",
    "        _handleIncomingCurrency(orderSize, trueOrderSize);\n",
    "\n",
    "        // Set up the swap parameters\n",
    "        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n",
    "            tokenIn: currency,\n",
    "            tokenOut: address(this),\n",
    "            fee: LP_FEE,\n",
    "            recipient: recipient,\n",
    "            amountIn: trueOrderSize,\n",
    "            amountOutMinimum: minAmountOut,\n",
    "            sqrtPriceLimitX96: sqrtPriceLimitX96\n",
    "        });\n",
    "\n",
    "        // Execute the swap\n",
    "        uint256 amountOut = ISwapRouter(swapRouter).exactInputSingle(params);\n",
    "\n",
    "        _handleTradeRewards(tradeReward, tradeReferrer);\n",
    "\n",
    "        _handleMarketRewards();\n",
    "\n",
    "        emit CoinBuy(msg.sender, recipient, tradeReferrer, amountOut, currency, tradeReward, trueOrderSize);\n",
    "\n",
    "        return (orderSize, amountOut);\n",
    "    }\n",
    "\n",
    "    /// @notice Executes a sell order\n",
    "    /// @param recipient The recipient of the currency\n",
    "    /// @param orderSize The amount of coins to sell\n",
    "    /// @param minAmountOut The minimum amount of currency to receive\n",
    "    /// @param sqrtPriceLimitX96 The price limit for the swap\n",
    "    /// @param tradeReferrer The address of the trade referrer\n",
    "    function sell(\n",
    "        address recipient,\n",
    "        uint256 orderSize,\n",
    "        uint256 minAmountOut,\n",
    "        uint160 sqrtPriceLimitX96,\n",
    "        address tradeReferrer\n",
    "    ) public nonReentrant returns (uint256, uint256) {\n",
    "        // Ensure the recipient is not the zero address\n",
    "        if (recipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        // Record the coin balance of this contract before the swap\n",
    "        uint256 beforeCoinBalance = balanceOf(address(this));\n",
    "\n",
    "        // Transfer the coins from the seller to this contract\n",
    "        transfer(address(this), orderSize);\n",
    "\n",
    "        // Approve the Uniswap V3 swap router\n",
    "        this.approve(swapRouter, orderSize);\n",
    "\n",
    "        // Set the swap parameters\n",
    "        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n",
    "            tokenIn: address(this),\n",
    "            tokenOut: currency,\n",
    "            fee: LP_FEE,\n",
    "            recipient: address(this),\n",
    "            amountIn: orderSize,\n",
    "            amountOutMinimum: minAmountOut,\n",
    "            sqrtPriceLimitX96: sqrtPriceLimitX96\n",
    "        });\n",
    "\n",
    "        // Execute the swap\n",
    "        uint256 amountOut = ISwapRouter(swapRouter).exactInputSingle(params);\n",
    "\n",
    "        // Record the coin balance of this contract after the swap\n",
    "        uint256 afterCoinBalance = balanceOf(address(this));\n",
    "\n",
    "        // If the swap was partially executed:\n",
    "        if (afterCoinBalance > beforeCoinBalance) {\n",
    "            // Calculate the refund\n",
    "            uint256 coinRefund = afterCoinBalance - beforeCoinBalance;\n",
    "\n",
    "            // Update the order size\n",
    "            orderSize -= coinRefund;\n",
    "\n",
    "            // Transfer the refund back to the seller\n",
    "            _transfer(address(this), recipient, coinRefund);\n",
    "        }\n",
    "\n",
    "        // If currency is WETH, convert to ETH\n",
    "        if (currency == WETH) {\n",
    "            IWETH(WETH).withdraw(amountOut);\n",
    "        }\n",
    "\n",
    "        // Calculate the trade reward\n",
    "        uint256 tradeReward = _calculateReward(amountOut, TOTAL_FEE_BPS);\n",
    "\n",
    "        // Calculate the payout after the fee\n",
    "        uint256 payoutSize = amountOut - tradeReward;\n",
    "\n",
    "        _handlePayout(payoutSize, recipient);\n",
    "\n",
    "        _handleTradeRewards(tradeReward, tradeReferrer);\n",
    "\n",
    "        _handleMarketRewards();\n",
    "\n",
    "        emit CoinSell(msg.sender, recipient, tradeReferrer, orderSize, currency, tradeReward, payoutSize);\n",
    "\n",
    "        return (orderSize, payoutSize);\n",
    "    }\n",
    "\n",
    "    /// @notice Enables a user to burn their tokens\n",
    "    /// @param amount The amount of tokens to burn\n",
    "    function burn(uint256 amount) external {\n",
    "        _burn(msg.sender, amount);\n",
    "    }\n",
    "\n",
    "    /// @notice Force claim any accrued secondary rewards from the market's liquidity position.\n",
    "    /// @dev This function is a fallback, secondary rewards will be claimed automatically on each buy and sell.\n",
    "    /// @param pushEthRewards Whether to push the ETH directly to the recipients.\n",
    "    function claimSecondaryRewards(bool pushEthRewards) external nonReentrant {\n",
    "        MarketRewards memory rewards = _handleMarketRewards();\n",
    "\n",
    "        if (pushEthRewards && rewards.totalAmountCurrency > 0 && currency == WETH) {\n",
    "            IProtocolRewards(protocolRewards).withdrawFor(payoutRecipient, rewards.creatorPayoutAmountCurrency);\n",
    "            IProtocolRewards(protocolRewards).withdrawFor(platformReferrer, rewards.platformReferrerAmountCurrency);\n",
    "            IProtocolRewards(protocolRewards).withdrawFor(protocolRewardRecipient, rewards.protocolAmountCurrency);\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @notice Set the creator's payout address\n",
    "    /// @param newPayoutRecipient The new recipient address\n",
    "    function setPayoutRecipient(address newPayoutRecipient) external onlyOwner {\n",
    "        _setPayoutRecipient(newPayoutRecipient);\n",
    "    }\n",
    "\n",
    "    /// @notice Set the contract URI\n",
    "    /// @param newURI The new URI\n",
    "    function setContractURI(string memory newURI) external onlyOwner {\n",
    "        _setContractURI(newURI);\n",
    "    }\n",
    "\n",
    "    /// @notice The contract metadata\n",
    "    function contractURI() external view returns (string memory) {\n",
    "        return tokenURI;\n",
    "    }\n",
    "\n",
    "    /// @notice ERC165 interface support\n",
    "    /// @param interfaceId The interface ID to check\n",
    "    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n",
    "        return\n",
    "            interfaceId == type(ICoin).interfaceId ||\n",
    "            interfaceId == type(ICoinComments).interfaceId ||\n",
    "            interfaceId == type(IERC7572).interfaceId ||\n",
    "            interfaceId == type(IERC165).interfaceId;\n",
    "    }\n",
    "\n",
    "    /// @notice Receives ETH converted from WETH\n",
    "    receive() external payable {\n",
    "        if (msg.sender != WETH) {\n",
    "            revert OnlyWeth();\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @dev For receiving the Uniswap V3 LP NFT on market graduation.\n",
    "    function onERC721Received(address, address, uint256, bytes calldata) external view returns (bytes4) {\n",
    "        if (msg.sender != poolAddress) revert OnlyPool();\n",
    "\n",
    "        return this.onERC721Received.selector;\n",
    "    }\n",
    "\n",
    "    /// @dev No-op to allow a swap on the pool to set the correct initial price, if needed\n",
    "    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata) external {}\n",
    "\n",
    "    /// @dev Overrides ERC20's _update function to\n",
    "    ///      - Prevent transfers to the pool if the market has not graduated.\n",
    "    ///      - Emit the superset `WowTokenTransfer` event with each ERC20 transfer.\n",
    "    function _update(address from, address to, uint256 value) internal virtual override {\n",
    "        super._update(from, to, value);\n",
    "\n",
    "        emit CoinTransfer(from, to, value, balanceOf(from), balanceOf(to));\n",
    "    }\n",
    "\n",
    "    /// @dev Used to set the payout recipient on coin creation and updates\n",
    "    /// @param newPayoutRecipient The new recipient address\n",
    "    function _setPayoutRecipient(address newPayoutRecipient) internal {\n",
    "        if (newPayoutRecipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        emit CoinPayoutRecipientUpdated(msg.sender, payoutRecipient, newPayoutRecipient);\n",
    "\n",
    "        payoutRecipient = newPayoutRecipient;\n",
    "    }\n",
    "\n",
    "    /// @dev Used to set the contract URI on coin creation and updates\n",
    "    /// @param newURI The new URI\n",
    "    function _setContractURI(string memory newURI) internal {\n",
    "        emit ContractMetadataUpdated(msg.sender, newURI, name());\n",
    "        emit ContractURIUpdated();\n",
    "\n",
    "        tokenURI = newURI;\n",
    "    }\n",
    "\n",
    "    /// @dev Deploy the pool\n",
    "    function _deployPool(int24 tickLower_) internal {\n",
    "        // If WETH is the pool's currency, validate the lower tick\n",
    "        if (currency == WETH && tickLower_ < LP_TICK_LOWER_WETH) {\n",
    "            revert InvalidWethLowerTick();\n",
    "        }\n",
    "\n",
    "        // Note: This validation happens on the Uniswap pool already; reverting early here for clarity\n",
    "        // If currency is not WETH: ensure lower tick is less than upper tick and satisfies the 200 tick spacing requirement for 1% Uniswap V3 pools\n",
    "        if (currency != WETH && (tickLower_ >= LP_TICK_UPPER || tickLower_ % 200 != 0)) {\n",
    "            revert InvalidCurrencyLowerTick();\n",
    "        }\n",
    "\n",
    "        // Sort the token addresses\n",
    "        address token0 = address(this) < currency ? address(this) : currency;\n",
    "        address token1 = address(this) < currency ? currency : address(this);\n",
    "\n",
    "        // If the coin is token0\n",
    "        bool isCoinToken0 = token0 == address(this);\n",
    "\n",
    "        // Determine the tick values\n",
    "        int24 tickLower = isCoinToken0 ? tickLower_ : -LP_TICK_UPPER;\n",
    "        int24 tickUpper = isCoinToken0 ? LP_TICK_UPPER : -tickLower_;\n",
    "\n",
    "        // Calculate the starting price for the pool\n",
    "        uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(isCoinToken0 ? tickLower : tickUpper);\n",
    "\n",
    "        // Determine the initial liquidity amounts\n",
    "        uint256 amount0 = isCoinToken0 ? POOL_LAUNCH_SUPPLY : 0;\n",
    "        uint256 amount1 = isCoinToken0 ? 0 : POOL_LAUNCH_SUPPLY;\n",
    "\n",
    "        // Create and initialize the pool\n",
    "        poolAddress = INonfungiblePositionManager(nonfungiblePositionManager).createAndInitializePoolIfNecessary(token0, token1, LP_FEE, sqrtPriceX96);\n",
    "\n",
    "        // Construct the LP data\n",
    "        INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager.MintParams({\n",
    "            token0: token0,\n",
    "            token1: token1,\n",
    "            fee: LP_FEE,\n",
    "            tickLower: tickLower,\n",
    "            tickUpper: tickUpper,\n",
    "            amount0Desired: amount0,\n",
    "            amount1Desired: amount1,\n",
    "            amount0Min: 0,\n",
    "            amount1Min: 0,\n",
    "            recipient: address(this),\n",
    "            deadline: block.timestamp\n",
    "        });\n",
    "\n",
    "        // Mint the LP\n",
    "        (lpTokenId, , , ) = INonfungiblePositionManager(nonfungiblePositionManager).mint(params);\n",
    "    }\n",
    "\n",
    "    /// @dev Handles incoming currency transfers for buy orders; if WETH is the currency the caller has the option to send native-ETH\n",
    "    /// @param orderSize The total size of the order in the currency\n",
    "    /// @param trueOrderSize The actual amount being used for the swap after fees\n",
    "    function _handleIncomingCurrency(uint256 orderSize, uint256 trueOrderSize) internal {\n",
    "        if (currency == WETH && msg.value > 0) {\n",
    "            if (msg.value != orderSize) {\n",
    "                revert EthAmountMismatch();\n",
    "            }\n",
    "\n",
    "            if (msg.value < MIN_ORDER_SIZE) {\n",
    "                revert EthAmountTooSmall();\n",
    "            }\n",
    "\n",
    "            IWETH(WETH).deposit{value: trueOrderSize}();\n",
    "            IWETH(WETH).approve(swapRouter, trueOrderSize);\n",
    "        } else {\n",
    "            // Ensure ETH is not sent with a non-ETH pair\n",
    "            if (msg.value != 0) {\n",
    "                revert EthTransferInvalid();\n",
    "            }\n",
    "\n",
    "            uint256 beforeBalance = IERC20(currency).balanceOf(address(this));\n",
    "            IERC20(currency).safeTransferFrom(msg.sender, address(this), orderSize);\n",
    "            uint256 afterBalance = IERC20(currency).balanceOf(address(this));\n",
    "\n",
    "            if ((afterBalance - beforeBalance) != orderSize) {\n",
    "                revert ERC20TransferAmountMismatch();\n",
    "            }\n",
    "\n",
    "            IERC20(currency).approve(swapRouter, trueOrderSize);\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @dev Handles sending ETH and ERC20 payouts and refunds to recipients\n",
    "    /// @param orderPayout The amount of currency to pay out\n",
    "    /// @param recipient The address to receive the payout\n",
    "    function _handlePayout(uint256 orderPayout, address recipient) internal {\n",
    "        if (currency == WETH) {\n",
    "            Address.sendValue(payable(recipient), orderPayout);\n",
    "        } else {\n",
    "            IERC20(currency).safeTransfer(recipient, orderPayout);\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @dev Handles calculating and depositing fees to an escrow protocol rewards contract\n",
    "    function _handleTradeRewards(uint256 totalValue, address _tradeReferrer) internal {\n",
    "        if (_tradeReferrer == address(0)) {\n",
    "            _tradeReferrer = protocolRewardRecipient;\n",
    "        }\n",
    "\n",
    "        uint256 tokenCreatorFee = _calculateReward(totalValue, TOKEN_CREATOR_FEE_BPS);\n",
    "        uint256 platformReferrerFee = _calculateReward(totalValue, PLATFORM_REFERRER_FEE_BPS);\n",
    "        uint256 tradeReferrerFee = _calculateReward(totalValue, TRADE_REFERRER_FEE_BPS);\n",
    "        uint256 protocolFee = totalValue - tokenCreatorFee - platformReferrerFee - tradeReferrerFee;\n",
    "\n",
    "        if (currency == WETH) {\n",
    "            address[] memory recipients = new address[](4);\n",
    "            uint256[] memory amounts = new uint256[](4);\n",
    "            bytes4[] memory reasons = new bytes4[](4);\n",
    "\n",
    "            recipients[0] = payoutRecipient;\n",
    "            amounts[0] = tokenCreatorFee;\n",
    "            reasons[0] = bytes4(keccak256(\"COIN_CREATOR_REWARD\"));\n",
    "\n",
    "            recipients[1] = platformReferrer;\n",
    "            amounts[1] = platformReferrerFee;\n",
    "            reasons[1] = bytes4(keccak256(\"COIN_PLATFORM_REFERRER_REWARD\"));\n",
    "\n",
    "            recipients[2] = _tradeReferrer;\n",
    "            amounts[2] = tradeReferrerFee;\n",
    "            reasons[2] = bytes4(keccak256(\"COIN_TRADE_REFERRER_REWARD\"));\n",
    "\n",
    "            recipients[3] = protocolRewardRecipient;\n",
    "            amounts[3] = protocolFee;\n",
    "            reasons[3] = bytes4(keccak256(\"COIN_PROTOCOL_REWARD\"));\n",
    "\n",
    "            IProtocolRewards(protocolRewards).depositBatch{value: totalValue}(recipients, amounts, reasons, \"\");\n",
    "        }\n",
    "\n",
    "        if (currency != WETH) {\n",
    "            IERC20(currency).safeTransfer(payoutRecipient, tokenCreatorFee);\n",
    "            IERC20(currency).safeTransfer(platformReferrer, platformReferrerFee);\n",
    "            IERC20(currency).safeTransfer(_tradeReferrer, tradeReferrerFee);\n",
    "            IERC20(currency).safeTransfer(protocolRewardRecipient, protocolFee);\n",
    "        }\n",
    "\n",
    "        emit CoinTradeRewards(\n",
    "            payoutRecipient,\n",
    "            platformReferrer,\n",
    "            _tradeReferrer,\n",
    "            protocolRewardRecipient,\n",
    "            tokenCreatorFee,\n",
    "            platformReferrerFee,\n",
    "            tradeReferrerFee,\n",
    "            protocolFee,\n",
    "            currency\n",
    "        );\n",
    "    }\n",
    "\n",
    "    function _handleMarketRewards() internal returns (MarketRewards memory) {\n",
    "        INonfungiblePositionManager.CollectParams memory params = INonfungiblePositionManager.CollectParams({\n",
    "            tokenId: lpTokenId,\n",
    "            recipient: address(this),\n",
    "            amount0Max: type(uint128).max,\n",
    "            amount1Max: type(uint128).max\n",
    "        });\n",
    "\n",
    "        (uint256 totalAmountToken0, uint256 totalAmountToken1) = INonfungiblePositionManager(nonfungiblePositionManager).collect(params);\n",
    "\n",
    "        address token0 = currency < address(this) ? currency : address(this);\n",
    "        address token1 = currency < address(this) ? address(this) : currency;\n",
    "\n",
    "        MarketRewards memory rewards;\n",
    "\n",
    "        rewards = _transferMarketRewards(token0, totalAmountToken0, rewards);\n",
    "        rewards = _transferMarketRewards(token1, totalAmountToken1, rewards);\n",
    "\n",
    "        emit CoinMarketRewards(payoutRecipient, platformReferrer, protocolRewardRecipient, currency, rewards);\n",
    "\n",
    "        return rewards;\n",
    "    }\n",
    "\n",
    "    function _transferMarketRewards(address token, uint256 totalAmount, MarketRewards memory rewards) internal returns (MarketRewards memory) {\n",
    "        if (totalAmount > 0) {\n",
    "            uint256 creatorPayout = _calculateReward(totalAmount, CREATOR_MARKET_REWARD_BPS);\n",
    "            uint256 platformReferrerPayout = _calculateReward(totalAmount, PLATFORM_REFERRER_MARKET_REWARD_BPS);\n",
    "            uint256 protocolPayout = totalAmount - creatorPayout - platformReferrerPayout;\n",
    "\n",
    "            if (token == WETH) {\n",
    "                IWETH(WETH).withdraw(totalAmount);\n",
    "\n",
    "                rewards.totalAmountCurrency = totalAmount;\n",
    "                rewards.creatorPayoutAmountCurrency = creatorPayout;\n",
    "                rewards.platformReferrerAmountCurrency = platformReferrerPayout;\n",
    "                rewards.protocolAmountCurrency = protocolPayout;\n",
    "\n",
    "                address[] memory recipients = new address[](3);\n",
    "                recipients[0] = payoutRecipient;\n",
    "                recipients[1] = platformReferrer;\n",
    "                recipients[2] = protocolRewardRecipient;\n",
    "\n",
    "                uint256[] memory amounts = new uint256[](3);\n",
    "                amounts[0] = rewards.creatorPayoutAmountCurrency;\n",
    "                amounts[1] = rewards.platformReferrerAmountCurrency;\n",
    "                amounts[2] = rewards.protocolAmountCurrency;\n",
    "\n",
    "                bytes4[] memory reasons = new bytes4[](3);\n",
    "                reasons[0] = bytes4(keccak256(\"COIN_CREATOR_MARKET_REWARD\"));\n",
    "                reasons[1] = bytes4(keccak256(\"COIN_PLATFORM_REFERRER_MARKET_REWARD\"));\n",
    "                reasons[2] = bytes4(keccak256(\"COIN_PROTOCOL_MARKET_REWARD\"));\n",
    "\n",
    "                IProtocolRewards(protocolRewards).depositBatch{value: totalAmount}(recipients, amounts, reasons, \"\");\n",
    "            } else if (token == address(this)) {\n",
    "                rewards.totalAmountCoin = totalAmount;\n",
    "                rewards.creatorPayoutAmountCoin = creatorPayout;\n",
    "                rewards.platformReferrerAmountCoin = platformReferrerPayout;\n",
    "                rewards.protocolAmountCoin = protocolPayout;\n",
    "\n",
    "                _transfer(address(this), payoutRecipient, rewards.creatorPayoutAmountCoin);\n",
    "                _transfer(address(this), platformReferrer, rewards.platformReferrerAmountCoin);\n",
    "                _transfer(address(this), protocolRewardRecipient, rewards.protocolAmountCoin);\n",
    "            } else {\n",
    "                rewards.totalAmountCurrency = totalAmount;\n",
    "                rewards.creatorPayoutAmountCurrency = creatorPayout;\n",
    "                rewards.platformReferrerAmountCurrency = platformReferrerPayout;\n",
    "                rewards.protocolAmountCurrency = protocolPayout;\n",
    "\n",
    "                IERC20(currency).safeTransfer(payoutRecipient, creatorPayout);\n",
    "                IERC20(currency).safeTransfer(platformReferrer, platformReferrerPayout);\n",
    "                IERC20(currency).safeTransfer(protocolRewardRecipient, protocolPayout);\n",
    "            }\n",
    "        }\n",
    "\n",
    "        return rewards;\n",
    "    }\n",
    "\n",
    "    /// @dev Utility for computing amounts in basis points.\n",
    "    function _calculateReward(uint256 amount, uint256 bps) internal pure returns (uint256) {\n",
    "        return (amount * bps) / 10_000;\n",
    "    }\n",
    "}// SPDX-License-Identifier: MIT\n",
    "pragma solidity ^0.8.23;\n",
    "\n",
    "import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n",
    "import {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n",
    "import {ICoin} from \"./interfaces/ICoin.sol\";\n",
    "import {ICoinComments} from \"./interfaces/ICoinComments.sol\";\n",
    "import {IERC7572} from \"./interfaces/IERC7572.sol\";\n",
    "import {INonfungiblePositionManager} from \"./interfaces/INonfungiblePositionManager.sol\";\n",
    "import {IUniswapV3Pool} from \"./interfaces/IUniswapV3Pool.sol\";\n",
    "import {ISwapRouter} from \"./interfaces/ISwapRouter.sol\";\n",
    "import {IProtocolRewards} from \"./interfaces/IProtocolRewards.sol\";\n",
    "import {IWETH} from \"./interfaces/IWETH.sol\";\n",
    "\n",
    "import {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n",
    "import {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\n",
    "import {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n",
    "import {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n",
    "import {ContractVersionBase} from \"./version/ContractVersionBase.sol\";\n",
    "import {CoinConstants} from \"./utils/CoinConstants.sol\";\n",
    "import {MultiOwnable} from \"./utils/MultiOwnable.sol\";\n",
    "import {TickMath} from \"./utils/TickMath.sol\";\n",
    "\n",
    "/*\n",
    "     $$$$$$\\   $$$$$$\\  $$$$$$\\ $$\\   $$\\ \n",
    "    $$  __$$\\ $$  __$$\\ \\_$$  _|$$$\\  $$ |\n",
    "    $$ /  \\__|$$ /  $$ |  $$ |  $$$$\\ $$ |\n",
    "    $$ |      $$ |  $$ |  $$ |  $$ $$\\$$ |\n",
    "    $$ |      $$ |  $$ |  $$ |  $$ \\$$$$ |\n",
    "    $$ |  $$\\ $$ |  $$ |  $$ |  $$ |\\$$$ |\n",
    "    \\$$$$$$  | $$$$$$  |$$$$$$\\ $$ | \\$$ |\n",
    "     \\______/  \\______/ \\______|\\__|  \\__|\n",
    "*/\n",
    "contract Coin is ICoin, CoinConstants, ContractVersionBase, ERC20PermitUpgradeable, MultiOwnable, ReentrancyGuardUpgradeable {\n",
    "    using SafeERC20 for IERC20;\n",
    "\n",
    "    address public immutable WETH;\n",
    "    address public immutable nonfungiblePositionManager;\n",
    "    address public immutable swapRouter;\n",
    "    address public immutable protocolRewards;\n",
    "    address public immutable protocolRewardRecipient;\n",
    "\n",
    "    address public payoutRecipient;\n",
    "    address public platformReferrer;\n",
    "    address public poolAddress;\n",
    "    address public currency;\n",
    "    uint256 public lpTokenId;\n",
    "    string public tokenURI;\n",
    "\n",
    "    constructor(\n",
    "        address _protocolRewardRecipient,\n",
    "        address _protocolRewards,\n",
    "        address _weth,\n",
    "        address _nonfungiblePositionManager,\n",
    "        address _swapRouter\n",
    "    ) initializer {\n",
    "        if (_protocolRewardRecipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_protocolRewards == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_weth == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_nonfungiblePositionManager == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "        if (_swapRouter == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        protocolRewardRecipient = _protocolRewardRecipient;\n",
    "        protocolRewards = _protocolRewards;\n",
    "        WETH = _weth;\n",
    "        nonfungiblePositionManager = _nonfungiblePositionManager;\n",
    "        swapRouter = _swapRouter;\n",
    "    }\n",
    "\n",
    "    /// @notice Initializes a new coin\n",
    "    /// @param payoutRecipient_ The address of the coin creator\n",
    "    /// @param tokenURI_ The metadata URI\n",
    "    /// @param name_ The coin name\n",
    "    /// @param symbol_ The coin symbol\n",
    "    /// @param platformReferrer_ The address of the platform referrer\n",
    "    /// @param currency_ The address of the currency\n",
    "    /// @param tickLower_ The tick lower for the Uniswap V3 pool; ignored for ETH/WETH\n",
    "    function initialize(\n",
    "        address payoutRecipient_,\n",
    "        address[] memory owners_,\n",
    "        string memory tokenURI_,\n",
    "        string memory name_,\n",
    "        string memory symbol_,\n",
    "        address platformReferrer_,\n",
    "        address currency_,\n",
    "        int24 tickLower_\n",
    "    ) public initializer {\n",
    "        // Validate the creation parameters\n",
    "        if (payoutRecipient_ == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        // Set base contract state\n",
    "        __ERC20_init(name_, symbol_);\n",
    "        __ERC20Permit_init(name_);\n",
    "        __MultiOwnable_init(owners_);\n",
    "        __ReentrancyGuard_init();\n",
    "\n",
    "        // Set mutable state\n",
    "        _setPayoutRecipient(payoutRecipient_);\n",
    "        _setContractURI(tokenURI_);\n",
    "\n",
    "        // Set immutable state\n",
    "        platformReferrer = platformReferrer_ == address(0) ? protocolRewardRecipient : platformReferrer_;\n",
    "        currency = currency_ == address(0) ? WETH : currency_;\n",
    "\n",
    "        // Mint the total supply\n",
    "        _mint(address(this), MAX_TOTAL_SUPPLY);\n",
    "\n",
    "        // Distribute the creator launch reward\n",
    "        _transfer(address(this), payoutRecipient, CREATOR_LAUNCH_REWARD);\n",
    "\n",
    "        // Approve the transfer of the remaining supply to the pool\n",
    "        IERC20(address(this)).safeIncreaseAllowance(address(nonfungiblePositionManager), POOL_LAUNCH_SUPPLY);\n",
    "\n",
    "        // Deploy the pool\n",
    "        _deployPool(tickLower_);\n",
    "    }\n",
    "\n",
    "    /// @notice Executes a buy order\n",
    "    /// @param recipient The recipient address of the coins\n",
    "    /// @param orderSize The amount of coins to buy\n",
    "    /// @param tradeReferrer The address of the trade referrer\n",
    "    /// @param sqrtPriceLimitX96 The price limit for Uniswap V3 pool swap\n",
    "    function buy(\n",
    "        address recipient,\n",
    "        uint256 orderSize,\n",
    "        uint256 minAmountOut,\n",
    "        uint160 sqrtPriceLimitX96,\n",
    "        address tradeReferrer\n",
    "    ) public payable nonReentrant returns (uint256, uint256) {\n",
    "        // Ensure the recipient is not the zero address\n",
    "        if (recipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        // Calculate the trade reward\n",
    "        uint256 tradeReward = _calculateReward(orderSize, TOTAL_FEE_BPS);\n",
    "\n",
    "        // Calculate the remaining size\n",
    "        uint256 trueOrderSize = orderSize - tradeReward;\n",
    "\n",
    "        // Handle incoming currency\n",
    "        _handleIncomingCurrency(orderSize, trueOrderSize);\n",
    "\n",
    "        // Set up the swap parameters\n",
    "        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n",
    "            tokenIn: currency,\n",
    "            tokenOut: address(this),\n",
    "            fee: LP_FEE,\n",
    "            recipient: recipient,\n",
    "            amountIn: trueOrderSize,\n",
    "            amountOutMinimum: minAmountOut,\n",
    "            sqrtPriceLimitX96: sqrtPriceLimitX96\n",
    "        });\n",
    "\n",
    "        // Execute the swap\n",
    "        uint256 amountOut = ISwapRouter(swapRouter).exactInputSingle(params);\n",
    "\n",
    "        _handleTradeRewards(tradeReward, tradeReferrer);\n",
    "\n",
    "        _handleMarketRewards();\n",
    "\n",
    "        emit CoinBuy(msg.sender, recipient, tradeReferrer, amountOut, currency, tradeReward, trueOrderSize);\n",
    "\n",
    "        return (orderSize, amountOut);\n",
    "    }\n",
    "\n",
    "    /// @notice Executes a sell order\n",
    "    /// @param recipient The recipient of the currency\n",
    "    /// @param orderSize The amount of coins to sell\n",
    "    /// @param minAmountOut The minimum amount of currency to receive\n",
    "    /// @param sqrtPriceLimitX96 The price limit for the swap\n",
    "    /// @param tradeReferrer The address of the trade referrer\n",
    "    function sell(\n",
    "        address recipient,\n",
    "        uint256 orderSize,\n",
    "        uint256 minAmountOut,\n",
    "        uint160 sqrtPriceLimitX96,\n",
    "        address tradeReferrer\n",
    "    ) public nonReentrant returns (uint256, uint256) {\n",
    "        // Ensure the recipient is not the zero address\n",
    "        if (recipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        // Record the coin balance of this contract before the swap\n",
    "        uint256 beforeCoinBalance = balanceOf(address(this));\n",
    "\n",
    "        // Transfer the coins from the seller to this contract\n",
    "        transfer(address(this), orderSize);\n",
    "\n",
    "        // Approve the Uniswap V3 swap router\n",
    "        this.approve(swapRouter, orderSize);\n",
    "\n",
    "        // Set the swap parameters\n",
    "        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n",
    "            tokenIn: address(this),\n",
    "            tokenOut: currency,\n",
    "            fee: LP_FEE,\n",
    "            recipient: address(this),\n",
    "            amountIn: orderSize,\n",
    "            amountOutMinimum: minAmountOut,\n",
    "            sqrtPriceLimitX96: sqrtPriceLimitX96\n",
    "        });\n",
    "\n",
    "        // Execute the swap\n",
    "        uint256 amountOut = ISwapRouter(swapRouter).exactInputSingle(params);\n",
    "\n",
    "        // Record the coin balance of this contract after the swap\n",
    "        uint256 afterCoinBalance = balanceOf(address(this));\n",
    "\n",
    "        // If the swap was partially executed:\n",
    "        if (afterCoinBalance > beforeCoinBalance) {\n",
    "            // Calculate the refund\n",
    "            uint256 coinRefund = afterCoinBalance - beforeCoinBalance;\n",
    "\n",
    "            // Update the order size\n",
    "            orderSize -= coinRefund;\n",
    "\n",
    "            // Transfer the refund back to the seller\n",
    "            _transfer(address(this), recipient, coinRefund);\n",
    "        }\n",
    "\n",
    "        // If currency is WETH, convert to ETH\n",
    "        if (currency == WETH) {\n",
    "            IWETH(WETH).withdraw(amountOut);\n",
    "        }\n",
    "\n",
    "        // Calculate the trade reward\n",
    "        uint256 tradeReward = _calculateReward(amountOut, TOTAL_FEE_BPS);\n",
    "\n",
    "        // Calculate the payout after the fee\n",
    "        uint256 payoutSize = amountOut - tradeReward;\n",
    "\n",
    "        _handlePayout(payoutSize, recipient);\n",
    "\n",
    "        _handleTradeRewards(tradeReward, tradeReferrer);\n",
    "\n",
    "        _handleMarketRewards();\n",
    "\n",
    "        emit CoinSell(msg.sender, recipient, tradeReferrer, orderSize, currency, tradeReward, payoutSize);\n",
    "\n",
    "        return (orderSize, payoutSize);\n",
    "    }\n",
    "\n",
    "    /// @notice Enables a user to burn their tokens\n",
    "    /// @param amount The amount of tokens to burn\n",
    "    function burn(uint256 amount) external {\n",
    "        _burn(msg.sender, amount);\n",
    "    }\n",
    "\n",
    "    /// @notice Force claim any accrued secondary rewards from the market's liquidity position.\n",
    "    /// @dev This function is a fallback, secondary rewards will be claimed automatically on each buy and sell.\n",
    "    /// @param pushEthRewards Whether to push the ETH directly to the recipients.\n",
    "    function claimSecondaryRewards(bool pushEthRewards) external nonReentrant {\n",
    "        MarketRewards memory rewards = _handleMarketRewards();\n",
    "\n",
    "        if (pushEthRewards && rewards.totalAmountCurrency > 0 && currency == WETH) {\n",
    "            IProtocolRewards(protocolRewards).withdrawFor(payoutRecipient, rewards.creatorPayoutAmountCurrency);\n",
    "            IProtocolRewards(protocolRewards).withdrawFor(platformReferrer, rewards.platformReferrerAmountCurrency);\n",
    "            IProtocolRewards(protocolRewards).withdrawFor(protocolRewardRecipient, rewards.protocolAmountCurrency);\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @notice Set the creator's payout address\n",
    "    /// @param newPayoutRecipient The new recipient address\n",
    "    function setPayoutRecipient(address newPayoutRecipient) external onlyOwner {\n",
    "        _setPayoutRecipient(newPayoutRecipient);\n",
    "    }\n",
    "\n",
    "    /// @notice Set the contract URI\n",
    "    /// @param newURI The new URI\n",
    "    function setContractURI(string memory newURI) external onlyOwner {\n",
    "        _setContractURI(newURI);\n",
    "    }\n",
    "\n",
    "    /// @notice The contract metadata\n",
    "    function contractURI() external view returns (string memory) {\n",
    "        return tokenURI;\n",
    "    }\n",
    "\n",
    "    /// @notice ERC165 interface support\n",
    "    /// @param interfaceId The interface ID to check\n",
    "    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n",
    "        return\n",
    "            interfaceId == type(ICoin).interfaceId ||\n",
    "            interfaceId == type(ICoinComments).interfaceId ||\n",
    "            interfaceId == type(IERC7572).interfaceId ||\n",
    "            interfaceId == type(IERC165).interfaceId;\n",
    "    }\n",
    "\n",
    "    /// @notice Receives ETH converted from WETH\n",
    "    receive() external payable {\n",
    "        if (msg.sender != WETH) {\n",
    "            revert OnlyWeth();\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @dev For receiving the Uniswap V3 LP NFT on market graduation.\n",
    "    function onERC721Received(address, address, uint256, bytes calldata) external view returns (bytes4) {\n",
    "        if (msg.sender != poolAddress) revert OnlyPool();\n",
    "\n",
    "        return this.onERC721Received.selector;\n",
    "    }\n",
    "\n",
    "    /// @dev No-op to allow a swap on the pool to set the correct initial price, if needed\n",
    "    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata) external {}\n",
    "\n",
    "    /// @dev Overrides ERC20's _update function to\n",
    "    ///      - Prevent transfers to the pool if the market has not graduated.\n",
    "    ///      - Emit the superset `WowTokenTransfer` event with each ERC20 transfer.\n",
    "    function _update(address from, address to, uint256 value) internal virtual override {\n",
    "        super._update(from, to, value);\n",
    "\n",
    "        emit CoinTransfer(from, to, value, balanceOf(from), balanceOf(to));\n",
    "    }\n",
    "\n",
    "    /// @dev Used to set the payout recipient on coin creation and updates\n",
    "    /// @param newPayoutRecipient The new recipient address\n",
    "    function _setPayoutRecipient(address newPayoutRecipient) internal {\n",
    "        if (newPayoutRecipient == address(0)) {\n",
    "            revert AddressZero();\n",
    "        }\n",
    "\n",
    "        emit CoinPayoutRecipientUpdated(msg.sender, payoutRecipient, newPayoutRecipient);\n",
    "\n",
    "        payoutRecipient = newPayoutRecipient;\n",
    "    }\n",
    "\n",
    "    /// @dev Used to set the contract URI on coin creation and updates\n",
    "    /// @param newURI The new URI\n",
    "    function _setContractURI(string memory newURI) internal {\n",
    "        emit ContractMetadataUpdated(msg.sender, newURI, name());\n",
    "        emit ContractURIUpdated();\n",
    "\n",
    "        tokenURI = newURI;\n",
    "    }\n",
    "\n",
    "    /// @dev Deploy the pool\n",
    "    function _deployPool(int24 tickLower_) internal {\n",
    "        // If WETH is the pool's currency, validate the lower tick\n",
    "        if (currency == WETH && tickLower_ < LP_TICK_LOWER_WETH) {\n",
    "            revert InvalidWethLowerTick();\n",
    "        }\n",
    "\n",
    "        // Note: This validation happens on the Uniswap pool already; reverting early here for clarity\n",
    "        // If currency is not WETH: ensure lower tick is less than upper tick and satisfies the 200 tick spacing requirement for 1% Uniswap V3 pools\n",
    "        if (currency != WETH && (tickLower_ >= LP_TICK_UPPER || tickLower_ % 200 != 0)) {\n",
    "            revert InvalidCurrencyLowerTick();\n",
    "        }\n",
    "\n",
    "        // Sort the token addresses\n",
    "        address token0 = address(this) < currency ? address(this) : currency;\n",
    "        address token1 = address(this) < currency ? currency : address(this);\n",
    "\n",
    "        // If the coin is token0\n",
    "        bool isCoinToken0 = token0 == address(this);\n",
    "\n",
    "        // Determine the tick values\n",
    "        int24 tickLower = isCoinToken0 ? tickLower_ : -LP_TICK_UPPER;\n",
    "        int24 tickUpper = isCoinToken0 ? LP_TICK_UPPER : -tickLower_;\n",
    "\n",
    "        // Calculate the starting price for the pool\n",
    "        uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(isCoinToken0 ? tickLower : tickUpper);\n",
    "\n",
    "        // Determine the initial liquidity amounts\n",
    "        uint256 amount0 = isCoinToken0 ? POOL_LAUNCH_SUPPLY : 0;\n",
    "        uint256 amount1 = isCoinToken0 ? 0 : POOL_LAUNCH_SUPPLY;\n",
    "\n",
    "        // Create and initialize the pool\n",
    "        poolAddress = INonfungiblePositionManager(nonfungiblePositionManager).createAndInitializePoolIfNecessary(token0, token1, LP_FEE, sqrtPriceX96);\n",
    "\n",
    "        // Construct the LP data\n",
    "        INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager.MintParams({\n",
    "            token0: token0,\n",
    "            token1: token1,\n",
    "            fee: LP_FEE,\n",
    "            tickLower: tickLower,\n",
    "            tickUpper: tickUpper,\n",
    "            amount0Desired: amount0,\n",
    "            amount1Desired: amount1,\n",
    "            amount0Min: 0,\n",
    "            amount1Min: 0,\n",
    "            recipient: address(this),\n",
    "            deadline: block.timestamp\n",
    "        });\n",
    "\n",
    "        // Mint the LP\n",
    "        (lpTokenId, , , ) = INonfungiblePositionManager(nonfungiblePositionManager).mint(params);\n",
    "    }\n",
    "\n",
    "    /// @dev Handles incoming currency transfers for buy orders; if WETH is the currency the caller has the option to send native-ETH\n",
    "    /// @param orderSize The total size of the order in the currency\n",
    "    /// @param trueOrderSize The actual amount being used for the swap after fees\n",
    "    function _handleIncomingCurrency(uint256 orderSize, uint256 trueOrderSize) internal {\n",
    "        if (currency == WETH && msg.value > 0) {\n",
    "            if (msg.value != orderSize) {\n",
    "                revert EthAmountMismatch();\n",
    "            }\n",
    "\n",
    "            if (msg.value < MIN_ORDER_SIZE) {\n",
    "                revert EthAmountTooSmall();\n",
    "            }\n",
    "\n",
    "            IWETH(WETH).deposit{value: trueOrderSize}();\n",
    "            IWETH(WETH).approve(swapRouter, trueOrderSize);\n",
    "        } else {\n",
    "            // Ensure ETH is not sent with a non-ETH pair\n",
    "            if (msg.value != 0) {\n",
    "                revert EthTransferInvalid();\n",
    "            }\n",
    "\n",
    "            uint256 beforeBalance = IERC20(currency).balanceOf(address(this));\n",
    "            IERC20(currency).safeTransferFrom(msg.sender, address(this), orderSize);\n",
    "            uint256 afterBalance = IERC20(currency).balanceOf(address(this));\n",
    "\n",
    "            if ((afterBalance - beforeBalance) != orderSize) {\n",
    "                revert ERC20TransferAmountMismatch();\n",
    "            }\n",
    "\n",
    "            IERC20(currency).approve(swapRouter, trueOrderSize);\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @dev Handles sending ETH and ERC20 payouts and refunds to recipients\n",
    "    /// @param orderPayout The amount of currency to pay out\n",
    "    /// @param recipient The address to receive the payout\n",
    "    function _handlePayout(uint256 orderPayout, address recipient) internal {\n",
    "        if (currency == WETH) {\n",
    "            Address.sendValue(payable(recipient), orderPayout);\n",
    "        } else {\n",
    "            IERC20(currency).safeTransfer(recipient, orderPayout);\n",
    "        }\n",
    "    }\n",
    "\n",
    "    /// @dev Handles calculating and depositing fees to an escrow protocol rewards contract\n",
    "    function _handleTradeRewards(uint256 totalValue, address _tradeReferrer) internal {\n",
    "        if (_tradeReferrer == address(0)) {\n",
    "            _tradeReferrer = protocolRewardRecipient;\n",
    "        }\n",
    "\n",
    "        uint256 tokenCreatorFee = _calculateReward(totalValue, TOKEN_CREATOR_FEE_BPS);\n",
    "        uint256 platformReferrerFee = _calculateReward(totalValue, PLATFORM_REFERRER_FEE_BPS);\n",
    "        uint256 tradeReferrerFee = _calculateReward(totalValue, TRADE_REFERRER_FEE_BPS);\n",
    "        uint256 protocolFee = totalValue - tokenCreatorFee - platformReferrerFee - tradeReferrerFee;\n",
    "\n",
    "        if (currency == WETH) {\n",
    "            address[] memory recipients = new address[](4);\n",
    "            uint256[] memory amounts = new uint256[](4);\n",
    "            bytes4[] memory reasons = new bytes4[](4);\n",
    "\n",
    "            recipients[0] = payoutRecipient;\n",
    "            amounts[0] = tokenCreatorFee;\n",
    "            reasons[0] = bytes4(keccak256(\"COIN_CREATOR_REWARD\"));\n",
    "\n",
    "            recipients[1] = platformReferrer;\n",
    "            amounts[1] = platformReferrerFee;\n",
    "            reasons[1] = bytes4(keccak256(\"COIN_PLATFORM_REFERRER_REWARD\"));\n",
    "\n",
    "            recipients[2] = _tradeReferrer;\n",
    "            amounts[2] = tradeReferrerFee;\n",
    "            reasons[2] = bytes4(keccak256(\"COIN_TRADE_REFERRER_REWARD\"));\n",
    "\n",
    "            recipients[3] = protocolRewardRecipient;\n",
    "            amounts[3] = protocolFee;\n",
    "            reasons[3] = bytes4(keccak256(\"COIN_PROTOCOL_REWARD\"));\n",
    "\n",
    "            IProtocolRewards(protocolRewards).depositBatch{value: totalValue}(recipients, amounts, reasons, \"\");\n",
    "        }\n",
    "\n",
    "        if (currency != WETH) {\n",
    "            IERC20(currency).safeTransfer(payoutRecipient, tokenCreatorFee);\n",
    "            IERC20(currency).safeTransfer(platformReferrer, platformReferrerFee);\n",
    "            IERC20(currency).safeTransfer(_tradeReferrer, tradeReferrerFee);\n",
    "            IERC20(currency).safeTransfer(protocolRewardRecipient, protocolFee);\n",
    "        }\n",
    "\n",
    "        emit CoinTradeRewards(\n",
    "            payoutRecipient,\n",
    "            platformReferrer,\n",
    "            _tradeReferrer,\n",
    "            protocolRewardRecipient,\n",
    "            tokenCreatorFee,\n",
    "            platformReferrerFee,\n",
    "            tradeReferrerFee,\n",
    "            protocolFee,\n",
    "            currency\n",
    "        );\n",
    "    }\n",
    "\n",
    "    function _handleMarketRewards() internal returns (MarketRewards memory) {\n",
    "        INonfungiblePositionManager.CollectParams memory params = INonfungiblePositionManager.CollectParams({\n",
    "            tokenId: lpTokenId,\n",
    "            recipient: address(this),\n",
    "            amount0Max: type(uint128).max,\n",
    "            amount1Max: type(uint128).max\n",
    "        });\n",
    "\n",
    "        (uint256 totalAmountToken0, uint256 totalAmountToken1) = INonfungiblePositionManager(nonfungiblePositionManager).collect(params);\n",
    "\n",
    "        address token0 = currency < address(this) ? currency : address(this);\n",
    "        address token1 = currency < address(this) ? address(this) : currency;\n",
    "\n",
    "        MarketRewards memory rewards;\n",
    "\n",
    "        rewards = _transferMarketRewards(token0, totalAmountToken0, rewards);\n",
    "        rewards = _transferMarketRewards(token1, totalAmountToken1, rewards);\n",
    "\n",
    "        emit CoinMarketRewards(payoutRecipient, platformReferrer, protocolRewardRecipient, currency, rewards);\n",
    "\n",
    "        return rewards;\n",
    "    }\n",
    "\n",
    "    function _transferMarketRewards(address token, uint256 totalAmount, MarketRewards memory rewards) internal returns (MarketRewards memory) {\n",
    "        if (totalAmount > 0) {\n",
    "            uint256 creatorPayout = _calculateReward(totalAmount, CREATOR_MARKET_REWARD_BPS);\n",
    "            uint256 platformReferrerPayout = _calculateReward(totalAmount, PLATFORM_REFERRER_MARKET_REWARD_BPS);\n",
    "            uint256 protocolPayout = totalAmount - creatorPayout - platformReferrerPayout;\n",
    "\n",
    "            if (token == WETH) {\n",
    "                IWETH(WETH).withdraw(totalAmount);\n",
    "\n",
    "                rewards.totalAmountCurrency = totalAmount;\n",
    "                rewards.creatorPayoutAmountCurrency = creatorPayout;\n",
    "                rewards.platformReferrerAmountCurrency = platformReferrerPayout;\n",
    "                rewards.protocolAmountCurrency = protocolPayout;\n",
    "\n",
    "                address[] memory recipients = new address[](3);\n",
    "                recipients[0] = payoutRecipient;\n",
    "                recipients[1] = platformReferrer;\n",
    "                recipients[2] = protocolRewardRecipient;\n",
    "\n",
    "                uint256[] memory amounts = new uint256[](3);\n",
    "                amounts[0] = rewards.creatorPayoutAmountCurrency;\n",
    "                amounts[1] = rewards.platformReferrerAmountCurrency;\n",
    "                amounts[2] = rewards.protocolAmountCurrency;\n",
    "\n",
    "                bytes4[] memory reasons = new bytes4[](3);\n",
    "                reasons[0] = bytes4(keccak256(\"COIN_CREATOR_MARKET_REWARD\"));\n",
    "                reasons[1] = bytes4(keccak256(\"COIN_PLATFORM_REFERRER_MARKET_REWARD\"));\n",
    "                reasons[2] = bytes4(keccak256(\"COIN_PROTOCOL_MARKET_REWARD\"));\n",
    "\n",
    "                IProtocolRewards(protocolRewards).depositBatch{value: totalAmount}(recipients, amounts, reasons, \"\");\n",
    "            } else if (token == address(this)) {\n",
    "                rewards.totalAmountCoin = totalAmount;\n",
    "                rewards.creatorPayoutAmountCoin = creatorPayout;\n",
    "                rewards.platformReferrerAmountCoin = platformReferrerPayout;\n",
    "                rewards.protocolAmountCoin = protocolPayout;\n",
    "\n",
    "                _transfer(address(this), payoutRecipient, rewards.creatorPayoutAmountCoin);\n",
    "                _transfer(address(this), platformReferrer, rewards.platformReferrerAmountCoin);\n",
    "                _transfer(address(this), protocolRewardRecipient, rewards.protocolAmountCoin);\n",
    "            } else {\n",
    "                rewards.totalAmountCurrency = totalAmount;\n",
    "                rewards.creatorPayoutAmountCurrency = creatorPayout;\n",
    "                rewards.platformReferrerAmountCurrency = platformReferrerPayout;\n",
    "                rewards.protocolAmountCurrency = protocolPayout;\n",
    "\n",
    "                IERC20(currency).safeTransfer(payoutRecipient, creatorPayout);\n",
    "                IERC20(currency).safeTransfer(platformReferrer, platformReferrerPayout);\n",
    "                IERC20(currency).safeTransfer(protocolRewardRecipient, protocolPayout);\n",
    "            }\n",
    "        }\n",
    "\n",
    "        return rewards;\n",
    "    }\n",
    "\n",
    "    /// @dev Utility for computing amounts in basis points.\n",
    "    function _calculateReward(uint256 amount, uint256 bps) internal pure returns (uint256) {\n",
    "        return (amount * bps) / 10_000;\n",
    "    }\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2e3398be-e748-4123-a7a6-31add01f339a",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
